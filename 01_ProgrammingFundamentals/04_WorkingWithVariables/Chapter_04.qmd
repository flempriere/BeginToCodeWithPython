---
title: "Chapter 4: Working With Variables"
---

## Notes

### Variables in Python

- Variables let us add *memory* to python
  - Can be viewed as an alias for a storage location
- Variables in python are created by defining a name, and providing a value, e.g. the below defines a variable `total` and assigns it the value $0$

```{python}
total = 0
```

```{mermaid}
block-beta
    columns 3
    space
    title["Anatomy of Variable Assignment"]
    space

    block:variable
    columns 1
        varName["total"]
        variablebody["variable"]
        variableDescr["(thing to which value assigned)"]
    end

    block:equals
    columns 1
        equalsSymbol["="]
        equalsName["equals"]
        equalsDescr["(means assign)"]
    end

    block:argumentblock
    columns 1
        zero["0"]
        zeroName["expression"]
        zeroDescr["(value to assign)"]
    end

classDef BG stroke:transparent, fill:transparent
class title BG
class variablebody BG
class variableDescr BG
class equalsName BG
class equalsDescr BG
class zeroName BG
class zeroDescr BG
```

- The above diagramatically breaks down variable assignment. On the left we have the variable, then `=`  which means *assignment*, followed by the expression to assign
- The assignment expression does not need to be made of simple primitives, e.g. `total = us_sales + world_wide_sales` defines the variable `total` to be equal to the sum of the variables `us_sales` and `world_wide_sales`

#### Example: Working with Variables

*Start up a python interpreter, then run the following commands in sequence*

1. `total = 0`
   ```{python}
    total = 0
   ```
    - *No output is generated, the assignment is performed silently*

2. `total`

   ```{python}
    total
   ```

    - `0` *output*
    - `total` *has been assigned* `0`*, putting the variable name into the terminal returns the value associated with this value*

3. `total = total + 10`

   ```{python}
    total = total + 10
   ```

    - *No output*
    - *Like with the first statement, variable assignment generates no output*
    - *Here we assign* `total` *the value given by the **current** value of* `total` *plus* $10$
4. `total`

   ```{python}
    total
   ```
    - `10` *output*
    - *The new value of* `total` *is printed*

#### Python Names

- Variables require names
- Python variable names must obey a number of rules
    1. Must start with a letter or _
    2. Can contain letters, numbers or _ characters
- Some valid names are
  - `total`
  - `xyz`
  -`t0tal`
- Some invalid names are
  - `2_be_or_not_to_be`
    - Starts with a number which is not allowed
  - `tot@l`
    - `@` is not a valid character for a variable name
- Python names are case sensitive, i.e. `FRED` and `fred` are distinct variables

:::{.callout-tip}
**Create Meaningful Names**

Don't use silly or meaningless names like `hello_mom`. Use meaningful names that convey information about what they represent like `length` or `length_in_centimetres`. The PEP8 style guide, sets out how to write and format python programs. This includes a section on [naming conventions](https://peps.python.org/pep-0008/#naming-conventions)

Some languages recommend using *camel case* for variable naming. In this format words in a variable are distinguished by capital letters, but the first letter of the variable is lower case, e.g. `lengthInCentimetres`. Camel case is called this because the capital letters look like the humps of a camel. Either standard works, but when writing python it is best to stick to the python style guides
:::

- Python does not limit the length of variable names
  - There should be no performance cost associated with long variable names
  - Longer names can be hard to read
  - Names should be no longer than they need to convey clear meaning

#### Exercise: Typing Errors and Testing

*You've already seen that python can generate errors when it is unable to interpret an input. Answer the following questions to investigate how errors can arise in using variables. Assume that `total` has already been defined*

1. *Can you identify an error in the statement below, which is supposed to add* $10$ *to the variable* `total`*?*

   ```{python}
    #| echo: false
    %reset
   ```

   ```{python}
    total = 0
    Total = total + 10
   ```

    - Variable names are case-sensitive. Therefore `Total` and `total` are distinct variables. So this declares a new variable `Total` and assigns it the value of `total + 10`. The value of `total` itself is unchanged.
    - This is a *logic error*, it is a legal statement in python that generates the wrong behaviour
      - Logic errors are some of the hardest errors to deal with since they (typically) don't stop a program running, they just produce incorrect behaviour
      - Python typically cannot warn you about them ahead of time
    - This variable misassignment is why python style guides recommend the use of all lowercase letters for variable names

:::{.callout-note}
Other languages with more strict type systems and variable declarations, may be able to identify logic errors like the one above.
:::

2. *How do we prevent logic errors?*
    - Testing
      - i.e checking that the actual behaviour of a program matches the expected behaviour
      - Run a program with input that will generate a known output when running correctly
        - Verify the program generates this output
    - Testing doesn't guarantee a program is correct
      - Typically hard to check all inputs and use cases
      - Does however give confidence and can provide that a program *isn't* correct
    - Typically tests should be written as the program is created or if using *test-driven development* the tests are written *before* the program itself is written
3. *The statement below also contains a misspelling of the variable* `total`*. However, this time the name on the right-hand side of the equals is mispelled. What will happen when this program runs?*

   ```{python}
    #| echo: false
    %reset
   ```

   ```{python}
    total = 0
    total = Total + 10
   ```

    - In this case, `Total` is not defined as a variable, so there is no meaningful way to interpret a value. Hence we would expect an error. Since the error is that `Total` doesn't exist, we see a `NameError`.

#### Example: [Self-Timer Party Game](./Examples/02_SelfTimer/selfTimer.py)

*Consider the [Nerves of Steel](../03_PythonProgramStructure/Chapter_03.qmd#exercise-34-nerves-of-steel) exercise from [Chapter 3](../03_PythonProgramStructure/Chapter_03.qmd). In the game, players must remain standing right up to the moment before they think a random timer will expire*

*One suggestion is that the game might provide more skill if the program told the players how long they had to stand. The game now functions as a "Self-Timer", the winner is now arguably the person who can best keep track of the time*

*The "game" sequence is*

1. *Set the time to remain standing to a random number*
2. *Display time to remain standing*
3. *Sleep for the time to remain standing*
4. *Display a message for the winner*

*Observe that the time is required to be used in two places, displaying the time remaining and then sleeping for that period of time. This means we need to use a variable to store the value of the time remaining*

```{python}
# Chapter 4 Example 2: Self Timer
# Based on original code by Rob Miles
# Extends the Nerves of Steel Game from Chapter 3, by adding a skill element
# with the players being informed of how long they have to stand for

import time
import random

print('Welcome to Self Timer')
print() #just prints a newline
print('Everybody stand up')
print('Stay standing until you think the time has ended')
print('Then sit down')
print('Anyone still standing when the time expires loses')
print('The last person to sit down before the time ended will win')

stand_time = random.randint(5, 20) #generate the time to stand for

print('Stay standing for', stand_time, 'seconds.') #display standing time
time.sleep(stand_time) #sleep for the standing time
print('****TIMES UP, LAST TO SIT WINS!****')
```



- *Most of the code is just text, but the key takeaway is the line `stand_time = random.randint(5, 20)` which assigns `stand_time` the result of `random.randint(5, 20)`, i.e a random number from `5` to `20` inclusive*
- *We then call `stand_time` is our call to `print` to display the time, and then `sleep` for the same amount of time*
- *Observe we couldn't just write the number into both functions explicitly since it's randomly generated, we would need to know ahead of time what the value will be*

### Working with Text

- Variables can also hold text, e.g. `customer_name = 'fred'` assigns the string `'fred'` to `customer_name`
- Can use a string variable anywhere we would use a string literal, e.g. `message = 'the name is ' + customer_name` performs the string concatenation of `'the name is'` and the value of `customer_name` and assigns the result to `message`

#### Example: Text and Numeric Variables

*Python tracks the contents of each variable and only allows operations that make sense. Using the python interpreter experiment with the following combinations of string and number variables.*

```{python}
customer_age_in_years = 25
customer_name = 'fred'
```

*After entering the above two lines in the interpreter, run the following line*

```{python}
customer_age_in_years + customer_name
```

*Here we are trying to add a number and a string, which we saw previously shouldn't work. The terminal should provide some error output like the below*


*Now try the below line*

```{python}
customer_age_in_years = 'Fred'
```

*One might expect the above to generate an error, after all we assign text to a variable that was just storing a number. Instead python simply discards the old numeric value of the variable, and now stores text in `customer_age_in_years`. You should generally avoid doing this, being able to reason about the type of a variable is typically an important part of safe and effective programming, and the weak typing of python is typically disliked outside of quick prototyping*

:::{.callout-note}
The above behaviour is an example of python as a what's called a weakly typed language. Types are a quite developed part of programming theory that can be discussed later. In some languages, types are enforced to greater degrees of strictness. In some languages (like `C`) you can assign variables *compatible* types, i.e. ones that can be converted to the variable's inate type. In other stricter languages a variable can only hold the exact specified type

The more strictly a language enforces its typing system typically the harder it is to generate errors at runtime, however they are often correspondingly more painful to actually write the code in the first place
:::

#### Marking the Start and End of Strings

## Summary

## Questions and Answers
