---
title: "Chapter 10: Using Classes to Create Active Objects"
---

## Notes

### Create a Time Tracker

- Program's tend to evolve in scope over time
    - Sometimes due to scope underestimation
    - Also because customers tend to request new features
- Consider the [Tiny Contacts](../09_UsingClasses/Chapter_09.qmd#make-a-tiny-contacts-app)
    - Client now wants to functionality to track the time spent with a client

- As usual start with the interface,

```text
Time Tracker

1. New Contact
2. Find Contact
3. Edit Contact
4. Add Session
5. Exit Program

Enter your command:
```

We want to now storyboard out the new `Add Session` option

```text
Enter your command: 4
Add Hours
Enter the Contact Name: Rob
Name: Rob Miles
Previous Hours worked: 0
Session Length: 3
Updated hours worked: 3.0
```

We also want to update the `Find Contact` option to include the hours,

```text
Find Contact
Enter the Contact Name: Rob
Name: Rob Miles
Address: 18 Pussycat Mews, London, NE1 410S
Telephone: 1234 56789
Hours worked: 3.0
```

#### Add a Data Attribute to a Class

- We need to store the hours worked
- Simplest approach is to redefine the `Contact` class
    - Add an `hours_worked` field

```{python}
class Contact:
    """
    Contact with a name, address and telephone number.
    Tracks the hours worked with a client

    Attributes
    ----------
    name : str
        Contact Name
    address : str
        Contact's postal or street address.
    telephone : str
        Contact phone number (stored as a string).
    hours_worked : int | float
        Hours worked with a Contact, initialised to 0

    Examples
    --------
    >>> Contact("Rob Miles", "18 Pussycat Mews, London, NE1 410S", "+44(1234) 56789")
    <Contact ...>
    """

    def __init__(self, name, address, telephone):
        """
        Create a new Contact instance

        Parameters
        ----------
        name : str
            Contact Name
        address : str
            Contact's postal or street address.
        telephone : str
            Contact phone number (stored as a string).
        """
        self.name = name
        self.address = address
        self.telephone = telephone
        self.hours_worked = 0
```

- Defaulted to `0` as part of the constructor
    - We might discuss this with the client, it's possible a contact might have some initial consult hours

- From here we can add a new `add_session` function (see the [complete updated code](./Examples/01_TimeTracker/TimeTracker.py), in our version which supports duplicate names in the search)

  ```python
    def add_session():
        """
        Prompts the user to add hours worked to contacts matching a search

        Returns
        -------
        None

        See Also
        --------
        find_contacts : returns contacts matching a search name
        """
        print("add session")
        search_name = read_text("Enter the contact name: ")
        contact = find_contact(search_name)
        if contact != None:
            #found a contact
            print("Name: ", contact.name)
            print("Previous hours worked:", contact.hours_worked)
            session_length = BTCInput.read_float_ranged(prompt="Session length: ", min_value=0.5, max_value=3.5)
            contact.hours_worked = contact.hours_worked + session_length
            print("Updated hours worked:", contact.hours_worked)
        else:
            print("This name was not found")
  ```

- Don't forget we also have to update how we display contacts for the
`Find Contact` functionality (or in our case the `display_contact`) function.

  ```{python}
    def display_contact(contact):
        """
        Displays the Contact details for the supplied contact

        Parameters
        ----------
        contact : Contact
            contact to display

        Returns
        -------
        None

        See Also
        --------
        display_contacts : Displays all contacts matching a search name
        """
        print("Name:", contact.name)
        print("Address:", contact.address)
        print("Telephone:", contact.telephone)
        print("Hours worked for this Contact:", contact.hours_worked, "\n")
  ```

- If we create a new `Contact` object then we can see how this looks,

  ```{python}
    contact = Contact(name="Alice", address="Bob St", telephone="555")
    display_contact(contact)
    contact.hours_worked = 5.0
    display_contact(contact)
  ```

##### Create a Cohesive Object

- When extending a program you should always look at its design
- Code *rots* as it gets older
    - Gets harder to maintain and understand
- Want to make the design as clear and simple as possible
- Like a builder we want to make houses out of walls, walls out of bricks and bricks out of clay
    - i.e. clear progression in scale and responsibility
- A technique for this is called *object-oriented design*
    - Objects are designed to be *cohesive*
    - A cohesive object should contain all the attributes and methods to work with its domain
- For the `Contact` object we want it to be responsible for all contact information
    - Currently not very cohesive
    - Time Tracker works directly on `Contact` object attributes
- Business logic that applies to a `Contact` is outside the function
    - e.g. in the `add_session` function, we have hardcoded a minimum session time of half an hour and a maximum session time of three and half hours
    - This is problematic
        1. Because the numbers are just written there as opposed to being defined as constants with meaning (they are *magic constants*)
        2. This data validation is external to the data storage object itself, the `Contact`
    - We also perform the act of updating the `Contact`'s hours worked, outside the `Contact` object

  ```python
    session_length = BTCInput.read_float_ranged(prompt="Session length: ", min_value=0.5, max_value=3.5)
    contact.hours_worked = contact.hours_worked + session_length
  ```

- The magic constant problem is one issue,
    - If we were to use the `Contact` as a libary object in another application, (like a graphical version) then we would have to maintain the validation code in two seperate places

:::{.callout-tip}
**Keep Business Rules in Business Objects**

The issue here is we have defined *business rules* (things our customer asks the system to do) outside of the *business objects* (things created to implement the customer's system).
:::

- A solution is to make the `Contact` object responsible for validating the session length
    - Any application that uses the `Contact` object will naturally use its internal validation
    - Only one location to change now

#### Create Method Attributes for a Class

- Any python code can access `hours_worked` in a `Contact`
    - Really only need `hours_worked` to be accessed to,
        1. Display time spent with a contact
        2. Add the length of a session to `hours_worked`
- Python objects can hold method attributes
    - Functions bound to the object
- Let us ask an object to do something
- E.g. the `string` object has the method `upper` (seen in [Chapter 5](../../01_ProgrammingFundamentals/05_MakingDecisions/Chapter_05.qmd#compare-strings-in-programs))

- Let us define two method attributes for `Contact`
    - Removes the need to directly access the attribute
- Start by defining a method to access the hours worked

```{python}
class Contact:
    """
    Contact with a name, address and telephone number.
    Tracks the hours worked with a client

    Attributes
    ----------
    name : str
        Contact Name
    address : str
        Contact's postal or street address.
    telephone : str
        Contact phone number (stored as a string).
    hours_worked : int | float
        Hours worked with a Contact, initialised to 0

    Examples
    --------
    >>> Contact("Rob Miles", "18 Pussycat Mews, London, NE1 410S", "+44(1234) 56789")
    <Contact ...>
    """

    def __init__(self, name, address, telephone):
        """
        Create a new Contact instance

        Parameters
        ----------
        name : str
            Contact Name
        address : str
            Contact's postal or street address.
        telephone : str
            Contact phone number (stored as a string).
        """
        self.name = name
        self.address = address
        self.telephone = telephone
        self.hours_worked = 0

    def get_hours_worked(self):
        """
        Get the hours worked for this contact
        """
        return self.hours_worked
```

##### Code Analysis: The `get_hours_worked` Method

*Consider the following questions regarding the* `get_hours_worked` *function*

1. *What is the parameter* `self` *used to accomplish?*

    - A method is part of an object
    - `self` tells the method which object it is a part of
    - The code sample below shows how the method doesn't need an additional reference to the `Contact` it refers to

      ```{python}
        # set up
        rob = Contact("Rob", "A St", "1")
        rob.hours_worked = 1
        jim = Contact("Jim", "B St", "555")
        jim.hours_worked = 2

        # demonstration
        rob_work = rob.get_hours_worked()
        jim_work = jim.get_hours_worked()
        if rob_work > jim_work:
            print("More work for rob")
        else:
            print("More work for jim")
      ```

2. *Is the* `get_hours_worked` *method stored when we save contact information in a file*

    - No, if we use [`pickle`](../09_UsingClasses/Chapter_09.qmd#save-contacts-in-a-file-using-pickle) to store a contact list, the method attributes are not stored. Pickle only stores the data attributes

3. *Can a program still access the* `hours_worked` *attribute of a* `Contact` *class*

    - Yes, it can. Using method attributes to get data doesn't stop a program accessing the data directly
    - We simply remove the desire to
    - Later chapters look at techniques for enforcing this more robustly

- We can create a second method to handle adding a session to a `Contact`

  ```{python}
    # existing class definition
    class Contact:
        def __init__(self, name, address, telephone):
            self.name = name
            self.address = address
            self.telephone = telephone
            self.hours_worked = 0

        def get_hours_worked(self):
            """
            Gets the hours worked for this contact

            Returns
            -------
            int | float
                hours worked for this contact
            """
            return self.hours_worked

        # new method
        def add_session(self, session_length):
            """
            Adds a session (in hours) to the Contacts hours

            Parameters
            ----------
            session_length : int | float
                time spent on session in hours

            Returns
            -------
            None
            """
            self.hours_worked = self.hours_worked + session_length
  ```

- Takes two parameters

    1. `self` - the object the method is attached to
        - Here the `Contact` being updated
    2. `session_length`
        - The length of the session to be added

You can see the above implementation integrated into [our TimeTracker implementation](./Examples/02_TimeTrackerWithMethods/TimeTrackerWithMethods.py). Aside from defining these new functions we
have to update the file scope `add_session` function (distinct from the class scope `add_session` method) and the `display_contact` functions to
use the new methods

#### Add Validation to Methods

- Currently `add_session` would allow function calls like,

  ```{python}
    rob = Contact("Rob", "A St", "555")
    rob.add_session(-10)
    print(rob.get_hours_worked())
  ```

- Legal call
    - Makes no logical sense
    - Can't work negative hours
- At the moment the validation is performed in the global `add_session` function
    - Suppose this was maintained by another team
    - They could change it, and break your code

:::{.callout-note}
**Think Carefully about Valid Input**

You should think carefully about what is valid input for any function, especially when you restrict it. As observed here, a negative number of hours doesn't make sense on the surface. However, it might make sense in the case of,

1. Correcting an overestimated number of hours
2. The Client wants to give a client a discounted number of hours
:::

- We want to move the validation inside the `Contact` object
    - Want `add_session` to reject hours that are less than half-an-hour or greater than three and a half
- We could add these as variables for each instance of a `Contact`
    - But they're the same for every instance
    - Would be nice to have a way to define it once for the class

##### Create Class Variables

- A class variable is data not attached to a specific object instance
- Can define the min and max hours as a class variable
    - No longer magic constants
    - Accessible by all `Contact` instances

  ```{python}
    class Contact:
        """
        Contact with a name, address and telephone number.
        Tracks the hours worked with a client

        Attributes
        ----------
        name : str
            Contact Name
        address : str
            Contact's postal or street address.
        telephone : str
            Contact phone number (stored as a string).
        hours_worked : int | float
            Hours worked with a Contact, initialised to 0

        Class Attributes
        ----------------
        min_session_length : Final[int | float]
            minimum length of a billable session

        max_session_length : Final[int | float]
            maximum length of a billable session


        Examples
        --------
        >>> Contact("Rob Miles", "18 Pussycat Mews, London, NE1 410S", "+44(1234) 56789")
        <Contact ...>
        """

        min_session_length = 0.5
        max_session_length = 3.5

        def __init__(self, name, address, telephone):
            """
            Create a new Contact instance

            Parameters
            ----------
            name : str
                Contact Name
            address : str
                Contact's postal or street address.
            telephone : str
                Contact phone number (stored as a string).
            """
            self.name = name
            self.address = address
            self.telephone = telephone
            self.hours_worked = 0

            def get_hours_worked(self):
                """
                Gets the hours worked for this contact

                Returns
                -------
                int | float
                    hours worked for this contact
                """
                return self.hours_worked

            # new method
            def add_session(self, session_length):
                """
                Adds a session (in hours) to the Contacts hours

                Parameters
                ----------
                session_length : int | float
                    time spent on session in hours

                Returns
                -------
                None
                """
                if session_length < Contact.min_session_length or session_length > Contact.max_session_length:
                    return
                self.hours_worked = self.hours_worked + session_length
  ```

- `add_session` now silently rejects invalid `session_length` values
- The idiom of first checking for invalid input and performing a `return` if encountered is called an *early return* and is a common technique
    - Reduces the need for indentation on the happy path - the error free path
- Observe we have to prefix the class variables with the class name as a namespace
- The `Final` label in the docstring indicates that the session length variables are expected to be constant and should not be modified by a consuming
program

###### Code Analysis: Using class variables

*Build your understanding of class variables by answering the following questions about their use-cases*

1. *Should I use a class variable to hold the age of a contact?*

    - No. Each contact will have an age, so the age must be a data attribute unique to each object instance

2. *Should I use a class variable to hold the maximum age of a contact?*

    - Yes, we don't need to store a copy of this value for every `Contact` instance, so it can be a class variable

3. *Should I use a class variable to hold the price per hour that the lawyer will charge?*

    - It depends, if the lawyer charges the same for every client then it may be reasonable
    - If the lawyer wishes to charge different contacts different rates, then we would have to store it as a data attribute
        - In that case we might store the minimum and maximum hourly rate as class variables

##### Create a Static Method to Validate Values

- Cohesion generally means objects shouldn't expose attributes for external clients
- Ideally clients interact with a  `Contact` via method calls
    - e.g. `get_hours_worked` and `add_session`
    - Eliminates direct dependency on `hours_worked` data attribute
- In the same vein, we don't want users to directly interact with class variables
    - e.g. `max_session_length` and `min_session_length` are used for internal validation
    - External client should have no reason to directly modify them
- Could create a method, `validate_session_length`
    - Receive a `session_length` argument
    - Return `True` if valid, else `False`
- Validation information (`max_session_length` and `min_session_length`) is held at the class level
    - Would be nice to also have this validation method at the class level too
- We can create class level methods through a *Static Method*
    - Static methods can be considered as methods defined on a class rather than an object instance
- We can define one as below,

  ```{python}
    class Contact:
        """
        Contact with a name, address and telephone number.
        Tracks the hours worked with a client

        Attributes
        ----------
        name : str
            Contact Name
        address : str
            Contact's postal or street address.
        telephone : str
            Contact phone number (stored as a string).
        hours_worked : int | float
            Hours worked with a Contact, initialised to 0

        Class Attributes
        ----------------
        min_session_length : Final[int | float]
            minimum length of a billable session

        max_session_length : Final[int | float]
            maximum length of a billable session

        Examples
        --------
        >>> Contact("Rob Miles", "18 Pussycat Mews, London, NE1 410S", "+44(1234) 56789")
        <Contact ...>
        """

        min_session_length = 0.5
        max_session_length = 3.5

        @staticmethod
        def valid_session_length(session_length):
            """
            Check a session length is valid

            Parameters
            ----------
            session_length : int | float
                length of a consult session in hours

            Returns
            -------
            bool
                `True` if the session length is valid else `False`
            """
            if (
                session_length < Contact.min_session_length
                or session_length > Contact.max_session_length
            ):
                return False
            return True

        def __init__(self, name, address, telephone):
            """
            Create a new Contact instance

            Parameters
            ----------
            name : str
                Contact Name
            address : str
                Contact's postal or street address.
            telephone : str
                Contact phone number (stored as a string).
            """
            self.name = name
            self.address = address
            self.telephone = telephone
            self.hours_worked = 0

        def get_hours_worked(self):
            """
            Gets the hours worked for this contact

            Returns
            -------
            int | float
                hours worked for this contact
            """
            return self.hours_worked

        # new method
        def add_session(self, session_length):
            """
            Adds a session (in hours) to the Contacts hours

            Parameters
            ----------
            session_length : int | float
                time spent on session in hours

            Returns
            -------
            None

            See Also
            --------
            Contact.valid_session_length : checks a session length is valid
            """
            if not Contact.valid_session_length(session_length):
                return
            self.hours_worked = self.hours_worked + session_length
  ```

- The `@staticmethod` tag above the definition of `valid_session_length` is called a *decorator*
- A decorator *wraps* a function to modify how it works
- Decorators are added by writing `@` followed by the decorator name above the function to be wrapped
    - You can wrap a function with multiple decorators
- The `@staticmethod` decorator is a python language built-in
    - Converts a method into a static method
    - Static methods can exist even without an instance of the given class
- Static methods can be called directly from the class e.g.

  ```{python}
    print(Contact.valid_session_length(5))
  ```

###### Code Analysis:  Creating Static Validation Methods

*Input validation is a very common use-case for static methods. Consider the following questions to understand static validation methods*

1. *Why does the* `valid_session_length` *method not have a* `self` *parameter?*
    - `self` refers to a particular object instance
    - static methods are not associated with an instance
        - Associated with the class
        - Thus no `self` to refer to

2. *Why does the* `valid_session_length` *method not print a message to the user communicating that the session length is invalid?*

    - `valid_session_length` only has responsibility for checking if a session length is valid
    - How to handle an *invalid* session length is the responsibility of the caller
        - e.g. a text-based vs graphical interface may want to handle this differently
            - e.g. display text vs a window
    - This concept of making a function responsible for one thing is called either
        - The *single responsibility principle*,
        - or more generally *seperation of concerns*
    - Here a `Contact` object performs behaviours that modify or capture a the state of a clients interactions with a client
        - How the user responds to those states is not its responsibility

3. *What does a decorator do?*

    - A decorator is a function that *wraps* another function
    - They can do some work, call a function then do some clean-up

4. *Can I create my own decorators?*

    - Yes
    - They are beyond the scope of this book though

5. *How do I know when to create a static method in a class?*

    - You want to create behaviour associated with a class, *but*
        - Independent of specific instance of a class

##### Return Status Messages from a Validation Method

- `add_session` prevents invalid session lengths being added to a `Contact`
- Currently user has no way of knowing if a session was added
    - Mistakes might be missed
    - Records then lost
- Need to indicate if `add_session` succeeded
- Can do so by returning a *status flag* from `add_session` rather than `None`
    - `True` indicates session added
    - `False` indicates session failed

  ```python
    def add_session(self, session_length):
    """
    Adds a session (in hours) to the Contacts hours

    Parameters
    ----------
    session_length : int | float
        time spent on session in hours

    Returns
    -------
    bool
        `True` if session successfully added, else `False`

    See Also
    --------
    Contact.valid_session_length : checks a session length is valid
    """
    if not Contact.valid_session_length(session_length):
        return False
    self.hours_worked = self.hours_worked + session_length
    return True
  ```

- The calling program can then check the status
    - Behave as appropriate on error

  ```python
    session_length = BTCInput.read_float(prompt="Session Length: ")
    if contact.add_session(session_length):
        print("Updated hours succeeded", contact.get_hours_worked())
    else:
        print("Add hours failed")
  ```

- The above uses the status
    - On success the new hours are reported
    - On failure, the user is notified of the error
- The full implementation is given in [TimeTrackerWithStatusReporting.py](./Examples/05_TimeTrackerWithStatusReporting/TimeTrackerWithStatusReporting.py)
- The problem with status messages is that the user can ignore them, e.g. the below variation of the previous example, ignores the return value


 ```python
    contact.add_session(BTCInput.read_float(prompt="Session Length: "))
    print("Updated hours:", contact.get_hours_worked())
 ```

- Thus no guarantee that failure will be handled

##### Raise an Exception to indicate an Error

- Exceptions force  the caller to deal with them
    - Unhandled exceptions crash the program
- Exceptions are designed for when an error occurs where continuing makes no sense
    - e.g. converting strings to numbers
    - meaningless to continue with an unconverted number
    - *Unless* the caller specifies what to do in that case
    - So this causes an exception

      ```{python}
        x = int("Rob")
      ```

- We can make our on code throw exceptions
    - We use the `raise` keyword

  ```{python}
    def add_session(self, session_length):
        """
        Adds a session (in hours) to the Contacts hours

        Parameters
        ----------
        session_length : int | float
            time spent on session in hours

        Returns
        -------
        None

        Raises
        ------
        Exception
            Raised if invalid session length passed

        See Also
        --------
        Contact.valid_session_length : checks a session length is valid
        """
        if not Contact.valid_session_length(session_length):
            raise Exception("Invalid Session Length")
        self.hours_worked = self.hours_worked + session_length
  ```

- `Contact`'s `add_session` now raises an `Exception` if the session length is invalid
- Exception somewhat like a message
    - Tells the program what went wrong
- `Exception` class provides behaviours for exceptions
    - Takes a string as an initialiser argument
    - string should describe the error
- Once raised, the exception is either,
    1. handled by an `Except` handler inside a `try` block
    2. Stops the program with an error

- The complete integration of the above is given byy [TimeTrackerWithException.py](./Examples/06_TimeTrackerWithException/TimeTrackerWithException.py)

##### Make Something Happen: Raising Exceptions from Code

*Investigate how exceptions are raised using the sample program [Time Tracker with Exception](./Examples/06_TimeTrackerWithException/TimeTrackerWithException.py)*

Start a python interpreter and run the example program above, select option $1$ on the menu, and enter the following,

```{python}
# | echo: false
print("""Time Tracker

1. New Contact
2. Find Contact
3. Edit Contact
4. Add Session
5. Exit Program

Enter your command: \033[31m1\033[0m
Create new contact
Enter the contact name: \033[31m Rob Miles\033[0m
Enter the contact address: \033[31m 18 Pussycat Mews, London, NE1 410S\033[0m
Enter the contact phone: \033[31m 1234 56789 \033[0m""")
```

Now add a session lasting 2 hours to the contact using option 4:

```{python}
#| echo: false

    print("""Enter your command: \033[31m 4\033[0m
    add session
    Enter the contact name: \033[31m Rob Miles\033[0m
    Name: Rob Miles
    Previous hours worked: 0
    Session Length: \033[31m 2\033[0m
    Updated hours worked: 2.0""")
```

This should work because $2$ is a valid session length, now repeat but
attempt to add a session length of $4$, which should be invalid,

```{python}
#| echo : false

    print("""Enter your command: \033[31m 4\033[0m
    add session
    Enter the contact name: \033[31m Rob Miles\033[0m
    Name: Rob Miles
    Previous hours worked: 2.0
    Session Length: \033[31m 4\033[0m""")
```

```{python}
#| echo: false

    rob = Contact("Rob Miles", "18 Pussycat Mews, London, NE1 410S", "1234 56789")
    add_session(rob, 2)
    add_session(rob, 4)
```

:::{.callout-note}
Our implementation will look slightly different to the above (which is the book code) because it has additional logic for handling duplicates. But follow the steps and the prompts and you should get roughly the same process
:::

##### Extract an Exception Error Message

- Now that we can raise exceptions, how do we handle them?
- We've seen that we control jumps to an appropriate `except` but what if we
want to access the message in the exception?
    - We can use the `as` keyword to assign the exception a variable label
    - We modify the user call to the `Contact` object, `add_session` as, (see the full implementation as [TimeTrackerWithExceptionHandler.py](./Examples/07_TimeTrackerWithExceptionHandler/TimeTrackerWithExceptionHandler.py))

  ```python
    hours_worked = BTCInput.read_float(prompt="Enter hours spent: ")
    try:
        contact.add_session(hours_worked)
        print("Updated hours succeeded:", contact.get_hours_worked())
    except Exception as e:
        print("Add failed:", e)
  ```

- The main change is rather than just going `except Exception:` we add a `as e`
    - Defines a variable `e` that stores the exception
    - `e` exists for the scope of the `except` block
- Passing an exception to `print` prints our the message associated with the exception
- A representative use might look like,

```{python}
#| echo : false

    print("""Enter your command: \033[31m 4\033[0m
    add session
    Enter the contact name: \033[31m Rob Miles\033[0m
    Name: Rob Miles
    Previous hours worked: 2.0
    Session Length: \033[31m -1\033[0m
    Add failed: Invalid Session Length""")
```

##### Make Something Happen: Catching Exceptions

*Repeat the steps in the [previous example](#make-something-happen-raising-exceptions-from-code) but this time use the new code in [Time Tracker with Exceptionn Handler](./Examples/07_TimeTrackerWithExceptionHandler/TimeTrackerWithExceptionHandler.py). You should find the program runs and the errors are captured without causing a crash*

##### Code Analysis: Raising and Dealing with Exceptions

*Consider the following questions about dealing with exceptions*

1. *Why does this version of the program not check the result returned by* `add_session`*?*

    - This implementation of `add_session` returns `None`
    - Instead an exception is raised to indicate a failure state
    - There is therefore nothing to check

2. *Isn't raising an exception and stopping the program when something goes wrong a bit harsh?*

    - Depends on your philosophy
    - Generally you want to avoid *silent errors*
    - i.e. errors that are undetected by the user
    - Exceptions force the user to handle the error rather than silently ignore it
    - If the user wants to avoid exception handling, they can explicitly use `validate_session_length`

3. *Can a method be resumed once it has raised an exception?*

    - No
    - Exceptions immediately terminate the normal control flow
    - The user can always call the function again

4. *Why would you want to create your own types of exceptions?*

    - Allows any errors returned to be descriptive to your specific code
    - e.g. if your program relies on a specific file being loaded you might want a more descriptive error message than the standard `FileException` provides
    - Error management and reporting should be decided early in a program

5. *Should I always use exceptions to indicate something has gone wrong?*

    - Depends
        - You may not care about handling all types of errors
    - Exceptions ensure errors are dealt with
        - User can customise the error handling in response to exception
        - e.g. for a text-based vs GUI interface

6. *Why have we made* `add_session` *work like this? The program worked before we made this change*

    - Technically correct
        - Old code used the error status to validate code
    - Arguably cleaner with the new error handling
        - Knowledge about the `Contact` class has been centralised in the `Contact` class itself
        - No need to have external variables storing information about valid session length or doing the validation
    - Typically a good idea to put all knowledge about a classes behaviour in the class itself

#### Protect a Data Attribute against Damage

- Client no longer needs to directly interact with `hours_worked`
- However, client can still modify `hours_worked`
    - Programmer could accidently change the value
    - Could also intentionally change it to break the code
- Ideally we want to prevent it being directly modified

:::{.callout-warning}
**Python protects against mistakes, not attacks**

Python provides features to help protect data attributes against accidental modifications. However, they don't stop a programmer who intentionally (and perhaps maliciously) decides they want to modify the data attributes.

There is no mechanism in the python language to prevent another progrmmer adding code that changes `hours_worked` in the `Contact` object
:::

- By convention, python dictates that an attribute name starting with `_` should not be used outside the class
    - Also referred to as being *internal* to the class
    - e.g. `_hours_worked` means that the  variable should not be touched

      ```python
        def get_hours_worked(self):
            """
            Gets the hours worked for this contact

            Returns
            -------
            int | float
                hours worked for this contact
            """
            return self._hours_worked
      ```

- Above we provide a `get_hours_worked` method to get the value of `_hours_worked`
    - `_` indicates not to modify `hours_worked` itself
- No actual protection for `_hours_worked`
    - Could still be ignored by a programmer
- Can get greater security through, *name-mangling*
    - starting a varible name with double underscores `__`
- *name-mangling* makes it harder to access and modify the variable

##### Make Something Happen: Protecting Data Attributes in a Class

*Follow the following steps to examine how to make a python class secure. Open a python interpreter and enter the statements below*

```{python}
    class Secret:
        def __init__(self):
            self._secret = 99
            self.__top_secret = 100
```

The above creates a class `Secret` which has two attributes, `_secret` and `__top_secret`

*Create an instance of the* `Secret` *class*

```{python}
    x = Secret()
```

The above creates a new instance of a `Secret` class and stores it with the variable `x`.

*Try to access the* `_secret` *attribute on* `x`

```{python}
    x._secret
```

Even though we said that `_` indicates we should not access the data attribute, we can see that nothing stops us from doing so

*Now try to access the* `__top_secret` *attribute*

```{python}
    x.__top_secret
```

This time we get an `AttributeError` which suggests that there is no `__top_secret` attribute associated with the `Secret` class

*However, Python has performed some "name-mangling" to the name* `__top_secret`*. Inside the* `Secret` *class we can  refer to* `__top_secret`*. Outside the class, the variable name is prepended with the class name (and an underscore). So we can still access it, as the below proves*

```{python}
    x._Secret__top_secret
```

Name-mangling thus secures us against accidental attribute use, however any one who knows the name mangling scheme and our attributes can still modify the data attribute if they want to

There are programs that check against this kind of bad code behaviour. One example is [pylint](https://www.pylint.org/)

#### Protected Methods

- Our current methods for the `Contact` class are all intended to be used by clients
    - Referred to as *public* methods
- We might also want to protect methods in a class
- Can use `_` prefix to indicate that it should not be used
- Or `__` prefix to name mangle

:::{.callout-tip}
**Writing secure code is all about workflow**

Making a secure program is all about establishing a workflow to generate quality code. For example, using prototypes to make sure that a customer
agrees with the direction of a program early in the development

The next step is to sensible design and tools like pylint to make sure we're writing good quality code.
:::

### Create Class Properties

- We've talked about protecting `hours_spent` for our `Contact`
- We should add more business logic to ensure that name, address and telephone items are sensible
    - As a purely toy example, lets say they must each be $4$ characters long
- Realistically they would be discussed and confirmed with the customer

```{python}
class Contact:

    __min_text_length = 4

    @staticmethod
    def valid_text(text):
        """
        Validates text to be stored in the contact storage

        Parameters
        ----------
        text : str
            text string to store

        Returns
        -------
        bool
            `True` if the text is valid, else `False`
        """

        if len(text) < Contact.__min_text_length:
            return False
        else:
            return True
```

- Above mirrors `valid_session_length`
- Called to validate text to be stored in a `Contact`
- We could then name mangle `name`, `address`, `telephone`
- Supply methods to get and set these attributes
    - e.g. `set_name` and `get_name` for example
- Python has a built-in way for providing read and write access to protected data
- This is called a *Property*
    - Properties preserve simple access, while allowing us to implement validation

#### Code Analysis: Properties in Classes


```{python}
class Contact:
    __min_text_length = 4

    @staticmethod
    def valid_text(text):
        """
        Validates text to be stored in the contact storage

        Valid input must be have a length greater than or
        equal to Contact.__min_text_length

        Parameters
        ----------
        text : str
            text string to store

        Returns
        -------
        bool
            `True` if the text is valid, else `False`
        """
        if len(text) < Contact.__min_text_length:
            return False
        else:
            return True

    @property  # decorator makes name a property
    def name(self):  # name of property function to get the name
        """
        name : str
            Contact Name

        Raises
        ------
        Exception
            raised if new name is invalid

        See Also
        --------
        Contact.valid_text : validates text input
        """
        return self.__name  # return private attribute containing the name

    @name.setter  # decorator to identify the setter for name
    def name(self, name):
        if not Contact.validate_text(name):
            raise Exception("Invalid name")
        self.__name = name
```

*The code above shows how to implement a property for* `name` *in the* `Contact` *class. The property implements validation and rejects invalid names. Work through the following questions to understand properties*

1. *How does the value being set in the property get into the* `setter`*?*

    - `setter` is called with two parameters
    - `self` refers to the object on which the `setter` is being called
    - The second is the proposed value to set the property to
        - Here it is setting the `name` attribute

2. *How does the program know which* `setter` *method to call for a particular property?*

    - The `setter` decorator has the format `property.setter`
        - Associates a `setter` to a property

3. *Must the* `setter` *method raise an exception if the value is being set is not valid?*

    - No
    - `setter` could ignore invalid values, or assign a default
    - Exceptions allow us to inform the user that the set has failed
        - And also forces the user to deal with the error

4. *Do we need to perform the same validation for all properties in a class?*

    - No
    - We could test that telephone is purely numeric (for example)
        - This is not a good idea for real telephone numbers
    - We could ensure address matches a certain structure for a valid address

5. *Must a property have a* `setter`*?*

    - No
    - Properties without a `setter` are *read-only*
    - They cannot be modified
    - We could use this to remove the `get_hours_worked` method
        - Use a property instead

#### Make Something Happen: Investigating Properties

*Investigate how properties work. Open up the python interpreter and enter the statements below*

```{python}
class Prop:
    @property
    def x(self):
        print("got property x")
        return self.__x
    @x.setter
    def x(self, x):
        print("set property x:", x)
        self.__x = x
```

This creates a new class `Prop` with a property `x` that has a `setter`

*Now create an instance of this class as below*

```{python}
    test = Prop()
```

*Put a value for* `x` *into the* `test` *instance*

```{python}
    test.x = 99
```

When python executes the above, it runs the setter method for the property. As we can see from the output above.

*Now try to read the property*

```{python}
    print(test.x)
```

When reading the property, python runs the property method, as indicated above

*We can combine getting and setting in complex expressions, execute the following*

```{python}
    test.x = test.x + 1
```

We can see that first the getter is called to get the current value of `x`, then the setter is called to update it to the expression on the right

To convert the `Contact` class to use properties for `name`, `telephone` and `address` we have to add properties and then setters

- The relevant changes to the `Contact` class are then,

```{python}
class Contact:
    """
    Contact with a name, address and telephone number.
    Tracks the hours worked with a client

    Attributes
    ----------
    name : str
        Contact Name
    address : str
        Contact's postal or street address.
    telephone : str
        Contact phone number (stored as a string).


    Examples
    --------
    >>> Contact("Rob Miles", "18 Pussycat Mews, London, NE1 410S", "+44(1234) 56789")
    <Contact ...>
    """

    __min_session_length = 0.5
    __max_session_length = 3.5

    @staticmethod
    def valid_session_length(session_length):
        """
        Check a session length is valid

        Parameters
        ----------
        session_length : int | float
            length of a consult session in hours

        Returns
        -------
        bool
            `True` if the session length is valid else `False`
        """
        if (
            session_length < Contact.__min_session_length
            or session_length > Contact.__max_session_length
        ):
            return False
        return True

    __min_text_length = 4

    @staticmethod
    def valid_text(text):
        """
        Validates text to be stored in the contact storage

        Valid input must be have a length greater than or
        equal to Contact.__min_text_length

        Parameters
        ----------
        text : str
            text string to store

        Returns
        -------
        bool
            `True` if the text is valid, else `False`
        """
        if len(text) < Contact.__min_text_length:
            return False
        else:
            return True

    @property
    def name(self):
        """
        name : str
            Contact Name

        Raises
        ------
        Exception
            raised if new name is invalid

        See Also
        --------
        Contact.valid_text : validates text input
        """
        return self.__name

    @name.setter
    def name(self, name):
        if not Contact.valid_text(name):
            raise Exception("Invalid name")
        self.__name = name

    @property
    def address(self):
        """
        address : str
            Contact Address

        Raises
        ------
        Exception
            raised if new address is invalid

        See Also
        --------
        Contact.valid_text : validates text input
        """
        return self.__address

    @address.setter
    def address(self, address):
        if not Contact.valid_text(address):
            raise Exception("Invalid address")
        self.__address = address

    @property
    def telephone(self):
        """
        telephone : str
            Contact Telephone

        Raises
        ------
        Exception
            raised if new telephone is invalid

        See Also
        --------
        Contact.valid_text : validates text input
        """
        return self.__telephone

    @telephone.setter
    def telephone(self, telephone):
        if not Contact.valid_text(telephone):
            raise Exception("Invalid telephone")
        self.__telephone = telephone

    def __init__(self, name, address, telephone):
        """
        Create a new Contact instance

        Parameters
        ----------
        name : str
            Contact Name
        address : str
            Contact's postal or street address.
        telephone : str
            Contact phone number (stored as a string).
        """
        self.name = name
        self.address = address
        self.telephone = telephone
        self.__hours_worked = 0
```

- The great thing about properties is they can  be effectively drop in for traditional attributes
    - We make the attributes themselves name mangled
    - Define properties to mask the original names
- No need to update the downstream calling code
    - property syntax matches the traditional access pattern
- The complete integration is seen in [TimeTrackerWithPropertie.py](./Examples/09_TimeTrackerWithProperties/TimeTrackerWithProperties.py)

:::{.callout-caution}
**Failures in property code can be confusing**

The [example program](./Examples/09_TimeTrackerWithProperties/TimeTrackerWithProperties.py) implements the name, address and telephone number elements of a contact as properties. Setting a property to an invalid value will cause an exception. The initialiser looks like,

```python
    def __init__(self, name, address, telephone):
        self.name = name
        self.address = address
        self.telephone = telephone
        self.__hours_worked = 0
```

These statements look like normal variable assignments, nothing here indicates that these steps can fail. However, the following statement fails,

```{python}
    rob = Contact(name="Rob", address="18 Pussycat Mews, London NE1 410S", telephone="1234 56789")
```

The above raises an exception because the value `Rob` passed for the `name` property is too short. `__init__` attempts to set `name` which calls the setter, and the property code raises an exception.

Programmers may expect methods or functions to cause exceptions but they typically do not expect statements that look like variable assignments. When implementing properties you need to be clear about how they work and how to handle failure.

We could extend our previous [error handling code](#make-something-happen-catching-exceptions) to add additional exception handlers to handle invalid assignments
:::

### Evolve Class Design

>Scenario
>
>The lawyer likes your program but would now like to use it for billing. The program should track both the hours worked for a client and the the billing amount owed by each contact
>
>Prices are calculated as follows, for every session worked there is
>   - A $30 flat case fee
>   - A $50 hourly fee
>
> For example a one hour session would cost $80
>
>The client wants the billing amount to be automatically updated each time they add a session. Displaying a contact
should then also display the billing amount
>
>```text
>Name: Rob Miles
>Address: 18 Pussycat Mews, London, NE1 410S
>Telephone: 1234 56789
>Hours on the case: 2.0
>Billing amount: 130.0
>```

#### Code Analysis: Managing the Billing Amount

*Work through the following questions to understand how we design managing the billing amount*

1. *How would we store the billing amount for a contact?*

    - Store as a data attribute on a `Contact` object
    - Manage like `__hours_worked` with validators
    - Let's call it `__billing_amount`

2. *Why does* `__billing_amount` *have two leading underscores in the name?*

    - Indicates the variable is private to the class
    - Provides name-mangling to reduce chance for accidental use
    - Provide access via a read-only property

      ```python
        @property
        def billing_amount(self):
            return self.__billing_amount
      ```

    - We omit a setter, the property cannot be directly modified
    - Can  then access the property  as we would expect

      ```python
        print("Rob owes:", rob.billing_amount)
      ```

    - Same output might look like,

      ```python
        #| echo: false
        print("Rob owes:", 130.0)
      ```

3. *What would the statement calculating the billable amount for a session look like?*

    - At it's most basic the statement might look like,

      ```python
        amount_to_bill = 30 + (50 * session_length)
      ```

    - `session_lengtth` value is multipled by the hourly rate ($50$)
    - flat fee $30$ is added to the total
    - Can then add this to the billing amount

      ```python
        self.__billing_amount = self.billing_amount + amount_to_bill
      ```

    - Observe that this approach means that each session incurs the same $30$ case opening fee
    - It's possible multiple sessions might be spent on the same case
        - Might not incur the $30$ fee each time
        - This would be something to confirm with the client

4. *Is it sensible to just use the values* $30$ *and* $50$ *in this code?*

    - No
    - They are magic constants
    - Better to make them internal class variables of the `Contact` class

      ```python
        class Contact
            __open_fee = 30
            __hourly_fee = 50
      ```

    - Observe that we flag them as private, they are internals for the class
    - The new amount to bill statement is then,

      ```python
        amount_to_bill = Contact.__open_fee + (Contact.__hourly_fee * session_length)
      ```

5. *Where should the above statement go?*

    - Adjusting the billing is something that occurs when we add a session
    - Makes sense to go in the `add_session` code of the `Contact` class

      ```python
        def add_session(self, session_length):
            """
            Adds a session (in hours) to the Contacts hours

            Updates the Contact's session hours and calculates
            the billable amount owed

            Parameters
            ----------
            session_length : int | float
                time spent on session in hours

            Returns
            -------
            None

            Raises
            ------
            Exception
                Raised if invalid session length passed

            See Also
            --------
            Contact.valid_session_length : checks a session length is valid
            """
            if not Contact.validate_session_length(session_length):
                raise Exception("Invalid session length")
            self.__hours_worked = self.__hours_worked + session_length
            amount_to_bill = Contact.__open_fee + (Contact.__hourly_fee * session_length)
            self.__billing_amount = self.__billing_amount + amount_to_bill
            return
      ```

    - Billing amount is updated *after* we have validated and updated the hours worked

- We change the `display_contact` method to add the billing amount

```python
def display_contact(contact):
    """
    Displays the Contact details for the supplied contact

    Parameters
    ----------
    contact : Contact
        contact to display

    Returns
    -------
    None

    See Also
    --------
    display_contacts : Displays all contacts matching a search name
    """
    print("Name:", contact.name)
    print("Address:", contact.address)
    print("Telephone:", contact.telephone)
    print("Hours worked for this Contact:", contact.get_hours_worked(), "\n")
    print("Amount to bill:", contact.billing_amount)
```

- The complete program can be found in [Time Tracker with Billing Amount](./Examples/11_TimeTrackerWithBillingAmount/TimeTrackerWithPropertiesAndExceptionHandling.py)

#### Manage Class Versions

## Summary

## Questions and Answers
