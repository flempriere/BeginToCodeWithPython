[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Beginning to Code with Python: Notes, Examples and Exercises",
    "section": "",
    "text": "This repository contains code fragments, notes and exercises from the book Begin to Code With Python by Rob Miles. The book is available at the official Microsoft Press Store.\nI started this repository to work through an easy and basic book before working on some more intermediate level python projects and books."
  },
  {
    "objectID": "index.html#contents",
    "href": "index.html#contents",
    "title": "Beginning to Code with Python: Notes, Examples and Exercises",
    "section": "Contents",
    "text": "Contents\n\nPart 1. Programming Fundamentals\n\nChapter 2: Python and Programming\nChapter 3: Python Program Structure\nChapter 4: Working with Variables\nChapter 5: Making Decisions\nChapter 6: Repeating Actions with Loops\nChapter 7: Using Functions to Simplify Programs\nChapter 8: Storing Collections of Data\n\n\n\nPart 2. Advanced Programming\n\nChapter 9: Using Classes to Store Data\n\nExtension Exercises for Chapter 9\n\nChapter 10: Use Classes to Create Active Objects\n\n\n\nUseful Python\n\n\n\n\n\n\nImportant\n\n\n\nChapter 1 only provides basic information on installing python and assumes a Windows environment so is not covered in these notes"
  },
  {
    "objectID": "index.html#python-version-and-writing-style",
    "href": "index.html#python-version-and-writing-style",
    "title": "Beginning to Code with Python: Notes, Examples and Exercises",
    "section": "Python Version and Writing Style",
    "text": "Python Version and Writing Style\n\nThe original book was written with python 2.X and python 3.6 in mind.\nCurrently we’ve written the code using python 3.12.\nSmall changes have been made to the supplied code to resolve the following issues:\n\nsnaps get_string function not allowing the user to actually supply input\nsnaps display_image modified to deal with issues where .png files might not display\n\nIn general the code style of the solutions is restricted to elements of the python language introduced up until that point\n\nFor some of the extension exercises we have gone beyond that by still restricting ourselves to concepts that have been introduced, e.g\n\nWe use random.choice to select random items from a list, after having been exposed to both the random and list libraries\nWe use the string method find after having been introdued to the concept of string methods and substring searching with startswith"
  },
  {
    "objectID": "02_AdvancedProgramming/09_UsingClasses/Chapter_09_ExtensionExercises.html",
    "href": "02_AdvancedProgramming/09_UsingClasses/Chapter_09_ExtensionExercises.html",
    "title": "Extended Exercises for Chapter 9",
    "section": "",
    "text": "Write a music track storage program that lets you search for tracks based on the length of the track. The program could suggest tracks that could be combined to fill an exact amount of time or give the total play time of a specific playlist.\nYou will have to create a class that can hold track information, store the information in a list and then create some behaviours that would search through and process the data\nThis is the most complicated application that we have built so far, and so it is best to both design and implement in stages. We’ll sketch the process and some of the functions out here, but the full program can be found in our implementation. First storyboard out the high level functionality we want.\n\n\nAt the highest level there are two functionalities we need from the given brief,\n1. Enter Tracks and manage tracks in a database\n2. Use these Tracks to build playlists\nIf we focus in on the first item, this is similar to our Tiny Contacts Program. We also have the feature that we want to be able to search for tracks based on their length. This leads to the following interface,\n1. Add a Track\n2. Edit a Track\n3. Remove a Track\n4. Sort Tracks by decreasing length\n5. Sort Tracks by increasing length\n6. Find Tracks by Name\n7. Find Tracks shorter than a given length\n8. Find Tracks longer than a  given length\n\nEnter a command:\nSince we want to be able to easily save, load and reconstruct the music track objects we’ll use pickle to implement saving and loading in the same way as for Tiny Contacts (i.e. on program start and exit)\nWe can then turn to our playlist interface. At some level this will look like the interface for adding tracks to the database. With some extra featues such as a convenience function to remove all the tracks in a playlist. The two functions we were told that we had to add was\n\nTo be able to get the length of a given playlist, and,\nTo be able to generate a playlist of an exact length given the tracks in the database.\n\nIt would also be nice for the user to be able to save their playlist. We want this to be something human readable they could give to a friend, so we’ll simply output the track names to a text file.\nFor simplicity we’ll assume that the user can only work on one playlist at a time.\nOur interface would look like,\n1. Add Track to Playlist\n2. Remove Track from Playlist\n3. Clear Playlist\n4. Display Current Playlist\n5. Show Runtime of Current Playlist\n6. Suggest Playlist of Specified Length\n7. Save Current Playlist\n\n\n\nThe most immediate problem is that we have a lot of functionality, that would probably overwhelm the user. To get around this we will have a general main menu (as seen below) and sub-menus for\n\nModifying the track database\nDisplaying / Searching the Track database\nBuild Playlists\n\ndef run_main_menu():\n    \"\"\"Provides the user with a looping main menu\n\n    The user has the option to,\n    1. Manage Tracks\n    2. Find and Display Tracks\n    3. Manage a Playlist\n    4. Exit the program\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    ValueError\n        An invalid number is encountered in menu selection, should not\n        occur in live code, please raise a bug report if encountered\n\n    \"\"\"\n    main_menu = \"\"\"Music Storage\n\n1. Track Management\n2. Find and Display Tracks\n3. Playlist Management\n4. Exit Program\n\nEnter your command: \"\"\"\n    while True:\n        command = BTCInput.read_int_ranged(prompt=main_menu, min_value=1, max_value=4)\n        if command == 1:\n            run_track_menu()\n        elif command == 2:\n            run_display_track_menu()\n        elif command == 3:\n            run_playlist_management_menu()\n        elif command == 4:\n            try:\n                save_tracks(file_name)\n            except:  # noqa: E722\n                print(\"Tracks failed to save\")\n            break\n        else:\n            raise ValueError(\n                \"Unexpected command id found: \" + str(command) + \" in main menu\"\n            )\nThe sub-menu’s look similar (see below). The main menu lets us exit the program, while the sub-menu’s exit back to the main menu.\ndef run_display_track_menu():\n    \"\"\"\n    Provides the user with a looping menu to display tracks\n\n    The user has the option to\n    1. Display tracks matching a name\n    2. Display tracks less than (or equal to) a given max length\n    3. Display tracks greater than (or equal to) a given min length\n    4. Return to the Main Menu\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    ValueError\n        An invalid number is encountered in menu selection, should not\n        occur in live code, please raise a bug report if encountered\n    \"\"\"\n\n    display_track_menu = \"\"\"Find and Display Tracks\n\n1. Find Tracks by Name\n2. Find Tracks by length (Maximum length)\n3. Find Tracks by length (Minimum length)\n4. Back to Main Menu\n\nEnter your command: \"\"\"\n    while True:\n        command = BTCInput.read_int_ranged(\n            prompt=display_track_menu, min_value=1, max_value=4\n        )\n        if command == 1:\n            find_tracks_by_name()\n        elif command == 2:\n            find_tracks_shorter_than_length()\n        elif command == 3:\n            find_tracks_greater_than_length()\n        elif command == 4:\n            break\n        else:\n            raise ValueError(\n                \"Invalid command id \"\n                + str(command)\n                + \" found in track display sub-menu\"\n            )\n\n\n\nLet’s work through the sections step by step.\n\n\nFirst we need to define our Music Track objects. We use a simple class that stores a name and a track length. We use seconds for the length. We name the variables name and length_in_seconds to make them clear.\n\nclass MusicTrack:\n    \"\"\"\n    Music Track with a name and a length (in seconds)\n\n    Attributes\n    ----------\n    name : str\n        name of the music track\n    length_in_seconds : int\n        length of the track in seconds\n\n    Raises\n    ------\n    ValueError\n        Raised if `length_in_seconds` is non-positive\n\n    Examples\n    --------\n    &gt;&gt;&gt; MusicTrack(\"Merry Christmas Everyone\", 220)\n    &lt;MusicTrack ...&gt;\n    \"\"\"\n\n    def __init__(self, name, length_in_seconds):\n        \"\"\"\n        Create a new MusicTrack instance\n\n        Parameters\n        ----------\n        name : str\n            name of the music track\n        length_in_seconds : int\n            length of the track in seconds (must be positive)\n\n        Raises\n        ------\n        ValueError\n                Raised if length_in_seconds is invalid\n        \"\"\"\n        self.name = name\n        if length_in_seconds &lt;= 0:\n            raise ValueError(\"Track length must be greater than zero\")\n        self.length_in_seconds = length_in_seconds\n\nOne immediate caveat is that a music track should not have a length that isn’t a positive integer. We enforce this by raising an exception if one is passed to the constructor.\nWe would also ideally like to take care of this at the user input level. It would be pretty frustrating to put in a number as a user then have the program crash. We would like to enforce that the user can put in any positive number, unfortunately BTCInput doesn’t provide this. We could simply put an upper bound on the track length, instead we roll our own input function.\ndef read_min_valued_integer(prompt, min_value):\n    \"\"\"\n    Displays a prompt and reads in a integer number greater\n    than or equal to min_value.\n\n    Keyboard interrupts (CTRL+C) are ignored\n    Invalid numbers are rejected\n    returns a number containing the value input by the user\n\n    Parameters\n    ----------\n    prompt : str\n        string to display to the user before the enter the number\n\n    min_value : int\n        minimum value (inclusive) to accept from the user\n\n    Returns\n    -------\n    int\n        integer &gt; 0 entered by the user\n    \"\"\"\n    while True:\n        result = BTCInput.read_int(prompt)\n        if result &gt;= min_value:\n            return result\n        else:\n            print(\"That number is invalid\")\n            print(\"Number must be &gt;\", min_value)\nWe make this generic by calling it read_min_valued_integer and using a parameter to define a min_value. There is no bound on the max_value. We then use BTCInput.read_int and wrap it in the bound checkings we need.\n\n\n\nWe can then define a function new_track to add tracks to the database,\ndef new_track():\n    \"\"\"\n    Creates and adds a new track to the track storage program\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    MusicTrack : class for storing music track information\n    \"\"\"\n    print(\"Add a new track\")\n    name = BTCInput.read_text(\"Enter the track name: \")\n    length = read_min_valued_integer(\n        \"Enter the track length (in seconds): \", min_value=1\n    )\n    tracks.append(MusicTrack(name=name, length_in_seconds=length))\n\nRunning the above with the input, (represented by red text), generates output like,\n\n\nprint(\"Enter the track name: \\033[31mMerry Christmas Everyone\\033[0m\")\nprint(\"Enter the track length (in seconds): \\033[31m220\\033[0m\")\nprint(tracks)\nprint(tracks[0].name)\nprint(tracks[0].length_in_seconds)\n\n\nEnter the track name: Merry Christmas Everyone\n\nEnter the track length (in seconds): 220\n\n[&lt;__main__.MusicTrack object at 0x7fcfe88184a0&gt;]\n\nMerry Christmas Everyone\n\n220\n\n\n\n\n\n\n\nBefore we go further we need to implement a search by name functionality. We’ll adopt the following convention\n\nA filter_ function takes a search parameter, and a list of of MusicTrack objects to search through and returns a list of MusicTrack objects that meet the conditions\n\nBy adding the list parameter we can reuse these functions for the playlist functionality later\n\nA find_ function, prompts the user for the search parameter, calls the corresponding filter_ and displays the list\n\nThe first filter_ we implement is filter_by_name which uses the same logic as Tiny Contacts (a name is searched using startswith). See below,\n\ndef filter_tracks_by_name(search_name, tracks_to_search):\n    \"\"\"\n    Finds tracks matching a search name\n\n    Filters tracks from the list `tracks_to_search` with a name\n    containing `search_name` as a prefix\n\n    Parameters\n    ----------\n    search_name : str\n        name to search for (search uses prefix matching)\n\n    tracks_to_search : list[MusicTrack]\n        list of music tracks to search through\n\n    Returns\n    -------\n    list[MusicTrack]\n        list of contacts matching the name. If no matches\n        exist the list is empty\n\n    \"\"\"\n    search_name = search_name.strip().lower()  # normalise the search name\n    results = []\n    for track in tracks_to_search:\n        name = track.name.strip().lower()  # normalise track word\n        if name.startswith(search_name):\n            results.append(track)\n    return results\n\nRunning this for the track we just added,\n\n# looking for a match that exists\nresults = filter_tracks_by_name(\"Merry Christmas\", tracks)\n\nprint(results)\nprint(results[0].name)\nprint(results[0].length_in_seconds)\n\n# looking for non existent match\nprint(filter_tracks_by_name(\"Missing Track\", tracks))\n\n[&lt;__main__.MusicTrack object at 0x7fcfe88184a0&gt;]\nMerry Christmas Everyone\n220\n[]\n\n\n\n\n\nWe can now implement the edit functionality with edit_tracks, using the same pattern we discussed before.\n\nWe find all the matches to a named search\nThe user is then prompted if they want to edit each match\nThe user can then edit each entry\n\ndef edit_tracks():\n    \"\"\"\n    Edits a user selected track\n\n    Reads in a name to search for and then allows the user to edit\n    the details of the Music Track\n\n    If there a no matching Music Tracks the function will indicate\n    that the name was not found. If multiple matches are found, the\n    user will have the option to edit each of them\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    filter_tracks_by_name : filters a list of tracks by a search name\n    \"\"\"\n    print(\"Edit Music Tracks\")\n    matched_tracks = filter_tracks_by_name(\n        BTCInput.read_text(\"Enter track name to edit: \"), tracks\n    )\n    print(\"Found\", len(matched_tracks), \"matches\")\n\n    for track in matched_tracks:\n        display_track(track)\n        if BTCInput.read_int_ranged(\n            \"Edit this track? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        ):\n            new_name = BTCInput.read_text(\"Enter new name or . to leave unchanged: \")\n            if new_name != \".\":\n                track.name = new_name\n            new_length_in_seconds = read_min_valued_integer(\n                \"Enter new length (in seconds) or 0 to leave unchanged: \", min_value=0\n            )\n            if new_length_in_seconds != 0:\n                track.length_in_seconds = new_length_in_seconds\nWe have to make one change to the pattern of the Tiny Contacts which is to account for the fact that length is a positive number. To do this we use 0 rather than \".\" to indicate that the variable should be left unchanged. An example use might look like,\n\nprint(\"Edit Music Tracks\")\nprint(\"Enter track name to edit: \\033[31mMerry Christmas Everyone\\033[0m\")\nprint(\"Found 1 matches\")\nprint(\"Merry Christmas Everyone (220 seconds)\")\nprint(\"Edit this track? (1 - Yes, 0 - No): \\033[31m1\\033[0m\")\nprint(\"Enter new name or . to leave unchanged: \\033[31m.\\033[0m\")\nprint(\"Enter new name or 0 to leave unchanged: \\033[31m210\\033[0m\")\n\nprint(tracks[0].name)\nprint(tracks[0].length_in_seconds)\n\n\nEdit Music Tracks\n\nEnter track name to edit: Merry Christmas Everyone\n\nFound 1 matches\n\nMerry Christmas Everyone (220 seconds)\n\nEdit this track? (1 - Yes, 0 - No): 1\n\nEnter new name or . to leave unchanged: .\n\nEnter new name or 0 to leave unchanged: 210\n\nMerry Christmas Everyone\n\n210\n\n\n\n\n\n\n\nThe remove_track follows the same pattern, instead of the edit dialog, we use the .remove method on a list to remove the matching track,\n    for track in matched_tracks:\n        display_track(track)\n        if BTCInput.read_int_ranged(\"Delete this track? (1 - Yes, 0 - No): \", 0, 1):\n            tracks.remove(track)\n\n\n\nThe next step is to implement sorting functionality. Based on the description we implement these sorts based on the length of the track. The ascending order search is then,\n\ndef sort_low_to_high(tracks_to_sort):\n    \"\"\"\n    Sorts tracks by increasing track length\n\n    Sorts the music track list given by `tracks_to_sort`\n    by length from shortest to greatest\n\n    Parameters\n    ----------\n    tracks_to_sort : list[MusicTrack]\n        list of tracks to sort\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    sort_high_to_low : sort tracks by decreasing track length\n    \"\"\"\n    print(\"Sort low to high\")\n    for sort_pass in range(0, len(tracks)):\n        done_swap = False\n        for count in range(0, len(tracks) - 1 - sort_pass):\n            if (\n                tracks_to_sort[count].length_in_seconds\n                &gt; tracks_to_sort[count + 1].length_in_seconds\n            ):\n                temp = tracks_to_sort[count]\n                tracks_to_sort[count] = tracks_to_sort[count + 1]\n                tracks_to_sort[count + 1] = temp\n                done_swap = True\n        if not done_swap:\n            break\n\nLet’s add another track Rockin Little Christmas, 157 seconds,\n\ntracks.append(MusicTrack(\"Rockin Little Christmas\", 157))\n\nprint(\"tracks[0]:\", tracks[0].name, tracks[0].length_in_seconds)\nprint(\"tracks[1]:\", tracks[1].name, tracks[1].length_in_seconds)\n\ntracks[0]: Merry Christmas Everyone 210\ntracks[1]: Rockin Little Christmas 157\n\n\nThen if we run the sort,\n\nsort_low_to_high(tracks)\nprint(\"tracks[0]:\", tracks[0].name, tracks[0].length_in_seconds)\nprint(\"tracks[1]:\", tracks[1].name, tracks[1].length_in_seconds)\n\nSort low to high\ntracks[0]: Rockin Little Christmas 157\ntracks[1]: Merry Christmas Everyone 210\n\n\nThe descending order search follows the same structure.\n\n\n\nThe only two track database management functions now are save and load, which are done simply via pickle.\ndef save_tracks(file_name):\n    \"\"\"\n    Saves the music tracks to the given file\n\n    Music tracks are stored in binary as a pickled file\n\n    Parameters\n    ----------\n    file_name : str\n        string giving the path to the file to store the track data in\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    An Exception is raised if the file could not be saved\n\n    See Also\n    --------\n    load_tracks : load music tracks from a pickled file\n    \"\"\"\n    print(\"Save music tracks\")\n    with open(file_name, \"wb\") as out_file:\n        pickle.dump(tracks, out_file)\n\n\ndef load_tracks(file_name):\n    \"\"\"\n    Loads the music tracks from the given file\n\n    Music Tracks are stored in binary as a pickled file\n\n    Parameters\n    ----------\n    file_name : str\n        string giving the path to the file where the recipes data is stored\n\n    Returns\n    -------\n    None\n        Music Tracks are loaded into the global tracks list\n\n    Raises\n    ------\n    An Exception is raised if the file could not be loaded\n\n    See Also\n    --------\n    save_tracks : save tracks as a pickled file\n    \"\"\"\n    global tracks  # connect to global track list to load into\n    print(\"Load contacts\")\n    with open(file_name, \"rb\") as input_file:\n        tracks = pickle.load(input_file)\nsave_tracks is called on program exit to write out the track database to a hard-coded database file. Similarly, load_tracks will attempt to read the database file on program start. If it can’t find the database file then a new blank database is generated\n\n\n\n\nWith our track database management up and running the next step is to look set up how we can display and search for the tracks in the database. The three functionalities we have to implement are,\n1. Find Tracks (by name)\n2. Find Tracks by length (Maximum length)\n3. Find Tracks by length (Minimum length)\nThe first one simply wraps the filter_tracks_by_name in a user prompt for a search name and displays the matches. This just leaves us to implement the display functionality.\n\n\nWe first define a function display_track to display a single track,\n\ndef display_track(track):\n    \"\"\"\n    Displays the name and length (in seconds) of a track\n\n    Params\n    ------\n    track : MusicTrack\n        track to display\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_tracks : display all tracks in a list\n    \"\"\"\n    print(\"Name:\", track.name, \"(\", track.length_in_seconds, \"seconds )\")\n\nWe can see how it used below,\n\ndisplay_track(tracks[0])\n\nName: Rockin Little Christmas ( 157 seconds )\n\n\nWe can then define a higher level function display_tracks that displays an entire list of tracks,\n\ndef display_tracks(tracks):\n    \"\"\"\n    Displays all the tracks in the provided list of tracks\n\n    Params\n    ------\n    list[MusicTrack]\n        List of MusicTrack objcts to display\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_track : display a single track\n    \"\"\"\n    if len(tracks) &gt; 0:\n        for track in tracks:\n            display_track(track)\n    else:\n        print(\"No tracks found\")\n\nFor example, running on our small little example track list,\n\ndisplay_tracks(tracks)\n\nName: Rockin Little Christmas ( 157 seconds )\nName: Merry Christmas Everyone ( 210 seconds )\n\n\n\n\n\nLet us consider the problem of now finding tracks by a given length. We want two functions. One where we return all tracks with a length less than or equal to the provided length, and a second which returns all with a length greater than or equal to the provided length. Both have the same logic so we’ll only focus on the first case. As with filter_tracks_by_name we first define a filter function that takes in a maximum length as a parameter (and a search list) and returns a list of matches. This looks like,\n\ndef filter_tracks_shorter_than_length(max_length, tracks_to_filter):\n    \"\"\"\n    Filter a list of tracks to those shorter than a target length\n\n    Finds and returns a list of all tracks with a length\n    shorter (or equal to) `max_length` in the provided `tracks_to_filter`\n\n    Parameters\n    ----------\n    max_length : int\n        maximum (inclusive) length of tracks to include in\n        the filtered result\n\n    tracks_to_filter : list[MusicTrack]\n        list of tracks to filter\n\n    Returns\n    -------\n    list[MusicTrack]\n        List of MusicTracks satisfying\n        `MusicTrack.length_in_seconds &lt;= maximum length`.\n        If no MusicTracks are found an empty list is returned\n\n    See Also\n    --------\n    filter_tracks_greater_than_length : filters out tracks shorter than a given length\n    \"\"\"\n    tracks_shorter_than_max_length = []\n    for track in tracks_to_filter:\n        if track.length_in_seconds &lt;= max_length:\n            tracks_shorter_than_max_length.append(track)\n    return tracks_shorter_than_max_length\n\nTo see how this function works, lets run it on our test list, with three values, 220 which should catch everything, 200 which should catch one track, and 100 which should catch nothing.\n\nprint(\"Filter all the tracks...\")\ndisplay_tracks(filter_tracks_shorter_than_length(220, tracks))\nprint(\"Filter some of the tracks...\")\ndisplay_tracks(filter_tracks_shorter_than_length(200, tracks))\nprint(\"Filter none of the tracks\")\ndisplay_tracks(filter_tracks_shorter_than_length(100, tracks))\n\nFilter all the tracks...\nName: Rockin Little Christmas ( 157 seconds )\nName: Merry Christmas Everyone ( 210 seconds )\nFilter some of the tracks...\nName: Rockin Little Christmas ( 157 seconds )\nFilter none of the tracks\nNo tracks found\n\n\nWe can then define the find_tracks_shorter_than_length function, we prompts the user for the maximum time, passes this time and the tracks list through to the filter function and displays the results.\ndef find_tracks_shorter_than_length():\n    \"\"\"\n    Finds and displays all tracks shorter (or equal to) a user prompted\n    maximum length\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    filter_tracks_shorter_than_length : filters out tracks greater than a given length\n    \"\"\"\n    max_length = read_min_valued_integer(\n        \"Enter the maximum track length (in seconds): \", min_value=1\n    )\n    display_tracks(filter_tracks_shorter_than_length(max_length, tracks))\nThe case where we instead pass a minimum time is identical\n\n\n\n\nFor the most part, the playlist management repeats code that has already been seen before. We’ll only allow the user to work with one playlist at a time, and store the playlist as a list of MusicTrack objects. Recall that our interface is,\n1. Add Track to Playlist\n2. Remove Track from Playlist\n3. Clear Playlist\n4. Display Current Playlist\n5. Show Runtime of Current Playlist\n6. Suggest Playlist of Specified Length\n7. Save Current Playlist\n8. Back to Main Menu\nLet’s step through each of these and look at what needs new functionality\n\nadd_track_to_playlist - Uses existing filter_track_by_name to search for a user prompted track name. User is then prompted to optionally add matches to the playlist\nremove_tracks_from_playlist - Identical to remove_track but runs against the current playlist list\nclear_playlist - We use the list inbuilt method clear to clear the playlist\ndisplay_current_playlist - Achieved by passing the playlist list variable to the display_tracks function\ncalculate_playlist_length - No functionality yet implemented\nsuggest_playlist_of_given_length - No functionality yet implemented\nsave_playlist - Not yet implemented\n\nSo as we can see most of the functionality is already implemented. Let’s focus on the three remaining features, calculate_playlist_length, suggest_playlist_of_given_length and save_playlist\n\n\nImplementing calculate_playlist_length is pretty straightforward. We simply iterate over the tracks in the playlist and sum up their lengths\n\ndef calculate_playlist_length():\n    \"\"\"\n    Calculates and displays the total length of the\n    current playlist in seconds\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"Calculate length of playlist\")\n    total_length = 0\n    for track in playlist:\n        total_length = total_length + track.length_in_seconds\n    print(\"The playlist is\", total_length, \"seconds long\")\n\nFor example, if we use a little bit of magic to change our tracks list to the playlist, we can demonstrate the above function,\n\nplaylist = tracks\ncalculate_playlist_length()\n\nCalculate length of playlist\nThe playlist is 367 seconds long\n\n\n\n\n\nSimilarly, save_playlist can be implemented pretty easily using what we’ve seen. We prompt the user for the file that they want to save to, then write out the names of all of the tracks (one per line) using the standard try...except and with consruct we’ve seen before\ndef save_playlist():\n    \"\"\"\n    Saves the current playlist as a human readable list\n\n    The user is prompted to give a file name to save the playlist in\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    Exceptions are raised if the save fails\n    \"\"\"\n    print(\"Save playlist\")\n    if len(playlist) == 0:\n        print(\"No playlist to save\")\n        return\n\n    file_name = BTCInput.read_text(\"Enter file to save playlist to: \")\n    try:\n        with open(file_name, \"w\") as output_file:\n            for track in playlist:\n                output_file.write(track.name + \"\\n\")\n    except:  # noqa: E722\n        print(\"Failed to save playlist\")\n\n\n\nObserve that the user always has to choose to save the playlist. This is because we implement it much more as form of printing out a list of songs to give to someone else rather than ensuring that a database is maintained. As a result we provide no behaviour for loading a playlist\nThe last function we want to implement is the ability to suggest a playlist of a given length. The original exercise suggests this as being to create a playlist of an exact length. Doing this requires us to solve what is called the Subset Sum Problem which is in general very difficult - we are asked to find a subset of the tracks in the database such that the sum of their lengths matches the target. Intuitively we should also recognise that given the granularity of song lengths for many lengths the user might put in, no exact solution exists.\nOur solution to this will be to instead ask the user for an upper bound on the playlist length. We will then randomly select songs such that the total length is less than this length. The user is then shown the proposed playlist and can either accept or reject it. If the reject it they can then ask the program to generate a new one. Once a playlist is accepted it can be edited using the other playlist management functions.\nOur implementation for this is below,\ndef suggest_playlist_of_given_length():\n    \"\"\"\n    Suggests a playlist of length less than or equal to\n    a user prompted length\n\n    Asks the user for a maximum playlist length, and\n    then suggests a playlist by combining tracks randomly\n    such that the suggested playlist is no greater than\n    the length\n\n    The user has the option to review the proposed list\n    and either accept, reject or regenerate the list\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"Suggest playlist of given length\")\n    global playlist\n\n    target_length = read_min_valued_integer(\n        \"Enter maximum playlist length: \", min_value=1\n    )\n\n    while True:\n        suggested_playlist = []\n        playlist_length = 0\n        # find tracks that could fit in the playlist\n        candidate_songs = filter_tracks_shorter_than_length(target_length, tracks)\n\n        if len(candidate_songs) == 0:\n            print(\"Could not generate a playlist of that length. Try a longer playlist\")\n            return\n\n        while len(candidate_songs) &gt; 0:  # stop when no more eligable songs\n            # add a random song and update the playlist length\n            song_choice = random.choice(candidate_songs)\n            suggested_playlist.append(song_choice)\n            playlist_length = playlist_length + song_choice.length_in_seconds\n\n            # filter out songs that no longer fit\n            candidate_songs = filter_tracks_shorter_than_length(\n                target_length - playlist_length, candidate_songs\n            )\n        print(\"Generated a playlist...\")\n        # let the user review the playlist\n        display_tracks(suggested_playlist)\n        if BTCInput.read_int_ranged(\n            \"Accept this playlist? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        ):\n            playlist = suggested_playlist\n            return\n        else:\n            if BTCInput.read_int_ranged(\n                \"Generate again? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n            ):\n                continue\n            return\nThe bulk of the logic however is given by (after getting target_length from the user),\n        candidate_songs = filter_tracks_shorter_than_length(target_length, tracks)\n\n        if len(candidate_songs) == 0:\n            print(\"Could not generate a playlist of that length. Try a longer playlist\")\n            return\n\n        while len(candidate_songs) &gt; 0:  # stop when no more eligable songs\n            # add a random song and update the playlist length\n            song_choice = random.choice(candidate_songs)\n            suggested_playlist.append(song_choice)\n            playlist_length = playlist_length + song_choice.length_in_seconds\n\n            # filter out songs that no longer fit\n            candidate_songs = filter_tracks_shorter_than_length(\n                target_length - playlist_length, candidate_songs\n            )\n\nWe filter the track database to get all the tracks that could fit in the allowed playlist time\nWe then randomly pick one of the songs using random.choice\n\nWe add this to our proposed playlist, and add its length to a counter tracking the total length\n\nWe then filter the candidate list again but with the amount of time we have yet to use (target_time - playlist_length)\nWe repeat steps 2-3 until there are no more candidate songs, this gives our final playlist which we can then propose to the user\n\nThis sums up the description of the music storage app. The provided code demonstrates a sample database in tracks.pickle and a sample playlist in example_playlist.txt. You are encouraged to play around with the code and make sure you understand what is going on. This program is not super complicated but it has many components, if you can follow it, you are doing well!",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 9: Use Classes to Store Data",
      "Extended Exercises for Chapter 9"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/09_UsingClasses/Chapter_09_ExtensionExercises.html#make-something-happen-music-storage-app",
    "href": "02_AdvancedProgramming/09_UsingClasses/Chapter_09_ExtensionExercises.html#make-something-happen-music-storage-app",
    "title": "Extended Exercises for Chapter 9",
    "section": "",
    "text": "Write a music track storage program that lets you search for tracks based on the length of the track. The program could suggest tracks that could be combined to fill an exact amount of time or give the total play time of a specific playlist.\nYou will have to create a class that can hold track information, store the information in a list and then create some behaviours that would search through and process the data\nThis is the most complicated application that we have built so far, and so it is best to both design and implement in stages. We’ll sketch the process and some of the functions out here, but the full program can be found in our implementation. First storyboard out the high level functionality we want.\n\n\nAt the highest level there are two functionalities we need from the given brief,\n1. Enter Tracks and manage tracks in a database\n2. Use these Tracks to build playlists\nIf we focus in on the first item, this is similar to our Tiny Contacts Program. We also have the feature that we want to be able to search for tracks based on their length. This leads to the following interface,\n1. Add a Track\n2. Edit a Track\n3. Remove a Track\n4. Sort Tracks by decreasing length\n5. Sort Tracks by increasing length\n6. Find Tracks by Name\n7. Find Tracks shorter than a given length\n8. Find Tracks longer than a  given length\n\nEnter a command:\nSince we want to be able to easily save, load and reconstruct the music track objects we’ll use pickle to implement saving and loading in the same way as for Tiny Contacts (i.e. on program start and exit)\nWe can then turn to our playlist interface. At some level this will look like the interface for adding tracks to the database. With some extra featues such as a convenience function to remove all the tracks in a playlist. The two functions we were told that we had to add was\n\nTo be able to get the length of a given playlist, and,\nTo be able to generate a playlist of an exact length given the tracks in the database.\n\nIt would also be nice for the user to be able to save their playlist. We want this to be something human readable they could give to a friend, so we’ll simply output the track names to a text file.\nFor simplicity we’ll assume that the user can only work on one playlist at a time.\nOur interface would look like,\n1. Add Track to Playlist\n2. Remove Track from Playlist\n3. Clear Playlist\n4. Display Current Playlist\n5. Show Runtime of Current Playlist\n6. Suggest Playlist of Specified Length\n7. Save Current Playlist\n\n\n\nThe most immediate problem is that we have a lot of functionality, that would probably overwhelm the user. To get around this we will have a general main menu (as seen below) and sub-menus for\n\nModifying the track database\nDisplaying / Searching the Track database\nBuild Playlists\n\ndef run_main_menu():\n    \"\"\"Provides the user with a looping main menu\n\n    The user has the option to,\n    1. Manage Tracks\n    2. Find and Display Tracks\n    3. Manage a Playlist\n    4. Exit the program\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    ValueError\n        An invalid number is encountered in menu selection, should not\n        occur in live code, please raise a bug report if encountered\n\n    \"\"\"\n    main_menu = \"\"\"Music Storage\n\n1. Track Management\n2. Find and Display Tracks\n3. Playlist Management\n4. Exit Program\n\nEnter your command: \"\"\"\n    while True:\n        command = BTCInput.read_int_ranged(prompt=main_menu, min_value=1, max_value=4)\n        if command == 1:\n            run_track_menu()\n        elif command == 2:\n            run_display_track_menu()\n        elif command == 3:\n            run_playlist_management_menu()\n        elif command == 4:\n            try:\n                save_tracks(file_name)\n            except:  # noqa: E722\n                print(\"Tracks failed to save\")\n            break\n        else:\n            raise ValueError(\n                \"Unexpected command id found: \" + str(command) + \" in main menu\"\n            )\nThe sub-menu’s look similar (see below). The main menu lets us exit the program, while the sub-menu’s exit back to the main menu.\ndef run_display_track_menu():\n    \"\"\"\n    Provides the user with a looping menu to display tracks\n\n    The user has the option to\n    1. Display tracks matching a name\n    2. Display tracks less than (or equal to) a given max length\n    3. Display tracks greater than (or equal to) a given min length\n    4. Return to the Main Menu\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    ValueError\n        An invalid number is encountered in menu selection, should not\n        occur in live code, please raise a bug report if encountered\n    \"\"\"\n\n    display_track_menu = \"\"\"Find and Display Tracks\n\n1. Find Tracks by Name\n2. Find Tracks by length (Maximum length)\n3. Find Tracks by length (Minimum length)\n4. Back to Main Menu\n\nEnter your command: \"\"\"\n    while True:\n        command = BTCInput.read_int_ranged(\n            prompt=display_track_menu, min_value=1, max_value=4\n        )\n        if command == 1:\n            find_tracks_by_name()\n        elif command == 2:\n            find_tracks_shorter_than_length()\n        elif command == 3:\n            find_tracks_greater_than_length()\n        elif command == 4:\n            break\n        else:\n            raise ValueError(\n                \"Invalid command id \"\n                + str(command)\n                + \" found in track display sub-menu\"\n            )\n\n\n\nLet’s work through the sections step by step.\n\n\nFirst we need to define our Music Track objects. We use a simple class that stores a name and a track length. We use seconds for the length. We name the variables name and length_in_seconds to make them clear.\n\nclass MusicTrack:\n    \"\"\"\n    Music Track with a name and a length (in seconds)\n\n    Attributes\n    ----------\n    name : str\n        name of the music track\n    length_in_seconds : int\n        length of the track in seconds\n\n    Raises\n    ------\n    ValueError\n        Raised if `length_in_seconds` is non-positive\n\n    Examples\n    --------\n    &gt;&gt;&gt; MusicTrack(\"Merry Christmas Everyone\", 220)\n    &lt;MusicTrack ...&gt;\n    \"\"\"\n\n    def __init__(self, name, length_in_seconds):\n        \"\"\"\n        Create a new MusicTrack instance\n\n        Parameters\n        ----------\n        name : str\n            name of the music track\n        length_in_seconds : int\n            length of the track in seconds (must be positive)\n\n        Raises\n        ------\n        ValueError\n                Raised if length_in_seconds is invalid\n        \"\"\"\n        self.name = name\n        if length_in_seconds &lt;= 0:\n            raise ValueError(\"Track length must be greater than zero\")\n        self.length_in_seconds = length_in_seconds\n\nOne immediate caveat is that a music track should not have a length that isn’t a positive integer. We enforce this by raising an exception if one is passed to the constructor.\nWe would also ideally like to take care of this at the user input level. It would be pretty frustrating to put in a number as a user then have the program crash. We would like to enforce that the user can put in any positive number, unfortunately BTCInput doesn’t provide this. We could simply put an upper bound on the track length, instead we roll our own input function.\ndef read_min_valued_integer(prompt, min_value):\n    \"\"\"\n    Displays a prompt and reads in a integer number greater\n    than or equal to min_value.\n\n    Keyboard interrupts (CTRL+C) are ignored\n    Invalid numbers are rejected\n    returns a number containing the value input by the user\n\n    Parameters\n    ----------\n    prompt : str\n        string to display to the user before the enter the number\n\n    min_value : int\n        minimum value (inclusive) to accept from the user\n\n    Returns\n    -------\n    int\n        integer &gt; 0 entered by the user\n    \"\"\"\n    while True:\n        result = BTCInput.read_int(prompt)\n        if result &gt;= min_value:\n            return result\n        else:\n            print(\"That number is invalid\")\n            print(\"Number must be &gt;\", min_value)\nWe make this generic by calling it read_min_valued_integer and using a parameter to define a min_value. There is no bound on the max_value. We then use BTCInput.read_int and wrap it in the bound checkings we need.\n\n\n\nWe can then define a function new_track to add tracks to the database,\ndef new_track():\n    \"\"\"\n    Creates and adds a new track to the track storage program\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    MusicTrack : class for storing music track information\n    \"\"\"\n    print(\"Add a new track\")\n    name = BTCInput.read_text(\"Enter the track name: \")\n    length = read_min_valued_integer(\n        \"Enter the track length (in seconds): \", min_value=1\n    )\n    tracks.append(MusicTrack(name=name, length_in_seconds=length))\n\nRunning the above with the input, (represented by red text), generates output like,\n\n\nprint(\"Enter the track name: \\033[31mMerry Christmas Everyone\\033[0m\")\nprint(\"Enter the track length (in seconds): \\033[31m220\\033[0m\")\nprint(tracks)\nprint(tracks[0].name)\nprint(tracks[0].length_in_seconds)\n\n\nEnter the track name: Merry Christmas Everyone\n\nEnter the track length (in seconds): 220\n\n[&lt;__main__.MusicTrack object at 0x7fcfe88184a0&gt;]\n\nMerry Christmas Everyone\n\n220\n\n\n\n\n\n\n\nBefore we go further we need to implement a search by name functionality. We’ll adopt the following convention\n\nA filter_ function takes a search parameter, and a list of of MusicTrack objects to search through and returns a list of MusicTrack objects that meet the conditions\n\nBy adding the list parameter we can reuse these functions for the playlist functionality later\n\nA find_ function, prompts the user for the search parameter, calls the corresponding filter_ and displays the list\n\nThe first filter_ we implement is filter_by_name which uses the same logic as Tiny Contacts (a name is searched using startswith). See below,\n\ndef filter_tracks_by_name(search_name, tracks_to_search):\n    \"\"\"\n    Finds tracks matching a search name\n\n    Filters tracks from the list `tracks_to_search` with a name\n    containing `search_name` as a prefix\n\n    Parameters\n    ----------\n    search_name : str\n        name to search for (search uses prefix matching)\n\n    tracks_to_search : list[MusicTrack]\n        list of music tracks to search through\n\n    Returns\n    -------\n    list[MusicTrack]\n        list of contacts matching the name. If no matches\n        exist the list is empty\n\n    \"\"\"\n    search_name = search_name.strip().lower()  # normalise the search name\n    results = []\n    for track in tracks_to_search:\n        name = track.name.strip().lower()  # normalise track word\n        if name.startswith(search_name):\n            results.append(track)\n    return results\n\nRunning this for the track we just added,\n\n# looking for a match that exists\nresults = filter_tracks_by_name(\"Merry Christmas\", tracks)\n\nprint(results)\nprint(results[0].name)\nprint(results[0].length_in_seconds)\n\n# looking for non existent match\nprint(filter_tracks_by_name(\"Missing Track\", tracks))\n\n[&lt;__main__.MusicTrack object at 0x7fcfe88184a0&gt;]\nMerry Christmas Everyone\n220\n[]\n\n\n\n\n\nWe can now implement the edit functionality with edit_tracks, using the same pattern we discussed before.\n\nWe find all the matches to a named search\nThe user is then prompted if they want to edit each match\nThe user can then edit each entry\n\ndef edit_tracks():\n    \"\"\"\n    Edits a user selected track\n\n    Reads in a name to search for and then allows the user to edit\n    the details of the Music Track\n\n    If there a no matching Music Tracks the function will indicate\n    that the name was not found. If multiple matches are found, the\n    user will have the option to edit each of them\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    filter_tracks_by_name : filters a list of tracks by a search name\n    \"\"\"\n    print(\"Edit Music Tracks\")\n    matched_tracks = filter_tracks_by_name(\n        BTCInput.read_text(\"Enter track name to edit: \"), tracks\n    )\n    print(\"Found\", len(matched_tracks), \"matches\")\n\n    for track in matched_tracks:\n        display_track(track)\n        if BTCInput.read_int_ranged(\n            \"Edit this track? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        ):\n            new_name = BTCInput.read_text(\"Enter new name or . to leave unchanged: \")\n            if new_name != \".\":\n                track.name = new_name\n            new_length_in_seconds = read_min_valued_integer(\n                \"Enter new length (in seconds) or 0 to leave unchanged: \", min_value=0\n            )\n            if new_length_in_seconds != 0:\n                track.length_in_seconds = new_length_in_seconds\nWe have to make one change to the pattern of the Tiny Contacts which is to account for the fact that length is a positive number. To do this we use 0 rather than \".\" to indicate that the variable should be left unchanged. An example use might look like,\n\nprint(\"Edit Music Tracks\")\nprint(\"Enter track name to edit: \\033[31mMerry Christmas Everyone\\033[0m\")\nprint(\"Found 1 matches\")\nprint(\"Merry Christmas Everyone (220 seconds)\")\nprint(\"Edit this track? (1 - Yes, 0 - No): \\033[31m1\\033[0m\")\nprint(\"Enter new name or . to leave unchanged: \\033[31m.\\033[0m\")\nprint(\"Enter new name or 0 to leave unchanged: \\033[31m210\\033[0m\")\n\nprint(tracks[0].name)\nprint(tracks[0].length_in_seconds)\n\n\nEdit Music Tracks\n\nEnter track name to edit: Merry Christmas Everyone\n\nFound 1 matches\n\nMerry Christmas Everyone (220 seconds)\n\nEdit this track? (1 - Yes, 0 - No): 1\n\nEnter new name or . to leave unchanged: .\n\nEnter new name or 0 to leave unchanged: 210\n\nMerry Christmas Everyone\n\n210\n\n\n\n\n\n\n\nThe remove_track follows the same pattern, instead of the edit dialog, we use the .remove method on a list to remove the matching track,\n    for track in matched_tracks:\n        display_track(track)\n        if BTCInput.read_int_ranged(\"Delete this track? (1 - Yes, 0 - No): \", 0, 1):\n            tracks.remove(track)\n\n\n\nThe next step is to implement sorting functionality. Based on the description we implement these sorts based on the length of the track. The ascending order search is then,\n\ndef sort_low_to_high(tracks_to_sort):\n    \"\"\"\n    Sorts tracks by increasing track length\n\n    Sorts the music track list given by `tracks_to_sort`\n    by length from shortest to greatest\n\n    Parameters\n    ----------\n    tracks_to_sort : list[MusicTrack]\n        list of tracks to sort\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    sort_high_to_low : sort tracks by decreasing track length\n    \"\"\"\n    print(\"Sort low to high\")\n    for sort_pass in range(0, len(tracks)):\n        done_swap = False\n        for count in range(0, len(tracks) - 1 - sort_pass):\n            if (\n                tracks_to_sort[count].length_in_seconds\n                &gt; tracks_to_sort[count + 1].length_in_seconds\n            ):\n                temp = tracks_to_sort[count]\n                tracks_to_sort[count] = tracks_to_sort[count + 1]\n                tracks_to_sort[count + 1] = temp\n                done_swap = True\n        if not done_swap:\n            break\n\nLet’s add another track Rockin Little Christmas, 157 seconds,\n\ntracks.append(MusicTrack(\"Rockin Little Christmas\", 157))\n\nprint(\"tracks[0]:\", tracks[0].name, tracks[0].length_in_seconds)\nprint(\"tracks[1]:\", tracks[1].name, tracks[1].length_in_seconds)\n\ntracks[0]: Merry Christmas Everyone 210\ntracks[1]: Rockin Little Christmas 157\n\n\nThen if we run the sort,\n\nsort_low_to_high(tracks)\nprint(\"tracks[0]:\", tracks[0].name, tracks[0].length_in_seconds)\nprint(\"tracks[1]:\", tracks[1].name, tracks[1].length_in_seconds)\n\nSort low to high\ntracks[0]: Rockin Little Christmas 157\ntracks[1]: Merry Christmas Everyone 210\n\n\nThe descending order search follows the same structure.\n\n\n\nThe only two track database management functions now are save and load, which are done simply via pickle.\ndef save_tracks(file_name):\n    \"\"\"\n    Saves the music tracks to the given file\n\n    Music tracks are stored in binary as a pickled file\n\n    Parameters\n    ----------\n    file_name : str\n        string giving the path to the file to store the track data in\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    An Exception is raised if the file could not be saved\n\n    See Also\n    --------\n    load_tracks : load music tracks from a pickled file\n    \"\"\"\n    print(\"Save music tracks\")\n    with open(file_name, \"wb\") as out_file:\n        pickle.dump(tracks, out_file)\n\n\ndef load_tracks(file_name):\n    \"\"\"\n    Loads the music tracks from the given file\n\n    Music Tracks are stored in binary as a pickled file\n\n    Parameters\n    ----------\n    file_name : str\n        string giving the path to the file where the recipes data is stored\n\n    Returns\n    -------\n    None\n        Music Tracks are loaded into the global tracks list\n\n    Raises\n    ------\n    An Exception is raised if the file could not be loaded\n\n    See Also\n    --------\n    save_tracks : save tracks as a pickled file\n    \"\"\"\n    global tracks  # connect to global track list to load into\n    print(\"Load contacts\")\n    with open(file_name, \"rb\") as input_file:\n        tracks = pickle.load(input_file)\nsave_tracks is called on program exit to write out the track database to a hard-coded database file. Similarly, load_tracks will attempt to read the database file on program start. If it can’t find the database file then a new blank database is generated\n\n\n\n\nWith our track database management up and running the next step is to look set up how we can display and search for the tracks in the database. The three functionalities we have to implement are,\n1. Find Tracks (by name)\n2. Find Tracks by length (Maximum length)\n3. Find Tracks by length (Minimum length)\nThe first one simply wraps the filter_tracks_by_name in a user prompt for a search name and displays the matches. This just leaves us to implement the display functionality.\n\n\nWe first define a function display_track to display a single track,\n\ndef display_track(track):\n    \"\"\"\n    Displays the name and length (in seconds) of a track\n\n    Params\n    ------\n    track : MusicTrack\n        track to display\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_tracks : display all tracks in a list\n    \"\"\"\n    print(\"Name:\", track.name, \"(\", track.length_in_seconds, \"seconds )\")\n\nWe can see how it used below,\n\ndisplay_track(tracks[0])\n\nName: Rockin Little Christmas ( 157 seconds )\n\n\nWe can then define a higher level function display_tracks that displays an entire list of tracks,\n\ndef display_tracks(tracks):\n    \"\"\"\n    Displays all the tracks in the provided list of tracks\n\n    Params\n    ------\n    list[MusicTrack]\n        List of MusicTrack objcts to display\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_track : display a single track\n    \"\"\"\n    if len(tracks) &gt; 0:\n        for track in tracks:\n            display_track(track)\n    else:\n        print(\"No tracks found\")\n\nFor example, running on our small little example track list,\n\ndisplay_tracks(tracks)\n\nName: Rockin Little Christmas ( 157 seconds )\nName: Merry Christmas Everyone ( 210 seconds )\n\n\n\n\n\nLet us consider the problem of now finding tracks by a given length. We want two functions. One where we return all tracks with a length less than or equal to the provided length, and a second which returns all with a length greater than or equal to the provided length. Both have the same logic so we’ll only focus on the first case. As with filter_tracks_by_name we first define a filter function that takes in a maximum length as a parameter (and a search list) and returns a list of matches. This looks like,\n\ndef filter_tracks_shorter_than_length(max_length, tracks_to_filter):\n    \"\"\"\n    Filter a list of tracks to those shorter than a target length\n\n    Finds and returns a list of all tracks with a length\n    shorter (or equal to) `max_length` in the provided `tracks_to_filter`\n\n    Parameters\n    ----------\n    max_length : int\n        maximum (inclusive) length of tracks to include in\n        the filtered result\n\n    tracks_to_filter : list[MusicTrack]\n        list of tracks to filter\n\n    Returns\n    -------\n    list[MusicTrack]\n        List of MusicTracks satisfying\n        `MusicTrack.length_in_seconds &lt;= maximum length`.\n        If no MusicTracks are found an empty list is returned\n\n    See Also\n    --------\n    filter_tracks_greater_than_length : filters out tracks shorter than a given length\n    \"\"\"\n    tracks_shorter_than_max_length = []\n    for track in tracks_to_filter:\n        if track.length_in_seconds &lt;= max_length:\n            tracks_shorter_than_max_length.append(track)\n    return tracks_shorter_than_max_length\n\nTo see how this function works, lets run it on our test list, with three values, 220 which should catch everything, 200 which should catch one track, and 100 which should catch nothing.\n\nprint(\"Filter all the tracks...\")\ndisplay_tracks(filter_tracks_shorter_than_length(220, tracks))\nprint(\"Filter some of the tracks...\")\ndisplay_tracks(filter_tracks_shorter_than_length(200, tracks))\nprint(\"Filter none of the tracks\")\ndisplay_tracks(filter_tracks_shorter_than_length(100, tracks))\n\nFilter all the tracks...\nName: Rockin Little Christmas ( 157 seconds )\nName: Merry Christmas Everyone ( 210 seconds )\nFilter some of the tracks...\nName: Rockin Little Christmas ( 157 seconds )\nFilter none of the tracks\nNo tracks found\n\n\nWe can then define the find_tracks_shorter_than_length function, we prompts the user for the maximum time, passes this time and the tracks list through to the filter function and displays the results.\ndef find_tracks_shorter_than_length():\n    \"\"\"\n    Finds and displays all tracks shorter (or equal to) a user prompted\n    maximum length\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    filter_tracks_shorter_than_length : filters out tracks greater than a given length\n    \"\"\"\n    max_length = read_min_valued_integer(\n        \"Enter the maximum track length (in seconds): \", min_value=1\n    )\n    display_tracks(filter_tracks_shorter_than_length(max_length, tracks))\nThe case where we instead pass a minimum time is identical\n\n\n\n\nFor the most part, the playlist management repeats code that has already been seen before. We’ll only allow the user to work with one playlist at a time, and store the playlist as a list of MusicTrack objects. Recall that our interface is,\n1. Add Track to Playlist\n2. Remove Track from Playlist\n3. Clear Playlist\n4. Display Current Playlist\n5. Show Runtime of Current Playlist\n6. Suggest Playlist of Specified Length\n7. Save Current Playlist\n8. Back to Main Menu\nLet’s step through each of these and look at what needs new functionality\n\nadd_track_to_playlist - Uses existing filter_track_by_name to search for a user prompted track name. User is then prompted to optionally add matches to the playlist\nremove_tracks_from_playlist - Identical to remove_track but runs against the current playlist list\nclear_playlist - We use the list inbuilt method clear to clear the playlist\ndisplay_current_playlist - Achieved by passing the playlist list variable to the display_tracks function\ncalculate_playlist_length - No functionality yet implemented\nsuggest_playlist_of_given_length - No functionality yet implemented\nsave_playlist - Not yet implemented\n\nSo as we can see most of the functionality is already implemented. Let’s focus on the three remaining features, calculate_playlist_length, suggest_playlist_of_given_length and save_playlist\n\n\nImplementing calculate_playlist_length is pretty straightforward. We simply iterate over the tracks in the playlist and sum up their lengths\n\ndef calculate_playlist_length():\n    \"\"\"\n    Calculates and displays the total length of the\n    current playlist in seconds\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"Calculate length of playlist\")\n    total_length = 0\n    for track in playlist:\n        total_length = total_length + track.length_in_seconds\n    print(\"The playlist is\", total_length, \"seconds long\")\n\nFor example, if we use a little bit of magic to change our tracks list to the playlist, we can demonstrate the above function,\n\nplaylist = tracks\ncalculate_playlist_length()\n\nCalculate length of playlist\nThe playlist is 367 seconds long\n\n\n\n\n\nSimilarly, save_playlist can be implemented pretty easily using what we’ve seen. We prompt the user for the file that they want to save to, then write out the names of all of the tracks (one per line) using the standard try...except and with consruct we’ve seen before\ndef save_playlist():\n    \"\"\"\n    Saves the current playlist as a human readable list\n\n    The user is prompted to give a file name to save the playlist in\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    Exceptions are raised if the save fails\n    \"\"\"\n    print(\"Save playlist\")\n    if len(playlist) == 0:\n        print(\"No playlist to save\")\n        return\n\n    file_name = BTCInput.read_text(\"Enter file to save playlist to: \")\n    try:\n        with open(file_name, \"w\") as output_file:\n            for track in playlist:\n                output_file.write(track.name + \"\\n\")\n    except:  # noqa: E722\n        print(\"Failed to save playlist\")\n\n\n\nObserve that the user always has to choose to save the playlist. This is because we implement it much more as form of printing out a list of songs to give to someone else rather than ensuring that a database is maintained. As a result we provide no behaviour for loading a playlist\nThe last function we want to implement is the ability to suggest a playlist of a given length. The original exercise suggests this as being to create a playlist of an exact length. Doing this requires us to solve what is called the Subset Sum Problem which is in general very difficult - we are asked to find a subset of the tracks in the database such that the sum of their lengths matches the target. Intuitively we should also recognise that given the granularity of song lengths for many lengths the user might put in, no exact solution exists.\nOur solution to this will be to instead ask the user for an upper bound on the playlist length. We will then randomly select songs such that the total length is less than this length. The user is then shown the proposed playlist and can either accept or reject it. If the reject it they can then ask the program to generate a new one. Once a playlist is accepted it can be edited using the other playlist management functions.\nOur implementation for this is below,\ndef suggest_playlist_of_given_length():\n    \"\"\"\n    Suggests a playlist of length less than or equal to\n    a user prompted length\n\n    Asks the user for a maximum playlist length, and\n    then suggests a playlist by combining tracks randomly\n    such that the suggested playlist is no greater than\n    the length\n\n    The user has the option to review the proposed list\n    and either accept, reject or regenerate the list\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"Suggest playlist of given length\")\n    global playlist\n\n    target_length = read_min_valued_integer(\n        \"Enter maximum playlist length: \", min_value=1\n    )\n\n    while True:\n        suggested_playlist = []\n        playlist_length = 0\n        # find tracks that could fit in the playlist\n        candidate_songs = filter_tracks_shorter_than_length(target_length, tracks)\n\n        if len(candidate_songs) == 0:\n            print(\"Could not generate a playlist of that length. Try a longer playlist\")\n            return\n\n        while len(candidate_songs) &gt; 0:  # stop when no more eligable songs\n            # add a random song and update the playlist length\n            song_choice = random.choice(candidate_songs)\n            suggested_playlist.append(song_choice)\n            playlist_length = playlist_length + song_choice.length_in_seconds\n\n            # filter out songs that no longer fit\n            candidate_songs = filter_tracks_shorter_than_length(\n                target_length - playlist_length, candidate_songs\n            )\n        print(\"Generated a playlist...\")\n        # let the user review the playlist\n        display_tracks(suggested_playlist)\n        if BTCInput.read_int_ranged(\n            \"Accept this playlist? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        ):\n            playlist = suggested_playlist\n            return\n        else:\n            if BTCInput.read_int_ranged(\n                \"Generate again? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n            ):\n                continue\n            return\nThe bulk of the logic however is given by (after getting target_length from the user),\n        candidate_songs = filter_tracks_shorter_than_length(target_length, tracks)\n\n        if len(candidate_songs) == 0:\n            print(\"Could not generate a playlist of that length. Try a longer playlist\")\n            return\n\n        while len(candidate_songs) &gt; 0:  # stop when no more eligable songs\n            # add a random song and update the playlist length\n            song_choice = random.choice(candidate_songs)\n            suggested_playlist.append(song_choice)\n            playlist_length = playlist_length + song_choice.length_in_seconds\n\n            # filter out songs that no longer fit\n            candidate_songs = filter_tracks_shorter_than_length(\n                target_length - playlist_length, candidate_songs\n            )\n\nWe filter the track database to get all the tracks that could fit in the allowed playlist time\nWe then randomly pick one of the songs using random.choice\n\nWe add this to our proposed playlist, and add its length to a counter tracking the total length\n\nWe then filter the candidate list again but with the amount of time we have yet to use (target_time - playlist_length)\nWe repeat steps 2-3 until there are no more candidate songs, this gives our final playlist which we can then propose to the user\n\nThis sums up the description of the music storage app. The provided code demonstrates a sample database in tracks.pickle and a sample playlist in example_playlist.txt. You are encouraged to play around with the code and make sure you understand what is going on. This program is not super complicated but it has many components, if you can follow it, you are doing well!",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 9: Use Classes to Store Data",
      "Extended Exercises for Chapter 9"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/09_UsingClasses/Chapter_09_ExtensionExercises.html#make-something-happen-recipe-storage-app",
    "href": "02_AdvancedProgramming/09_UsingClasses/Chapter_09_ExtensionExercises.html#make-something-happen-recipe-storage-app",
    "title": "Extended Exercises for Chapter 9",
    "section": "Make Something Happen: Recipe Storage App",
    "text": "Make Something Happen: Recipe Storage App\nMake a recipe storage app that stores lists of ingredients and preperation details. Remember that one of the items in a class could be a list of strings, which could be the steps performed to prepare the recipe\nThis program will have less individual features than our music storage program, however the object we’re working on will be complex so it’s worth also working through this exercise.\n\nStoryboarding out the design\nLet us start by setting out some design specifications,\n\nThe user should be able to add recipes\nThe user should be able to search for recipes\n\nSearch for a recipe by name\nSearch for recipes with a given ingredient\n\nThe user should be able to view a list of ingredients in a recipe\nThe user should be able to view a recipe’s steps\n\nAll steps displayed at once\nDisplayed step by step\n\nThe user should be able to edit a given recipe\n\nEdit ingredients (including remove them)\nEdit steps including remove them\n\nThe user should be able to delete a recipe\n\n\n\nDesigning the Recipe Class\nFrom this let’s design our recipe specification. A recipe at it’s most basic is a list of ingredients and a list of steps. However, if I look at the recipes that I have at home, quite often ingredients are often listed both with a quantity and some description of how they should be prepared. For example a recipe might specify\n\n2 spring onions (scallions), finely sliced\n\nWe would like to store this extra information. A natural way to do it would then be to use a dictionary, storing the ingredients as keys, and the description as the value, i.e.\n\ningredients = {\"spring onions\" : \"2, finely sliced\"}\n\nThis also means that the user could quickly get a list of ingredients for a recipe just by printing the dictionary. We can also easily search for recipes with a given ingredient by using,\nif ingredient in ingredients\nHowever, this comes with the downside that the user would need to specify the exact ingredient to search, i.e. we would have, for the previous example,\n\nprint(\"spring onions\" in ingredients)\nprint(\"Spring Onions\" in ingredients)\nprint(\"scallions\" in ingredients)\n\nTrue\nFalse\nFalse\n\n\nA user might certainly expect that all these match. The problem is worse when we consider for example an ingredient like\n\nsmall chicken thighs\n\nOne user might enter this as (in the dictionary notation),\ningredients = {\"chicken\" : \"thighs, small\"}\nwhile another might instead use,\ningredients = {\"chicken thighs\" : \"small\"}\nIf the first user was to search \"chicken\" on a recipe entered by the second user, they would not find what they expected!\nFor the purposes of this exercise to get familiarity working with dictionaries, we’ll simply note these challenges and continue.\nThe second problem to consider is duplicate keys. In the recipes I read it is quite common for recipes to be broken down into subcomponents, each of which may use the same ingredient. This results in an ingredient being listed multiple times. The way to resolve this is to store the ingredient description as a list of strings rather than just one string. For example if a recipe specified,\n\nblack pepper, to serve black pepper, 1/4 teaspoon ground\n\nThe resulting dictionary entry would look like,\ningredients = {\"black pepper\" : [\"to serve\", \"1/4 teaspoon ground\"]}\nThe next part of the recipe is the steps themselves. This can simply be treated as an ordered list of strings, so we just store them in a list. Finally a recipe should have a name. This leaves our Recipe object looking like,\n\nclass Recipe:\n    \"\"\"\n    Represent a cooking recipe.\n\n    Attributes\n    ----------\n    name : str\n        Recipe name\n\n    ingredients : dict[str, list[str]]\n        Ingredients required for the recipe. Ingredients are stored\n        as a dictionary in the format `ingredients[ingredient] = [\"description\", ...]`\n\n    steps: list[str]\n        Ordered list of instructions/steps to prepare the recipe.\n\n    Example\n    -------\n    &gt;&gt;&gt; Recipe(\"Omelette\", {\"eggs\" : [2], \"milk\": [\"1 cup\"]}, [\"Beat eggs\", \"Add milk\", \"Cook on pan\"])\n    \"\"\"\n\n    def __init__(self, name, ingredients, steps):\n        \"\"\"\n        Create a new Recipe instance\n\n        Parameters\n        ----------\n        name : str\n            Name of the Recipe\n        ingredients : dict[str, list[str]]\n            Ingredients required for the recipe. Ingredients are stored\n            as a dictionary in the format `ingredients[ingredient] = [\"description\", ...]`\n            e.g. `ingredients[\"Brown Onion\"] = [\"1 Medium, diced\"]`\n        steps : list[str]\n            Ordered list of instructions/steps to prepare the recipe.\n        \"\"\"\n        self.name = name\n        self.ingredients = ingredients\n        self.steps = steps\n\n\nCreating a Recipe from User Input\nWe wrap the construction of these objects in a function add_recipe to get input from the user,\ndef new_recipe():\n    \"\"\"\n    Add a new recipe to the recipe database.\n\n    A recipe consists of a name, dictionary of ingredients and a list of steps\n    The user is prompted for the name, ingredients and the steps\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    Recipe : Class responsible for storing recipe information\n    \"\"\"\n    print(\"Add New Recipe\")\n    name = BTCInput.read_text(\"Enter the recipe name: \")\n\n    print(\"Enter ingredients\")\n    ingredients = get_ingredients()\n    print(\"Enter Steps\")\n    steps = get_steps()\n    recipe = Recipe(name, ingredients, steps)\n    recipes.append(recipe)\nThis code should look pretty similar to what we’ve seen before except for the fact that we refer to an unspecified get_ingredients and get_steps. These functions both read ingredients or steps one at a time from the user to construct the appropriate dictionary (or list) for the Recipe object. Both are similar, so we’ll look at the more complicated get_ingredients to understand the idea,\ndef get_ingredients():\n    \"\"\"\n    Gets a dictionary of ingredients from the user.\n\n    Ingredients are processed\n    as key, value pairs of ingredients and descriptions such as their quantity\n    or how they are to be prepared.\n\n    Supports duplicates for an ingredient. If a duplicate is detected the\n    user will be prompted if they wish to overwrite the existing key, value\n    pair, add the description to the pair or ignore the current entry\n\n    Returns\n    -------\n    dict[str, list[str]]\n        Dictionary of Ingredient, description pairs. The dictionary is\n        keyed by ingredients and the descriptions are stored as a list\n        of strings\n\n    Raises\n    ------\n    ValueError\n        An invalid number is encountered in menu selection, should not\n        occur in live code, please raise a bug report if encountered\n    \"\"\"\n    ingredients = {}\n    while True:\n        ingredient = BTCInput.read_text(\"Enter next ingredient or . to stop: \")\n        if ingredient == \".\":\n            break\n        if ingredient in ingredients:\n            print(\"That ingredient is already included!\")\n            duplicate_choice = BTCInput.read_int_ranged(\n                \"Overwrite (2), append (1) or forget (0)?: \", min_value=0, max_value=2\n            )\n            if duplicate_choice == 0:\n                continue  # ignore this entry and move to the next\n            elif duplicate_choice == 1:\n                pass  # for append behave normally\n            elif duplicate_choice == 2:\n                del ingredients[ingredient]  # remove existing entries\n            else:\n                raise ValueError(\n                    \"Invalid value \"\n                    + str(duplicate_choice)\n                    + \"encountered resolving duplicate ingredient\"\n                )\n        ingredient_description = BTCInput.read_text(\"Enter quantity and description: \")\n        if ingredient in ingredients:\n            ingredients[ingredient].append(ingredient_description)\n        else:\n            ingredients[ingredient] = [ingredient_description]\n\n    return ingredients\nThis code can be broken down as follows,\n\nAsk the user for the name of the next ingredient\n\nThis next bit is a bit tricky, but we check if the ingredient already exists in the dictionary, if it does the user can,\n\nOverwrite it\n\nSay if they accidently misentered the previous ingredient they can use this to correct it\nWe use the del keyword to delete the key and the list associated with the key ingredient\n\nAppend it\n\nThis allows the inclusion of multiple ingredient descriptions per ingredient\n\nForget it\n\nPerhaps the user simply accidently entered an ingredient twice, this gives them to option to simply forget this entry and move on\n\n\n\nAsk the user for a description of the ingredient like the quantity or how to prepare it\nTo add the ingredient and description we then have to check,\n\nIf the ingredient doesn’t exist yet, we have to create a new list containing the description, this is then assigned to the key ingredient\nIf the ingredient exists we can simply append to the existing list\n\nThis repeats until the user provides the \".\" as input, indicating they wish to stop\nThe created dictionary is returned\n\nadd_steps follows the same process, except the processed steps are simply stored in an ordered list which is returned\n\n\n\nFinding Recipes\nLet’s now look at adding search to our recipes. Our specification states that we should be able to search for recipes by ingredients or by name\n\nListing Recipes\nFirst we need a way to display the recipes returned by a search. Since recipes can have many steps and ingredients we don’t want to follow the Tiny Contacts and Music Storage Track approach of printing out all the contents of the objects, instead we’ll simply print the names of the recipes.\n\ndef list_recipes(recipes):\n    \"\"\"\n    Prints the recipe names in a given list\n\n    Parameters\n    ----------\n    recipes : list[Recipe]\n        list of recipes to display\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"List Recipes\")\n    if len(recipes) == 0:\n        print(\"No recipes found\")\n        return\n    for recipe in recipes:\n        print(\"-\", recipe.name)\n\nWe can see this in action if we use the toy demonstration,\n\nbacon_and_eggs = Recipe(\n    name=\"Bacon and Eggs\",\n    ingredients={\"Bacon\": [\"2 rashs\"], \"Eggs\": [\"1 large\"]},\n    steps=[\"Cook bacon\", \"Cook Eggs\"],\n)\n\neggs_on_toast = Recipe(\n    name=\"Eggs on Toast\",\n    ingredients={\"Bread\": \"2 slices\", \"Eggs\": [\"1 large\"]},\n    steps=[\"Toast bread\", \"Cook Eggs\"],\n)\n\nrecipes = [bacon_and_eggs, eggs_on_toast]\nlist_recipes(recipes)\n\nList Recipes\n- Bacon and Eggs\n- Eggs on Toast\n\n\nObserve that list_recipes takes a list to print. That means we can use the similar filter vs find approach as used in Music Storage to managing recipe selection\n\n\nFind Recipes by Name\nThe by name search is similar to what we have already implemented in our Tiny Contacts and Music Storage programs. However, instead of using startswith we’ll use the find string method, the documentation for find reads,\n\n    import pydoc\n    pydoc.help(\"a string\".find)\n\nHelp on built-in function find:\n\nfind(...) method of builtins.str instance\n    S.find(sub[, start[, end]]) -&gt; int\n\n    Return the lowest index in S where substring sub is found,\n    such that sub is contained within S[start:end].  Optional\n    arguments start and end are interpreted as in slice notation.\n\n    Return -1 on failure.\n\n\n\nWe can see that find searchs a string for matching substring anywhere in the string (like startswith searchs a string for matching substring at the start)\nImportantly, it also returns -1 if there no match. This means that we can use find to see if a recipe name contains the user provided search string. So we define our filter function as,\n\ndef filter_recipe_by_name(search_name):\n    \"\"\"\n    Finds and returns recipes whose name contains a search name\n\n    Parameters\n    ----------\n    search_name : str\n        name to search for, search is conducted as a substring search\n\n    Returns\n    -------\n    list[Recipe]\n        list of recipes whose name contains `search_name` as a substring\n    \"\"\"\n    results = []\n    search_name = search_name.strip().lower()\n    for recipe in recipes:\n        if recipe.name.strip().lower().find(search_name) != -1:\n            results.append(recipe)\n    return results\n\nWe use the standard normalisation of strip().lower() then call find and check the return value is not -1 to determine if we have a match\n\n\n\n\n\n\nNote\n\n\n\nRemember our convention is a filter_ function takes a search parameter and returns a list of matches while a find_ prompts the user for the search parameter and displays / prints the matches\n\n\nWe can see the outcome of running, filter_by_name for a couple of inputs on our recipes list,\n\nprint(\"Looking for toast...\")\nlist_recipes(filter_recipe_by_name(\"toast\"))\nprint(\"Looking for eggs\")\nlist_recipes(filter_recipe_by_name(\"egg\"))\nprint(\"Looking for milk\")\nlist_recipes(filter_recipe_by_name(\"milk\"))\n\nLooking for toast...\nList Recipes\n- Eggs on Toast\nLooking for eggs\nList Recipes\n- Bacon and Eggs\n- Eggs on Toast\nLooking for milk\nList Recipes\nNo recipes found\n\n\nThe corresponding find_by_name function then looks very simple,\ndef find_recipe_by_name():\n    \"\"\"\n    Prints all recipes matching a user-specified search\n\n    Returns\n    -------\n    None\n        Matches are printed to standard output\n\n    See Also\n    --------\n    filter_recipe_by_name : returns a list containing recipes which match a name\n    find_recipe_by_ingredient : find recipes containing a user-prompted ingredient\n    \"\"\"\n    print(\"Find Recipe by Name\")\n    results = filter_recipe_by_name(BTCInput.read_text(\"Enter recipe name: \"))\n    list_recipes(results)\n\n\nFinding by Ingredients\nMatching for ingredients looks very similar to the search method proposed for the dictionary based Tiny Contacts, combined with our filter and find technique. The filter function,\n\ndef filter_recipe_by_ingredient(search_ingredient):\n    \"\"\"\n    Find and return a list of all recipes which contain a given ingredient\n\n    Parameters\n    ----------\n    search_ingredient : str\n        ingredient to search for\n\n    Returns\n    -------\n    list[Recipe]\n        list of Recipes containing `search_ingredient`\n\n    Warnings\n    --------\n    search matching is exact on `search_ingredient`, for example if a recipe\n    had the ingredient dictionary,\n\n    `{\"Bread\" : [\"sliced\"], \"chicken thighs\" : [\"large\"]}`\n\n    1. `filter_recipes_by_ingredient(\"Bread\")` would match\n    2. `filter_recipes_by_ingredient(\"bread\")` would not match\n    3. `filter_recipes_by_ingredient(\"chicken\")` would not match\n    \"\"\"\n    results = []\n    for recipe in recipes:\n        if search_ingredient in recipe.ingredients:\n            results.append(recipe)\n    return results\n\nWhich we can see would have the following results,\n\nprint(\"Searching by ingredient: Eggs\")\nlist_recipes(filter_recipe_by_ingredient(\"Eggs\"))\nprint(\"Searching by ingredient: eggs\")\nlist_recipes(filter_recipe_by_ingredient(\"eggs\"))\nprint(\"Searching by ingredients: Bacon\")\nlist_recipes(filter_recipe_by_ingredient(\"Bacon\"))\nprint(\"Searching by ingredients: Milk\")\nlist_recipes(filter_recipe_by_ingredient(\"milk\"))\n\nSearching by ingredient: Eggs\nList Recipes\n- Bacon and Eggs\n- Eggs on Toast\nSearching by ingredient: eggs\nList Recipes\nNo recipes found\nSearching by ingredients: Bacon\nList Recipes\n- Bacon and Eggs\nSearching by ingredients: Milk\nList Recipes\nNo recipes found\n\n\nWe can see that as discussed the dictionary key search is vulnerable to how the user chooses to input their ingredient. We could get around simple differences like eggs and Eggs by simply normalising the keys when they’re entered however if the user was to instead search egg this would still break. Even worse would be if they searched scallion instead of spring onion which would break even if we used a method like find\nAs you should be able to see, the general search and find problem is difficult!\n\n\n\nViewing a Recipe\nWe now have a way to find recipes so we can start looking at how to view them. As mentioned in printing out a recipe, they may have too much information to simply print them out. We have three specifications to implement\n\nDisplay a recipe’s ingredients\n\nThis might be useful if we are simply trying to write a shopping list\n\nDisplay a recipe’s steps\n\nThis might useful if we want to read through an entire recipe\n\nDisplay recipe step by step\n\nThis would be useful when working through a recipe, the user would then be able to step through each recipe as they completed it\n\n\n\nSelecting a Recipe to View\nWe will implement recipe viewing using a similar technique to the Music Track program. If the user selects to view a recipe, we will first perform a name based search, then the user can decide to view any matches. If they do they will be taken to a new menu, which looks like,\nCurrent Recipe: \"Recipe currently selected to view\"\nView Recipe\n1. View Ingredients\n2. View Steps\n3. View Step by Step\n4. Return to Main Menu\nThe implementation of this first part looks like,\ndef view_recipes():\n    \"\"\"\n    Provide a prompt for the user to select a recipe to view\n\n    Reports the number of successful matches. For each match\n    (if any) the user is then prompted if they wish to view\n    the recipe in which case they are taken to the view\n    recipe menu\n\n    See Also\n    --------\n    `run_view_recipe_menu` - provides options for viewing a specific recipe\n    \"\"\"\n    print(\"View Recipe\")\n    results = filter_recipe_by_name(BTCInput.read_text(\"Enter recipe to view: \"))\n    if len(results) == 0:\n        print(\"No recipe found matching that name\")\n    else:\n        print(\"Found\", len(results), \"matches\")\n    for recipe in results:\n        print(\"Recipe: \", recipe.name)\n        command = BTCInput.read_int_ranged(\n            \"View this recipe? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        )\n        if command == 1:\n            run_view_recipe_menu(recipe)\nObserve that we defer the viewing functionality to the run_view_recipe_menu function which accepts a Recipe object as a parameter.\n\n\nViewing a Selected Recipe\nTo implement each of these features, lets work through them step by step\n\nList ingredients\n\nWe could simply output the dictionary, but that won’t format nicely\nInstead loop over the dictionary and print each ingredient then the list of descriptions with each ingredient getting its own line\n\nList Steps\n\nAgain simply printing the list would not format nicely\nWe print the steps as a bullet-pointed list using by printing each list entry on a new line prepended by -\n\nList Step by Step\n\nFor this we can follow the same procedure as above, but\nBefore the next iteration of the loop over the step list, we prompt the user to continue\nFor usability we’ll allow the user quit stepping through at any point using q\n\n\nFinally after selecting any option, the function loops back to the start allowing the user to chose another view option until they choose to quit back to the main menu.\ndef run_view_recipe_menu(recipe):\n    \"\"\"\n    Provides a looping menu interface allowing the user\n    to view the details of a specific recipe\n\n    View Options are\n\n    1. List ingredients\n        - Shows all the ingredients in a recipe\n    2. View All Steps\n        - Shows all the steps in a recipe\n    3. Step through Recipe\n        - Allows the user to interactively step through a recipe\n        one step at a time\n\n    Parameters\n    ----------\n    recipe : Recipe\n        recipe to view\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    ValueError\n        An invalid number is encountered in menu selection, should not\n        occur in live code, please raise a bug report if encountered\n    \"\"\"\n    header = \"Current Recipe: \" + recipe.name + \"\\n\"\n    view_recipe_menu = (\n        header\n        + \"\"\"View Recipe\n1. List Ingredients\n2. View All Steps\n3. Step through Recipe\n4. Return to Main Menu\n\nEnter your command: \"\"\"\n    )\n    while True:\n        command = BTCInput.read_int_ranged(\n            prompt=view_recipe_menu, min_value=1, max_value=4\n        )\n        if command == 1:\n            print(\"Ingredients\")\n            for ingredient in recipe.ingredients:\n                print(ingredient, \"-\", recipe.ingredients[ingredient])\n        if command == 2:\n            print(\"View all Steps\")\n            for step in recipe.steps:\n                print(\"-\", step)\n        if command == 3:\n            print(\n                \"Step through Recipe\"\n            )  # waits for user confirmation before printing next step\n            for step in recipe.steps:\n                print(\"-\", step)\n                go_to_next = BTCInput.read_text(\"Next step? (Q - Quit): \")\n                if go_to_next.strip().upper() == \"Q\":\n                    return\n        if command == 4:\n            break\nA sample pipeline for above might look like,\n\n\n\nView Recipe\n\nEnter recipe to view:  Bacon\n\nFound 1 matches\n\nRecipe: Bacon and Eggs\n\nView this recipe? (1 - Yes, 0 - No): 1\n\nCurrent Recipe: Bacon and Eggs\n\nView Recipe\n\n1. List Ingredients\n\n2. View All Steps\n\n3. Step through Recipe\n\n4. Return to Main Menu\n\n\n\nEnter your command: 1\n\n\n\nBacon - 2 rashs\n\nEggs - 1 large\n\n\n\n\n\n\n\n\n\nEditing and Removing a Recipe\n\nRemove a Recipe\nThe last features to implement are the processes of editing and removing a recipe. Remove can be implemented simply enough, we use find_recipes_by_name to get a list of matching recipes from the user, then simply prompt them to see if the want to remove each one\ndef remove_recipe():\n    \"\"\"\n    Remove a recipe from the database\n\n    Prompts the user to select a recipe to match.\n    Reports the number of successful matches. For each match\n    (if any) the user is prompted if they want to remove the recipe\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    filter_recipe_by_name : gives a list of recipes matching a name\n    \"\"\"\n    print(\"Remove Recipe\")\n    results = filter_recipe_by_name(BTCInput.read_text(\"Enter recipe to remove: \"))\n    if len(results) == 0:\n        print(\"No recipe found matching that name\")\n    else:\n        print(\"Found\", len(results), \"matches\")\n    for recipe in results:\n        print(\"Recipe:\", recipe.name)\n        command = BTCInput.read_int_ranged(\n            \"View this recipe? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        )\n        if command == 1:\n            recipes.remove(recipe)\n\n\nEdit a Recipe\nFor editing we also go with a simple implementation similar to what we’ve already used for Tiny Contacts and the Music Track Storage App. Here the user will search for a track to edit, then after confirming they want to edit it, we prompt them for a new name, new ingredient dictionary or new list of steps.\ndef edit_recipe():\n    \"\"\"\n    Provides a prompt to the user to select a recipe to edit\n\n    Reports the number of successful matches. For each match\n    (if any) the user is prompted if they want to edit the recipe\n    in which case they are provided the options to edit the name,\n    ingredients or steps\n\n    Returns\n    -------\n    None\n\n    Warnings\n    --------\n\n    Edits are performed in-place and live, they cannot be rolled back\n\n    See Also\n    --------\n    filter_recipe_by_name : gives a list of recipes matching a name\n    \"\"\"\n    print(\"Edit Recipe\")\n    results = filter_recipe_by_name(BTCInput.read_text(\"Enter recipe to edit: \"))\n    if len(results) == 0:\n        print(\"No recipe found matching that name\")\n    else:\n        print(\"Found\", len(results), \"matches\")\n    for recipe in results:\n        print(\"Recipe:\", recipe.name)\n        command = BTCInput.read_int_ranged(\n            \"Edit this recipe? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        )\n        if command == 0:\n            continue\n        new_name = BTCInput.read_text(\"Enter new name or . to leave unchanged: \")\n        if new_name != \".\":\n            recipe.name = new_name\n        should_edit_ingredients = BTCInput.read_int_ranged(\n            \"Edit ingredients? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        )\n        if should_edit_ingredients:\n            recipe.ingredients = get_ingredients()\n        should_edit_steps = BTCInput.read_int_ranged(\n            \"Edit steps? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        )\n        if should_edit_steps:\n            recipe.steps = get_steps()\nThis implementatation perhaps isn’t the greatest, for example it might be annoying to have to renter every step if you just want to fix a typo in one step, or to have to renter every ingredient if you want to add a new one. However for now this will do for a first pass\n\n\n\nImproving the Recipe Application\nAs we’ve hinted, there are plenty of ways that the recipe app could be completed. However as it stands now, I’m pretty happy with it as a something thats gone through an initial design and a refactor. if you’re interested you might like to try improve the following features\n\nImprove the ingredient search to be more forgiving in how it matches\nImprove the edit functionality\n\nAllow the ingredient dictionary to be edited such that,\n\nAn individual key can be edited\nAn individual key can be removed\nAn individual key can be added, (including as a duplicate)\n\nAllow the steps list to be edited such that,\n\nAn individual step can be edited\nAn individual step can be removed\nAn individual step can be added",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 9: Use Classes to Store Data",
      "Extended Exercises for Chapter 9"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/08_StoringCollectionsOfData/Chapter_08.html",
    "href": "01_ProgrammingFundamentals/08_StoringCollectionsOfData/Chapter_08.html",
    "title": "Chapter 8: Storing Collections of Data",
    "section": "",
    "text": "Consider the following vignette\nThe owner of an ice-cream stand wants a program to track sales\n\nThere are ten stands, each selling multiple items\nThe program should take sales data as input and then provide the following views on the data\n\nSorted from lowest to highest\nSorted from highest to lowest\nShow just the highest and the lowest\nShow the total number of sales\nShow the average number of sales\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nGetting the specification right: Storyboarding\nAgreeing on the specification with your client is important. A technique is called storyboarding, best done by sitting down with a paper and pen (or a whiteboard)\nA storyboard shows how the program should flow in response to various user inputs. E.g. depicting the menus the user might use, with a storyboard for each menu choice. The storyboard should also show how the program will work\nFor bigger programs you can break different components out into their own storyboards, much in the same way we built up functions. Storyboards depict what needs to happen, but not how to do it.\n\n\n\nGiven the spec for the ice cream stand we can now outline the program\n\nStore the sales data in variables\nImplement a way to sort the data\nA way to print the output\nStore the data globally and pass it to functions to handle the work\n\nWe can construct the prototype interface, similar to the Ride Selector Program\n  Ice-Cream Sales\n\n  1: Print the Sales\n  2: Sort Low to High\n  3: Sort High to Low\n  4: Highest and Lowest\n  5: Total Sales\n  6: Average Sales\n  7: Enter Figures\n\n  Enter your command: 3\n\n\n\n\nWe first need to store the sales\n\nFor ten stores, we could theoretically use ten variables, one for each store\nBut this method becomes clunky when we want to start analysing the variables\nE.g. the following code (FindingLargestSales.py), only handles finding if the first stand is the one with the greatest sales\n  # Example 8.1 Finding the Largest Sales\n  #\n  # Checks if sales1 has the largest sales. Demonstrates the difficulty of using\n  # individual named variables to deal with aggregate data\n\n  import BTCInput\n\n  sales1 = BTCInput.read_int(\"Enter the sales for stand 1: \")\n  sales2 = BTCInput.read_int(\"Enter the sales for stand 2: \")\n  sales3 = BTCInput.read_int(\"Enter the sales for stand 3: \")\n  sales4 = BTCInput.read_int(\"Enter the sales for stand 4: \")\n  sales5 = BTCInput.read_int(\"Enter the sales for stand 5: \")\n  sales6 = BTCInput.read_int(\"Enter the sales for stand 6: \")\n  sales7 = BTCInput.read_int(\"Enter the sales for stand 7: \")\n  sales8 = BTCInput.read_int(\"Enter the sales for stand 8: \")\n  sales9 = BTCInput.read_int(\"Enter the sales for stand 9: \")\n  sales10 = BTCInput.read_int(\"Enter the sales for stand 10: \")\n\n  if (\n      sales1 &gt; sales2\n      and sales1 &gt; sales3\n      and sales1 &gt; sales4\n      and sales1 &gt; sales5\n      and sales1 &gt; sales6\n      and sales1 &gt; sales7\n      and sales1 &gt; sales8\n      and sales1 &gt; sales9\n      and sales1 &gt; sales10\n  ):\n      print(\"Stand 1 had the best sales\")\nProblem: We would have to repeat the code each time for each individual sales variable\nIf we add more stands, we have add another named variable and another big if statement\n\nAND modify all the previous if statements\n\n\nClearly this approach is not very maintainable\n\n\n\n\n\nA collection is a composite type\n\nIt stores multiple elements of another type\n\nWe’ve already (briefly) seen one type of collection the tuple\nThe most common form of collection is the list\n\nWhat it sounds like, a list of items\n\n\n\n\nOpen a python interpreter and work through the following steps to learn about list\n\nA list is created using brackets around the contents [], e.g.\n\n sales = []\n\n\nThe above defines sales as an empty list\n\nItems can be appended to a list using the append function\n\n sales.append(99)\n sales\n\n[99]\n\n\n\nAs we can see from above sales now contains the value 99\n\nCalling append again, adds the new item to the end of the list\n\n sales.append(100)\n sales\n\n[99, 100]\n\n\nObserve from above you can see the contents of a list, by simply typing the variable name in the interpreter\n\nIn scripts we can also use the explicit print call\n\n  print(sales)\n\n[99, 100]\n\n\n\nYou can access individual items of the list, using the indexing operator []\n\n sales[0]\n\n99\n\n\n\nSyntax is list_name[index] where index is an integer giving the index of the item\nPython lists are zero-indexed. i.e. the first value is stored at index \\(0\\)\n\nThe indexing operator can be used to change the value of an item at a given index\n\n sales[1] = 101\n sales\n\n[99, 101]\n\n\n\nThe above changes the value of the second item in sales to \\(101\\)\n\n\n\n\n\n\n\nWarning\n\n\n\nIndexed elements must exist\nWhenever we use the indexing operator the index must exist! For example if we tried to view the (non-existent) third item, we would get an error, e.g.\n\n example_list = [1, 2]\n print(example_list[2])\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[7], line 2\n      1 example_list = [1, 2]\n----&gt; 2 print(example_list[2])\n\nIndexError: list index out of range\n\n\n\nThe above illustrates the common off-by-one error where we access the last index past the list rather than the last element of the list. Here the type of exception thrown is called an IndexError\n\n\nA single list can store values of different types, and can replace items with new items of a different type\n\n sales.append(\"Rob\")\n sales[0] = \"Python\"\n sales\n\n['Python', 101, 'Rob']\n\n\n\nThe above appends a new string \"Rob\", converts sales[0] from an int to the string \"Python\" and leaves the number \\(101\\) in sales[1] untouched\nOverall list thus mixes string and integer types*\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAvoid Mixing Types in Lists\nust because you can* mix types in lists, doesn’t mean you should. Typically lists and list processing is much easier when a list stores all items of the same type*\n\n\n\n\n\n\n\nYou can use loops to populate a list (see ReadAndDisplay.py)\n  # Example 8.2.1 Read and Display\n  #\n  # Demonstrates using a loop to populate a list\n\n  import BTCInput\n\n  # create an empty list to populate\n  sales = []\n\n  for count in range(1, 11):\n      prompt = \"Enter the sales for stand \" + str(count) + \": \"\n      sales.append(BTCInput.read_int(prompt))\n\n  print(sales)\n\n\n\nExamine the code given above and consider the following questions to understand how the list is processed\n\nWhat is the purpose of the count variable?\n\ncount tracks the value of the current index in the loop. This is used to print the id for the sales stand we are collecting the data from\n\nWhy does the range of count go from \\(1\\) to \\(11\\)?\n\nThe range function returns a collection with the start included but the stop excluded. Since we have stores \\(1\\) through \\(10\\), we want the range to go from \\(1\\) to \\(11\\) so the generated numbers are \\(1\\) through to \\(10\\)\n\nWhich item in the list would hold the sales for stand number \\(1\\)?\n\nThe first item in the list, or the zeroth indexed, i.e. sales[0]\n\nWhat part of the code would have to be changed if we instead had \\(100\\) stands?\n\nWe simply change range(1,11) through to range(1,101)\nThe program below (ReadAndDisplay2.py) is a variant in which the user specifies the number of stands\n  # Example 8.2.2 Read and Display 2\n  #\n  # Improved version of Read and Display which allows the user to specify\n  # the number of stands\n\n  import BTCInput\n\n  # create an empty list to populate\n  sales = []\n\n  number_of_stands = BTCInput.read_int(\"Enter the number of stands: \")\n  for count in range(1, number_of_stands + 1):\n      prompt = \"Enter the sales for stand \" + str(count) + \": \"\n      sales.append(BTCInput.read_int(prompt))\n\n  print(sales)\nThe above is more flexible, but as a result it is more complicated, the trade off between flexibility and ease of use is one that should be considered with the input of the users\n\nIf I got one sales value wrong, would it be possible to edit the list to put in a corrected version?\n\nThis is not implemented in the current program, but we have already seen that you can reassign the value of list at a given index, so we could implement this in a more complete program\n\n\n\n\n\n\n\nWe’ve already seen that print has a default way of displaying a list\nWe can use a for loop for if we want custom printing for each item\n  # Example 8.3 Read and Display Loop\n  #\n  # Uses a for loop to provide custom list printing\n\n  import BTCInput\n\n  sales = []\n\n  for count in range(1, 11):\n      prompt = \"Enter the sales for stand \" + str(count) + \": \"\n      sales.append(BTCInput.read_int(prompt))\n\n  # print a heading\n  print(\"Sales Figures\")\n  count = 1\n  for sales_value in sales:\n      print(\"Sales for stand\", count, \"are\", sales_value)\n      count = count + 1\n\n\n\nLists can hold any type of data that you need to store, including strings. You can change the ice-cream sales program to read and store the names of guests for a party or an event you’re planning. Make a modified version of the sales program that reads in some guest names and then displays them. Make your program handle between \\(5\\) and \\(15\\) guests\n\nWe basically just copy the previous program with the following changes\n\nsales \\(\\rightarrow\\) guests\nsales_value \\(\\rightarrow\\) guest\nWe change the prompts to appropriately refer to guests rather than sales\n\nThe two main changes are\n\nWe add an initial prompt for the number of guests\n\nWe use BTCInput.read_int_ranged to ensure the value is from \\(5\\) to \\(15\\)\n\nWe use BTCInput.read_text instead of BTCInput.read_int to get the guest names\n\n\n    # Exercise 8.1 Party Guests\n    #\n    # A program that receives and then prints a list of party guests\n    # Works for between 5 and 15 guests\n\n    import BTCInput\n\n    guests = []\n    number_of_guests = BTCInput.read_int_ranged(\n        \"Enter the number of guests (5-15): \", 5, 15\n    )\n\n    for count in range(1, number_of_guests + 1):\n        prompt = \"Enter the name of guest \" + str(count) + \": \"\n        guests.append(BTCInput.read_text(prompt))\n\n    # print a heading\n    print(\"\\nGuests attending:\")\n    count = 1\n    for guest in guests:\n        print(\"- \", guest)\n        count = count + 1\n\n\n\n\n\n\nThe previous examples build up our program as one long chain of events\nHowever, if we think about our program this isn’t strictly the cleanest\n\nThere are two distinct responsibilities occuring\n\nFirst we read in the data\nSecond we display the data\n\nThese are natural candidates to be converted into functions\n\nBy pairing these behaviours the program locks us into one way of processing data\n\nWhat happens if we want to read in a second set of data?\nWhat if we want to print the data multiple times?\n\nRefactoring is the process of modifying existing code\n\nSpecifically changing how factors interact\n\nRefactoring avoids the problem of overcomplicating the design at the start of the process\n\nInstead we write the program the most simple way we can\nThen once a structure emerges, or we need to add functionality we can refactor the design\n\nLet us factor out the two key components identified above into a new implementation (Functions.py)\n  # Example 8.4 Functions\n  #\n  # Demonstrates refactoring a program into component functions\n\n  import BTCInput\n\n  sales = []\n\n\n  def read_sales(number_of_sales):\n      \"\"\"\n      Reads in the sales values and stores them in the sales list\n\n      Parameters\n      ----------\n      number_of_sales : int\n          Number of Stores to record sales values for\n\n      Returns\n      -------\n      None\n          Results are read into the sales list\n      \"\"\"\n      sales.clear()  # remove existing sales values\n      for count in range(1, number_of_sales + 1):\n          prompt = \"Enter the sales for stand \" + str(count) + \": \"\n          sales.append(BTCInput.read_int(prompt))\n\n\n  def print_sales():\n      \"\"\"\n      Prints the sales figures on the screen with a heading.\n\n      Each figure is numbered in sequence\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Sales Figures\")\n      count = 1\n      for sales_value in sales:\n          print(\"Sales for stand\", count, \"are\", sales_value)\n          count = count + 1\n\n\n  read_sales(10)\n  print_sales()\n\n\n\nOur sales analysis program now consists of two functions, read_sales and print_sales\n\nWhat does the parameter for the read_sales function do?\n\nWe hinted at in the previous section that we might want to account for the potential for the number of stands to change in a future implementation. To support this behaviour read_sales reads in the number of sales value that it should reads\n\nWhat does clear do?\n\nWe want to start with a fresh list every time we read the sales values\nclear is a method on list objects that clears its contents\n\nWhy don’t we need to tell the print_sales function how many sales figures to print?\n\nThe for loop goes through the contents of the sales list\nA list tracks its own size\nIn some languages like C, containers do not naturally track their sizes and we would need to specify them\n\nWhy didn’t we have to write global sales in the read_sales function?\n\nPython variable names are references to memory\nThese are distinct from the objects that live in that memory\nAssignments change what object a reference (variable) refers to\n\ne.g. sales=[]\n\nHowever, calling methods on a variable, is not changing the reference e.g. sales.append(99) (They change the object contents)\n\nSo we don’t need to use global because by calling methods its clear what reference we’re using\n\n\n\n\n\n\n\nA development technique called stubs is where we write placeholder functions before we can provide a complete implementation for a given behaviour\nThe placeholders are sometimes called stub functions e.g. the two below\n\ndef sort_high_to_low():\n    \"\"\"\n    Print out a sales list from highest to lowest\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    sort_low_to_high : sorts from lowest to highest\n    \"\"\"\n    pass\n\n\ndef sort_low_to_high():\n    \"\"\"\n    Print out a sales list from lowest to highest\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    sort_high_to_low : sorts from highest to lowest\n    \"\"\"\n    pass\n\nPlaceholders let us model the flow of program before we have all the behaviours specified\n\nObviously does not model the complete program since the functions are incomplete\n\npass is a keyword for a statement that does nothing\n\nIt is effectively a placeholder statement\n\n\n\n\n\n\nAt the start of the Chapter we defined a user interface\n\nBy using the previous discussion on stubbing, and our initial functions we can implement this menu (see the full implementation in FunctionsAndMenu.py)\n\n  menu = \"\"\"\n  Ice Cream Sales\n\n  1. Print the Sales\n  2. Sort High to Low\n  3. Sort Low to High\n  4. Highest and Lowest\n  5. Total Sales\n  6. Average Sales\n  7. Enter Figures\n\n  Enter your command: \"\"\"\n\n  command = BTCInput.read_int_ranged(menu, 1, 7)\n\n  if command == 1:\n      print_sales()\n  elif command == 2:\n      sort_high_to_low()\n  elif command == 3:\n      sort_low_to_high()\n  elif command == 4:\n      highest_and_lowest()\n  elif command == 5:\n      total_sales()\n  elif command == 6:\n      average_sales()\n  elif command == 7:\n      read_sales(10)\n  else:\n      raise ValueError(\"Unexpected value \" + str(command) + \" found\")\nWe use stub functions for the unimplemented behaviour\n\n\n\n\n\n\n\nTip\n\n\n\nUsing Else Clauses to Guard Against Modification\nIn the example above the final else clause should never trip because we expect the result of BTCInput.read_int_ranged(menu, 1, 7) to be between \\(1\\) and \\(7\\) (inclusive) which is captured by the if..elif chain\nWhy then do we include the else clause? The reason is to protect against modification. This could include,\n\nThe author of BTCInput introduces a bug in read_int_ranged that allows invalid input to leak through\nSomeone editing the sales program changes the allowed range of input for read_int_ranged (perhaps to introduce new functions) but forgets to include them in the elif chain\n\nIn either case, the else clause trips, and rather than a silent error which may have occured if we expected the else to catch a \\(7\\), or if there was no else an exception is raised, which immediately notifies us that there’s a problem in the code\nThis technique of guarding against potential modifications is a simple technique for catching sources of errors and making sure you’re confirming your assumptions\n\n\n\n\n\nIn many of the examples and exercises I’ve used elif to simplify cases where we would otherwise have a bunch of nested if...else conditions.\nelif is short for else if and is effectively a next condition to check if the first if (or all preceding elif) statement is False\n\nAll elif conditions must come before the else\n\n\n\n\n\n\n\n\nSorting is a common task for computing programs\nIt can be time-intensive\nThere are often multiple ways that we may wish to sort things, e.g.\n\nAlphabetically vs Numerically\nIncreasing vs Decreasing\nCase-sensitive vs Case-insensitive\n\nTraditional sorts are down, one item (or pair of items) at a time\nAlgorithms, are a sequence of steps that solve a problem\n\nSorting Algorithms are algorithms that sort collections\nProgramming is really the implementation of an algorithm\n\nBubble Sort is a simple sorting algorithm\n\nEasy to follow and understand\nNot scalable to larger data sets\n\n\n\n\n\nOften when implementing an algorithm we want to use a fixed set of test data\n\ni.e. Data for which we can easily know the desired final state or output\nAllows us to check our algorithm is not incorrect\n\nWe can define a list in python with some contents,\n\nsales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n\n\n\n\n\n\nblock-beta\n    columns 6\n\n    classDef BG stroke:transparent, fill:transparent\n\n    index[\"Index\"]:1\n    class index BG\n\n    block:Indices:5\n    columns 10\n        0\n        1\n        2\n        3\n        4\n        5\n        6\n        7\n        8\n        9\n    end\n\n    value[\"Value\"]:1\n    class value BG\n\n    block:Values:5\n    columns 10\n        50\n        54_1[\"54\"]\n        29\n        33\n        22\n        100\n        45\n        54_2[\"54\"]\n        89\n        75\n    end\n\n\n\n\n\n\n\n\nThe above shows how the test data looks in a python list\nFor a highest to lowest sort we want the largest value to be in index \\(0\\) and the lowest in index \\(9\\)\nThe basic idea of Bubble sort is to compare neighbouring values, if the right value is larger we want to swap them so the larger value is on the left\n\nThus closer to the top of the list\n\n\n\n\n\n\n\n\nImportant\n\n\n\nSwap Two Values in a Variable\nThe following code to swap two variables is broken,\nif sales[0] &lt; sales[1]:\n    # the two items are in the wrong order and must be swapped\n    sales[0] = sales[1]\n    sales[1] = sales[0]\nWhy? Lets work through what happens\n\nsales[0] is set to the value of sales[1]\nsales[1] is set to the current value of sales[0]\nBut, sales[0] has already been set to sales[1]\n\nSo sales[1] is set to the same value it already has\n\n\nThe net result is that we only copy sales[1] to sales[0]\nThe correct implementation is given below,\nif sales[0] &lt; sales[1]:\n    temp = sales[0]\n    sales[0] = sales[1]\n    sales[1] = temp\ntemp is used to store the value of sales[0] before it was overwritten\n\n\nObviously, we don’t want to write the code with explicit reference to indices. However we can write this generically with a for loop as below\nfor count in range(0, len(sales) - 1):\n    if sales[count] &lt; sales[count - 1]:\n        temp = sales[count]\n        sales[count] = sales[count + 1]\n        sales[count + 1] = temp\n\n\nThe above code uses some new python features. Work through the following questions to understand what’s going on\n\nWhy have you used a for loop, rather than a while loop?\n\nWe could use either, the for loop is slightly smaller since we don’t have to manually increment count\nAdditionally range technically returns what is called a generator,\nThis is more memory efficient\n\nRather than creating a full list of numbers in memory, it just returns the next number each time the for loop requests it\n\n\nWhat does the len function do on line \\(1\\)?\n\nlen returns the length of a collection, i.e. the number of items in the collection\nThis lets you write code that is insensitive to the size of the collection being worked with\nMeans our sorting code could work on any length list\n\nWhy is the limit of count the length of the list minus 1?\n\nThis is because bubble sort compares the current item to the item to its right, i.e. at the next index\nIf the range goes to the last index, then program will try an access an element one past the end of the list which doesn’t exist\n\nThis will cause an error. e.g.\n\n\n\n a_list = [1,2]\n for count in range(0, len(a_list)):\n     if a_list[count] &lt; a_list[count + 1]:\n         temp = a_list[count]\n         a_list[count] = a_list[count + 1]\n         a_list[count + 1] = temp\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[9], line 3\n      1 a_list = [1,2]\n      2 for count in range(0, len(a_list)):\n----&gt; 3     if a_list[count] &lt; a_list[count + 1]:\n      4         temp = a_list[count]\n      5         a_list[count] = a_list[count + 1]\n\nIndexError: list index out of range\n\n\n\n\n\nThe complete implementation of the above discussion below performs one pass through the list\n\n\n# Example 8.6 Bubble Sort First Pass\n#\n# Implements the first pass of bubble sort and shows the impact on the list\n\n# test data\nsales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\ndef sort_high_to_low():\n    \"\"\"\n    Print out a sales list from highest to lowest\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    for count in range(0, len(sales) - 1):\n        if sales[count] &lt; sales[count + 1]:\n            temp = sales[count]\n            sales[count] = sales[count + 1]\n            sales[count + 1] = temp\n\n\nprint(\"Input list:\", sales)\n\nsort_high_to_low()\n\nprint(\"Output list:\", sales)\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nOutput list: [54, 50, 33, 29, 100, 45, 54, 89, 75, 22]\n\n\nafter which the test data looks like this\n\n\n\n\n\nblock-beta\n    columns 6\n\n    classDef BG stroke:transparent, fill:transparent\n\n    index[\"Index\"]:1\n    class index BG\n\n    block:Indices:5\n    columns 10\n        0\n        1\n        2\n        3\n        4\n        5\n        6\n        7\n        8\n        9\n    end\n\n    value[\"Value\"]:1\n    class value BG\n\n    block:Values:5\n    columns 10\n        54_1[\"54\"]\n        50\n        33\n        29\n        100\n        45\n        54_2[\"54\"]\n        89\n        75\n        22\n    end\n\n\n\n\n\n\n\nNotice that the list has been partially sorted\n\nAlso notice that the smallest value \\(22\\) has been moved to the correct index (the end)\nThe high numbers effectively bubble left past one of the values smaller than them\n\nSince we can see that after sorting the smallest value has been moved to the end we expect on the second loop through the second smallest value will have been moved to the correct spot\n\nSo we want to loop through len(sales) times\n\nThe working bubble sort implemention is then,\n\n\n# Example 8.7 Bubble Sort Multiple Pass\n#\n# Implements a complete working version of bubble sort\n\n# test data\nsales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\ndef sort_high_to_low():\n    \"\"\"\n    Print out a sales list from highest to lowest\n\n    Returns\n    -------\n    None\n    \"\"\"\n    for sort_pass in range(0, len(sales)):\n        for count in range(0, len(sales) - 1):\n            if sales[count] &lt; sales[count + 1]:\n                temp = sales[count]\n                sales[count] = sales[count + 1]\n                sales[count + 1] = temp\n\n\nprint(\"Input list:\", sales)\n\nsort_high_to_low()\n\nprint(\"Output list:\", sales)\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nOutput list: [100, 89, 75, 54, 54, 50, 45, 33, 29, 22]\n\n\n\n\n\nAs seen above, the sorting program now works correctly. Once you have a working implementation its worth investigating if there are changes you can make to improve the efficiency. Work through the following questions to get the idea\n\nIs the program making more comparisons than necessary?\n\nYes, as we mentioned before, after one pass the smallest item will always be at the end of the collection\nThis means we don’t need to check any swaps against it any more for the inner loop\nAfter each pass the size of this sorted section increases by at least one\nAn implementation taking this into account is,\n  for sort_pass in range(0, len(sales)):\n      for count in range(0, len(sales) - 1 - sort_pass):\n          if sales[count] &lt; sales[count + 1]:\n              temp = sales[count]\n              sales[count] = sales[count + 1]\n              sales[count + 1] = temp\n\nIs the program performing more passes through the list than nessecary?\n\nProbably, unless the largest value is at the end of the list all values should be bubbled to their correct spot in less than len(sales) passes\nWe can stop doing additional passes if we work out the list is already sorted\nHow?\n\nWe use a flag to track if any swaps occur in a pass\nIf none do then the list is already sorted and we can stop\n\n\n  # Example 8.8 Efficient Bubble Sort\n  #\n  # A bubble sort implementation incorporating efficiency savings to the number\n  # of comparisons and passes through the list\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def sort_high_to_low():\n      \"\"\"\n      Print out a sales list from highest to lowest\n\n      Returns\n      -------\n      None\n      \"\"\"\n      for sort_pass in range(0, len(sales)):\n          done_swap = False\n          for count in range(0, len(sales) - 1 - sort_pass):\n              if sales[count] &lt; sales[count + 1]:\n                  temp = sales[count]\n                  sales[count] = sales[count + 1]\n                  sales[count + 1] = temp\n                  done_swap = True\n          if not done_swap:\n              break\n\n  print(\"Input list:\", sales)\n\n  sort_high_to_low()\n\n  print(\"Output list:\", sales)\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nOutput list: [100, 89, 75, 54, 54, 50, 45, 33, 29, 22]\n\n\n\n\n\n\n\nBubble sort works for strings as well as integers. We saw that in Chapter 5 the python relational operators also work for strings. See if you can modify the Party Guest Program to display the names in alphabetical order\nWe can basically just reuse our sort code, but renamed for the guest program.\ndef sort_alphabetical():\n    \"\"\"\n    Sorts a list alphabetically\n\n    Returns\n    -------\n    None\n    \"\"\"\n    for sort_pass in range(0, len(guests)):\n        done_swap = False\n        for count in range(0, len(guests) - 1 - sort_pass):\n            if guests[count] &gt; guests[count + 1]:\n                temp = guests[count]\n                guests[count] = guests[count + 1]\n                guests[count + 1] = temp\n                done_swap = True\n        if not done_swap:\n            break\nThere is a second modification above, which is changing the sign of the relational operator, e.g.\nguests[count] &lt; guests[count + 1]\nhas been changed to,\nguests[count] &gt; guests[count + 1]\nThis is because as written the program tries to put the smallest strings last, but for strings; where the relational operator is alphabetically ordered this puts strings starting with a for example, after those starting with z etc. So we need to swap the sign so that the list is printed a, b, … , z etc.\nWhy don’t we have to make more modifications? Well the code as written only requires that the items being sorted are stored in a list, and that the items in the list can be compared with a relational operator. Both of these properties are satisfied by a collection of strings so the code effectively works out of the box\nThe complete code, including the integration with reading and printing the guest list is given in SortAlphabetically.py\n\n\n\n\n\nTo flip the direction of the sort, we just need the condition that determines what is out of order or not\n\nWe do this by changing \\(&lt;\\) to \\(&gt;\\), i.e.\n\n  # Example 8.9 Bubble Sort Low to High\n  #\n  # Implementation of Bubble Sort that sorts from low to high\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def sort_low_to_high():\n      \"\"\"\n      Print out a sales list from highest to lowest\n\n      Returns\n      -------\n      None\n      \"\"\"\n      for sort_pass in range(0, len(sales)):\n          done_swap = False\n          for count in range(0, len(sales) - 1 - sort_pass):\n              if sales[count] &gt; sales[count + 1]:\n                  temp = sales[count]\n                  sales[count] = sales[count + 1]\n                  sales[count + 1] = temp\n                  done_swap = True\n          if not done_swap:\n              break\n\n\n  print(\"Input list:\", sales)\n\n  sort_low_to_high()\n\n  print(\"Output list:\", sales)\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nOutput list: [22, 29, 33, 45, 50, 54, 54, 75, 89, 100]\n\n\n\nThe code above is given in BubbleSortLowToHigh.py\n\n\n\n\n\nIn comparison to sorting, finding a value is much easier\nThe basic outline for finding the highest is,\n  for values in collection\n      if(new value &gt; highest seen so far)\n          highest = new value\nWe can write the code for the highest and lowest in python then as,\n  highest = sales[0]\n  for sales_value in sales:\n      if sales_value &gt; highest:\n          highest = sales_value\n\n  lowest = sales[0]\n  for sales_value in sales:\n      if sales_value &lt; lowest:\n          lowest = sales_value\nIf we want to find both at the same time, then we can combine the code above, which means we only have to do one pass through the collection\n\n  # Example 8.10 Highest and Lowest\n  #\n  # Function that finds the highest and lowest value in a collection\n\n  # Example 8.9 Bubble Sort Low to High\n  #\n  # Implementation of Bubble Sort that sorts from low to high\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def highest_and_lowest():\n      \"\"\"\n      Print out the highest and lowest elements of a sales list\n\n      Returns\n      -------\n      None\n      \"\"\"\n      highest = sales[0]\n      lowest = sales[0]\n\n      for sales_value in sales:\n          if sales_value &gt; highest:\n              highest = sales_value\n          elif sales_value &lt; lowest:\n              lowest = sales_value\n      print(\"The highest is:\", highest)\n      print(\"The lowest is\", lowest)\n\n\n  print(\"Input list:\", sales)\n\n  highest_and_lowest()\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nThe highest is: 100\nThe lowest is 22\n\n\n\nThe code above is given in HighestAndLowest.py\n\n\n\n\n\n\nTo evaluate the total we have to sum the contents of a list, simple using the for loops we’ve looked at, (implementation in TotalSales.py)\n\n  # Example 8.11 Total Sales\n  #\n  # Calculate the Total Sales\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def total_sales():\n      \"\"\"\n      Print out the total sales of a sales list\n\n      Returns\n      -------\n      None\n      \"\"\"\n      total = 0\n      for sales_value in sales:\n          total = total + sales_value\n      print(\"Total sales are:\", total)\n\n\n  print(\"Input list:\", sales)\n\n  total_sales()\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nTotal sales are: 551\n\n\nIt is a simple extra step to them calculate the average, (divide the total by the number of elements in the collection)\n\n  # Example 8.12 Average Sales\n  #\n  # Calculate the Average Sales\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def average_sales():\n      \"\"\"\n      Print out the average sales of a sales list\n\n      Returns\n      -------\n      None\n      \"\"\"\n      total = 0\n      for sales_value in sales:\n          total = total + sales_value\n      average_sales = total / len(sales)\n      print(\"Average sales are:\", average_sales)\n\n\n  print(\"Input list:\", sales)\n\n  average_sales()\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nAverage sales are: 55.1\n\n\n\n\n\n\n\nThe previous Exercises have given us all the parts, now we want to put it together\nThe crux of our program should be a loop around the menu through which the user selects different functions\nWe first however need to read in the data from the user\nFor useability we should add the ability to quit the program\nThe final program implements this\n\n# Example 8.13 Complete Program\n#\n# A Complete implementation of the Sales Program combining all the individual\n# programs that we have implemented\n\nimport BTCInput\n\nsales = []\n\n\ndef read_sales(number_of_sales):\n    \"\"\"\n    Reads in the sales values and stores them in the sales list\n\n    Parameters\n    ----------\n    number_of_sales : int\n        Number of Stores to record sales values for\n\n    Returns\n    -------\n    None\n        Results are read into the sales list\n    \"\"\"\n    sales.clear()  # remove existing sales values\n    for count in range(1, number_of_sales + 1):\n        prompt = \"Enter the sales for stand \" + str(count) + \": \"\n        sales.append(BTCInput.read_int(prompt))\n\n\ndef print_sales():\n    \"\"\"\n    Prints the sales figures on the screen with a heading. Each figure is\n    numbered in sequence\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"Sales Figures\")\n    count = 1\n    for sales_value in sales:\n        print(\"Sales for stand\", count, \"are\", sales_value)\n        count = count + 1\n\n\ndef sort_high_to_low():\n    \"\"\"\n    Print out a sales list from highest to lowest\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    sort_low_to_high : sorts from lowest to highest\n    \"\"\"\n    for sort_pass in range(0, len(sales)):\n        done_swap = False\n        for count in range(0, len(sales) - 1 - sort_pass):\n            if sales[count] &lt; sales[count + 1]:\n                temp = sales[count]\n                sales[count] = sales[count + 1]\n                sales[count + 1] = temp\n                done_swap = True\n        if not done_swap:\n            break\n\n\ndef sort_low_to_high():\n    \"\"\"\n    Print out a sales list from lowest to highest\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    sort_high_to_low : sorts from highest to lowest\n    \"\"\"\n    for sort_pass in range(0, len(sales)):\n        done_swap = False\n        for count in range(0, len(sales) - 1 - sort_pass):\n            if sales[count] &gt; sales[count + 1]:\n                temp = sales[count]\n                sales[count] = sales[count + 1]\n                sales[count + 1] = temp\n                done_swap = True\n        if not done_swap:\n            break\n\n\ndef highest_and_lowest():\n    \"\"\"\n    Print out the highest and lowest elements of a sales list\n\n    Returns\n    -------\n    None\n    \"\"\"\n    highest = sales[0]\n    lowest = sales[0]\n\n    for sales_value in sales:\n        if sales_value &gt; highest:\n            highest = sales_value\n        elif sales_value &lt; lowest:\n            lowest = sales_value\n    print(\"The highest is:\", highest)\n    print(\"The lowest is\", lowest)\n\n\ndef total_sales():\n    \"\"\"\n    Print out the total sales of a sales list\n\n    Returns\n    -------\n    None\n    \"\"\"\n    total = 0\n    for sales_value in sales:\n        total = total + sales_value\n    print(\"Total sales are:\", total)\n\n\ndef average_sales():\n    \"\"\"\n    Print out the average sales of a sales list\n\n    Returns\n    -------\n    None\n    \"\"\"\n    total = 0\n    for sales_value in sales:\n        total = total + sales_value\n    average_sales = total / len(sales)\n    print(\"Average sales are:\", average_sales)\n\n\n# Get initial sales list\nread_sales(10)\n\n\nmenu = \"\"\"\nIce Cream Sales\n\n0. Quit the Program\n1. Print the Sales\n2. Sort High to Low\n3. Sort Low to High\n4. Highest and Lowest\n5. Total Sales\n6. Average Sales\n7. Enter Figures\n\nEnter your command: \"\"\"\n\nwhile True:\n    command = BTCInput.read_int_ranged(menu, 0, 7)\n    if command == 0:\n        break\n    if command == 1:\n        print_sales()\n    elif command == 2:\n        sort_high_to_low()\n    elif command == 3:\n        sort_low_to_high()\n    elif command == 4:\n        highest_and_lowest()\n    elif command == 5:\n        total_sales()\n    elif command == 6:\n        average_sales()\n    elif command == 7:\n        read_sales(10)\n    else:\n        raise ValueError(\"Unexpected value \" + str(command) + \" found\")\n\n\n\n\n\n\nWarning\n\n\n\nKeeping Information Synchronised when Sorting\nPlaying around with the program you might notice one thing. The stands are numbered in the order that they are printed. This works great for printing the original list out, but once we start sorting these numbers don’t match their original value. This is fine if we only care about the sales figures, but if we want to maintain a relationship between a stand and its sales this is something that would have to be modified.\nThis is something you would discuss with the client\n\n\n\n\n\n\n\nA natural extension to the program would be the ability to read or store the sales data to a file\nFiles allow for persisting the data between sessions\nTo do this we’ll add two new options, 8. Save Sales and 9. Load Sales\nLet us start by stubbing out our functions (the complete integration is found in LoadAndSave.py),\n  def save_sales(file_path):\n      \"\"\"\n      Saves the contents of the sales list to a file\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to save to\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the save fails\n\n      See Also\n      --------\n      load_sales : load sales from a sales list file\n      \"\"\"\n      print(\"Save the sales in:\", file_path)\n\n\n  def load_sales(file_path):\n      \"\"\"\n      loads the contents of a file into the sales list\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to load from\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the load fails\n\n      See Also\n      --------\n      save_sales : save the sales list into a file\n      \"\"\"\n      print(\"Load the sales in:\", file_path)\nWe also add a basic integration to the user menu, where we use BTCInput.read_text to get a file name, then call the function\nObserve that by adding the complete docstring’s we’re also starting to document the requirements for these functions in-code\n    elif command == 7:\n      read_sales(10)\n  elif command == 8:\n      file_to_save_to = BTCInput.read_text(\"Enter file to save to: \")\n      save_sales(file_to_save_to)\n  elif command == 9:\n      file_to_load_from = BTCInput.read_text(\"Enter file to load: \")\n      load_sales(file_to_load_from)\n  else:\n      raise ValueError(\"Unexpected value \" + str(command) + \" found\")\n\n\n\n\nWhen interacting with a file, python represents it as a memory object\n\nTechnically representing the connection\n\nopen creates a connection to a file, the below, opens a file, test.txt, in write mode w and stores it in the variable output_file\n  output_file = open('test.txt', 'w')\n\nThe two arguments are called the file_path and the mode\n\nfile_path is the file you want to open\nmode is what you want to do with it\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\nIt’s very easy to overwrite an existing file\nThe open function will not prevent you from modifying important files. For example files opened for write will first wipe the contents of any existing file that matches the path then write the new contents.\nPython provides the os module which has some extra functionality for handling files and directories, e.g. you can check that a file exists before you open it if you then want check if the user wants to overwrite it before opening it\nimport os.path\nif os.path.isfile(\"text.txt\"):\n    print(\"The file exists\")\n\n\n\nIf we’ve opened a file in write mode, we can use the write method on the file object to write to the file\n  output_file.write(\"First line\\n\")\n  output_file.write(\"Second line\\n\")\n  output_file.close()\nOnce you’re done with a file you need to call close\n\nCompletes any unfinished writes (ensures data integrity)\nReleases the file so other programs or processes can use it\n\nFiles open for writing are locked for editing by that process, nothing else can use them\n\n\nPutting everything together our simple file writing program is,\n  # Exercise 8.15 File Output\n  #\n  # A simple program to demonstrate opening and writing to a file\n\n  output_file = open(\"test.txt\", \"w\")\n  output_file.write(\"line 1\\n\")\n  output_file.write(\"line 2\\n\")\n  output_file.close()\n\n\n\nConsider the following questions about file writing\n\nWhy have you called the write function a method? Isn’t it a function?\n\nAs discussed earlier, methods are functions associated with a specific object\nTypically when we say functionw we refer to a function that is defined outside of an object\nwrite is a method on the file object\n\nIt is impossible to use write without there being a file object to use\nMethods allow us to work with multiple file objects without having to worry about making sure we pass the correct one to the function\n\n\nWhat does the \\n mean at the end of the strings?\n\nIt’s the new line symbol write doesn’t automatically end the line after we call it\nWe have to manually pass the new line\n\nWhere is the file text.txt actually created?\n\nThe file_path is relative to the current running python program\nHence the file is written to the same directory\n\nE.g. if we had a folder called “My Programs” with a python program “MakeFiles.py”, when we run “MakeFiles.py” the files it makes are stored in “My Programs”\n\nYou can use more complicated file_paths\n\npath = \"./data/test.txt\" would look for test.txt in the data subdirectory of the current python program (relative path)\npath = \"c:/data/test.txt\" would look for test.txt in the data subdirectory of the c drive (absolute path)\n\n\n\n\n\n\n\nNote\n\n\n\nDenoting a Directory Seperator\nOn Windows \\ is used to seperate directories, but in python you always use /\n\n\n\nCan any program use a file written from a Python program?\n\nYes, python uses the underlying operating systems file handling services\nAny other program on the operating system can access files created or modified by python\n\nCan I add lines at the end of a python file?\n\nYes, rather than open the file in write w, you open the file in append (a).\nAny writes will then be appended to the end of the file.\nA non-existent file will be created the same way as for write mode\n\n\n\n\n\n\nUsing the above discussion we can implement the write_sales function\n  # Example 8.16 Write Sales\n  #\n  # Implements the Write Sales function\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def save_sales(file_path):\n      \"\"\"\n      Saves the contents of the sales list to a file\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to save to\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the save fails\n      \"\"\"\n      print(\"Save the sales in: \", file_path)\n      output_file = open(file_path, \"w\")\n      for sale in sales:\n          output_file.write(str(sale) + \"\\n\")\n      output_file.close()\n\n\n  save_sales(\"test_output.txt\")\n\n\n\n\nThe save_sales function combines several behaviours and is worth examining in detail. What is the purpose of the function? To take a list of sales figures and write those figures to a file (preferably in a format that is easy for a human to read and to load back into the program.) Consider the following questions\n\nWhat does the str function do? Why are we using it?\n\nThe str function converts the sales number to a string\nWhile print can handle non-string inputs, write can only take a string\n\nWhy can’t we just write out the sales list as one object?\n\nA list does not provide any built-in methods for writing an object out to a file\nWe could try and print out it’s string representation (i.e. call str and output that)\nDoesn’t give us great ability to control the way the data is output\n\n\n\n\n\n\n\nWe an also use open to read from a file, we just use the read mode (r)\n  input_file = open(\"test.txt\", \"r\")\nWe can then loop over the lines in a file using a for loop\nfor line in input_file:\n      print(line)\nWe should still use close() when we’re done reading\n  input_file.close()\nThe complete sample program looks like,\n  # Example 8.17 File Input\n  #\n  # Demonstrates reading input from a file\n\n  input_file = open(\"test.txt\", \"r\")\n  for line in input_file:\n      print(line)\n  input_file.close()\n\n\n\nWork through the following questions to understand how reading from files works\n\nIf you look at the following output, you’ll notice there are empty lines after each line of text. Why is that?\n line 1\n\n line 2\n\n\nEvery time we read a line from a file, we read the terminating new line\nThis is included in the string stored in line so when we call print we get that new line and the new line added by print\nWe could fix this by modifying our print call, to remove the new line\n  print(line, end='')\nA more natural way to fix this is to remove the newline when we first read in the string\nThe strip method when called without arguments returns a copy of the string with all leading and trailing whitespace removed from the string\n\n  line = line.strip()\n\nThis is an example of conditioning input\nProcess of making sure that an input does not contain any unexpected values\nE.g. we might also want to use strip to remove non-printable characters\n\nlstrip and rstrip are variants of strip that only work on the lead or end of the string respectively\n\n\nWhy do we have to close the file we’re reading?\n\nFor reading a file forgetting to close it won’t cause issues with other programs or processes that also try to read from the file\nHowever, lets other programs now write to that file\nReleases the memory associated with holding the connection\nYour computer might not let you shut down if it thinks there are still unclosed files\n\nWhat would happen if you tried to write to a file that had been opened for reading?\n\nAn exception will be raised\nr+ is a mode that lets you read and write to a file\nYou typically don’t want to read and write to a file at the same time\n\nHard to ensure the integrity of the data and avoid corrupting it\nSuch as by writing a line longer than the one previously written\n\nthis may corrupt the next line\n\n\nA better pattern is to load data, update the data then write that back into the file\n\nA temporary file (often abreviated as a tmp file) can be used if we need an intermediate file to write to\n\n\nCan a program read an entire file at once?\n\nYes, the* read method by default will try to read an entire file\nline endings are preserved\nBe careful with large files, as this may overwhelm your computers memory…\n\n # Example 8.18 File Read\n #\n # Demonstrates the use of file_object.read to read\n # the contents of a file in one go\n\n input_file = open(\"test.txt\", \"r\")\n total_file = input_file.read()\n print(total_file)\n input_file.close()\n\n\n\n\n\nLet’s now implement load_sales\n  # Example 8.19 Load Sales\n  #\n  # Implements the Load Sales function\n\n  sales = []\n\n\n  def load_sales(file_path):\n      \"\"\"\n      loads the contents of a file into the sales list\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to load from\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the load fails\n      \"\"\"\n      print(\"Load the sales in:\", file_path)\n      sales.clear()\n      input_file = open(file_path, \"r\")\n      for line in input_file:\n          line = line.strip()\n          sales.append(int(line))\n      input_file.close()\n\n\n\nload_sales works as the opposite of save_sales instead of taking a sales list and putting it into a text file, we pull the figures from a file and load them into the sales list. Consider the following questions\n\nWhat does the int function do?\n\nThe numbers pulled out of the file are initially stored as a string\nWe need to convert them to a number, so we call int\n\nWhat happens if the input file was empty?\n\nThe function works as one would hope\nThe loop doesn’t iterate and we get an empty sales list\n\n\n\n\n\n\n\n\nDealing with files, also means dealing with the errors they can introduce\n\ne.g. A file might have been deleted, a USB removed, or simply the user might pass the wrong name\n\nWhen an error occurs we want to ensure two things:\n\nNo files are left open\nThe user is aware that the error has occured\n\nFile objects typically raise exceptions when their methods\n\nEnables us to handle and report on their errors\nUse the try ... except syntax we’ve seen before\n\n  try:\n      output_file = open(file_path, \"w\")\n      for sale in sales:\n          output_file.write(str(sale) + \"\\n\")\n      output_file.close()\n      print(\"File Written Successfully\")\n  except:\n      print(\"Something went wrong with the file\")\n\n\n\nThe code performing the file write is wrapped in a try...except block. If write, open or close causes an exception it will be caught and handled by the except clause. Let’s work through the following questions to see if this solves the ensures that the file is closed and the user is informed\n\nIn what circumstances will the code in the except part be executed?\n\nIf any of the file functions, write, open, or close raise an exception, the code in the except part will be executed\nAn error message is thus only printed when an error occurs\n\nIn what circumstances will the “File written successfully?” message be printed?\n\nThis is only printed if every step in the file writing process is completed successfully\n\nAn error message is always printed if an error is thrown, but will the file always be closed?\n\nNo, this is a problem, as we said that all files needed to be closed even when an error occurs!\nWe could put the close statement in the exception handling section to, but a more general solution to this problem is to use a finally block\n\nA finally block contains code that is always executed after all of the try and/or except code has executed\nGood for code that we naturally want to run after the block no matter if the process succeeds or fail (such as clean-up)\n\n\n try:\n     output_file = open(filename, \"w\")\n     for sale in sales:\n         output_file.write(str(sale) + \"\\n\")\n except:\n     print(\"Something went wrong with writing to the file\")\n finally:\n     output_file.close()\n\n\n\n\n\n\nIt would be great if we didn’t have to remember to manually ensure a file gets closed\n\nFailing to properly close a file can lead to hard to pin down behaviour\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIntermittent Faults are the Worst Kind to Fix\nA piece of code that is broken all the time is annoying, but at least you can typically easily identify what is not working. If a program fails only some of the time this can be much harder to solve. Often you require precise directions as to the steps taken up to the point of failure in order to be able to attempt to replicate the problem. This adds significant overhead to fixing the problem\n\n\n\nThe with construct allows the programmer to automatically manage the acquisition and release of resources\n\nMore generic than just file access\nYou can write your own services to work with with\n\nAdvanced topic we can ignore for now\n\n\n\n\n\n\n\n\nblock-beta\n    columns 6\n\n    classDef BG stroke:transparent, fill:transparent\n\n\n    space\n    title[\"Breakdown of a with statement\"]:4\n    space\n\n    class title BG\n\n    block:With\n    columns 1\n        with[\"with\"]\n        withDescr[\"(start of a with block)\"]\n    end\n\n    class with BG\n    class withDescr BG\n\n\n    block:Expression\n    columns 1\n        expression[\"expression\"]\n        expressionDescr[\"(expression generating resource to use)\"]\n    end\n\n    class expression BG\n    class expressionDescr BG\n\n    block:As\n    columns 1\n        as[\"as\"]\n        space\n    end\n\n    class as BG\n\n    block:Name\n    columns 1\n        name[\"name\"]\n        nameDescr[\"(name to represent the resource)\"]\n    end\n\n    class name BG\n    class nameDescr BG\n\n    block:Colon\n    columns 1\n        colon[\":\"]\n        space\n    end\n\n    class colon BG\n\n    block:Suite\n    columns 1\n        suite[\"Statement block\"]\n        suiteDescr[\"(statements)\"]\n    end\n\n    class suite BG\n    class suiteDescr BG\n\n\n\n\n\n\n\nwith is used to provide an object that provides a service\nas is used to assign a semantically meaningful name to the resource\nwith activates an “enter” behaviour on its object\n\nFor files this is open\n\nWhen the block is finished, with calls some exit behaviour on the object\n\nFor files this causes the file to be closed\n\nwith allows us to ensure a few things\n\nThe file is always closed\nThe reference to the file only exists as long as we are using it\n\n  # Example 8.20 Using with to Access Files\n  #\n  # Rewrites read_sales and load_sales to use the with functionality\n  # implemented in python\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def save_sales(file_path):\n      \"\"\"\n      Saves the contents of the sales list to a file\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to save to\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the save fails\n\n      See Also\n      --------\n      load_sales : load sales from a given file\n      \"\"\"\n      print(\"Save the sales in:\", file_path)\n      try:\n          with open(file_path, \"w\") as output_file:\n              for sale in sales:\n                  output_file.write(str(sale) + \"\\n\")\n      except:  # noqa: E722\n          print(\"Something went wrong with the file\")\n\n\n  def load_sales(file_path):\n      \"\"\"\n      loads the contents of a file into the sales list\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to load from\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the load fails\n\n      See Also\n      --------\n      save_sales : save sales to a file\n      \"\"\"\n      print(\"Load the sales in:\", file_path)\n      sales.clear()\n      try:\n          with open(file_path, \"r\") as input_file:\n              for line in input_file:\n                  line = line.strip()\n                  sales.append(int(line))\n      except:  # noqa: E722\n          print(\"Something went wrong with the file\")\n\n\n  print(\"Sales before save and load:\", sales)\n  save_sales(\"test.txt\")\n  load_sales(\"test.txt\")\n  print(\"Sales after save and load:\", sales)\nObserve that we no longer have to explicitly include the close call\nwith does not handle exceptions however, so we still have to include a try...except block\nWhen an exception occurs the with first releases the resource with its exit behaviour\n\ne.g. closes the file\nThen the excecution moves to the except block\n\nIf we wanted to handle exceptions without releasing the resource, we would have to swap the order to,\n  with open(\"file\", \"mode\"):\n      try:\n          #do standard thing here\n      except:\n          # handle exception without releasing resource\n      finally:\n          # do something regardless of success or fail without releasing resource\n\n\n\n\nAdd a save function to your party guest program so that you can record a list of people who attended your party\nWe build off our version that generates a sorted list. We can basically copy the save_sales function making changes to the refer to the guests list instead of sales and giving a more appropriate name to the loop variable.\ndef save(file_path):\n    \"\"\"\n    Saves the guest list to a file\n\n    Parameters\n    ----------\n\n    file_path : str\n        string giving the file path to save to\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    FileException\n        Raised if the save fails\n    \"\"\"\n    print(\"Save the guest list in:\", file_path)\n    try:\n        with open(file_path, \"w\") as output_file:\n            for guest in guests:\n                output_file.write(str(guest) + \"\\n\")\n    except:  # noqa: E722\n        print(\"Something went wrong with the file\")\nWe then run the program as normal\n\nAsk for the number of guests\nRead in the guests\nSort the guest list\nDisplay the guest list\n\nWe then ask the user if they want to save the guest list. For simplicity we use BTCInput.read_input_ranged to ask for a \\(0\\) or a \\(1\\) where a \\(1\\) indicates the user wishes to save, while \\(0\\) indicates they dont. If the user wishes to save we then prompt them using BTCInput.read_text for a file name and then call save on the given file path\nuser_wants_to_save = BTCInput.read_int_ranged(\n    \"Would you like save the list? (1 for yes, 0 for no): \", min_value=0, max_value=1\n)\n\nif user_wants_to_save:\n    save_file_name = BTCInput.read_text(\"Enter file name to save as: \")\n    save(save_file_name)\n\nThe complete integrated code is given in GuestListWithSave.py\n\n\n\n\n\n\nA list holds data in one dimension, i.e. its length\nOften data is multi-dimensional\ne.g. Our Ice Cream Sales client might now ask for the ability to track sales, by store and by day of the week\n\n\n\n\n\n\nblock-beta\n    columns 5\n\n    classDef Header fill:#bbf,stroke:#333,stroke-width:4px;\n    classDef BG stroke:transparent, fill:transparent\n\n    space:2\n    title[\"Data Table\"]:2\n    space:1\n\n    class title BG\n\n    space\n    block:fields:4\n    columns 4\n        monday[\"Monday\"]\n        tuesday[\"Tuesday\"]\n        wednesday[\"Wednesday\"]\n        stop[\"...\"]\n    end\n\n    class fields Header\n\n    Stand1[\"Stand 1\"]\n    50\n    80\n    10\n    Blank1[\"...\"]\n\n    class Stand1 BG\n\n    Stand2[\"Stand 2\"]\n    54\n    98\n    7\n    Blank2[\"...\"]\n\n    class Stand2 BG\n\n    Stand3[\"Stand 3\"]\n    29\n    40\n    80_2[\"80\"]\n    Blank3[\"...\"]\n\n    class Stand3 BG\n\n    Stand4[\"...\"]\n    stand4_1[\" \"]\n    stand4_2[\" \"]\n    stand4_3[\" \"]\n    stand4_4[\" \"]\n\n    class Stand4 BG\n\n\n\n\n\n\n\n\nOur current implementation is effectively a vertical slice for one of the days\nCan implement multiple lists, one per day of the week\n\nEffectively repeats the problem we had before of a distinct named variable for each item\n\nWe want a list of lists\n\n  mon_sales = [50, 54, 29, 33,  22, 100, 45, 54, 89, 75]\n  tue_sales = [80, 98, 40, 43, 43, 80, 50, 60, 79, 30]\n  wed_sales = [10, 7, 80, 43, 48, 82, 33, 55, 83, 80]\n  thu_sales = [15, 20, 38, 10, 36, 50, 20, 26, 45, 20]\n  fri_sales = [20, 25, 47, 18, 56, 70, 30, 36, 65, 28]\n  sat_sales = [122, 140, 245, 128, 156, 163, 90, 140, 150, 128]\n  sun_sales = [100, 130, 234, 114, 138, 156, 107, 132, 134, 148]\n\n  week_sales = [mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales, sun_sales]\n\nThink of lists of lists as a collection of rows and columns\n\nWe first specify the row we want say tue_sales\nThen the column, say Stand 1\n\n  print(week_sales[1][0])\n\n80\n\n\n\n\n\n\nIt can be difficult to get the hang of working with multiple indices. Which of the following indices would fail when the program runs?\nStatement 1: week_sales[0][0] = 50\nStatement 2: week_sales[8][7] = 88\nStatement 3: week_sales[7][10] = 100\n\nStatement 1 is valid\nStatement 2 is invalid because the first index \\(8\\) corresponds to the day of the week\n\nThe valid indices here are \\(0\\) to \\(6\\)\n\nStatement 3 is also invalid for the same reason\n\nEven though there are seven days of the week\nThe list is zero indexed\n\n\nLet’s see this in action\n\nStatement 1:\n\n\nweek_sales[0][0]\n\n50\n\n\n\nStatement 2:\n\n\nweek_sales[8][7]\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[20], line 1\n----&gt; 1 week_sales[8][7]\n\nIndexError: list index out of range\n\n\n\n\nStatement 3:\n\n\nweek_sales[7][10]\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[21], line 1\n----&gt; 1 week_sales[7][10]\n\nIndexError: list index out of range\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nMake it easy to test your program\nTesting is important, but unless it’s easy or automatic it’s pretty common to get left by the wayside.\nIn a program one might use a function make_test_data or for larger projects a test framework that is used to generate test data.\nWhenever you find yourself repeating a pattern to test code, consider how you can automate or bypass that process\n\n\n\n\n\n\nWe can use nested for loops to work through individual values in a list of lists\nE.g. if we want to calculate the total sales over a week, (full code given in TablesOfSaleData.py)\n\n  total_sales = 0\n  for day_sales in week_sales:\n      for sales_value in day_sales:\n          total_sales = total_sales + sales_value\n\n  print(\"Total sales for the week are\", total_sales)\n\nTotal sales for the week are 5205\n\n\n\nday_sales in the outer loop iterates over each constituent list in the list of lists\nsales_value is then each value in the current list referenced by day_sales\n\n\n\n\nConsider the code for summing the sales data in the previous example. Answer the following questions to make sure you understand how it works\n\nHow many times will the statements inside the two loops be obeyed?\n\nIn total they will be run \\(70\\) times\nThe outer loop runs seven times (once for each day of the week)\nThe inner loop runs ten times (one for each stand)\n\nfor each iteration of the outer loop\n\n\nHow would you change this program so that it could handle more than one week’s worth of sales?\n\nWe can add more days to the list\nRather than have them correspond to Monday - Friday it might be Week 1 Day 1 etc.\nThese would be additional rows in the list of lists\n\nHow would we add a day’s worth of sales to the list?\n\nWe have to read in a new list of values\nCan then append it to the list of lists\n  read_sales(10) # read ten values into sales list\n  week_sales.append(sales) # append the values to the weekly sales list\n\n\n\n\n\n\n\nIt is possible to work with higher dimensions\nFor example we might want to store multiple weeks of data\n\nThen we would have a list of (list of (lists))s\n\nWorks just like two dimensions but with an extra index, for example we can append a week of sales like so,\n  annual_sales.append(week_sales)\n\n\n\n\n\n\n\nTip\n\n\n\nKeep your dimensions low\nYou should rarely have to use more than three dimensions. If you find yourself using highly nested / high-dimensional structures you might want to rethink how you’re representing your data\nOne technique we will see later is the use of classes, which can make it easier to create linear collections\nThe computer itself is perfectly happy working in higher dimensions. The real difficulty is that you probably aren’t and it can be hard to reason about high dimension data\n\n\n\n\n\n\n\nNow we have the ability to manipulate weekly sales data, the next question is how to display that data and the requests.\nWhen we enter the data we want to see something like,\n  Enter the Monday sales figures for stand 2:\nHere we need to have a variable to control what day is printed\n\nSimplest implementation is an integer to track the day, implemented in DayNameIf.py\n\n\n  # Example 8.22 Day Name If\n  #\n  # Uses a if, elif, else construction to convert an integer\n  # to a string representation of the day of the week\n\n  import time\n\n  current_time = time.localtime()\n  day_number = current_time.tm_wday\n\n  if day_number == 0:\n      day_name = \"Monday\"\n  elif day_number == 1:\n      day_name = \"Tuesday\"\n  elif day_number == 2:\n      day_name = \"Wednesday\"\n  elif day_number == 3:\n      day_name = \"Thursday\"\n  elif day_number == 4:\n      day_name = \"Friday\"\n  elif day_number == 5:\n      day_name = \"Saturday\"\n  elif day_number == 6:\n      day_name = \"Sunday\"\n  else:\n      raise ValueError(\"Unexpected day_number \" + str(day_number) + \" encountered\")\n\n  print(day_name)\n\nSaturday\n\n\nThis works, but is fragile, a cleaner way to do this is to use a lookup table\n\ni.e. we use day_number to index a list that stores the correct day\n\nWe use thetime library for fun so the program prints the current day\n\n  # Example 8.23 Day Name List\n  #\n  # Uses a lookup table to correctly print the day\n\n  import time\n\n  current_time = time.localtime()\n  day_number = current_time.tm_wday\n\n  day_names = [\n      \"Monday\",\n      \"Tuesday\",\n      \"Wednesday\",\n      \"Thursday\",\n      \"Friday\",\n      \"Saturday\",\n      \"Sunday\",\n  ]\n\n  day_name = day_names[day_number]\n\n  print(\"Today is\", day_name)\n\nToday is Saturday\n\n\nLookup tables are powerful for shrinking written code\nThey also are used to create data-driven applications\n\nPrograms that use built-in or loaded data rather than fixed behaviour\n\n\n\n\n\n\nLists are the standard collection type\n\nThey are mutable, i.e. we can change the value of a given index or add new items\n\nConsider the day_names list, once defined we don’t want to change it\n\nWe would like to also prevent this, to catch potential programming errors e.g.\n  day_names[5] = \"Splatterday\"\n\nA tuple is like a list, but the contents cannot be changed\n\nA tuple is said to be immutable\nIf we attempt to change the tuple we get an error, (demonstrated in the implementation DayNameList.py)\n\nSpecifically a TypeError\nBecause the action we are trying to take (change the value at an index) is not supported by the object type (tuple)\n\n\n  # Example 8.24 Day Name Tuple\n  #\n  # Reimplements the Day Name lookup table with a tuple\n  # and demonstrates the immutability of the data structure\n\n  import time\n\n  current_time = time.localtime()\n  day_number = current_time.tm_wday\n\n  day_names = (\n      \"Monday\",\n      \"Tuesday\",\n      \"Wednesday\",\n      \"Thursday\",\n      \"Friday\",\n      \"Saturday\",\n      \"Sunday\",\n  )\n\n  day_name = day_names[day_number]\n\n  print(\"Today is\", day_name)\n\n  print(\"Attempting to change the lookup table...\")\n\n  day_names[day_number] = \"Splatterday\"  # type: ignore\n  print(\"Today is\", day_names[day_number])\n\nToday is Saturday\nAttempting to change the lookup table...\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[25], line 27\n     23 print(\"Today is\", day_name)\n     25 print(\"Attempting to change the lookup table...\")\n---&gt; 27 day_names[day_number] = \"Splatterday\"  # type: ignore\n     28 print(\"Today is\", day_names[day_number])\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\n\nTuple is created as for a list but using () to delimit the items rather than []\nTuples are good for working with complicated values\n\ne.g. composite types\n\nFor Example, consider a pirates treasure map\n\nTreasure’s location is given by\n\nA reference landmark\nNumber of steps north\nNumber of steps east\n\n\nA function can strictly speaking return one value\n\nWe can return multiple values as a tuple\n\n  def get_treasure_location():\n      # get the treasures location\n      return (\"The old oak tree\", 20, 30)\n\nThis returns three values\n\nThe string \"The old oak tree\"\nThe number of steps north, 20\nThe number of steps east, 30\n\n\nLike lists, tuples are zero-indexed\n\n\n\n\n\n\n\nWarning\n\n\n\nTake care with your tuple indices\nWhen returning multiple items from a function via a tuple, we have to be clear to specify the order of what the items in the tuple correspond to. This is effectively a contract between the function and any caller (if you change the order, you will break the code of anyone who relies on the current order)\nThe order that parameters are returned in should thus be clearly documented, e.g.\ndef get_treasure_location():\n    \"\"\"\n    Gets the location of the treasure\n\n    Returns\n    -------\n    str\n        Name of a landmark to start at\n    int\n        Number of paces north\n    int\n        Number of paces east\n    \"\"\"\n\n    return (\"The old oak tree\", 20, 30)\n\n\n\nAn alternative to explicitly referencing the index of a returned tuple, is called tuple-unpacking\n\nWe provide a comma-seperated list of variables to assign the tuple values (in order) to, e.g.\n      landmark, north, east = get_treasure_location()\n  print(\"Start at\", landmark, \"walk\", north, \"paces north and\", east, \"paces east\")\n\nThe complete Pirate’s Treasure program implemention is given in PiratesTreasure.py",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 8: Storing Collections of Data"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/08_StoringCollectionsOfData/Chapter_08.html#notes",
    "href": "01_ProgrammingFundamentals/08_StoringCollectionsOfData/Chapter_08.html#notes",
    "title": "Chapter 8: Storing Collections of Data",
    "section": "",
    "text": "Consider the following vignette\nThe owner of an ice-cream stand wants a program to track sales\n\nThere are ten stands, each selling multiple items\nThe program should take sales data as input and then provide the following views on the data\n\nSorted from lowest to highest\nSorted from highest to lowest\nShow just the highest and the lowest\nShow the total number of sales\nShow the average number of sales\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nGetting the specification right: Storyboarding\nAgreeing on the specification with your client is important. A technique is called storyboarding, best done by sitting down with a paper and pen (or a whiteboard)\nA storyboard shows how the program should flow in response to various user inputs. E.g. depicting the menus the user might use, with a storyboard for each menu choice. The storyboard should also show how the program will work\nFor bigger programs you can break different components out into their own storyboards, much in the same way we built up functions. Storyboards depict what needs to happen, but not how to do it.\n\n\n\nGiven the spec for the ice cream stand we can now outline the program\n\nStore the sales data in variables\nImplement a way to sort the data\nA way to print the output\nStore the data globally and pass it to functions to handle the work\n\nWe can construct the prototype interface, similar to the Ride Selector Program\n  Ice-Cream Sales\n\n  1: Print the Sales\n  2: Sort Low to High\n  3: Sort High to Low\n  4: Highest and Lowest\n  5: Total Sales\n  6: Average Sales\n  7: Enter Figures\n\n  Enter your command: 3\n\n\n\n\nWe first need to store the sales\n\nFor ten stores, we could theoretically use ten variables, one for each store\nBut this method becomes clunky when we want to start analysing the variables\nE.g. the following code (FindingLargestSales.py), only handles finding if the first stand is the one with the greatest sales\n  # Example 8.1 Finding the Largest Sales\n  #\n  # Checks if sales1 has the largest sales. Demonstrates the difficulty of using\n  # individual named variables to deal with aggregate data\n\n  import BTCInput\n\n  sales1 = BTCInput.read_int(\"Enter the sales for stand 1: \")\n  sales2 = BTCInput.read_int(\"Enter the sales for stand 2: \")\n  sales3 = BTCInput.read_int(\"Enter the sales for stand 3: \")\n  sales4 = BTCInput.read_int(\"Enter the sales for stand 4: \")\n  sales5 = BTCInput.read_int(\"Enter the sales for stand 5: \")\n  sales6 = BTCInput.read_int(\"Enter the sales for stand 6: \")\n  sales7 = BTCInput.read_int(\"Enter the sales for stand 7: \")\n  sales8 = BTCInput.read_int(\"Enter the sales for stand 8: \")\n  sales9 = BTCInput.read_int(\"Enter the sales for stand 9: \")\n  sales10 = BTCInput.read_int(\"Enter the sales for stand 10: \")\n\n  if (\n      sales1 &gt; sales2\n      and sales1 &gt; sales3\n      and sales1 &gt; sales4\n      and sales1 &gt; sales5\n      and sales1 &gt; sales6\n      and sales1 &gt; sales7\n      and sales1 &gt; sales8\n      and sales1 &gt; sales9\n      and sales1 &gt; sales10\n  ):\n      print(\"Stand 1 had the best sales\")\nProblem: We would have to repeat the code each time for each individual sales variable\nIf we add more stands, we have add another named variable and another big if statement\n\nAND modify all the previous if statements\n\n\nClearly this approach is not very maintainable\n\n\n\n\n\nA collection is a composite type\n\nIt stores multiple elements of another type\n\nWe’ve already (briefly) seen one type of collection the tuple\nThe most common form of collection is the list\n\nWhat it sounds like, a list of items\n\n\n\n\nOpen a python interpreter and work through the following steps to learn about list\n\nA list is created using brackets around the contents [], e.g.\n\n sales = []\n\n\nThe above defines sales as an empty list\n\nItems can be appended to a list using the append function\n\n sales.append(99)\n sales\n\n[99]\n\n\n\nAs we can see from above sales now contains the value 99\n\nCalling append again, adds the new item to the end of the list\n\n sales.append(100)\n sales\n\n[99, 100]\n\n\nObserve from above you can see the contents of a list, by simply typing the variable name in the interpreter\n\nIn scripts we can also use the explicit print call\n\n  print(sales)\n\n[99, 100]\n\n\n\nYou can access individual items of the list, using the indexing operator []\n\n sales[0]\n\n99\n\n\n\nSyntax is list_name[index] where index is an integer giving the index of the item\nPython lists are zero-indexed. i.e. the first value is stored at index \\(0\\)\n\nThe indexing operator can be used to change the value of an item at a given index\n\n sales[1] = 101\n sales\n\n[99, 101]\n\n\n\nThe above changes the value of the second item in sales to \\(101\\)\n\n\n\n\n\n\n\nWarning\n\n\n\nIndexed elements must exist\nWhenever we use the indexing operator the index must exist! For example if we tried to view the (non-existent) third item, we would get an error, e.g.\n\n example_list = [1, 2]\n print(example_list[2])\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[7], line 2\n      1 example_list = [1, 2]\n----&gt; 2 print(example_list[2])\n\nIndexError: list index out of range\n\n\n\nThe above illustrates the common off-by-one error where we access the last index past the list rather than the last element of the list. Here the type of exception thrown is called an IndexError\n\n\nA single list can store values of different types, and can replace items with new items of a different type\n\n sales.append(\"Rob\")\n sales[0] = \"Python\"\n sales\n\n['Python', 101, 'Rob']\n\n\n\nThe above appends a new string \"Rob\", converts sales[0] from an int to the string \"Python\" and leaves the number \\(101\\) in sales[1] untouched\nOverall list thus mixes string and integer types*\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAvoid Mixing Types in Lists\nust because you can* mix types in lists, doesn’t mean you should. Typically lists and list processing is much easier when a list stores all items of the same type*\n\n\n\n\n\n\n\nYou can use loops to populate a list (see ReadAndDisplay.py)\n  # Example 8.2.1 Read and Display\n  #\n  # Demonstrates using a loop to populate a list\n\n  import BTCInput\n\n  # create an empty list to populate\n  sales = []\n\n  for count in range(1, 11):\n      prompt = \"Enter the sales for stand \" + str(count) + \": \"\n      sales.append(BTCInput.read_int(prompt))\n\n  print(sales)\n\n\n\nExamine the code given above and consider the following questions to understand how the list is processed\n\nWhat is the purpose of the count variable?\n\ncount tracks the value of the current index in the loop. This is used to print the id for the sales stand we are collecting the data from\n\nWhy does the range of count go from \\(1\\) to \\(11\\)?\n\nThe range function returns a collection with the start included but the stop excluded. Since we have stores \\(1\\) through \\(10\\), we want the range to go from \\(1\\) to \\(11\\) so the generated numbers are \\(1\\) through to \\(10\\)\n\nWhich item in the list would hold the sales for stand number \\(1\\)?\n\nThe first item in the list, or the zeroth indexed, i.e. sales[0]\n\nWhat part of the code would have to be changed if we instead had \\(100\\) stands?\n\nWe simply change range(1,11) through to range(1,101)\nThe program below (ReadAndDisplay2.py) is a variant in which the user specifies the number of stands\n  # Example 8.2.2 Read and Display 2\n  #\n  # Improved version of Read and Display which allows the user to specify\n  # the number of stands\n\n  import BTCInput\n\n  # create an empty list to populate\n  sales = []\n\n  number_of_stands = BTCInput.read_int(\"Enter the number of stands: \")\n  for count in range(1, number_of_stands + 1):\n      prompt = \"Enter the sales for stand \" + str(count) + \": \"\n      sales.append(BTCInput.read_int(prompt))\n\n  print(sales)\nThe above is more flexible, but as a result it is more complicated, the trade off between flexibility and ease of use is one that should be considered with the input of the users\n\nIf I got one sales value wrong, would it be possible to edit the list to put in a corrected version?\n\nThis is not implemented in the current program, but we have already seen that you can reassign the value of list at a given index, so we could implement this in a more complete program\n\n\n\n\n\n\n\nWe’ve already seen that print has a default way of displaying a list\nWe can use a for loop for if we want custom printing for each item\n  # Example 8.3 Read and Display Loop\n  #\n  # Uses a for loop to provide custom list printing\n\n  import BTCInput\n\n  sales = []\n\n  for count in range(1, 11):\n      prompt = \"Enter the sales for stand \" + str(count) + \": \"\n      sales.append(BTCInput.read_int(prompt))\n\n  # print a heading\n  print(\"Sales Figures\")\n  count = 1\n  for sales_value in sales:\n      print(\"Sales for stand\", count, \"are\", sales_value)\n      count = count + 1\n\n\n\nLists can hold any type of data that you need to store, including strings. You can change the ice-cream sales program to read and store the names of guests for a party or an event you’re planning. Make a modified version of the sales program that reads in some guest names and then displays them. Make your program handle between \\(5\\) and \\(15\\) guests\n\nWe basically just copy the previous program with the following changes\n\nsales \\(\\rightarrow\\) guests\nsales_value \\(\\rightarrow\\) guest\nWe change the prompts to appropriately refer to guests rather than sales\n\nThe two main changes are\n\nWe add an initial prompt for the number of guests\n\nWe use BTCInput.read_int_ranged to ensure the value is from \\(5\\) to \\(15\\)\n\nWe use BTCInput.read_text instead of BTCInput.read_int to get the guest names\n\n\n    # Exercise 8.1 Party Guests\n    #\n    # A program that receives and then prints a list of party guests\n    # Works for between 5 and 15 guests\n\n    import BTCInput\n\n    guests = []\n    number_of_guests = BTCInput.read_int_ranged(\n        \"Enter the number of guests (5-15): \", 5, 15\n    )\n\n    for count in range(1, number_of_guests + 1):\n        prompt = \"Enter the name of guest \" + str(count) + \": \"\n        guests.append(BTCInput.read_text(prompt))\n\n    # print a heading\n    print(\"\\nGuests attending:\")\n    count = 1\n    for guest in guests:\n        print(\"- \", guest)\n        count = count + 1\n\n\n\n\n\n\nThe previous examples build up our program as one long chain of events\nHowever, if we think about our program this isn’t strictly the cleanest\n\nThere are two distinct responsibilities occuring\n\nFirst we read in the data\nSecond we display the data\n\nThese are natural candidates to be converted into functions\n\nBy pairing these behaviours the program locks us into one way of processing data\n\nWhat happens if we want to read in a second set of data?\nWhat if we want to print the data multiple times?\n\nRefactoring is the process of modifying existing code\n\nSpecifically changing how factors interact\n\nRefactoring avoids the problem of overcomplicating the design at the start of the process\n\nInstead we write the program the most simple way we can\nThen once a structure emerges, or we need to add functionality we can refactor the design\n\nLet us factor out the two key components identified above into a new implementation (Functions.py)\n  # Example 8.4 Functions\n  #\n  # Demonstrates refactoring a program into component functions\n\n  import BTCInput\n\n  sales = []\n\n\n  def read_sales(number_of_sales):\n      \"\"\"\n      Reads in the sales values and stores them in the sales list\n\n      Parameters\n      ----------\n      number_of_sales : int\n          Number of Stores to record sales values for\n\n      Returns\n      -------\n      None\n          Results are read into the sales list\n      \"\"\"\n      sales.clear()  # remove existing sales values\n      for count in range(1, number_of_sales + 1):\n          prompt = \"Enter the sales for stand \" + str(count) + \": \"\n          sales.append(BTCInput.read_int(prompt))\n\n\n  def print_sales():\n      \"\"\"\n      Prints the sales figures on the screen with a heading.\n\n      Each figure is numbered in sequence\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Sales Figures\")\n      count = 1\n      for sales_value in sales:\n          print(\"Sales for stand\", count, \"are\", sales_value)\n          count = count + 1\n\n\n  read_sales(10)\n  print_sales()\n\n\n\nOur sales analysis program now consists of two functions, read_sales and print_sales\n\nWhat does the parameter for the read_sales function do?\n\nWe hinted at in the previous section that we might want to account for the potential for the number of stands to change in a future implementation. To support this behaviour read_sales reads in the number of sales value that it should reads\n\nWhat does clear do?\n\nWe want to start with a fresh list every time we read the sales values\nclear is a method on list objects that clears its contents\n\nWhy don’t we need to tell the print_sales function how many sales figures to print?\n\nThe for loop goes through the contents of the sales list\nA list tracks its own size\nIn some languages like C, containers do not naturally track their sizes and we would need to specify them\n\nWhy didn’t we have to write global sales in the read_sales function?\n\nPython variable names are references to memory\nThese are distinct from the objects that live in that memory\nAssignments change what object a reference (variable) refers to\n\ne.g. sales=[]\n\nHowever, calling methods on a variable, is not changing the reference e.g. sales.append(99) (They change the object contents)\n\nSo we don’t need to use global because by calling methods its clear what reference we’re using\n\n\n\n\n\n\n\nA development technique called stubs is where we write placeholder functions before we can provide a complete implementation for a given behaviour\nThe placeholders are sometimes called stub functions e.g. the two below\n\ndef sort_high_to_low():\n    \"\"\"\n    Print out a sales list from highest to lowest\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    sort_low_to_high : sorts from lowest to highest\n    \"\"\"\n    pass\n\n\ndef sort_low_to_high():\n    \"\"\"\n    Print out a sales list from lowest to highest\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    sort_high_to_low : sorts from highest to lowest\n    \"\"\"\n    pass\n\nPlaceholders let us model the flow of program before we have all the behaviours specified\n\nObviously does not model the complete program since the functions are incomplete\n\npass is a keyword for a statement that does nothing\n\nIt is effectively a placeholder statement\n\n\n\n\n\n\nAt the start of the Chapter we defined a user interface\n\nBy using the previous discussion on stubbing, and our initial functions we can implement this menu (see the full implementation in FunctionsAndMenu.py)\n\n  menu = \"\"\"\n  Ice Cream Sales\n\n  1. Print the Sales\n  2. Sort High to Low\n  3. Sort Low to High\n  4. Highest and Lowest\n  5. Total Sales\n  6. Average Sales\n  7. Enter Figures\n\n  Enter your command: \"\"\"\n\n  command = BTCInput.read_int_ranged(menu, 1, 7)\n\n  if command == 1:\n      print_sales()\n  elif command == 2:\n      sort_high_to_low()\n  elif command == 3:\n      sort_low_to_high()\n  elif command == 4:\n      highest_and_lowest()\n  elif command == 5:\n      total_sales()\n  elif command == 6:\n      average_sales()\n  elif command == 7:\n      read_sales(10)\n  else:\n      raise ValueError(\"Unexpected value \" + str(command) + \" found\")\nWe use stub functions for the unimplemented behaviour\n\n\n\n\n\n\n\nTip\n\n\n\nUsing Else Clauses to Guard Against Modification\nIn the example above the final else clause should never trip because we expect the result of BTCInput.read_int_ranged(menu, 1, 7) to be between \\(1\\) and \\(7\\) (inclusive) which is captured by the if..elif chain\nWhy then do we include the else clause? The reason is to protect against modification. This could include,\n\nThe author of BTCInput introduces a bug in read_int_ranged that allows invalid input to leak through\nSomeone editing the sales program changes the allowed range of input for read_int_ranged (perhaps to introduce new functions) but forgets to include them in the elif chain\n\nIn either case, the else clause trips, and rather than a silent error which may have occured if we expected the else to catch a \\(7\\), or if there was no else an exception is raised, which immediately notifies us that there’s a problem in the code\nThis technique of guarding against potential modifications is a simple technique for catching sources of errors and making sure you’re confirming your assumptions\n\n\n\n\n\nIn many of the examples and exercises I’ve used elif to simplify cases where we would otherwise have a bunch of nested if...else conditions.\nelif is short for else if and is effectively a next condition to check if the first if (or all preceding elif) statement is False\n\nAll elif conditions must come before the else\n\n\n\n\n\n\n\n\nSorting is a common task for computing programs\nIt can be time-intensive\nThere are often multiple ways that we may wish to sort things, e.g.\n\nAlphabetically vs Numerically\nIncreasing vs Decreasing\nCase-sensitive vs Case-insensitive\n\nTraditional sorts are down, one item (or pair of items) at a time\nAlgorithms, are a sequence of steps that solve a problem\n\nSorting Algorithms are algorithms that sort collections\nProgramming is really the implementation of an algorithm\n\nBubble Sort is a simple sorting algorithm\n\nEasy to follow and understand\nNot scalable to larger data sets\n\n\n\n\n\nOften when implementing an algorithm we want to use a fixed set of test data\n\ni.e. Data for which we can easily know the desired final state or output\nAllows us to check our algorithm is not incorrect\n\nWe can define a list in python with some contents,\n\nsales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n\n\n\n\n\n\nblock-beta\n    columns 6\n\n    classDef BG stroke:transparent, fill:transparent\n\n    index[\"Index\"]:1\n    class index BG\n\n    block:Indices:5\n    columns 10\n        0\n        1\n        2\n        3\n        4\n        5\n        6\n        7\n        8\n        9\n    end\n\n    value[\"Value\"]:1\n    class value BG\n\n    block:Values:5\n    columns 10\n        50\n        54_1[\"54\"]\n        29\n        33\n        22\n        100\n        45\n        54_2[\"54\"]\n        89\n        75\n    end\n\n\n\n\n\n\n\n\nThe above shows how the test data looks in a python list\nFor a highest to lowest sort we want the largest value to be in index \\(0\\) and the lowest in index \\(9\\)\nThe basic idea of Bubble sort is to compare neighbouring values, if the right value is larger we want to swap them so the larger value is on the left\n\nThus closer to the top of the list\n\n\n\n\n\n\n\n\nImportant\n\n\n\nSwap Two Values in a Variable\nThe following code to swap two variables is broken,\nif sales[0] &lt; sales[1]:\n    # the two items are in the wrong order and must be swapped\n    sales[0] = sales[1]\n    sales[1] = sales[0]\nWhy? Lets work through what happens\n\nsales[0] is set to the value of sales[1]\nsales[1] is set to the current value of sales[0]\nBut, sales[0] has already been set to sales[1]\n\nSo sales[1] is set to the same value it already has\n\n\nThe net result is that we only copy sales[1] to sales[0]\nThe correct implementation is given below,\nif sales[0] &lt; sales[1]:\n    temp = sales[0]\n    sales[0] = sales[1]\n    sales[1] = temp\ntemp is used to store the value of sales[0] before it was overwritten\n\n\nObviously, we don’t want to write the code with explicit reference to indices. However we can write this generically with a for loop as below\nfor count in range(0, len(sales) - 1):\n    if sales[count] &lt; sales[count - 1]:\n        temp = sales[count]\n        sales[count] = sales[count + 1]\n        sales[count + 1] = temp\n\n\nThe above code uses some new python features. Work through the following questions to understand what’s going on\n\nWhy have you used a for loop, rather than a while loop?\n\nWe could use either, the for loop is slightly smaller since we don’t have to manually increment count\nAdditionally range technically returns what is called a generator,\nThis is more memory efficient\n\nRather than creating a full list of numbers in memory, it just returns the next number each time the for loop requests it\n\n\nWhat does the len function do on line \\(1\\)?\n\nlen returns the length of a collection, i.e. the number of items in the collection\nThis lets you write code that is insensitive to the size of the collection being worked with\nMeans our sorting code could work on any length list\n\nWhy is the limit of count the length of the list minus 1?\n\nThis is because bubble sort compares the current item to the item to its right, i.e. at the next index\nIf the range goes to the last index, then program will try an access an element one past the end of the list which doesn’t exist\n\nThis will cause an error. e.g.\n\n\n\n a_list = [1,2]\n for count in range(0, len(a_list)):\n     if a_list[count] &lt; a_list[count + 1]:\n         temp = a_list[count]\n         a_list[count] = a_list[count + 1]\n         a_list[count + 1] = temp\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[9], line 3\n      1 a_list = [1,2]\n      2 for count in range(0, len(a_list)):\n----&gt; 3     if a_list[count] &lt; a_list[count + 1]:\n      4         temp = a_list[count]\n      5         a_list[count] = a_list[count + 1]\n\nIndexError: list index out of range\n\n\n\n\n\nThe complete implementation of the above discussion below performs one pass through the list\n\n\n# Example 8.6 Bubble Sort First Pass\n#\n# Implements the first pass of bubble sort and shows the impact on the list\n\n# test data\nsales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\ndef sort_high_to_low():\n    \"\"\"\n    Print out a sales list from highest to lowest\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    for count in range(0, len(sales) - 1):\n        if sales[count] &lt; sales[count + 1]:\n            temp = sales[count]\n            sales[count] = sales[count + 1]\n            sales[count + 1] = temp\n\n\nprint(\"Input list:\", sales)\n\nsort_high_to_low()\n\nprint(\"Output list:\", sales)\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nOutput list: [54, 50, 33, 29, 100, 45, 54, 89, 75, 22]\n\n\nafter which the test data looks like this\n\n\n\n\n\nblock-beta\n    columns 6\n\n    classDef BG stroke:transparent, fill:transparent\n\n    index[\"Index\"]:1\n    class index BG\n\n    block:Indices:5\n    columns 10\n        0\n        1\n        2\n        3\n        4\n        5\n        6\n        7\n        8\n        9\n    end\n\n    value[\"Value\"]:1\n    class value BG\n\n    block:Values:5\n    columns 10\n        54_1[\"54\"]\n        50\n        33\n        29\n        100\n        45\n        54_2[\"54\"]\n        89\n        75\n        22\n    end\n\n\n\n\n\n\n\nNotice that the list has been partially sorted\n\nAlso notice that the smallest value \\(22\\) has been moved to the correct index (the end)\nThe high numbers effectively bubble left past one of the values smaller than them\n\nSince we can see that after sorting the smallest value has been moved to the end we expect on the second loop through the second smallest value will have been moved to the correct spot\n\nSo we want to loop through len(sales) times\n\nThe working bubble sort implemention is then,\n\n\n# Example 8.7 Bubble Sort Multiple Pass\n#\n# Implements a complete working version of bubble sort\n\n# test data\nsales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\ndef sort_high_to_low():\n    \"\"\"\n    Print out a sales list from highest to lowest\n\n    Returns\n    -------\n    None\n    \"\"\"\n    for sort_pass in range(0, len(sales)):\n        for count in range(0, len(sales) - 1):\n            if sales[count] &lt; sales[count + 1]:\n                temp = sales[count]\n                sales[count] = sales[count + 1]\n                sales[count + 1] = temp\n\n\nprint(\"Input list:\", sales)\n\nsort_high_to_low()\n\nprint(\"Output list:\", sales)\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nOutput list: [100, 89, 75, 54, 54, 50, 45, 33, 29, 22]\n\n\n\n\n\nAs seen above, the sorting program now works correctly. Once you have a working implementation its worth investigating if there are changes you can make to improve the efficiency. Work through the following questions to get the idea\n\nIs the program making more comparisons than necessary?\n\nYes, as we mentioned before, after one pass the smallest item will always be at the end of the collection\nThis means we don’t need to check any swaps against it any more for the inner loop\nAfter each pass the size of this sorted section increases by at least one\nAn implementation taking this into account is,\n  for sort_pass in range(0, len(sales)):\n      for count in range(0, len(sales) - 1 - sort_pass):\n          if sales[count] &lt; sales[count + 1]:\n              temp = sales[count]\n              sales[count] = sales[count + 1]\n              sales[count + 1] = temp\n\nIs the program performing more passes through the list than nessecary?\n\nProbably, unless the largest value is at the end of the list all values should be bubbled to their correct spot in less than len(sales) passes\nWe can stop doing additional passes if we work out the list is already sorted\nHow?\n\nWe use a flag to track if any swaps occur in a pass\nIf none do then the list is already sorted and we can stop\n\n\n  # Example 8.8 Efficient Bubble Sort\n  #\n  # A bubble sort implementation incorporating efficiency savings to the number\n  # of comparisons and passes through the list\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def sort_high_to_low():\n      \"\"\"\n      Print out a sales list from highest to lowest\n\n      Returns\n      -------\n      None\n      \"\"\"\n      for sort_pass in range(0, len(sales)):\n          done_swap = False\n          for count in range(0, len(sales) - 1 - sort_pass):\n              if sales[count] &lt; sales[count + 1]:\n                  temp = sales[count]\n                  sales[count] = sales[count + 1]\n                  sales[count + 1] = temp\n                  done_swap = True\n          if not done_swap:\n              break\n\n  print(\"Input list:\", sales)\n\n  sort_high_to_low()\n\n  print(\"Output list:\", sales)\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nOutput list: [100, 89, 75, 54, 54, 50, 45, 33, 29, 22]\n\n\n\n\n\n\n\nBubble sort works for strings as well as integers. We saw that in Chapter 5 the python relational operators also work for strings. See if you can modify the Party Guest Program to display the names in alphabetical order\nWe can basically just reuse our sort code, but renamed for the guest program.\ndef sort_alphabetical():\n    \"\"\"\n    Sorts a list alphabetically\n\n    Returns\n    -------\n    None\n    \"\"\"\n    for sort_pass in range(0, len(guests)):\n        done_swap = False\n        for count in range(0, len(guests) - 1 - sort_pass):\n            if guests[count] &gt; guests[count + 1]:\n                temp = guests[count]\n                guests[count] = guests[count + 1]\n                guests[count + 1] = temp\n                done_swap = True\n        if not done_swap:\n            break\nThere is a second modification above, which is changing the sign of the relational operator, e.g.\nguests[count] &lt; guests[count + 1]\nhas been changed to,\nguests[count] &gt; guests[count + 1]\nThis is because as written the program tries to put the smallest strings last, but for strings; where the relational operator is alphabetically ordered this puts strings starting with a for example, after those starting with z etc. So we need to swap the sign so that the list is printed a, b, … , z etc.\nWhy don’t we have to make more modifications? Well the code as written only requires that the items being sorted are stored in a list, and that the items in the list can be compared with a relational operator. Both of these properties are satisfied by a collection of strings so the code effectively works out of the box\nThe complete code, including the integration with reading and printing the guest list is given in SortAlphabetically.py\n\n\n\n\n\nTo flip the direction of the sort, we just need the condition that determines what is out of order or not\n\nWe do this by changing \\(&lt;\\) to \\(&gt;\\), i.e.\n\n  # Example 8.9 Bubble Sort Low to High\n  #\n  # Implementation of Bubble Sort that sorts from low to high\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def sort_low_to_high():\n      \"\"\"\n      Print out a sales list from highest to lowest\n\n      Returns\n      -------\n      None\n      \"\"\"\n      for sort_pass in range(0, len(sales)):\n          done_swap = False\n          for count in range(0, len(sales) - 1 - sort_pass):\n              if sales[count] &gt; sales[count + 1]:\n                  temp = sales[count]\n                  sales[count] = sales[count + 1]\n                  sales[count + 1] = temp\n                  done_swap = True\n          if not done_swap:\n              break\n\n\n  print(\"Input list:\", sales)\n\n  sort_low_to_high()\n\n  print(\"Output list:\", sales)\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nOutput list: [22, 29, 33, 45, 50, 54, 54, 75, 89, 100]\n\n\n\nThe code above is given in BubbleSortLowToHigh.py\n\n\n\n\n\nIn comparison to sorting, finding a value is much easier\nThe basic outline for finding the highest is,\n  for values in collection\n      if(new value &gt; highest seen so far)\n          highest = new value\nWe can write the code for the highest and lowest in python then as,\n  highest = sales[0]\n  for sales_value in sales:\n      if sales_value &gt; highest:\n          highest = sales_value\n\n  lowest = sales[0]\n  for sales_value in sales:\n      if sales_value &lt; lowest:\n          lowest = sales_value\nIf we want to find both at the same time, then we can combine the code above, which means we only have to do one pass through the collection\n\n  # Example 8.10 Highest and Lowest\n  #\n  # Function that finds the highest and lowest value in a collection\n\n  # Example 8.9 Bubble Sort Low to High\n  #\n  # Implementation of Bubble Sort that sorts from low to high\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def highest_and_lowest():\n      \"\"\"\n      Print out the highest and lowest elements of a sales list\n\n      Returns\n      -------\n      None\n      \"\"\"\n      highest = sales[0]\n      lowest = sales[0]\n\n      for sales_value in sales:\n          if sales_value &gt; highest:\n              highest = sales_value\n          elif sales_value &lt; lowest:\n              lowest = sales_value\n      print(\"The highest is:\", highest)\n      print(\"The lowest is\", lowest)\n\n\n  print(\"Input list:\", sales)\n\n  highest_and_lowest()\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nThe highest is: 100\nThe lowest is 22\n\n\n\nThe code above is given in HighestAndLowest.py\n\n\n\n\n\n\nTo evaluate the total we have to sum the contents of a list, simple using the for loops we’ve looked at, (implementation in TotalSales.py)\n\n  # Example 8.11 Total Sales\n  #\n  # Calculate the Total Sales\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def total_sales():\n      \"\"\"\n      Print out the total sales of a sales list\n\n      Returns\n      -------\n      None\n      \"\"\"\n      total = 0\n      for sales_value in sales:\n          total = total + sales_value\n      print(\"Total sales are:\", total)\n\n\n  print(\"Input list:\", sales)\n\n  total_sales()\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nTotal sales are: 551\n\n\nIt is a simple extra step to them calculate the average, (divide the total by the number of elements in the collection)\n\n  # Example 8.12 Average Sales\n  #\n  # Calculate the Average Sales\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def average_sales():\n      \"\"\"\n      Print out the average sales of a sales list\n\n      Returns\n      -------\n      None\n      \"\"\"\n      total = 0\n      for sales_value in sales:\n          total = total + sales_value\n      average_sales = total / len(sales)\n      print(\"Average sales are:\", average_sales)\n\n\n  print(\"Input list:\", sales)\n\n  average_sales()\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nAverage sales are: 55.1\n\n\n\n\n\n\n\nThe previous Exercises have given us all the parts, now we want to put it together\nThe crux of our program should be a loop around the menu through which the user selects different functions\nWe first however need to read in the data from the user\nFor useability we should add the ability to quit the program\nThe final program implements this\n\n# Example 8.13 Complete Program\n#\n# A Complete implementation of the Sales Program combining all the individual\n# programs that we have implemented\n\nimport BTCInput\n\nsales = []\n\n\ndef read_sales(number_of_sales):\n    \"\"\"\n    Reads in the sales values and stores them in the sales list\n\n    Parameters\n    ----------\n    number_of_sales : int\n        Number of Stores to record sales values for\n\n    Returns\n    -------\n    None\n        Results are read into the sales list\n    \"\"\"\n    sales.clear()  # remove existing sales values\n    for count in range(1, number_of_sales + 1):\n        prompt = \"Enter the sales for stand \" + str(count) + \": \"\n        sales.append(BTCInput.read_int(prompt))\n\n\ndef print_sales():\n    \"\"\"\n    Prints the sales figures on the screen with a heading. Each figure is\n    numbered in sequence\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"Sales Figures\")\n    count = 1\n    for sales_value in sales:\n        print(\"Sales for stand\", count, \"are\", sales_value)\n        count = count + 1\n\n\ndef sort_high_to_low():\n    \"\"\"\n    Print out a sales list from highest to lowest\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    sort_low_to_high : sorts from lowest to highest\n    \"\"\"\n    for sort_pass in range(0, len(sales)):\n        done_swap = False\n        for count in range(0, len(sales) - 1 - sort_pass):\n            if sales[count] &lt; sales[count + 1]:\n                temp = sales[count]\n                sales[count] = sales[count + 1]\n                sales[count + 1] = temp\n                done_swap = True\n        if not done_swap:\n            break\n\n\ndef sort_low_to_high():\n    \"\"\"\n    Print out a sales list from lowest to highest\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    sort_high_to_low : sorts from highest to lowest\n    \"\"\"\n    for sort_pass in range(0, len(sales)):\n        done_swap = False\n        for count in range(0, len(sales) - 1 - sort_pass):\n            if sales[count] &gt; sales[count + 1]:\n                temp = sales[count]\n                sales[count] = sales[count + 1]\n                sales[count + 1] = temp\n                done_swap = True\n        if not done_swap:\n            break\n\n\ndef highest_and_lowest():\n    \"\"\"\n    Print out the highest and lowest elements of a sales list\n\n    Returns\n    -------\n    None\n    \"\"\"\n    highest = sales[0]\n    lowest = sales[0]\n\n    for sales_value in sales:\n        if sales_value &gt; highest:\n            highest = sales_value\n        elif sales_value &lt; lowest:\n            lowest = sales_value\n    print(\"The highest is:\", highest)\n    print(\"The lowest is\", lowest)\n\n\ndef total_sales():\n    \"\"\"\n    Print out the total sales of a sales list\n\n    Returns\n    -------\n    None\n    \"\"\"\n    total = 0\n    for sales_value in sales:\n        total = total + sales_value\n    print(\"Total sales are:\", total)\n\n\ndef average_sales():\n    \"\"\"\n    Print out the average sales of a sales list\n\n    Returns\n    -------\n    None\n    \"\"\"\n    total = 0\n    for sales_value in sales:\n        total = total + sales_value\n    average_sales = total / len(sales)\n    print(\"Average sales are:\", average_sales)\n\n\n# Get initial sales list\nread_sales(10)\n\n\nmenu = \"\"\"\nIce Cream Sales\n\n0. Quit the Program\n1. Print the Sales\n2. Sort High to Low\n3. Sort Low to High\n4. Highest and Lowest\n5. Total Sales\n6. Average Sales\n7. Enter Figures\n\nEnter your command: \"\"\"\n\nwhile True:\n    command = BTCInput.read_int_ranged(menu, 0, 7)\n    if command == 0:\n        break\n    if command == 1:\n        print_sales()\n    elif command == 2:\n        sort_high_to_low()\n    elif command == 3:\n        sort_low_to_high()\n    elif command == 4:\n        highest_and_lowest()\n    elif command == 5:\n        total_sales()\n    elif command == 6:\n        average_sales()\n    elif command == 7:\n        read_sales(10)\n    else:\n        raise ValueError(\"Unexpected value \" + str(command) + \" found\")\n\n\n\n\n\n\nWarning\n\n\n\nKeeping Information Synchronised when Sorting\nPlaying around with the program you might notice one thing. The stands are numbered in the order that they are printed. This works great for printing the original list out, but once we start sorting these numbers don’t match their original value. This is fine if we only care about the sales figures, but if we want to maintain a relationship between a stand and its sales this is something that would have to be modified.\nThis is something you would discuss with the client\n\n\n\n\n\n\n\nA natural extension to the program would be the ability to read or store the sales data to a file\nFiles allow for persisting the data between sessions\nTo do this we’ll add two new options, 8. Save Sales and 9. Load Sales\nLet us start by stubbing out our functions (the complete integration is found in LoadAndSave.py),\n  def save_sales(file_path):\n      \"\"\"\n      Saves the contents of the sales list to a file\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to save to\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the save fails\n\n      See Also\n      --------\n      load_sales : load sales from a sales list file\n      \"\"\"\n      print(\"Save the sales in:\", file_path)\n\n\n  def load_sales(file_path):\n      \"\"\"\n      loads the contents of a file into the sales list\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to load from\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the load fails\n\n      See Also\n      --------\n      save_sales : save the sales list into a file\n      \"\"\"\n      print(\"Load the sales in:\", file_path)\nWe also add a basic integration to the user menu, where we use BTCInput.read_text to get a file name, then call the function\nObserve that by adding the complete docstring’s we’re also starting to document the requirements for these functions in-code\n    elif command == 7:\n      read_sales(10)\n  elif command == 8:\n      file_to_save_to = BTCInput.read_text(\"Enter file to save to: \")\n      save_sales(file_to_save_to)\n  elif command == 9:\n      file_to_load_from = BTCInput.read_text(\"Enter file to load: \")\n      load_sales(file_to_load_from)\n  else:\n      raise ValueError(\"Unexpected value \" + str(command) + \" found\")\n\n\n\n\nWhen interacting with a file, python represents it as a memory object\n\nTechnically representing the connection\n\nopen creates a connection to a file, the below, opens a file, test.txt, in write mode w and stores it in the variable output_file\n  output_file = open('test.txt', 'w')\n\nThe two arguments are called the file_path and the mode\n\nfile_path is the file you want to open\nmode is what you want to do with it\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\nIt’s very easy to overwrite an existing file\nThe open function will not prevent you from modifying important files. For example files opened for write will first wipe the contents of any existing file that matches the path then write the new contents.\nPython provides the os module which has some extra functionality for handling files and directories, e.g. you can check that a file exists before you open it if you then want check if the user wants to overwrite it before opening it\nimport os.path\nif os.path.isfile(\"text.txt\"):\n    print(\"The file exists\")\n\n\n\nIf we’ve opened a file in write mode, we can use the write method on the file object to write to the file\n  output_file.write(\"First line\\n\")\n  output_file.write(\"Second line\\n\")\n  output_file.close()\nOnce you’re done with a file you need to call close\n\nCompletes any unfinished writes (ensures data integrity)\nReleases the file so other programs or processes can use it\n\nFiles open for writing are locked for editing by that process, nothing else can use them\n\n\nPutting everything together our simple file writing program is,\n  # Exercise 8.15 File Output\n  #\n  # A simple program to demonstrate opening and writing to a file\n\n  output_file = open(\"test.txt\", \"w\")\n  output_file.write(\"line 1\\n\")\n  output_file.write(\"line 2\\n\")\n  output_file.close()\n\n\n\nConsider the following questions about file writing\n\nWhy have you called the write function a method? Isn’t it a function?\n\nAs discussed earlier, methods are functions associated with a specific object\nTypically when we say functionw we refer to a function that is defined outside of an object\nwrite is a method on the file object\n\nIt is impossible to use write without there being a file object to use\nMethods allow us to work with multiple file objects without having to worry about making sure we pass the correct one to the function\n\n\nWhat does the \\n mean at the end of the strings?\n\nIt’s the new line symbol write doesn’t automatically end the line after we call it\nWe have to manually pass the new line\n\nWhere is the file text.txt actually created?\n\nThe file_path is relative to the current running python program\nHence the file is written to the same directory\n\nE.g. if we had a folder called “My Programs” with a python program “MakeFiles.py”, when we run “MakeFiles.py” the files it makes are stored in “My Programs”\n\nYou can use more complicated file_paths\n\npath = \"./data/test.txt\" would look for test.txt in the data subdirectory of the current python program (relative path)\npath = \"c:/data/test.txt\" would look for test.txt in the data subdirectory of the c drive (absolute path)\n\n\n\n\n\n\n\nNote\n\n\n\nDenoting a Directory Seperator\nOn Windows \\ is used to seperate directories, but in python you always use /\n\n\n\nCan any program use a file written from a Python program?\n\nYes, python uses the underlying operating systems file handling services\nAny other program on the operating system can access files created or modified by python\n\nCan I add lines at the end of a python file?\n\nYes, rather than open the file in write w, you open the file in append (a).\nAny writes will then be appended to the end of the file.\nA non-existent file will be created the same way as for write mode\n\n\n\n\n\n\nUsing the above discussion we can implement the write_sales function\n  # Example 8.16 Write Sales\n  #\n  # Implements the Write Sales function\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def save_sales(file_path):\n      \"\"\"\n      Saves the contents of the sales list to a file\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to save to\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the save fails\n      \"\"\"\n      print(\"Save the sales in: \", file_path)\n      output_file = open(file_path, \"w\")\n      for sale in sales:\n          output_file.write(str(sale) + \"\\n\")\n      output_file.close()\n\n\n  save_sales(\"test_output.txt\")\n\n\n\n\nThe save_sales function combines several behaviours and is worth examining in detail. What is the purpose of the function? To take a list of sales figures and write those figures to a file (preferably in a format that is easy for a human to read and to load back into the program.) Consider the following questions\n\nWhat does the str function do? Why are we using it?\n\nThe str function converts the sales number to a string\nWhile print can handle non-string inputs, write can only take a string\n\nWhy can’t we just write out the sales list as one object?\n\nA list does not provide any built-in methods for writing an object out to a file\nWe could try and print out it’s string representation (i.e. call str and output that)\nDoesn’t give us great ability to control the way the data is output\n\n\n\n\n\n\n\nWe an also use open to read from a file, we just use the read mode (r)\n  input_file = open(\"test.txt\", \"r\")\nWe can then loop over the lines in a file using a for loop\nfor line in input_file:\n      print(line)\nWe should still use close() when we’re done reading\n  input_file.close()\nThe complete sample program looks like,\n  # Example 8.17 File Input\n  #\n  # Demonstrates reading input from a file\n\n  input_file = open(\"test.txt\", \"r\")\n  for line in input_file:\n      print(line)\n  input_file.close()\n\n\n\nWork through the following questions to understand how reading from files works\n\nIf you look at the following output, you’ll notice there are empty lines after each line of text. Why is that?\n line 1\n\n line 2\n\n\nEvery time we read a line from a file, we read the terminating new line\nThis is included in the string stored in line so when we call print we get that new line and the new line added by print\nWe could fix this by modifying our print call, to remove the new line\n  print(line, end='')\nA more natural way to fix this is to remove the newline when we first read in the string\nThe strip method when called without arguments returns a copy of the string with all leading and trailing whitespace removed from the string\n\n  line = line.strip()\n\nThis is an example of conditioning input\nProcess of making sure that an input does not contain any unexpected values\nE.g. we might also want to use strip to remove non-printable characters\n\nlstrip and rstrip are variants of strip that only work on the lead or end of the string respectively\n\n\nWhy do we have to close the file we’re reading?\n\nFor reading a file forgetting to close it won’t cause issues with other programs or processes that also try to read from the file\nHowever, lets other programs now write to that file\nReleases the memory associated with holding the connection\nYour computer might not let you shut down if it thinks there are still unclosed files\n\nWhat would happen if you tried to write to a file that had been opened for reading?\n\nAn exception will be raised\nr+ is a mode that lets you read and write to a file\nYou typically don’t want to read and write to a file at the same time\n\nHard to ensure the integrity of the data and avoid corrupting it\nSuch as by writing a line longer than the one previously written\n\nthis may corrupt the next line\n\n\nA better pattern is to load data, update the data then write that back into the file\n\nA temporary file (often abreviated as a tmp file) can be used if we need an intermediate file to write to\n\n\nCan a program read an entire file at once?\n\nYes, the* read method by default will try to read an entire file\nline endings are preserved\nBe careful with large files, as this may overwhelm your computers memory…\n\n # Example 8.18 File Read\n #\n # Demonstrates the use of file_object.read to read\n # the contents of a file in one go\n\n input_file = open(\"test.txt\", \"r\")\n total_file = input_file.read()\n print(total_file)\n input_file.close()\n\n\n\n\n\nLet’s now implement load_sales\n  # Example 8.19 Load Sales\n  #\n  # Implements the Load Sales function\n\n  sales = []\n\n\n  def load_sales(file_path):\n      \"\"\"\n      loads the contents of a file into the sales list\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to load from\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the load fails\n      \"\"\"\n      print(\"Load the sales in:\", file_path)\n      sales.clear()\n      input_file = open(file_path, \"r\")\n      for line in input_file:\n          line = line.strip()\n          sales.append(int(line))\n      input_file.close()\n\n\n\nload_sales works as the opposite of save_sales instead of taking a sales list and putting it into a text file, we pull the figures from a file and load them into the sales list. Consider the following questions\n\nWhat does the int function do?\n\nThe numbers pulled out of the file are initially stored as a string\nWe need to convert them to a number, so we call int\n\nWhat happens if the input file was empty?\n\nThe function works as one would hope\nThe loop doesn’t iterate and we get an empty sales list\n\n\n\n\n\n\n\n\nDealing with files, also means dealing with the errors they can introduce\n\ne.g. A file might have been deleted, a USB removed, or simply the user might pass the wrong name\n\nWhen an error occurs we want to ensure two things:\n\nNo files are left open\nThe user is aware that the error has occured\n\nFile objects typically raise exceptions when their methods\n\nEnables us to handle and report on their errors\nUse the try ... except syntax we’ve seen before\n\n  try:\n      output_file = open(file_path, \"w\")\n      for sale in sales:\n          output_file.write(str(sale) + \"\\n\")\n      output_file.close()\n      print(\"File Written Successfully\")\n  except:\n      print(\"Something went wrong with the file\")\n\n\n\nThe code performing the file write is wrapped in a try...except block. If write, open or close causes an exception it will be caught and handled by the except clause. Let’s work through the following questions to see if this solves the ensures that the file is closed and the user is informed\n\nIn what circumstances will the code in the except part be executed?\n\nIf any of the file functions, write, open, or close raise an exception, the code in the except part will be executed\nAn error message is thus only printed when an error occurs\n\nIn what circumstances will the “File written successfully?” message be printed?\n\nThis is only printed if every step in the file writing process is completed successfully\n\nAn error message is always printed if an error is thrown, but will the file always be closed?\n\nNo, this is a problem, as we said that all files needed to be closed even when an error occurs!\nWe could put the close statement in the exception handling section to, but a more general solution to this problem is to use a finally block\n\nA finally block contains code that is always executed after all of the try and/or except code has executed\nGood for code that we naturally want to run after the block no matter if the process succeeds or fail (such as clean-up)\n\n\n try:\n     output_file = open(filename, \"w\")\n     for sale in sales:\n         output_file.write(str(sale) + \"\\n\")\n except:\n     print(\"Something went wrong with writing to the file\")\n finally:\n     output_file.close()\n\n\n\n\n\n\nIt would be great if we didn’t have to remember to manually ensure a file gets closed\n\nFailing to properly close a file can lead to hard to pin down behaviour\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIntermittent Faults are the Worst Kind to Fix\nA piece of code that is broken all the time is annoying, but at least you can typically easily identify what is not working. If a program fails only some of the time this can be much harder to solve. Often you require precise directions as to the steps taken up to the point of failure in order to be able to attempt to replicate the problem. This adds significant overhead to fixing the problem\n\n\n\nThe with construct allows the programmer to automatically manage the acquisition and release of resources\n\nMore generic than just file access\nYou can write your own services to work with with\n\nAdvanced topic we can ignore for now\n\n\n\n\n\n\n\n\nblock-beta\n    columns 6\n\n    classDef BG stroke:transparent, fill:transparent\n\n\n    space\n    title[\"Breakdown of a with statement\"]:4\n    space\n\n    class title BG\n\n    block:With\n    columns 1\n        with[\"with\"]\n        withDescr[\"(start of a with block)\"]\n    end\n\n    class with BG\n    class withDescr BG\n\n\n    block:Expression\n    columns 1\n        expression[\"expression\"]\n        expressionDescr[\"(expression generating resource to use)\"]\n    end\n\n    class expression BG\n    class expressionDescr BG\n\n    block:As\n    columns 1\n        as[\"as\"]\n        space\n    end\n\n    class as BG\n\n    block:Name\n    columns 1\n        name[\"name\"]\n        nameDescr[\"(name to represent the resource)\"]\n    end\n\n    class name BG\n    class nameDescr BG\n\n    block:Colon\n    columns 1\n        colon[\":\"]\n        space\n    end\n\n    class colon BG\n\n    block:Suite\n    columns 1\n        suite[\"Statement block\"]\n        suiteDescr[\"(statements)\"]\n    end\n\n    class suite BG\n    class suiteDescr BG\n\n\n\n\n\n\n\nwith is used to provide an object that provides a service\nas is used to assign a semantically meaningful name to the resource\nwith activates an “enter” behaviour on its object\n\nFor files this is open\n\nWhen the block is finished, with calls some exit behaviour on the object\n\nFor files this causes the file to be closed\n\nwith allows us to ensure a few things\n\nThe file is always closed\nThe reference to the file only exists as long as we are using it\n\n  # Example 8.20 Using with to Access Files\n  #\n  # Rewrites read_sales and load_sales to use the with functionality\n  # implemented in python\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def save_sales(file_path):\n      \"\"\"\n      Saves the contents of the sales list to a file\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to save to\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the save fails\n\n      See Also\n      --------\n      load_sales : load sales from a given file\n      \"\"\"\n      print(\"Save the sales in:\", file_path)\n      try:\n          with open(file_path, \"w\") as output_file:\n              for sale in sales:\n                  output_file.write(str(sale) + \"\\n\")\n      except:  # noqa: E722\n          print(\"Something went wrong with the file\")\n\n\n  def load_sales(file_path):\n      \"\"\"\n      loads the contents of a file into the sales list\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to load from\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the load fails\n\n      See Also\n      --------\n      save_sales : save sales to a file\n      \"\"\"\n      print(\"Load the sales in:\", file_path)\n      sales.clear()\n      try:\n          with open(file_path, \"r\") as input_file:\n              for line in input_file:\n                  line = line.strip()\n                  sales.append(int(line))\n      except:  # noqa: E722\n          print(\"Something went wrong with the file\")\n\n\n  print(\"Sales before save and load:\", sales)\n  save_sales(\"test.txt\")\n  load_sales(\"test.txt\")\n  print(\"Sales after save and load:\", sales)\nObserve that we no longer have to explicitly include the close call\nwith does not handle exceptions however, so we still have to include a try...except block\nWhen an exception occurs the with first releases the resource with its exit behaviour\n\ne.g. closes the file\nThen the excecution moves to the except block\n\nIf we wanted to handle exceptions without releasing the resource, we would have to swap the order to,\n  with open(\"file\", \"mode\"):\n      try:\n          #do standard thing here\n      except:\n          # handle exception without releasing resource\n      finally:\n          # do something regardless of success or fail without releasing resource\n\n\n\n\nAdd a save function to your party guest program so that you can record a list of people who attended your party\nWe build off our version that generates a sorted list. We can basically copy the save_sales function making changes to the refer to the guests list instead of sales and giving a more appropriate name to the loop variable.\ndef save(file_path):\n    \"\"\"\n    Saves the guest list to a file\n\n    Parameters\n    ----------\n\n    file_path : str\n        string giving the file path to save to\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    FileException\n        Raised if the save fails\n    \"\"\"\n    print(\"Save the guest list in:\", file_path)\n    try:\n        with open(file_path, \"w\") as output_file:\n            for guest in guests:\n                output_file.write(str(guest) + \"\\n\")\n    except:  # noqa: E722\n        print(\"Something went wrong with the file\")\nWe then run the program as normal\n\nAsk for the number of guests\nRead in the guests\nSort the guest list\nDisplay the guest list\n\nWe then ask the user if they want to save the guest list. For simplicity we use BTCInput.read_input_ranged to ask for a \\(0\\) or a \\(1\\) where a \\(1\\) indicates the user wishes to save, while \\(0\\) indicates they dont. If the user wishes to save we then prompt them using BTCInput.read_text for a file name and then call save on the given file path\nuser_wants_to_save = BTCInput.read_int_ranged(\n    \"Would you like save the list? (1 for yes, 0 for no): \", min_value=0, max_value=1\n)\n\nif user_wants_to_save:\n    save_file_name = BTCInput.read_text(\"Enter file name to save as: \")\n    save(save_file_name)\n\nThe complete integrated code is given in GuestListWithSave.py\n\n\n\n\n\n\nA list holds data in one dimension, i.e. its length\nOften data is multi-dimensional\ne.g. Our Ice Cream Sales client might now ask for the ability to track sales, by store and by day of the week\n\n\n\n\n\n\nblock-beta\n    columns 5\n\n    classDef Header fill:#bbf,stroke:#333,stroke-width:4px;\n    classDef BG stroke:transparent, fill:transparent\n\n    space:2\n    title[\"Data Table\"]:2\n    space:1\n\n    class title BG\n\n    space\n    block:fields:4\n    columns 4\n        monday[\"Monday\"]\n        tuesday[\"Tuesday\"]\n        wednesday[\"Wednesday\"]\n        stop[\"...\"]\n    end\n\n    class fields Header\n\n    Stand1[\"Stand 1\"]\n    50\n    80\n    10\n    Blank1[\"...\"]\n\n    class Stand1 BG\n\n    Stand2[\"Stand 2\"]\n    54\n    98\n    7\n    Blank2[\"...\"]\n\n    class Stand2 BG\n\n    Stand3[\"Stand 3\"]\n    29\n    40\n    80_2[\"80\"]\n    Blank3[\"...\"]\n\n    class Stand3 BG\n\n    Stand4[\"...\"]\n    stand4_1[\" \"]\n    stand4_2[\" \"]\n    stand4_3[\" \"]\n    stand4_4[\" \"]\n\n    class Stand4 BG\n\n\n\n\n\n\n\n\nOur current implementation is effectively a vertical slice for one of the days\nCan implement multiple lists, one per day of the week\n\nEffectively repeats the problem we had before of a distinct named variable for each item\n\nWe want a list of lists\n\n  mon_sales = [50, 54, 29, 33,  22, 100, 45, 54, 89, 75]\n  tue_sales = [80, 98, 40, 43, 43, 80, 50, 60, 79, 30]\n  wed_sales = [10, 7, 80, 43, 48, 82, 33, 55, 83, 80]\n  thu_sales = [15, 20, 38, 10, 36, 50, 20, 26, 45, 20]\n  fri_sales = [20, 25, 47, 18, 56, 70, 30, 36, 65, 28]\n  sat_sales = [122, 140, 245, 128, 156, 163, 90, 140, 150, 128]\n  sun_sales = [100, 130, 234, 114, 138, 156, 107, 132, 134, 148]\n\n  week_sales = [mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales, sun_sales]\n\nThink of lists of lists as a collection of rows and columns\n\nWe first specify the row we want say tue_sales\nThen the column, say Stand 1\n\n  print(week_sales[1][0])\n\n80\n\n\n\n\n\n\nIt can be difficult to get the hang of working with multiple indices. Which of the following indices would fail when the program runs?\nStatement 1: week_sales[0][0] = 50\nStatement 2: week_sales[8][7] = 88\nStatement 3: week_sales[7][10] = 100\n\nStatement 1 is valid\nStatement 2 is invalid because the first index \\(8\\) corresponds to the day of the week\n\nThe valid indices here are \\(0\\) to \\(6\\)\n\nStatement 3 is also invalid for the same reason\n\nEven though there are seven days of the week\nThe list is zero indexed\n\n\nLet’s see this in action\n\nStatement 1:\n\n\nweek_sales[0][0]\n\n50\n\n\n\nStatement 2:\n\n\nweek_sales[8][7]\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[20], line 1\n----&gt; 1 week_sales[8][7]\n\nIndexError: list index out of range\n\n\n\n\nStatement 3:\n\n\nweek_sales[7][10]\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[21], line 1\n----&gt; 1 week_sales[7][10]\n\nIndexError: list index out of range\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nMake it easy to test your program\nTesting is important, but unless it’s easy or automatic it’s pretty common to get left by the wayside.\nIn a program one might use a function make_test_data or for larger projects a test framework that is used to generate test data.\nWhenever you find yourself repeating a pattern to test code, consider how you can automate or bypass that process\n\n\n\n\n\n\nWe can use nested for loops to work through individual values in a list of lists\nE.g. if we want to calculate the total sales over a week, (full code given in TablesOfSaleData.py)\n\n  total_sales = 0\n  for day_sales in week_sales:\n      for sales_value in day_sales:\n          total_sales = total_sales + sales_value\n\n  print(\"Total sales for the week are\", total_sales)\n\nTotal sales for the week are 5205\n\n\n\nday_sales in the outer loop iterates over each constituent list in the list of lists\nsales_value is then each value in the current list referenced by day_sales\n\n\n\n\nConsider the code for summing the sales data in the previous example. Answer the following questions to make sure you understand how it works\n\nHow many times will the statements inside the two loops be obeyed?\n\nIn total they will be run \\(70\\) times\nThe outer loop runs seven times (once for each day of the week)\nThe inner loop runs ten times (one for each stand)\n\nfor each iteration of the outer loop\n\n\nHow would you change this program so that it could handle more than one week’s worth of sales?\n\nWe can add more days to the list\nRather than have them correspond to Monday - Friday it might be Week 1 Day 1 etc.\nThese would be additional rows in the list of lists\n\nHow would we add a day’s worth of sales to the list?\n\nWe have to read in a new list of values\nCan then append it to the list of lists\n  read_sales(10) # read ten values into sales list\n  week_sales.append(sales) # append the values to the weekly sales list\n\n\n\n\n\n\n\nIt is possible to work with higher dimensions\nFor example we might want to store multiple weeks of data\n\nThen we would have a list of (list of (lists))s\n\nWorks just like two dimensions but with an extra index, for example we can append a week of sales like so,\n  annual_sales.append(week_sales)\n\n\n\n\n\n\n\nTip\n\n\n\nKeep your dimensions low\nYou should rarely have to use more than three dimensions. If you find yourself using highly nested / high-dimensional structures you might want to rethink how you’re representing your data\nOne technique we will see later is the use of classes, which can make it easier to create linear collections\nThe computer itself is perfectly happy working in higher dimensions. The real difficulty is that you probably aren’t and it can be hard to reason about high dimension data\n\n\n\n\n\n\n\nNow we have the ability to manipulate weekly sales data, the next question is how to display that data and the requests.\nWhen we enter the data we want to see something like,\n  Enter the Monday sales figures for stand 2:\nHere we need to have a variable to control what day is printed\n\nSimplest implementation is an integer to track the day, implemented in DayNameIf.py\n\n\n  # Example 8.22 Day Name If\n  #\n  # Uses a if, elif, else construction to convert an integer\n  # to a string representation of the day of the week\n\n  import time\n\n  current_time = time.localtime()\n  day_number = current_time.tm_wday\n\n  if day_number == 0:\n      day_name = \"Monday\"\n  elif day_number == 1:\n      day_name = \"Tuesday\"\n  elif day_number == 2:\n      day_name = \"Wednesday\"\n  elif day_number == 3:\n      day_name = \"Thursday\"\n  elif day_number == 4:\n      day_name = \"Friday\"\n  elif day_number == 5:\n      day_name = \"Saturday\"\n  elif day_number == 6:\n      day_name = \"Sunday\"\n  else:\n      raise ValueError(\"Unexpected day_number \" + str(day_number) + \" encountered\")\n\n  print(day_name)\n\nSaturday\n\n\nThis works, but is fragile, a cleaner way to do this is to use a lookup table\n\ni.e. we use day_number to index a list that stores the correct day\n\nWe use thetime library for fun so the program prints the current day\n\n  # Example 8.23 Day Name List\n  #\n  # Uses a lookup table to correctly print the day\n\n  import time\n\n  current_time = time.localtime()\n  day_number = current_time.tm_wday\n\n  day_names = [\n      \"Monday\",\n      \"Tuesday\",\n      \"Wednesday\",\n      \"Thursday\",\n      \"Friday\",\n      \"Saturday\",\n      \"Sunday\",\n  ]\n\n  day_name = day_names[day_number]\n\n  print(\"Today is\", day_name)\n\nToday is Saturday\n\n\nLookup tables are powerful for shrinking written code\nThey also are used to create data-driven applications\n\nPrograms that use built-in or loaded data rather than fixed behaviour\n\n\n\n\n\n\nLists are the standard collection type\n\nThey are mutable, i.e. we can change the value of a given index or add new items\n\nConsider the day_names list, once defined we don’t want to change it\n\nWe would like to also prevent this, to catch potential programming errors e.g.\n  day_names[5] = \"Splatterday\"\n\nA tuple is like a list, but the contents cannot be changed\n\nA tuple is said to be immutable\nIf we attempt to change the tuple we get an error, (demonstrated in the implementation DayNameList.py)\n\nSpecifically a TypeError\nBecause the action we are trying to take (change the value at an index) is not supported by the object type (tuple)\n\n\n  # Example 8.24 Day Name Tuple\n  #\n  # Reimplements the Day Name lookup table with a tuple\n  # and demonstrates the immutability of the data structure\n\n  import time\n\n  current_time = time.localtime()\n  day_number = current_time.tm_wday\n\n  day_names = (\n      \"Monday\",\n      \"Tuesday\",\n      \"Wednesday\",\n      \"Thursday\",\n      \"Friday\",\n      \"Saturday\",\n      \"Sunday\",\n  )\n\n  day_name = day_names[day_number]\n\n  print(\"Today is\", day_name)\n\n  print(\"Attempting to change the lookup table...\")\n\n  day_names[day_number] = \"Splatterday\"  # type: ignore\n  print(\"Today is\", day_names[day_number])\n\nToday is Saturday\nAttempting to change the lookup table...\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[25], line 27\n     23 print(\"Today is\", day_name)\n     25 print(\"Attempting to change the lookup table...\")\n---&gt; 27 day_names[day_number] = \"Splatterday\"  # type: ignore\n     28 print(\"Today is\", day_names[day_number])\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\n\nTuple is created as for a list but using () to delimit the items rather than []\nTuples are good for working with complicated values\n\ne.g. composite types\n\nFor Example, consider a pirates treasure map\n\nTreasure’s location is given by\n\nA reference landmark\nNumber of steps north\nNumber of steps east\n\n\nA function can strictly speaking return one value\n\nWe can return multiple values as a tuple\n\n  def get_treasure_location():\n      # get the treasures location\n      return (\"The old oak tree\", 20, 30)\n\nThis returns three values\n\nThe string \"The old oak tree\"\nThe number of steps north, 20\nThe number of steps east, 30\n\n\nLike lists, tuples are zero-indexed\n\n\n\n\n\n\n\nWarning\n\n\n\nTake care with your tuple indices\nWhen returning multiple items from a function via a tuple, we have to be clear to specify the order of what the items in the tuple correspond to. This is effectively a contract between the function and any caller (if you change the order, you will break the code of anyone who relies on the current order)\nThe order that parameters are returned in should thus be clearly documented, e.g.\ndef get_treasure_location():\n    \"\"\"\n    Gets the location of the treasure\n\n    Returns\n    -------\n    str\n        Name of a landmark to start at\n    int\n        Number of paces north\n    int\n        Number of paces east\n    \"\"\"\n\n    return (\"The old oak tree\", 20, 30)\n\n\n\nAn alternative to explicitly referencing the index of a returned tuple, is called tuple-unpacking\n\nWe provide a comma-seperated list of variables to assign the tuple values (in order) to, e.g.\n      landmark, north, east = get_treasure_location()\n  print(\"Start at\", landmark, \"walk\", north, \"paces north and\", east, \"paces east\")\n\nThe complete Pirate’s Treasure program implemention is given in PiratesTreasure.py",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 8: Storing Collections of Data"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/08_StoringCollectionsOfData/Chapter_08.html#summary",
    "href": "01_ProgrammingFundamentals/08_StoringCollectionsOfData/Chapter_08.html#summary",
    "title": "Chapter 8: Storing Collections of Data",
    "section": "Summary",
    "text": "Summary\n\nLists can be used to store large and arbitarily sized data\n\nWe refer to the individual elements of a list as items\nappend lets us add new elements to a list (at the end)\nlen returns the number of items in a list\nlists can contain different types of data in the same list\nlist values are accessed via the indexing operator []\n\nlists are indexed from \\(0\\)\nThe last index in a list is len(list) - 1\n\nNested lists allow for multi-dimensional structures\n\nFiles can be manipulated by python\n\nopen is used to access a file\nfiles can be read from or written to\nfor can be used to loop over lines from a file\nwhen using write to write to a file, newlines ('\\n') must be added exactly\nstrip can be used to remove whitespace when reading lines from a file\nFiles must be closed using the close method once they are no longer in use\nFiles can raise exceptions which must be handled or notified to the user\n\nThey must ensure the file is still closed\n\nwith can be used to automatically ensure a file is closed once it is no longer used, even in error scenarios\n\nTuples are immutable collections\n\nOnce they are defined we cannot modify or add values\nTuples are suitable for tuples or other fixed collections\nTuples can be used by functions that return more than one value",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 8: Storing Collections of Data"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/08_StoringCollectionsOfData/Chapter_08.html#questions-and-answers",
    "href": "01_ProgrammingFundamentals/08_StoringCollectionsOfData/Chapter_08.html#questions-and-answers",
    "title": "Chapter 8: Storing Collections of Data",
    "section": "Questions and Answers",
    "text": "Questions and Answers\n\nDo we really need lists?\n\nYes, any scenario with large or arbitrary data needs collections to meaningfully handle and manipulate them\n\nDo we really need tuples?\n\nNo, techically we could just use lists instead. They are useful though because they enforce properties that lists don’t such as immutability which is useful in some cases\n\nHow does the list actually work?\n\nWhen a list is created the program reserves memory to hold a few items\nThe memory also tracks the number of items currently stored in the list\nAppending an item consumes part of the allocated memory\nIf the list doesn’t have enough room, then more memory is allocated to the list\nWhen accessing a list item, the list checks if the item exists\n\nIf the item doesn’t exist, an exception is thrown\nelse, the item is found and returned\n\n\nWhy are tuples called tuples?\n\nTuples are ordered collections of elements in mathematics. Python adopted the terminology\n\nShould the sales program use a list to store the sales figures or a tuple?\n\nIt depends on the operations we want to peform\nOnce we have the list of sales figures, none of our operations strictly change the tuple (except sorting)\n\nCan implement sorting them as creating a new tuple\nProbably good to then use a tuple from a security perspective\nHowever, this makes the code more complicated\n\nIf we wanted to introduce an edit function later to modify sales data we might prefer a list for the clean implementation\n\nAs again opposed to the tuple approach\n\n\nCan functions return lists instead of tuples?\n\nYes, they can.\nHowever, typically the results of functions cannot be changed\n\nSo naturally a tuple\n\n\nWill my program run faster if I use tuples to store all the data in it?\n\nPotentially, tuples are faster to implement than lists\nDepends on what the program does, if you’re mutating a lot of data, the cost of constantly recreating multiple tuples might be greater than the cost of creating and modifying a list\nThe speed difference should hardly be noticable in any case\n\nDoes the with construction stop objects from throwing exceptions?\n\nNo, with is designed to ensure that even if an object throws an exception the managed resource is released correctly\nwith will still pass on the exception",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 8: Storing Collections of Data"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/06_RepeatingActionsWithLoops/Chapter_06.html",
    "href": "01_ProgrammingFundamentals/06_RepeatingActionsWithLoops/Chapter_06.html",
    "title": "Chapter 6: Repeating Actions with Loops",
    "section": "",
    "text": "while allows a program to repeat blocks of statements\nstructure is similar to an if\n\n\n\n\n\n\nblock-beta\n    columns 4\n    space\n    title[\"Breakdown of a While\"]:2\n    space\n\n    block:Input\n    columns 1\n        while[\"while\"]\n        whileDescr[\"(start of the while construction)\"]\n    end\n\n    block:MiddleOne\n    columns 1\n        condition[\"condition\"]\n        conditionDescr[\"(value that is True or False)\"]\n    end\n\n    block:MiddleTwo\n    columns 1\n        colon[\":\"]\n        colonDescr[\"Colon\"]\n    end\n\n    block:Suite\n    columns 1\n        suite[\"Statement block\"]\n        suiteDescr[\"(statements)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass condition BG\nclass conditionDescr BG\nclass colon BG\nclass colonDescr BG\nclass while BG\nclass whileDescr BG\nclass suite BG\nclass suiteDescr BG\n\n\n\n\n\n\n\nif the condition evaluates True then the block of statements is run\n\nAfter the statements are run, control returns to the start of the while loop\nIf the condition is still True then the loop runs again\n\n\n\n\nUse the python interpreter to run the following to understand the while loop\n\nCan we use a boolean value to control a while construction?\n\nYes, for example the block of statements in the while here shouldn’t run\n\n\n while False:\n     print(\"Loop\")\n print(\"Outside the Loop\")\n\nOutside the Loop\n\n\nCan a loop go on forever?\n\nYes, an control expression for a while that always evaluates True will cause the loop to run infinitely\n\n while True:\n     print(\"Loop\")\n print(\"Outside the Loop\")\n\nThe above should only print \"Loop\" when executed\nIf you accidently do this you may need to use CTRL+C, CRTL+Z or an interrupt execution feature of your live environment to stop the execution\n\nWill the following program ever print out the message, \"Outside loop\"?\n while True:\n     print(\"Inside Loop\")\n print(\"Outside Loop\")\n\nNo, the above is a quintessential infinite loop\n\nWill the following program ever print out the message, \"Inside Loop\"? How about \"Outside loop\"?\n\n while False:\n     print(\"Inside Loop\")\n print(\"Outside Loop\")\n\nOutside Loop\n\n\n\nThe while never executes the statements inside so \"Inside Loop\" is never printed, but \"Outside Loop\" is.\n\nWhat will the following program print?\n\n # Example 6.1 Loop with Flag\n #\n # Demonstrates control of a loop with a boolean flag\n\n flag = True\n while flag:\n     print(\"Inside Loop\")\n     flag = False\n print(\"Outside Loop\")\n\nInside Loop\nOutside Loop\n\n\n\nWhen we first enter the loop flag is True so the loop executes and*\"Inside Loop\" is printed\nflag is then set False so on the next iteration of the loop, the loop doesn’t execute.\nWe move to the next statement outside of the loop and print out \"Outside Loop\"\nThe pattern of using a control variable that is updated in the loop body in a while loop is very common\n\nWhat will the following program print?\n flag = True\n while flag:\n     print(\"Inside Loop\")\n     Flag = False\n print(\"Outside Loop\")\n\nThis looks similar to the previous, but note the typo, we refer to Flag not flag inside the loop\nThis which defines a new variable, instead of modifying the loop control.\nWe thus get an infinite series of \"Inside Loop\" being printed.\n\nWhat will the following program print?\n\n # Example 6.2 Loop with Counter\n #\n # Demonstrates use control of a while loop\n # using a conditional expression\n\n count = 0\n while count &lt; 5:\n     print(\"Inside Loop\")\n     count = count + 1\n print(\"Outside Loop\")\n\nInside Loop\nInside Loop\nInside Loop\nInside Loop\nInside Loop\nOutside Loop\n\n\n\ncount is initially set to \\(0\\)\nAt each iteration we print \"Inside Loop\" * and increase the value of count by \\(1\\)\nThe loop stops once count reaches \\(5\\)\nThis means that \"Inside Loop\" should be printed \\(5\\) times, followed by \"Outside Loop\"\n\n\n\n\n\nUse a while loop, to make a theme park selector that runs continously. All you need to do is put all of the statements that implement the theme park behaviour into a while True construction\nFor usability our program won’t loop endlessly. We’ll say that any number that it is not a valid ride number is code for quitting the program. The relevant changes to the Ride Selector are then,\n# Exercise 6.1 Looping Ride Selector\n#\n# Wraps the Ride Selector Program in a while\n# loop to allow the user to look at multiple rides\n\nrun_program = True\n\nwhile run_program:\n    print(\"\"\"Welcome to our Theme Park\n        These are the available ride:\n\n        1. Scenic River Cruise\n        2. Carnival Carousel\n        3. Jungle Adventure Water Splash\n        4. Downhill Mountain Run\n        5. The Regurgitator\n        Any other number to quit...\n        \"\"\")\n\n    ride_number_text = input(\"Please enter the ride number you want: \")\n    ride_number = int(ride_number_text)\n\n    if ride_number &lt; 1 or ride_number &gt; 5:\n        run_program = False\n    elif ride_number == 1:\nObserve that first we wrap all of the code in a while loop, and introduce a boolean flag run_program initially set to True to flag if the program continues to run at each loop iteration. When a user enters a number we first check if it corresponds to a ride number and if not, we set the program to quit on the next loop iteration by setting run_program to False. We now change the original if ride_number == 1 to and elif so it is only checked if we know the ride_number is valid. (The full code is in LoopingRideSelector.py)\n\n\n\nOne of the examples in the above question set involved a countup to \\(5\\). Implement a program that counts down from \\(10\\) to \\(0\\) over \\(10\\) seconds\n# Exercise 6.2: Countdown\n#\n# Performs a 10-second countdown\n\nimport time\n\ntime_left = 10\n\nwhile time_left &gt;= 0:\n    print(time_left)\n    time_left = time_left - 1\n    time.sleep(1)\n\n\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\n\n\nThis is a straightforward exercise (see Countdown.py), we set up our counter value to \\(10\\) and use the appropriate loop expression (here time_left &gt;= 0) to ensure that \\(0\\) is included in the countdown.\nIn the loop we print the current value of time_left, then decrement time_left by \\(1\\), and sleep for the required time. Observe that after the program prints \\(0\\), time_left becomes \\(-1\\) and the next iteration of the loop won’t run.\n\n\n\n\nRide Selector doesn’t account for invalid user entry\n\nBlindly assumes a number outside the range \\(1\\) to \\(5\\) represents quitting the program\n\nIdeally we would like to have a distinct number that represents quitting and a way to capture and handle any invalid inputs\n\n\n\n\n\n\n\nTip\n\n\n\nGreat Programmers Think Defensively\nDefensive programming is a programming technique in which a programmer attempts to defend their code against possible errors that might occur in a code e.g. receiving a word when expecting a number\nIt is good practice to think about, typically a user expects a computer to do something reasonable even when provided unreasonable input.\nData validation does have the downside in that it can make programs significantly bigger, and in compiled languages knowing that data is valid can make them much faster. A good skill is learning the correct layers or boundaries of a program to perform the defensive data validation so the core can run without concern\n\n\n\nIgnoring the question of quitting for now, data validation for the ride selector might look like,\n  if ride_number &lt; 1 or ride_number &gt; 5:\n      print('Invalid ride number')\n\n\n\n\nAbove acknowledges the error, but if we want to use this in our loop control we will need to use while\n  ride_number_text = input(\"Please enter the ride number you want: \")\n  ride_number = int(ride_number_text)\n\n  while ride_number &lt; 1 or ride_number &gt; 5:\n      print(\"There is no ride with that number\")\n      ride_number_text = input(\"Please enter the ride number you want: \")\n      ride_number = int(ride_number_text)\n  print(\"You have selected ride number: \", ride_number)\n\nwhile means program repeats until it receives valid input\nObserve the downside\n\nWe have to repeat the code asking for the ride number and converting to an integer\nSome languages have a do ... while statement which performs its test after executing the loop body for the first time\n\nWould allow us to write the above as one construct\n\n\n\n\n\n\nAdd ride number validation to the Looping Ride Selector implementation. Remember that the while construction must be added after the ride_number value has been read by the program\nWe can basically add the validation in immediately after the first attempt to read the ride number from the user. We also have to adjust the code to now use \\(0\\) as the explicit value for quitting rather than inferring any non-ride-number as a quit value. The main changes are,\n# Exercise 6.3 Ride Selector with Ride Number Validation\n#\n# Adds Ride Number validation to the Ride Selector\n# The program will query the user until a valid ride number or\n# the quit number is given\n\nwhile run_program:\n    print(\"\"\"Welcome to our Theme Park\n        These are the available ride:\n\n        1. Scenic River Cruise\n        2. Carnival Carousel\n        3. Jungle Adventure Water Splash\n        4. Downhill Mountain Run\n        5. The Regurgitator\n        Press 0 to quit the program\n        \"\"\")\n\n    ride_number_text = input(\"Please enter the ride number you want: \")\n    ride_number = int(ride_number_text)\n\n    while ride_number &lt; 0 or ride_number &gt; 5:\n        print(\"There is no ride with that number\")\n        ride_number_text = input(\"Please enter the ride number you want: \")\n        ride_number = int(ride_number_text)\n\n    if ride_number == 0:\n        run_program = False\nThe complete code is given in RideNumberValidation.py\n\n\n\nWhen creating composite conditions for loops, making sure the logic is correct is incredibly important. Examine the following program to understand more complicated loop control\nage_text = input(\"Please enter your age: \")\nage = int(age_text)\nwhile age &lt; 1 and age &gt; 95:\n    #repeat this code while the age is invalid\n    print(\"This age is not valid\")\n    age_text = input(\"Please enter your age: \")\n    age = int(age_text)\n#when we are here, we have a valid age value\nprint(\"Thank you for entering your age\")\n\nWhat is the fault in this program?\n\nThe condition age &lt; 1 and age &gt; 95 requires age to be both less than \\(1\\) and greater than \\(95\\), this is impossible, so the loop never runs\n\nWhat will the fault cause the program to do?\n\nSince the loop body can never run, every entered age will be considered valid\n\nHow do you fix this?\n\nThe desired logic is that age should be between \\(1\\) and \\(95\\) inclusive. This logic is captured by the or operator.\nThe corrected expression is*\n  while age &lt; 1 or age &gt; 95\n\n\n\n\n\n\n\n\nImportant\n\n\n\nAlways test failure behaviours along with successful ones\nIt’s very important when testing software to test both the successful path (the so-called “happy path”) and any possible error states.\nA good programmer proactively looks for potential points of failure, writes code to handle the errors and importantly checks that the code to handle the errors does what it’s supposed to do\nA good heuristic for starting to do this with simple programs is called boundary-value testing. Boundaries are the points between different expected behaviours. For example with the ride selector, we expect different behaviour for numbers \\(&lt; 1\\) or \\(&gt; 5\\) to those in the range \\(1\\) to \\(5\\). So a good set of tests might be \\(0\\), \\(1\\), \\(2\\), \\(4\\), \\(5\\), \\(6\\). i.e. we test either side of the boundary, and on the boundary\n\n\n\n\n\nAdd age validation to the Ride Selection Program. The theme park owner has told you that the minimum age for anyone going on a ride at the theme park is \\(1\\) year, and the maximum age is \\(95\\). Use these values in your program\nObserve that in this case if the user provides an age outside the accepted range, we don’t want to prompt them to put in a new age, since this could legitimately be their age. Instead we want to tell them regardless of the ride they chose they can’t ride. In this case we should use an if style validation technique\nThe change is applied at our age reading section of the program, we use an if...elif...else construct to tell the user they are either too young, too old, or to continue on to the standard ride selection code\nage_text = input(\"Please enter your age: \")\nage = int(age_text)\nif age &lt; 1:\n    print(\"You are too young to go on any rides\")\nelif age &gt; 95:\n    print(\"You are too old to go on any rides\")\nelse:\n    #continue on to normal ride selection code...\nThe full code is given in AgeValidation.py\n\n\n\n\n\n\n\nProblem: We can easily write a loop that checks if a value is invalid but how do we deal with the type being invalid?\n\ne.g. in the ride selector how do we deal with the user typing in a word rather than a number?\nConsider the snippet below, emulating the ride selector given a string input, we get an error, before we even get a chance to validate the value\n\n\n  ride_number_text = \"three\"\n  ride_number = int(ride_number_text)\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[6], line 2\n      1 ride_number_text = \"three\"\n----&gt; 2 ride_number = int(ride_number_text)\n\nValueError: invalid literal for int() with base 10: 'three'\n\n\n\n\nThis occurs because int requires it’s input to be convertable to a number\n\nUnfortunately this does not extend to human-language written versions of a number\nIn this case int throws an error, it is better to end the program than continue in an erroneous state\n\nIn general, when a program encounters an error state, it should aim to fail fast, rather than continue and generate unexpected outcomes\n\nExceptions are a mechanism by which elements of a program can inform other parts about errors that have occured\n\nExceptions combine a description of what the error that occured was, with where the error occured\nIn the example above e.g. we are told that we got a ValueError\ni.e. an invalid value was found, we are given the additional detail “invalid literal for int() with base 10: ‘three’”\nIn plain english, the program did not know how to convert ‘three’ to an integer\nWe are also told where, in this case the second line, in the function int\n\nTo recover from an exception we have to handle it, i.e. do something\n\nThe first step is to catch the exception\nWe wrap code that might throw an exception in a try... except block\n\n# Example 6.3: Catching Exceptions\n#\n# Demonstrates how to catch and handle\n# an exception\n\n  try:\n      ride_number_text = input(\"Please enter a ride number: \")\n      ride_number = int(ride_number_text) #statement that might raise exception\n      print(\"You have entered\", ride_number)\n  except ValueError: # Start of an exception handler\n      print(\"Invalid number\") # Performed if exception raised\nWe wrap the code that may throw an exception in a try\nWe then use except to define statements we want to run if an exception is thrown\n\nIf an exception is thrown, control immediately jumps to the except block\ne.g. In the above example if int throws a ValueError then the line print(\"You have entered\", ride_number) won’t run\n\nInstead print(\"Invalid number\") runs\n\n\nAs observed except is followed by the exception type we want to catch (in this case ValueError)\nThe full example is given in CatchingExceptions\n\n\n\n\n\n\nblock-beta\n    columns 4\n    space\n    title[\"Breakdown of a Try-Except Block\"]:2\n    space\n\n    block:Try:2\n    columns 1\n        try[\"try\"]\n        tryDescr[\"(start of the try construction)\"]\n    end\n\n    block:TryColon\n    columns 1\n        Trycolon[\":\"]\n        TryColonDescr[\"colon\"]\n    end\n\n    block:TrySuite\n    columns 1\n        Trysuite[\"Statements\"]\n        TrysuiteDescr[(\"statements to execute normally\")]\n    end\n\n\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass try BG\nclass tryDescr BG\nclass Trycolon BG\nclass TryColonDescr BG\nclass Trysuite BG\nclass TrysuiteDescr BG\n\n    block:ExceptOne\n    columns 1\n        exceptOne[\"except\"]\n        exceptOneDescr[\"(start of an exception construction)\"]\n    end\n\n    block:ExceptNameOne\n    columns 1\n        exceptOneName[\"Name\"]\n        exceptOneNameDescr[\"(exception name)\"]\n    end\n\n    block:ExceptOneColon\n    columns 1\n        exceptOneColon[\":\"]\n        exceptOneColonDescr[\"colon\"]\n    end\n\n    block:ExceptOneStatements\n    columns 1\n        exceptOneStatements[\"statements\"]\n        exceptOneStatementsDescr[(\"statements to execute if exception caught\")]\n    end\n\nclass exceptOne BG\nclass exceptOneDescr BG\nclass exceptOneName BG\nclass exceptOneNameDescr BG\nclass exceptOneColon BG\nclass exceptOneColonDescr BG\nclass exceptOneStatements BG\nclass exceptOneStatementsDescr BG\n\n    block:ExceptTwo\n    columns 1\n        exceptTwo[\"except\"]\n        exceptTwoDescr[\"(start of an exception construction)\"]\n    end\n\n    block:ExceptNameTwo\n    columns 1\n        exceptTwoName[\"Name\"]\n        exceptTwoNameDescr[\"(exception name)\"]\n    end\n\n    block:ExceptTwoColon\n    columns 1\n        exceptTwoColon[\":\"]\n        exceptTwoColonDescr[\"colon\"]\n    end\n\n    block:ExceptTwoStatements\n    columns 1\n        exceptTwoStatements[\"statements\"]\n        exceptTwoStatementsDescr[(\"statements to execute if exception caught\")]\n    end\n\nclass exceptTwo BG\nclass exceptTwoDescr BG\nclass exceptTwoName BG\nclass exceptTwoNameDescr BG\nclass exceptTwoColon BG\nclass exceptTwoColonDescr BG\nclass exceptTwoStatements BG\nclass exceptTwoStatementsDescr BG\n\n\n\n\n\n\n\nAs demonstrated above a try...except block may contain multiple except statements designed to handle different exception types\n\n\n\n\nWe’ve seen how to use loops to handle invalid values\nWe’ve seen how to use exceptions to handle invalid types\nNow let’s put that together to write a loop to handle exceptions\n\n\n\nWe want to make a program that will perform a while construction as long as the user keeps typing in text that cannot be converted into a number. Look at the example code below, (see HandlingInvalidText.py) and answer the questions\n# Example 6.4: Handling Invalid Text\n#\n# Combines loops and exception handling to prompt a user\n# for a valid number and repeat until a number is provided\n\nride_number_valid = False  # create and set a flag to False\nwhile not ride_number_valid:  # repeats while flag is False\n    try:\n        ride_number_text = input(\"Please enter the ride number you want: \")\n        ride_number = int(ride_number_text)  # can throw a ValueError\n        ride_number_valid = True  # successfully read a number\n    except ValueError:  # catch the ValueError\n        print(\"Invalid number. Please enter a number in digits\")\n# Once outside the loop we have a valid number\nprint(\"You have selected ride\", ride_number)\n\nWhat is the purpose of the variable, ride_number_valid?\n\nIt is a flag\nTracks the state of a program, in this case a valid number been read\nStarts False once successfully received an int flips to True\n\nHow many times would you expect the while construction to loop when the program is used?\n\nIdeally we would expect it to run once\n\ni.e. The user enters a number straight away\n\nIn the next best case we would expect it run twice\n\nThe user experiences an error, reads the message and corrects their input the next time\n\n\nWhy don’t we have to test ride_number_valid at line \\(10\\), to make sure that the ride number is valid?\n\nThe while loop stops when it’s condition is False\nThis corresponds to ride_number_valid = True\nSo we know that once we leave the loop ride_number_valid must be True\n\n\n\n\n\n\n\nSometimes there a multiple exception types we wish to handle\ne.g. a KeyboardInterrupt allows a user to issue an exception which could stop a program\n\nIf the user is interacting with somebody else’s external facing program, we might not want them to be able to do this\n\nSimultaneously we might need to ensure that the user inputs valid data like numbers\nWe can just add an additional except block\n\nWhen an exception is thrown, the appropriate handler takes control\n\nThe improved exception handling code is given in HandlingInvalidTextMultipleExceptions\n\n# Example 6.5: Improved Handling Invalid Text\n#\n# Extends Example 6.4 by preventing the user from issuing a\n# keyboard interrupt to stop the program\n\nride_number_valid = False  # create and set a flag to False\nwhile not ride_number_valid:  # repeats while flag is False\n    try:\n        ride_number_text = input(\"Please enter the ride number you want: \")\n        ride_number = int(ride_number_text)  # can throw a ValueError\n        ride_number_valid = True  # successfully read a number\n    except ValueError:  # catch the ValueError\n        print(\"Invalid number. Please enter a number in digits\")\n    except KeyboardInterrupt:  # catches the interrupt\n        print(\"You do not have permission to interupt this program\")\n# Once outside the loop we have a valid number\nprint(\"You have selected ride\", ride_number)  # type: ignore\n\n\n\n\n\n\nImportant\n\n\n\nPlan for Failure\nWhen writing a program you should always be thinking about how it could fail and the appropriate response. Any point that asks for user input is a major potential point of failure and should be handled correctly.\nYou should never catch exceptions to hide errors. You could all statements in a try...except block, but then you can’t identify any errors that occur.\n\n\n\n\n\n\n\nbreak statements allow you to exit a loop from inside\nAs soon as a break is encountered control immediately jumps to the next statement after the loop\nThe example code is given in UsingBreakToExitLoops.py\n\n# Example 6.6 Using Break to Exit Loops\n#\n# Demonstrates using a break statement to exit\n# a while loop from inside the loop\n\nwhile True:  # use break rather than a condition to exit\n    try:\n        ride_number_text = input(\"Please enter the ride number you want: \")\n        ride_number = int(ride_number_text)\n        break\n    except ValueError:\n        print(\"Invalid number text. Please enter digits\")\n    except KeyboardInterrupt:\n        print(\"You do not have permission to interupt this program\")\n# Once outside the loop we have a valid number\nprint(\"You have selected ride\", ride_number)  # type: ignore\n\nThe above follows the previous example, but uses break rather than a flag to control the loop\nbreak statements can be paired with conditionals like if, as demonstrated in EarlyExitLoop.py\n\n\n# Example 6.7 Loop with condition ending early\n#\n# Demonstrates the pairing of break and conditional\n# statements to end a program early\n\ncount = 0\nwhile count &lt; 5:\n    print(\"Inside Loop\")\n    count = count + 1\n    if count == 3:\n        break\nprint(\"Outside loop\")\n\nInside Loop\nInside Loop\nInside Loop\nOutside loop\n\n\n\n\n\n\n\n\nTip\n\n\n\nDon’t use too many break statements\nA loop can theoretically only use many break statements to control flow. However break statements make it harder to reason about the flow of a loop. Sometimes they are the cleanest way to do something, but often they just make the code less readable.\nIn general prefer to use conditions to control loops, they are easier to reason about the state at the end of the loop\n\n\n\n\n\n\ncontinue causes control to immediately jump to the start of the next loop iteration\nFor example consider the Ride Selector example. If a ride is temporarily down we might push a patch to skip any selection of the ride, e.g. IgnoreRide.py given below\n\n# Example 6.8: Ignore Ride\n#\n# Demonstrates the use of continue to move\n# to the next loop iteration, skipping remaining\n# loop logic\n\nwhile True:\n    ride_number_text = input(\"Please enter the ride number you want: \")\n    ride_number = int(ride_number_text)\n    if ride_number == 3:\n        print(\"sorry, this ride is unavailable\")\n        continue\n    print(\"you have selected ride number: \", ride_number)\n\n\n\n\n\n\nNote\n\n\n\nYou wont use continue as often as you use break\nbreak can be useful in quite a few use cases. continue tends to be much more niche and isn’t used often\n\n\n\n\n\n\nYou can use a variable to make a loop repeat a specified number of times, e.g. in the below Times Tables Program\n\n\n# Example 6.9 Times Tables Tutor\n#\n# Uses Times Tables to demonstrate use of a counter\n# variable to control a loop\n\ncount = 1\ntimes_value = 2\nwhile count &lt; 13:\n    result = count * times_value\n    print(count, \"times\", times_value, \"equals\", result)\n    count = count + 1\n\n1 times 2 equals 2\n2 times 2 equals 4\n3 times 2 equals 6\n4 times 2 equals 8\n5 times 2 equals 10\n6 times 2 equals 12\n7 times 2 equals 14\n8 times 2 equals 16\n9 times 2 equals 18\n10 times 2 equals 20\n11 times 2 equals 22\n12 times 2 equals 24\n\n\n\nThe combination of while count &lt; 13 and count = count + 1 means that after \\(12\\) loop iterations the loop condition evaluates False and the loop ends\n\n\n\n\nConsider the previous example and answer the following questions\n\n\nWhat statement would you change if you wanted to generate the times table for three instead of two?\n\nWe would change times_value\n\nWhich statement would you change if you wanted to generate up to the \\(24\\) times table?\n\nWe would change the loop condition to count &lt; 25\n\nWhat would happen to the program if we changed the line count = count + 1 to count = count - 1\n\nThe loop would produce negative times tables, and never stop since count will be decreased every iteration and thus is always less than \\(13\\)\n\n\n\n\n\nWrite a version of the previous example that asks the user for the value of the times table they want. Add validation so that the user must enter a number between \\(2\\) and \\(12\\) inclusive\nOur solution (given in UserSelectedTimesTableTutor.py) prompts the user to enter a number between \\(2\\) - \\(12\\) inclusive, and then validates that the input is in the range.\nA try, except block is used to catch any invalid input type, and the whole thing is wrapped in a while True block that only ends once a valid integer in the range \\(2\\) - \\(12\\) is received through the use of a break statement. - The actual times tables code is then identical\n# Exercise 6.5 User SelectedTimes Tables Tutor\n#\n# Version of the times table tutor that allows the user to select the\n# times table in the range 2 - 12 they are interested in\n\ncount = 1\nwhile True:\n    try:\n        times_value_text = input(\n            \"Please enter a times table between 2-12 (inclusive): \"\n        )\n        times_value = int(times_value_text)\n        if times_value &lt; 2 or times_value &gt; 12:\n            print(\"Sorry, that is not between 2-12 (inclusive)\")\n        else:\n            break\n    except ValueError:\n        print(\"Please enter an integer\")\n\nwhile count &lt; 13:\n    result = count * times_value\n    print(count, \"times\", times_value, \"equals\", result)\n    count = count + 1\n\n\n\n\n\nFor loops operate similar to while loops, but are designed for when the number of iterations are known\n\n\n\n\n\n\nblock-beta\n    columns 6\n    space\n    space\n    title[\"Breakdown of a For\"]:2\n    space\n    space\n\n    block:Input\n    columns 1\n        while[\"for\"]\n        whileDescr[\"(start of the for construction)\"]\n    end\n\n    block:MiddleOne\n    columns 1\n        condition[\"variable\"]\n        conditionName[\"function name\"]\n        conditionDescr[\"(variable controlled in the for)\"]\n    end\n\n    block:In\n    columns 1\n        in[\"in\"]\n    end\n\n    block:Items\n    columns 1\n        items[\"items\"]\n        itemsDescr[\"(items to work through)\"]\n    end\n\n    block:MiddleTwo\n    columns 1\n        colon[\":\"]\n        colonDescr[\"Colon\"]\n    end\n\n    block:Suite\n    columns 1\n        suite[\"Statement block\"]\n        suiteDescr[\"(statements)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass condition BG\nclass conditionName BG\nclass conditionDescr BG\nclass colon BG\nclass colonDescr BG\nclass while BG\nclass whileDescr BG\nclass items BG\nclass itemsDescr BG\nclass suite BG\nclass suiteDescr BG\nclass in BG\n\n\n\n\n\n\n\nfor loops over a collection of items, acting on each item in turn\nEach iteration acts on next item in the collection\nAn example of a collection is a tuple, e.g.\n\nnames = ('Rob', 'Mary', 'David', 'Jenny', 'Chris', 'Imogen')\nnames is a tuple (denoted by the () containing the above names)\nWe’ll discuss Tuples in more detail in Chapter 8\n\nWe can pair the above tuple with a for loop e.g.\n\n\n# Example 6.10 Name Printer\n#\n# Prints a collection of names\n\nnames = (\"Rob\", \"Mary\", \"David\", \"Jenny\", \"Chris\", \"Imogen\")\nfor name in names:\n    print(name)\n\nRob\nMary\nDavid\nJenny\nChris\nImogen\n\n\n\nrange is a python function for generating a collection of numbers\n\nsyntax is range(start, stop) where start is included, but stop is excluded\ne.g. We could rewrite ours times table program as using range (see [RangeBasedTimeTables.py])\n\n\n\n# Example 6.11 Range Based Times Tables\n#\n# Demonstrates Python's range function using a for\n# loop to generate a times table\n\ntimes_value = 2\nfor count in range(1, 13):\n    result = count * times_value\n    print(count, \"times\", times_value, \"equals\", result)\n\n1 times 2 equals 2\n2 times 2 equals 4\n3 times 2 equals 6\n4 times 2 equals 8\n5 times 2 equals 10\n6 times 2 equals 12\n7 times 2 equals 14\n8 times 2 equals 16\n9 times 2 equals 18\n10 times 2 equals 20\n11 times 2 equals 22\n12 times 2 equals 24\n\n\n\nbreak and continue also work with for loops\n\ncontinue causes the loop to proceed to the next item in the collection\n\n\n\n\nLook at the following simple programs, and answer the corresponding questions about break and continue\n\nWhat would the following code print?\n\n for count in range(1, 13):\n     if count == 5:\n         break\n     print(count)\n print('Finished')\n\n1\n2\n3\n4\nFinished\n\n\n\nIt would print 1, 2, 3, 4 then \"finished\"\nSince when count is \\(5\\) the loop breaks before the print statement and then the print outside the loop is called\n\nWhat would the following code print?\n\n for count in range(1, 13):\n     if count == 5:\n         continue\n     print(count)\n print('Finished')\n\n1\n2\n3\n4\n6\n7\n8\n9\n10\n11\n12\nFinished\n\n\n\nThis program is similar to the above, except it would print 1 through to 12 but skip 5, before printing \"Finished\".\nThis is because the continue causes the loop iteration for count = 5 to skip the print statement in the loop and go to the next loop iteration\n\nWhat would the following code print?\n\n for count in range(1, 13):\n     count = 13\n     print(count)\n print('Finished')\n\n13\n13\n13\n13\n13\n13\n13\n13\n13\n13\n13\n13\nFinished\n\n\n\nThis will print \\(13\\) twelve times, because each time count starts a loop iteration it is set to the next value in the range(1, 13)\n\nThen inside the loop count is set to 13 and that value is printed\n\nOf course \"Finished\" is printed after the loop is down\n\nWould the following program run forever?\n\n while True:\n     break\n print('Finished')\n\nFinished\n\n\n\nNo, it will immediately end because break exits the loop\n\nWould the following program print the message “Looping”?\n while True:\n     continue\n     print('Looping')\n\nNo, the loop will hit the continue keyword and the go back to the start\nThis happens forever\n\nWhat would the following program do? Is it legal?\n\n for letter in 'hello world':\n     print(letter)\n\nh\ne\nl\nl\no\n\nw\no\nr\nl\nd\n\n\n\nStrings are collections of letters\nThe above program works, it loops over and prints each letter in the string\n\n\n\n\n\nReverse the behaviour of the times-table program so that rather than printing out the times-table your program insteads asks questions like, “What is \\(6\\) times \\(4\\)?” The user could enter their answer, and the program could compare it with the correct answer and keep score of how many correct answers are given. You could use a loop to make the program produce \\(12\\) “times-table” questions, and you could use random numbers so that the quiz is different every time\nOur solution given in TimesTableQuiz.py is relatively complete. We use first print a header message, then we set up a variable to track the number of correct answers total and a second variable to track the number of questions to ask. We then go into our for loop, looping over range(0, NumberOfQuestions), this makes the loop run NumberOfQuestions times.\nThe actual quiz then proceeds, we randomly generate the two numbers, the times_value from the range [2, 12] and the count from the range [1, 12]. We then calculate the correct answer, and prompt the user for an answer, using the standard ValueError exception handling. If the user’s answer is correct we congratulate them and increment the score, else we tell them what the correct answer is. After they’ve answered all the questions we give them the final score\n# Exercise 6.6: Times Table Quiz\n#\n# Generates a times table quiz\n\nimport random\n\nprint(\"===Times table Quiz===\")\nscore = 0\nNumberOfQuestions = 12\n\nfor question in range(0, NumberOfQuestions):\n    times_value = random.randint(2, 12)\n    count = random.randint(1, 12)\n    correct_answer = times_value * count\n    while True:\n        try:\n            answer_text = input(\n                \"What is \" + str(count) + \" x \" + str(times_value) + \": \"\n            )\n            answer = int(answer_text)\n            break\n        except ValueError:\n            print(\"Please enter an integer\")\n    if answer == correct_answer:\n        score = score + 1\n        print(\"Correct!\")\n    else:\n        print(\"Sorry that's wrong!\")\n        print(\"The correct answer is\", correct_answer, \"you gave\", answer)\n\nprint(\"You got\", score, \"/\", NumberOfQuestions, \"correct\")\n\n\n\n\n\nPutting together what we’ve covered, we can make a digital clock using snaps (see DigitalClock.py)\n\n# Example 6.12: Digital Clock\n#\n# Uses a combination of loops and snaps to create a digital clock\n\nimport time\nimport snaps\n\nwhile True:\n    current_time = time.localtime()\n    hour_string = str(current_time.tm_hour)\n    minute_string = str(current_time.tm_min)\n    second_string = str(current_time.tm_sec)\n\n    time_string = hour_string + \":\" + minute_string + \":\" + second_string\n    snaps.display_message(time_string)\n    time.sleep(1)\n\n\nCombine the digital clock display from the previous example with the alarm clock from Chapter 5. Make the background image depend on the time of day\nOur final program is a bit complicated so we’ll analyse it in parts. The full file can be read in DigitalAlarmClock.py\nWe start by extracting the relevant date and time information from the current time, and perform a boolean check if it’s a weekend.\nWe first then check if the time is night (defined heuristically as from \\(7\\) pm through to \\(6\\) am) or day (\\(6\\) am to \\(7\\) pm). We then display a moon as the background in the former case, or a sun in the later.\nRemember we have to display the image first so that we can overlay the text on top.\n# Exercise 6.7: Digital Alarm Clock\n#\n# Integrates the Alarm Clock Functionality of\n# Chapter 5, with the Digital Clock Display of Chapter 6\n\nimport time\n\nimport snaps\n\nwhile True:\n    current_time = time.localtime()\n\n    hour = current_time.tm_hour\n    minute = current_time.tm_min\n    second = current_time.tm_sec\n    day = current_time.tm_mday\n    month = current_time.tm_mon\n    year = current_time.tm_year\n    is_weekend = current_time.tm_wday &gt;= 5\n\n    # draw the background\n    # define day as 6am - 7pm\n    if hour &gt;= 6 and hour &lt;= 19:\n        snaps.display_image(\"sun.png\")\n    else:\n        snaps.display_image(\"moon.png\")\nNow we prepare our datetime strings\n    # set up normal time and day clock behaviour\n    date_message = \"The date is \" + str(day) + \"/\" + str(month) + \"/\" + str(year)\n    time_message = \"The time is \" + str(hour) + \":\" + str(minute) + \":\" + str(second)\n    message = date_message + \"\\n\" + time_message\nNext we want to play a wake alarm at \\(7:30\\) giving as extra hour to sleep in on weekends. We also want to define a bed time. When the time hits \\(7:30\\) we want to play the alarm, then before bed time (\\(22:00\\))the clock should display a message telling us to get up, while after bed time it should tell us to go to sleep.\nThe if...else construct here is a bit more complicated. We only want to play the alarm sound at \\(7:30:00\\) rather than just if the user runs the clock after the wakeup time. This is because the clock will then continuously play the sound every second it updates!\nOur first if statement thus checks if we are exactly on the alarm time, and if we are plays the alarm sound and updates the message\nWe then have to consider now when we check if the time is after the alarm has gone off that it is also not before it is time to go back to bed. It’s cleaner to split this into two cases (our elif statements)\nIn the first case if the hour is equal to the hour to get up and greater than the minute to get up then it must be time to get up and we don’t need to play the alarm (since the first if statement catches this case). Note this makes the assumption that we don’t wake up at a time like \\(8:30\\) and then go to bed at \\(8:59\\) which is reasonable.\nThe second case is when the hour is greater than the hour to get up. Here we have to check that either the hour is less than the hour we go to bed at or if it is the same, that the minutes are less than the minutes we go to bed at. (Effectively the reverse of our old alarm condition.) In either of the previous cases we only then need to update the final printed message with the statement that we should be up\nThe last case (the else) is our default case for when none of the previous cases are matched. By exhaustion of cases this has to be when it is time for us to be in bed by default. So we don’t need to do extra checks and can just update the message to tell us to go to sleep\n    # Play alarm and optionally append a wakeup message\n    hour_to_get_up = 7 + is_weekend\n    hour_to_sleep = 22\n    minute_to_get_up = 30\n    minute_to_sleep = 0\n\n    wake_up_message = \"TIME TO GET UP!\"\n    sleep_message = \"TIME FOR BED!\"\n\n    # case 1: On the alarm\n    if hour == hour_to_get_up and minute == minute_to_get_up and second == 0:\n        snaps.play_sound(\"siren.wav\")\n        message = message + \"\\n\" + wake_up_message\n    # Past the alarm\n    elif hour == hour_to_get_up and minute &gt;= minute_to_get_up:\n        message = message + \"\\n\" + wake_up_message\n    # past the alarm but before bed\n    elif hour &gt; hour_to_get_up and (\n        hour &lt; hour_to_sleep or (hour == hour_to_sleep and minute &lt; minute_to_sleep)\n    ):\n        message = message + \"\\n\" + wake_up_message\n    # time for bed\n    else:\n        message = message + \"\\n\" + sleep_message\nFinally we display the message and then sleep for a second before updating the clock again\n    # display the message and then sleep\n    snaps.display_message(message, size=100)\n    time.sleep(1)",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 6: Repeating Actions with Loops"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/06_RepeatingActionsWithLoops/Chapter_06.html#notes",
    "href": "01_ProgrammingFundamentals/06_RepeatingActionsWithLoops/Chapter_06.html#notes",
    "title": "Chapter 6: Repeating Actions with Loops",
    "section": "",
    "text": "while allows a program to repeat blocks of statements\nstructure is similar to an if\n\n\n\n\n\n\nblock-beta\n    columns 4\n    space\n    title[\"Breakdown of a While\"]:2\n    space\n\n    block:Input\n    columns 1\n        while[\"while\"]\n        whileDescr[\"(start of the while construction)\"]\n    end\n\n    block:MiddleOne\n    columns 1\n        condition[\"condition\"]\n        conditionDescr[\"(value that is True or False)\"]\n    end\n\n    block:MiddleTwo\n    columns 1\n        colon[\":\"]\n        colonDescr[\"Colon\"]\n    end\n\n    block:Suite\n    columns 1\n        suite[\"Statement block\"]\n        suiteDescr[\"(statements)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass condition BG\nclass conditionDescr BG\nclass colon BG\nclass colonDescr BG\nclass while BG\nclass whileDescr BG\nclass suite BG\nclass suiteDescr BG\n\n\n\n\n\n\n\nif the condition evaluates True then the block of statements is run\n\nAfter the statements are run, control returns to the start of the while loop\nIf the condition is still True then the loop runs again\n\n\n\n\nUse the python interpreter to run the following to understand the while loop\n\nCan we use a boolean value to control a while construction?\n\nYes, for example the block of statements in the while here shouldn’t run\n\n\n while False:\n     print(\"Loop\")\n print(\"Outside the Loop\")\n\nOutside the Loop\n\n\nCan a loop go on forever?\n\nYes, an control expression for a while that always evaluates True will cause the loop to run infinitely\n\n while True:\n     print(\"Loop\")\n print(\"Outside the Loop\")\n\nThe above should only print \"Loop\" when executed\nIf you accidently do this you may need to use CTRL+C, CRTL+Z or an interrupt execution feature of your live environment to stop the execution\n\nWill the following program ever print out the message, \"Outside loop\"?\n while True:\n     print(\"Inside Loop\")\n print(\"Outside Loop\")\n\nNo, the above is a quintessential infinite loop\n\nWill the following program ever print out the message, \"Inside Loop\"? How about \"Outside loop\"?\n\n while False:\n     print(\"Inside Loop\")\n print(\"Outside Loop\")\n\nOutside Loop\n\n\n\nThe while never executes the statements inside so \"Inside Loop\" is never printed, but \"Outside Loop\" is.\n\nWhat will the following program print?\n\n # Example 6.1 Loop with Flag\n #\n # Demonstrates control of a loop with a boolean flag\n\n flag = True\n while flag:\n     print(\"Inside Loop\")\n     flag = False\n print(\"Outside Loop\")\n\nInside Loop\nOutside Loop\n\n\n\nWhen we first enter the loop flag is True so the loop executes and*\"Inside Loop\" is printed\nflag is then set False so on the next iteration of the loop, the loop doesn’t execute.\nWe move to the next statement outside of the loop and print out \"Outside Loop\"\nThe pattern of using a control variable that is updated in the loop body in a while loop is very common\n\nWhat will the following program print?\n flag = True\n while flag:\n     print(\"Inside Loop\")\n     Flag = False\n print(\"Outside Loop\")\n\nThis looks similar to the previous, but note the typo, we refer to Flag not flag inside the loop\nThis which defines a new variable, instead of modifying the loop control.\nWe thus get an infinite series of \"Inside Loop\" being printed.\n\nWhat will the following program print?\n\n # Example 6.2 Loop with Counter\n #\n # Demonstrates use control of a while loop\n # using a conditional expression\n\n count = 0\n while count &lt; 5:\n     print(\"Inside Loop\")\n     count = count + 1\n print(\"Outside Loop\")\n\nInside Loop\nInside Loop\nInside Loop\nInside Loop\nInside Loop\nOutside Loop\n\n\n\ncount is initially set to \\(0\\)\nAt each iteration we print \"Inside Loop\" * and increase the value of count by \\(1\\)\nThe loop stops once count reaches \\(5\\)\nThis means that \"Inside Loop\" should be printed \\(5\\) times, followed by \"Outside Loop\"\n\n\n\n\n\nUse a while loop, to make a theme park selector that runs continously. All you need to do is put all of the statements that implement the theme park behaviour into a while True construction\nFor usability our program won’t loop endlessly. We’ll say that any number that it is not a valid ride number is code for quitting the program. The relevant changes to the Ride Selector are then,\n# Exercise 6.1 Looping Ride Selector\n#\n# Wraps the Ride Selector Program in a while\n# loop to allow the user to look at multiple rides\n\nrun_program = True\n\nwhile run_program:\n    print(\"\"\"Welcome to our Theme Park\n        These are the available ride:\n\n        1. Scenic River Cruise\n        2. Carnival Carousel\n        3. Jungle Adventure Water Splash\n        4. Downhill Mountain Run\n        5. The Regurgitator\n        Any other number to quit...\n        \"\"\")\n\n    ride_number_text = input(\"Please enter the ride number you want: \")\n    ride_number = int(ride_number_text)\n\n    if ride_number &lt; 1 or ride_number &gt; 5:\n        run_program = False\n    elif ride_number == 1:\nObserve that first we wrap all of the code in a while loop, and introduce a boolean flag run_program initially set to True to flag if the program continues to run at each loop iteration. When a user enters a number we first check if it corresponds to a ride number and if not, we set the program to quit on the next loop iteration by setting run_program to False. We now change the original if ride_number == 1 to and elif so it is only checked if we know the ride_number is valid. (The full code is in LoopingRideSelector.py)\n\n\n\nOne of the examples in the above question set involved a countup to \\(5\\). Implement a program that counts down from \\(10\\) to \\(0\\) over \\(10\\) seconds\n# Exercise 6.2: Countdown\n#\n# Performs a 10-second countdown\n\nimport time\n\ntime_left = 10\n\nwhile time_left &gt;= 0:\n    print(time_left)\n    time_left = time_left - 1\n    time.sleep(1)\n\n\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\n\n\nThis is a straightforward exercise (see Countdown.py), we set up our counter value to \\(10\\) and use the appropriate loop expression (here time_left &gt;= 0) to ensure that \\(0\\) is included in the countdown.\nIn the loop we print the current value of time_left, then decrement time_left by \\(1\\), and sleep for the required time. Observe that after the program prints \\(0\\), time_left becomes \\(-1\\) and the next iteration of the loop won’t run.\n\n\n\n\nRide Selector doesn’t account for invalid user entry\n\nBlindly assumes a number outside the range \\(1\\) to \\(5\\) represents quitting the program\n\nIdeally we would like to have a distinct number that represents quitting and a way to capture and handle any invalid inputs\n\n\n\n\n\n\n\nTip\n\n\n\nGreat Programmers Think Defensively\nDefensive programming is a programming technique in which a programmer attempts to defend their code against possible errors that might occur in a code e.g. receiving a word when expecting a number\nIt is good practice to think about, typically a user expects a computer to do something reasonable even when provided unreasonable input.\nData validation does have the downside in that it can make programs significantly bigger, and in compiled languages knowing that data is valid can make them much faster. A good skill is learning the correct layers or boundaries of a program to perform the defensive data validation so the core can run without concern\n\n\n\nIgnoring the question of quitting for now, data validation for the ride selector might look like,\n  if ride_number &lt; 1 or ride_number &gt; 5:\n      print('Invalid ride number')\n\n\n\n\nAbove acknowledges the error, but if we want to use this in our loop control we will need to use while\n  ride_number_text = input(\"Please enter the ride number you want: \")\n  ride_number = int(ride_number_text)\n\n  while ride_number &lt; 1 or ride_number &gt; 5:\n      print(\"There is no ride with that number\")\n      ride_number_text = input(\"Please enter the ride number you want: \")\n      ride_number = int(ride_number_text)\n  print(\"You have selected ride number: \", ride_number)\n\nwhile means program repeats until it receives valid input\nObserve the downside\n\nWe have to repeat the code asking for the ride number and converting to an integer\nSome languages have a do ... while statement which performs its test after executing the loop body for the first time\n\nWould allow us to write the above as one construct\n\n\n\n\n\n\nAdd ride number validation to the Looping Ride Selector implementation. Remember that the while construction must be added after the ride_number value has been read by the program\nWe can basically add the validation in immediately after the first attempt to read the ride number from the user. We also have to adjust the code to now use \\(0\\) as the explicit value for quitting rather than inferring any non-ride-number as a quit value. The main changes are,\n# Exercise 6.3 Ride Selector with Ride Number Validation\n#\n# Adds Ride Number validation to the Ride Selector\n# The program will query the user until a valid ride number or\n# the quit number is given\n\nwhile run_program:\n    print(\"\"\"Welcome to our Theme Park\n        These are the available ride:\n\n        1. Scenic River Cruise\n        2. Carnival Carousel\n        3. Jungle Adventure Water Splash\n        4. Downhill Mountain Run\n        5. The Regurgitator\n        Press 0 to quit the program\n        \"\"\")\n\n    ride_number_text = input(\"Please enter the ride number you want: \")\n    ride_number = int(ride_number_text)\n\n    while ride_number &lt; 0 or ride_number &gt; 5:\n        print(\"There is no ride with that number\")\n        ride_number_text = input(\"Please enter the ride number you want: \")\n        ride_number = int(ride_number_text)\n\n    if ride_number == 0:\n        run_program = False\nThe complete code is given in RideNumberValidation.py\n\n\n\nWhen creating composite conditions for loops, making sure the logic is correct is incredibly important. Examine the following program to understand more complicated loop control\nage_text = input(\"Please enter your age: \")\nage = int(age_text)\nwhile age &lt; 1 and age &gt; 95:\n    #repeat this code while the age is invalid\n    print(\"This age is not valid\")\n    age_text = input(\"Please enter your age: \")\n    age = int(age_text)\n#when we are here, we have a valid age value\nprint(\"Thank you for entering your age\")\n\nWhat is the fault in this program?\n\nThe condition age &lt; 1 and age &gt; 95 requires age to be both less than \\(1\\) and greater than \\(95\\), this is impossible, so the loop never runs\n\nWhat will the fault cause the program to do?\n\nSince the loop body can never run, every entered age will be considered valid\n\nHow do you fix this?\n\nThe desired logic is that age should be between \\(1\\) and \\(95\\) inclusive. This logic is captured by the or operator.\nThe corrected expression is*\n  while age &lt; 1 or age &gt; 95\n\n\n\n\n\n\n\n\nImportant\n\n\n\nAlways test failure behaviours along with successful ones\nIt’s very important when testing software to test both the successful path (the so-called “happy path”) and any possible error states.\nA good programmer proactively looks for potential points of failure, writes code to handle the errors and importantly checks that the code to handle the errors does what it’s supposed to do\nA good heuristic for starting to do this with simple programs is called boundary-value testing. Boundaries are the points between different expected behaviours. For example with the ride selector, we expect different behaviour for numbers \\(&lt; 1\\) or \\(&gt; 5\\) to those in the range \\(1\\) to \\(5\\). So a good set of tests might be \\(0\\), \\(1\\), \\(2\\), \\(4\\), \\(5\\), \\(6\\). i.e. we test either side of the boundary, and on the boundary\n\n\n\n\n\nAdd age validation to the Ride Selection Program. The theme park owner has told you that the minimum age for anyone going on a ride at the theme park is \\(1\\) year, and the maximum age is \\(95\\). Use these values in your program\nObserve that in this case if the user provides an age outside the accepted range, we don’t want to prompt them to put in a new age, since this could legitimately be their age. Instead we want to tell them regardless of the ride they chose they can’t ride. In this case we should use an if style validation technique\nThe change is applied at our age reading section of the program, we use an if...elif...else construct to tell the user they are either too young, too old, or to continue on to the standard ride selection code\nage_text = input(\"Please enter your age: \")\nage = int(age_text)\nif age &lt; 1:\n    print(\"You are too young to go on any rides\")\nelif age &gt; 95:\n    print(\"You are too old to go on any rides\")\nelse:\n    #continue on to normal ride selection code...\nThe full code is given in AgeValidation.py\n\n\n\n\n\n\n\nProblem: We can easily write a loop that checks if a value is invalid but how do we deal with the type being invalid?\n\ne.g. in the ride selector how do we deal with the user typing in a word rather than a number?\nConsider the snippet below, emulating the ride selector given a string input, we get an error, before we even get a chance to validate the value\n\n\n  ride_number_text = \"three\"\n  ride_number = int(ride_number_text)\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[6], line 2\n      1 ride_number_text = \"three\"\n----&gt; 2 ride_number = int(ride_number_text)\n\nValueError: invalid literal for int() with base 10: 'three'\n\n\n\n\nThis occurs because int requires it’s input to be convertable to a number\n\nUnfortunately this does not extend to human-language written versions of a number\nIn this case int throws an error, it is better to end the program than continue in an erroneous state\n\nIn general, when a program encounters an error state, it should aim to fail fast, rather than continue and generate unexpected outcomes\n\nExceptions are a mechanism by which elements of a program can inform other parts about errors that have occured\n\nExceptions combine a description of what the error that occured was, with where the error occured\nIn the example above e.g. we are told that we got a ValueError\ni.e. an invalid value was found, we are given the additional detail “invalid literal for int() with base 10: ‘three’”\nIn plain english, the program did not know how to convert ‘three’ to an integer\nWe are also told where, in this case the second line, in the function int\n\nTo recover from an exception we have to handle it, i.e. do something\n\nThe first step is to catch the exception\nWe wrap code that might throw an exception in a try... except block\n\n# Example 6.3: Catching Exceptions\n#\n# Demonstrates how to catch and handle\n# an exception\n\n  try:\n      ride_number_text = input(\"Please enter a ride number: \")\n      ride_number = int(ride_number_text) #statement that might raise exception\n      print(\"You have entered\", ride_number)\n  except ValueError: # Start of an exception handler\n      print(\"Invalid number\") # Performed if exception raised\nWe wrap the code that may throw an exception in a try\nWe then use except to define statements we want to run if an exception is thrown\n\nIf an exception is thrown, control immediately jumps to the except block\ne.g. In the above example if int throws a ValueError then the line print(\"You have entered\", ride_number) won’t run\n\nInstead print(\"Invalid number\") runs\n\n\nAs observed except is followed by the exception type we want to catch (in this case ValueError)\nThe full example is given in CatchingExceptions\n\n\n\n\n\n\nblock-beta\n    columns 4\n    space\n    title[\"Breakdown of a Try-Except Block\"]:2\n    space\n\n    block:Try:2\n    columns 1\n        try[\"try\"]\n        tryDescr[\"(start of the try construction)\"]\n    end\n\n    block:TryColon\n    columns 1\n        Trycolon[\":\"]\n        TryColonDescr[\"colon\"]\n    end\n\n    block:TrySuite\n    columns 1\n        Trysuite[\"Statements\"]\n        TrysuiteDescr[(\"statements to execute normally\")]\n    end\n\n\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass try BG\nclass tryDescr BG\nclass Trycolon BG\nclass TryColonDescr BG\nclass Trysuite BG\nclass TrysuiteDescr BG\n\n    block:ExceptOne\n    columns 1\n        exceptOne[\"except\"]\n        exceptOneDescr[\"(start of an exception construction)\"]\n    end\n\n    block:ExceptNameOne\n    columns 1\n        exceptOneName[\"Name\"]\n        exceptOneNameDescr[\"(exception name)\"]\n    end\n\n    block:ExceptOneColon\n    columns 1\n        exceptOneColon[\":\"]\n        exceptOneColonDescr[\"colon\"]\n    end\n\n    block:ExceptOneStatements\n    columns 1\n        exceptOneStatements[\"statements\"]\n        exceptOneStatementsDescr[(\"statements to execute if exception caught\")]\n    end\n\nclass exceptOne BG\nclass exceptOneDescr BG\nclass exceptOneName BG\nclass exceptOneNameDescr BG\nclass exceptOneColon BG\nclass exceptOneColonDescr BG\nclass exceptOneStatements BG\nclass exceptOneStatementsDescr BG\n\n    block:ExceptTwo\n    columns 1\n        exceptTwo[\"except\"]\n        exceptTwoDescr[\"(start of an exception construction)\"]\n    end\n\n    block:ExceptNameTwo\n    columns 1\n        exceptTwoName[\"Name\"]\n        exceptTwoNameDescr[\"(exception name)\"]\n    end\n\n    block:ExceptTwoColon\n    columns 1\n        exceptTwoColon[\":\"]\n        exceptTwoColonDescr[\"colon\"]\n    end\n\n    block:ExceptTwoStatements\n    columns 1\n        exceptTwoStatements[\"statements\"]\n        exceptTwoStatementsDescr[(\"statements to execute if exception caught\")]\n    end\n\nclass exceptTwo BG\nclass exceptTwoDescr BG\nclass exceptTwoName BG\nclass exceptTwoNameDescr BG\nclass exceptTwoColon BG\nclass exceptTwoColonDescr BG\nclass exceptTwoStatements BG\nclass exceptTwoStatementsDescr BG\n\n\n\n\n\n\n\nAs demonstrated above a try...except block may contain multiple except statements designed to handle different exception types\n\n\n\n\nWe’ve seen how to use loops to handle invalid values\nWe’ve seen how to use exceptions to handle invalid types\nNow let’s put that together to write a loop to handle exceptions\n\n\n\nWe want to make a program that will perform a while construction as long as the user keeps typing in text that cannot be converted into a number. Look at the example code below, (see HandlingInvalidText.py) and answer the questions\n# Example 6.4: Handling Invalid Text\n#\n# Combines loops and exception handling to prompt a user\n# for a valid number and repeat until a number is provided\n\nride_number_valid = False  # create and set a flag to False\nwhile not ride_number_valid:  # repeats while flag is False\n    try:\n        ride_number_text = input(\"Please enter the ride number you want: \")\n        ride_number = int(ride_number_text)  # can throw a ValueError\n        ride_number_valid = True  # successfully read a number\n    except ValueError:  # catch the ValueError\n        print(\"Invalid number. Please enter a number in digits\")\n# Once outside the loop we have a valid number\nprint(\"You have selected ride\", ride_number)\n\nWhat is the purpose of the variable, ride_number_valid?\n\nIt is a flag\nTracks the state of a program, in this case a valid number been read\nStarts False once successfully received an int flips to True\n\nHow many times would you expect the while construction to loop when the program is used?\n\nIdeally we would expect it to run once\n\ni.e. The user enters a number straight away\n\nIn the next best case we would expect it run twice\n\nThe user experiences an error, reads the message and corrects their input the next time\n\n\nWhy don’t we have to test ride_number_valid at line \\(10\\), to make sure that the ride number is valid?\n\nThe while loop stops when it’s condition is False\nThis corresponds to ride_number_valid = True\nSo we know that once we leave the loop ride_number_valid must be True\n\n\n\n\n\n\n\nSometimes there a multiple exception types we wish to handle\ne.g. a KeyboardInterrupt allows a user to issue an exception which could stop a program\n\nIf the user is interacting with somebody else’s external facing program, we might not want them to be able to do this\n\nSimultaneously we might need to ensure that the user inputs valid data like numbers\nWe can just add an additional except block\n\nWhen an exception is thrown, the appropriate handler takes control\n\nThe improved exception handling code is given in HandlingInvalidTextMultipleExceptions\n\n# Example 6.5: Improved Handling Invalid Text\n#\n# Extends Example 6.4 by preventing the user from issuing a\n# keyboard interrupt to stop the program\n\nride_number_valid = False  # create and set a flag to False\nwhile not ride_number_valid:  # repeats while flag is False\n    try:\n        ride_number_text = input(\"Please enter the ride number you want: \")\n        ride_number = int(ride_number_text)  # can throw a ValueError\n        ride_number_valid = True  # successfully read a number\n    except ValueError:  # catch the ValueError\n        print(\"Invalid number. Please enter a number in digits\")\n    except KeyboardInterrupt:  # catches the interrupt\n        print(\"You do not have permission to interupt this program\")\n# Once outside the loop we have a valid number\nprint(\"You have selected ride\", ride_number)  # type: ignore\n\n\n\n\n\n\nImportant\n\n\n\nPlan for Failure\nWhen writing a program you should always be thinking about how it could fail and the appropriate response. Any point that asks for user input is a major potential point of failure and should be handled correctly.\nYou should never catch exceptions to hide errors. You could all statements in a try...except block, but then you can’t identify any errors that occur.\n\n\n\n\n\n\n\nbreak statements allow you to exit a loop from inside\nAs soon as a break is encountered control immediately jumps to the next statement after the loop\nThe example code is given in UsingBreakToExitLoops.py\n\n# Example 6.6 Using Break to Exit Loops\n#\n# Demonstrates using a break statement to exit\n# a while loop from inside the loop\n\nwhile True:  # use break rather than a condition to exit\n    try:\n        ride_number_text = input(\"Please enter the ride number you want: \")\n        ride_number = int(ride_number_text)\n        break\n    except ValueError:\n        print(\"Invalid number text. Please enter digits\")\n    except KeyboardInterrupt:\n        print(\"You do not have permission to interupt this program\")\n# Once outside the loop we have a valid number\nprint(\"You have selected ride\", ride_number)  # type: ignore\n\nThe above follows the previous example, but uses break rather than a flag to control the loop\nbreak statements can be paired with conditionals like if, as demonstrated in EarlyExitLoop.py\n\n\n# Example 6.7 Loop with condition ending early\n#\n# Demonstrates the pairing of break and conditional\n# statements to end a program early\n\ncount = 0\nwhile count &lt; 5:\n    print(\"Inside Loop\")\n    count = count + 1\n    if count == 3:\n        break\nprint(\"Outside loop\")\n\nInside Loop\nInside Loop\nInside Loop\nOutside loop\n\n\n\n\n\n\n\n\nTip\n\n\n\nDon’t use too many break statements\nA loop can theoretically only use many break statements to control flow. However break statements make it harder to reason about the flow of a loop. Sometimes they are the cleanest way to do something, but often they just make the code less readable.\nIn general prefer to use conditions to control loops, they are easier to reason about the state at the end of the loop\n\n\n\n\n\n\ncontinue causes control to immediately jump to the start of the next loop iteration\nFor example consider the Ride Selector example. If a ride is temporarily down we might push a patch to skip any selection of the ride, e.g. IgnoreRide.py given below\n\n# Example 6.8: Ignore Ride\n#\n# Demonstrates the use of continue to move\n# to the next loop iteration, skipping remaining\n# loop logic\n\nwhile True:\n    ride_number_text = input(\"Please enter the ride number you want: \")\n    ride_number = int(ride_number_text)\n    if ride_number == 3:\n        print(\"sorry, this ride is unavailable\")\n        continue\n    print(\"you have selected ride number: \", ride_number)\n\n\n\n\n\n\nNote\n\n\n\nYou wont use continue as often as you use break\nbreak can be useful in quite a few use cases. continue tends to be much more niche and isn’t used often\n\n\n\n\n\n\nYou can use a variable to make a loop repeat a specified number of times, e.g. in the below Times Tables Program\n\n\n# Example 6.9 Times Tables Tutor\n#\n# Uses Times Tables to demonstrate use of a counter\n# variable to control a loop\n\ncount = 1\ntimes_value = 2\nwhile count &lt; 13:\n    result = count * times_value\n    print(count, \"times\", times_value, \"equals\", result)\n    count = count + 1\n\n1 times 2 equals 2\n2 times 2 equals 4\n3 times 2 equals 6\n4 times 2 equals 8\n5 times 2 equals 10\n6 times 2 equals 12\n7 times 2 equals 14\n8 times 2 equals 16\n9 times 2 equals 18\n10 times 2 equals 20\n11 times 2 equals 22\n12 times 2 equals 24\n\n\n\nThe combination of while count &lt; 13 and count = count + 1 means that after \\(12\\) loop iterations the loop condition evaluates False and the loop ends\n\n\n\n\nConsider the previous example and answer the following questions\n\n\nWhat statement would you change if you wanted to generate the times table for three instead of two?\n\nWe would change times_value\n\nWhich statement would you change if you wanted to generate up to the \\(24\\) times table?\n\nWe would change the loop condition to count &lt; 25\n\nWhat would happen to the program if we changed the line count = count + 1 to count = count - 1\n\nThe loop would produce negative times tables, and never stop since count will be decreased every iteration and thus is always less than \\(13\\)\n\n\n\n\n\nWrite a version of the previous example that asks the user for the value of the times table they want. Add validation so that the user must enter a number between \\(2\\) and \\(12\\) inclusive\nOur solution (given in UserSelectedTimesTableTutor.py) prompts the user to enter a number between \\(2\\) - \\(12\\) inclusive, and then validates that the input is in the range.\nA try, except block is used to catch any invalid input type, and the whole thing is wrapped in a while True block that only ends once a valid integer in the range \\(2\\) - \\(12\\) is received through the use of a break statement. - The actual times tables code is then identical\n# Exercise 6.5 User SelectedTimes Tables Tutor\n#\n# Version of the times table tutor that allows the user to select the\n# times table in the range 2 - 12 they are interested in\n\ncount = 1\nwhile True:\n    try:\n        times_value_text = input(\n            \"Please enter a times table between 2-12 (inclusive): \"\n        )\n        times_value = int(times_value_text)\n        if times_value &lt; 2 or times_value &gt; 12:\n            print(\"Sorry, that is not between 2-12 (inclusive)\")\n        else:\n            break\n    except ValueError:\n        print(\"Please enter an integer\")\n\nwhile count &lt; 13:\n    result = count * times_value\n    print(count, \"times\", times_value, \"equals\", result)\n    count = count + 1\n\n\n\n\n\nFor loops operate similar to while loops, but are designed for when the number of iterations are known\n\n\n\n\n\n\nblock-beta\n    columns 6\n    space\n    space\n    title[\"Breakdown of a For\"]:2\n    space\n    space\n\n    block:Input\n    columns 1\n        while[\"for\"]\n        whileDescr[\"(start of the for construction)\"]\n    end\n\n    block:MiddleOne\n    columns 1\n        condition[\"variable\"]\n        conditionName[\"function name\"]\n        conditionDescr[\"(variable controlled in the for)\"]\n    end\n\n    block:In\n    columns 1\n        in[\"in\"]\n    end\n\n    block:Items\n    columns 1\n        items[\"items\"]\n        itemsDescr[\"(items to work through)\"]\n    end\n\n    block:MiddleTwo\n    columns 1\n        colon[\":\"]\n        colonDescr[\"Colon\"]\n    end\n\n    block:Suite\n    columns 1\n        suite[\"Statement block\"]\n        suiteDescr[\"(statements)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass condition BG\nclass conditionName BG\nclass conditionDescr BG\nclass colon BG\nclass colonDescr BG\nclass while BG\nclass whileDescr BG\nclass items BG\nclass itemsDescr BG\nclass suite BG\nclass suiteDescr BG\nclass in BG\n\n\n\n\n\n\n\nfor loops over a collection of items, acting on each item in turn\nEach iteration acts on next item in the collection\nAn example of a collection is a tuple, e.g.\n\nnames = ('Rob', 'Mary', 'David', 'Jenny', 'Chris', 'Imogen')\nnames is a tuple (denoted by the () containing the above names)\nWe’ll discuss Tuples in more detail in Chapter 8\n\nWe can pair the above tuple with a for loop e.g.\n\n\n# Example 6.10 Name Printer\n#\n# Prints a collection of names\n\nnames = (\"Rob\", \"Mary\", \"David\", \"Jenny\", \"Chris\", \"Imogen\")\nfor name in names:\n    print(name)\n\nRob\nMary\nDavid\nJenny\nChris\nImogen\n\n\n\nrange is a python function for generating a collection of numbers\n\nsyntax is range(start, stop) where start is included, but stop is excluded\ne.g. We could rewrite ours times table program as using range (see [RangeBasedTimeTables.py])\n\n\n\n# Example 6.11 Range Based Times Tables\n#\n# Demonstrates Python's range function using a for\n# loop to generate a times table\n\ntimes_value = 2\nfor count in range(1, 13):\n    result = count * times_value\n    print(count, \"times\", times_value, \"equals\", result)\n\n1 times 2 equals 2\n2 times 2 equals 4\n3 times 2 equals 6\n4 times 2 equals 8\n5 times 2 equals 10\n6 times 2 equals 12\n7 times 2 equals 14\n8 times 2 equals 16\n9 times 2 equals 18\n10 times 2 equals 20\n11 times 2 equals 22\n12 times 2 equals 24\n\n\n\nbreak and continue also work with for loops\n\ncontinue causes the loop to proceed to the next item in the collection\n\n\n\n\nLook at the following simple programs, and answer the corresponding questions about break and continue\n\nWhat would the following code print?\n\n for count in range(1, 13):\n     if count == 5:\n         break\n     print(count)\n print('Finished')\n\n1\n2\n3\n4\nFinished\n\n\n\nIt would print 1, 2, 3, 4 then \"finished\"\nSince when count is \\(5\\) the loop breaks before the print statement and then the print outside the loop is called\n\nWhat would the following code print?\n\n for count in range(1, 13):\n     if count == 5:\n         continue\n     print(count)\n print('Finished')\n\n1\n2\n3\n4\n6\n7\n8\n9\n10\n11\n12\nFinished\n\n\n\nThis program is similar to the above, except it would print 1 through to 12 but skip 5, before printing \"Finished\".\nThis is because the continue causes the loop iteration for count = 5 to skip the print statement in the loop and go to the next loop iteration\n\nWhat would the following code print?\n\n for count in range(1, 13):\n     count = 13\n     print(count)\n print('Finished')\n\n13\n13\n13\n13\n13\n13\n13\n13\n13\n13\n13\n13\nFinished\n\n\n\nThis will print \\(13\\) twelve times, because each time count starts a loop iteration it is set to the next value in the range(1, 13)\n\nThen inside the loop count is set to 13 and that value is printed\n\nOf course \"Finished\" is printed after the loop is down\n\nWould the following program run forever?\n\n while True:\n     break\n print('Finished')\n\nFinished\n\n\n\nNo, it will immediately end because break exits the loop\n\nWould the following program print the message “Looping”?\n while True:\n     continue\n     print('Looping')\n\nNo, the loop will hit the continue keyword and the go back to the start\nThis happens forever\n\nWhat would the following program do? Is it legal?\n\n for letter in 'hello world':\n     print(letter)\n\nh\ne\nl\nl\no\n\nw\no\nr\nl\nd\n\n\n\nStrings are collections of letters\nThe above program works, it loops over and prints each letter in the string\n\n\n\n\n\nReverse the behaviour of the times-table program so that rather than printing out the times-table your program insteads asks questions like, “What is \\(6\\) times \\(4\\)?” The user could enter their answer, and the program could compare it with the correct answer and keep score of how many correct answers are given. You could use a loop to make the program produce \\(12\\) “times-table” questions, and you could use random numbers so that the quiz is different every time\nOur solution given in TimesTableQuiz.py is relatively complete. We use first print a header message, then we set up a variable to track the number of correct answers total and a second variable to track the number of questions to ask. We then go into our for loop, looping over range(0, NumberOfQuestions), this makes the loop run NumberOfQuestions times.\nThe actual quiz then proceeds, we randomly generate the two numbers, the times_value from the range [2, 12] and the count from the range [1, 12]. We then calculate the correct answer, and prompt the user for an answer, using the standard ValueError exception handling. If the user’s answer is correct we congratulate them and increment the score, else we tell them what the correct answer is. After they’ve answered all the questions we give them the final score\n# Exercise 6.6: Times Table Quiz\n#\n# Generates a times table quiz\n\nimport random\n\nprint(\"===Times table Quiz===\")\nscore = 0\nNumberOfQuestions = 12\n\nfor question in range(0, NumberOfQuestions):\n    times_value = random.randint(2, 12)\n    count = random.randint(1, 12)\n    correct_answer = times_value * count\n    while True:\n        try:\n            answer_text = input(\n                \"What is \" + str(count) + \" x \" + str(times_value) + \": \"\n            )\n            answer = int(answer_text)\n            break\n        except ValueError:\n            print(\"Please enter an integer\")\n    if answer == correct_answer:\n        score = score + 1\n        print(\"Correct!\")\n    else:\n        print(\"Sorry that's wrong!\")\n        print(\"The correct answer is\", correct_answer, \"you gave\", answer)\n\nprint(\"You got\", score, \"/\", NumberOfQuestions, \"correct\")\n\n\n\n\n\nPutting together what we’ve covered, we can make a digital clock using snaps (see DigitalClock.py)\n\n# Example 6.12: Digital Clock\n#\n# Uses a combination of loops and snaps to create a digital clock\n\nimport time\nimport snaps\n\nwhile True:\n    current_time = time.localtime()\n    hour_string = str(current_time.tm_hour)\n    minute_string = str(current_time.tm_min)\n    second_string = str(current_time.tm_sec)\n\n    time_string = hour_string + \":\" + minute_string + \":\" + second_string\n    snaps.display_message(time_string)\n    time.sleep(1)\n\n\nCombine the digital clock display from the previous example with the alarm clock from Chapter 5. Make the background image depend on the time of day\nOur final program is a bit complicated so we’ll analyse it in parts. The full file can be read in DigitalAlarmClock.py\nWe start by extracting the relevant date and time information from the current time, and perform a boolean check if it’s a weekend.\nWe first then check if the time is night (defined heuristically as from \\(7\\) pm through to \\(6\\) am) or day (\\(6\\) am to \\(7\\) pm). We then display a moon as the background in the former case, or a sun in the later.\nRemember we have to display the image first so that we can overlay the text on top.\n# Exercise 6.7: Digital Alarm Clock\n#\n# Integrates the Alarm Clock Functionality of\n# Chapter 5, with the Digital Clock Display of Chapter 6\n\nimport time\n\nimport snaps\n\nwhile True:\n    current_time = time.localtime()\n\n    hour = current_time.tm_hour\n    minute = current_time.tm_min\n    second = current_time.tm_sec\n    day = current_time.tm_mday\n    month = current_time.tm_mon\n    year = current_time.tm_year\n    is_weekend = current_time.tm_wday &gt;= 5\n\n    # draw the background\n    # define day as 6am - 7pm\n    if hour &gt;= 6 and hour &lt;= 19:\n        snaps.display_image(\"sun.png\")\n    else:\n        snaps.display_image(\"moon.png\")\nNow we prepare our datetime strings\n    # set up normal time and day clock behaviour\n    date_message = \"The date is \" + str(day) + \"/\" + str(month) + \"/\" + str(year)\n    time_message = \"The time is \" + str(hour) + \":\" + str(minute) + \":\" + str(second)\n    message = date_message + \"\\n\" + time_message\nNext we want to play a wake alarm at \\(7:30\\) giving as extra hour to sleep in on weekends. We also want to define a bed time. When the time hits \\(7:30\\) we want to play the alarm, then before bed time (\\(22:00\\))the clock should display a message telling us to get up, while after bed time it should tell us to go to sleep.\nThe if...else construct here is a bit more complicated. We only want to play the alarm sound at \\(7:30:00\\) rather than just if the user runs the clock after the wakeup time. This is because the clock will then continuously play the sound every second it updates!\nOur first if statement thus checks if we are exactly on the alarm time, and if we are plays the alarm sound and updates the message\nWe then have to consider now when we check if the time is after the alarm has gone off that it is also not before it is time to go back to bed. It’s cleaner to split this into two cases (our elif statements)\nIn the first case if the hour is equal to the hour to get up and greater than the minute to get up then it must be time to get up and we don’t need to play the alarm (since the first if statement catches this case). Note this makes the assumption that we don’t wake up at a time like \\(8:30\\) and then go to bed at \\(8:59\\) which is reasonable.\nThe second case is when the hour is greater than the hour to get up. Here we have to check that either the hour is less than the hour we go to bed at or if it is the same, that the minutes are less than the minutes we go to bed at. (Effectively the reverse of our old alarm condition.) In either of the previous cases we only then need to update the final printed message with the statement that we should be up\nThe last case (the else) is our default case for when none of the previous cases are matched. By exhaustion of cases this has to be when it is time for us to be in bed by default. So we don’t need to do extra checks and can just update the message to tell us to go to sleep\n    # Play alarm and optionally append a wakeup message\n    hour_to_get_up = 7 + is_weekend\n    hour_to_sleep = 22\n    minute_to_get_up = 30\n    minute_to_sleep = 0\n\n    wake_up_message = \"TIME TO GET UP!\"\n    sleep_message = \"TIME FOR BED!\"\n\n    # case 1: On the alarm\n    if hour == hour_to_get_up and minute == minute_to_get_up and second == 0:\n        snaps.play_sound(\"siren.wav\")\n        message = message + \"\\n\" + wake_up_message\n    # Past the alarm\n    elif hour == hour_to_get_up and minute &gt;= minute_to_get_up:\n        message = message + \"\\n\" + wake_up_message\n    # past the alarm but before bed\n    elif hour &gt; hour_to_get_up and (\n        hour &lt; hour_to_sleep or (hour == hour_to_sleep and minute &lt; minute_to_sleep)\n    ):\n        message = message + \"\\n\" + wake_up_message\n    # time for bed\n    else:\n        message = message + \"\\n\" + sleep_message\nFinally we display the message and then sleep for a second before updating the clock again\n    # display the message and then sleep\n    snaps.display_message(message, size=100)\n    time.sleep(1)",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 6: Repeating Actions with Loops"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/06_RepeatingActionsWithLoops/Chapter_06.html#summary",
    "href": "01_ProgrammingFundamentals/06_RepeatingActionsWithLoops/Chapter_06.html#summary",
    "title": "Chapter 6: Repeating Actions with Loops",
    "section": "Summary",
    "text": "Summary\n\nwhile repeats statements as long as a logical expression is True\n\na while True loop runs forever\n\nfor is designed for looping through items in a collection of values one-by-one\nbreak and continue are two methods for controlling loop execution inside a loop\n\nbreak immediately terminates a loop\ncontinue immediately moves to the next loop iteration\n\nTuples are a basic form of container for storing values\n\ndeclared as a comma seperated list of values surrounded by parentheses\n\nrange(start, stop) creates a collection of integers from start (inclusive) to stop (exclusive)",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 6: Repeating Actions with Loops"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/06_RepeatingActionsWithLoops/Chapter_06.html#questions-and-answers",
    "href": "01_ProgrammingFundamentals/06_RepeatingActionsWithLoops/Chapter_06.html#questions-and-answers",
    "title": "Chapter 6: Repeating Actions with Loops",
    "section": "Questions and Answers",
    "text": "Questions and Answers\n\nDo we really need loops?\n\nIn theory no, you could unroll a loop into repeated code, however this can be clunky to do for arbitrary length loops or complicated control expressions\n\nAre loops dangerous?\n\nThey can be. A poorly phrased loop may never execute, or potentially never stop executing.\nSome safety-critical applications may opt to exclude loops entirely to avoid these risks",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 6: Repeating Actions with Loops"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/04_WorkingWithVariables/Chapter_04.html",
    "href": "01_ProgrammingFundamentals/04_WorkingWithVariables/Chapter_04.html",
    "title": "Chapter 4: Working With Variables",
    "section": "",
    "text": "Variables let us add memory to python\n\nCan be viewed as an alias for a storage location\n\nVariables in python are created by defining a name, and providing a value, e.g. the below defines a variable total and assigns it the value \\(0\\)\n\n\ntotal = 0\n\n\n\n\n\n\nblock-beta\n    columns 3\n    space\n    title[\"Anatomy of Variable Assignment\"]\n    space\n\n    block:variable\n    columns 1\n        varName[\"total\"]\n        variablebody[\"variable\"]\n        variableDescr[\"(thing to which value assigned)\"]\n    end\n\n    block:equals\n    columns 1\n        equalsSymbol[\"=\"]\n        equalsName[\"equals\"]\n        equalsDescr[\"(means assign)\"]\n    end\n\n    block:argumentblock\n    columns 1\n        zero[\"0\"]\n        zeroName[\"expression\"]\n        zeroDescr[\"(value to assign)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass variablebody BG\nclass variableDescr BG\nclass equalsName BG\nclass equalsDescr BG\nclass zeroName BG\nclass zeroDescr BG\n\n\n\n\n\n\n\nThe above diagramatically breaks down variable assignment. On the left we have the variable, then = which means assignment, followed by the expression to assign\nThe assignment expression does not need to be made of simple primitives, e.g. total = us_sales + world_wide_sales defines the variable total to be equal to the sum of the variables us_sales and world_wide_sales\n\n\n\nStart up a python interpreter, then run the following commands in sequence\n\ntotal = 0\n\n total = 0\n\n\nNo output is generated, the assignment is performed silently\n\ntotal\n\n total\n\n0\n\n\n\n0 output\ntotal has been assigned 0, putting the variable name into the terminal returns the value associated with this value\n\ntotal = total + 10\n\n total = total + 10\n\n\nNo output\nLike with the first statement, variable assignment generates no output\nHere we assign total the value given by the current value of total plus \\(10\\)\n\ntotal\n\n total\n\n10\n\n\n\n10 output\nThe new value of total is printed\n\n\n\n\n\n\nVariables require names\nPython variable names must obey a number of rules\n\nMust start with a letter or _\nCan contain letters, numbers or _ characters\n\nSome valid names are\n\ntotal\nxyz\nt0tal\n\nSome invalid names are\n\n2_be_or_not_to_be\n\nStarts with a number which is not allowed\n\ntot@l\n\n@ is not a valid character for a variable name\n\n\nPython names are case sensitive, i.e. FRED and fred are distinct variables\n\n\n\n\n\n\n\nTip\n\n\n\nCreate Meaningful Names\nDon’t use silly or meaningless names like hello_mom. Use meaningful names that convey information about what they represent like length or length_in_centimetres. The PEP8 style guide, sets out how to write and format python programs. This includes a section on naming conventions\nSome languages recommend using camel case for variable naming. In this format words in a variable are distinguished by capital letters, but the first letter of the variable is lower case, e.g. lengthInCentimetres. Camel case is called this because the capital letters look like the humps of a camel. Either standard works, but when writing python it is best to stick to the python style guides\n\n\n\nPython does not limit the length of variable names\n\nThere should be no performance cost associated with long variable names\nLonger names can be hard to read\nNames should be no longer than they need to convey clear meaning\n\n\n\n\n\nYou’ve already seen that python can generate errors when it is unable to interpret an input. Answer the following questions to investigate how errors can arise in using variables. Assume that total has already been defined\n\nCan you identify an error in the statement below, which is supposed to add \\(10\\) to the variable total?\n\n # clearing saved variables in the notebook\n %reset\n\n\n total = 0\n Total = total + 10\n\n\nVariable names are case-sensitive. Therefore Total and total are distinct variables. So this declares a new variable Total and assigns it the value of total + 10. The value of total itself is unchanged.\nThis is a logic error, it is a legal statement in python that generates the wrong behaviour\n\nLogic errors are some of the hardest errors to deal with since they (typically) don’t stop a program running, they just produce incorrect behaviour\nPython typically cannot warn you about them ahead of time\n\nThis variable misassignment is why python style guides recommend the use of all lowercase letters for variable names\n\n\n\n\n\n\n\nNote\n\n\n\nIdentifying Errors\nOther languages with more strict type systems and variable declarations, may be able to identify logic errors like the one above.\n\n\nHow do we prevent logic errors?\n\nTesting\n\ni.e checking that the actual behaviour of a program matches the expected behaviour\nRun a program with input that will generate a known output when running correctly\n\nVerify the program generates this output\n\n\nTesting doesn’t guarantee a program is correct\n\nTypically hard to check all inputs and use cases\nDoes however give confidence and can provide that a program isn’t correct\n\nTypically tests should be written as the program is created or if using test-driven development the tests are written before the program itself is written\n\nThe statement below also contains a misspelling of the variable total. However, this time the name on the right-hand side of the equals is mispelled. What will happen when this program runs?\n\n # Again clear the notebook variables\n %reset\n\n\n total = 0\n total = Total + 10\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 2\n      1 total = 0\n----&gt; 2 total = Total + 10\n\nNameError: name 'Total' is not defined\n\n\n\n\nIn this case, Total is not defined as a variable, so there is no meaningful way to interpret a value. Hence we would expect an error. Since the error is that Total doesn’t exist, we see a NameError.\n\n\n\n\n\nConsider the Nerves of Steel exercise from Chapter 3. In the game, players must remain standing right up to the moment before they think a random timer will expire\nOne suggestion is that the game might provide more skill if the program told the players how long they had to stand. The game now functions as a “Self-Timer”, the winner is now arguably the person who can best keep track of the time\nThe “game” sequence is\n\nSet the time to remain standing to a random number\nDisplay time to remain standing\nSleep for the time to remain standing\nDisplay a message for the winner\n\nObserve that the time is required to be used in two places, displaying the time remaining and then sleeping for that period of time. This means we need to use a variable to store the value of the time remaining\n# Example 4.1: Self Timer\n#\n# Extends the Nerves of Steel Game from Chapter 3, by adding a skill element\n# with the players being informed of how long they have to stand for\n\nimport random\nimport time\n\nprint(\"Welcome to Self Timer\")\nprint()  # just prints a newline\nprint(\"Everybody stand up\")\nprint(\"Stay standing until you think the time has ended\")\nprint(\"Then sit down\")\nprint(\"Anyone still standing when the time expires loses\")\nprint(\"The last person to sit down before the time ended will win\")\n\nstand_time = random.randint(5, 20)  # generate the time to stand for\n\nprint(\"Stay standing for\", stand_time, \"seconds.\")  # display standing time\ntime.sleep(stand_time)  # sleep for the standing time\nprint(\"****TIMES UP, LAST TO SIT WINS!****\")\n\n\nWelcome to Self Timer\n\nEverybody stand up\nStay standing until you think the time has ended\nThen sit down\nAnyone still standing when the time expires loses\nThe last person to sit down before the time ended will win\nStay standing for 20 seconds.\n****TIMES UP, LAST TO SIT WINS!****\n\n\nMost of the code is just text, but the key takeaway is the line stand_time = random.randint(5, 20) which assigns stand_time the result of random.randint(5, 20), i.e a random number from 5 to 20 inclusive. We then call stand_time is our call to print to display the time, and then sleep for the same amount of time. Observe we couldn’t just write the number into both functions explicitly since it’s randomly generated, we would need to know ahead of time what the value will be\n\n\n\n\n\nVariables can also hold text, e.g. customer_name = 'fred' assigns the string 'fred' to customer_name\nCan use a string variable anywhere we would use a string literal, e.g. message = 'the name is ' + customer_name performs the string concatenation of 'the name is' and the value of customer_name and assigns the result to message, which we can confirm below,\n\n\n  customer_name = \"fred\"\n  message = \"the name is \" + customer_name\n  print(message)\n\nthe name is fred\n\n\n\n\nPython tracks the contents of each variable and only allows operations that make sense. Using the python interpreter experiment with the following combinations of string and number variables.\n\ncustomer_age_in_years = 25\ncustomer_name = 'fred'\n\nAfter entering the above two lines in the interpreter, run the following line\n\ncustomer_age_in_years + customer_name\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[13], line 1\n----&gt; 1 customer_age_in_years + customer_name\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\n\nHere we are trying to add a number and a string, which we saw previously shouldn’t work. The terminal should provide some error output like the below\nNow try the below line\n\ncustomer_age_in_years = 'Fred'\n\nOne might expect the above to generate an error, after all we assign text to a variable that was just storing a number. Instead python simply discards the old numeric value of the variable, and now stores text in customer_age_in_years. You should generally avoid doing this, being able to reason about the type of a variable is typically an important part of safe and effective programming, and the weak typing of python is typically disliked outside of quick prototyping\n\n\n\n\n\n\nNote\n\n\n\nWeak vs Strong Typing\nThe above behaviour is an example of python as a what’s called a weakly typed language. Types are a quite developed part of programming theory that can be discussed later. In some languages, types are enforced to greater degrees of strictness. In some languages (like C) you can assign variables compatible types, i.e. ones that can be converted to the variable’s inate type. In other stricter languages a variable can only hold the exact specified type\nThe more strictly a language enforces its typing system typically the harder it is to generate errors at runtime, however they are often correspondingly more painful to actually write the code in the first place\n\n\n\n\n\n\nPython lets you use either single-quotes (’) or double-quotes (“)\n\nLets us include ’ or ” in a string, by using the alternate delimiter\n\nFor example, compare the two quote snippets,\n\n\nprint(\"It's a trap\")\n\nIt's a trap\n\n\n\nWhereas if we tried to just use single quotes,\n\n\nprint('It's a trap')\n\n\n  Cell In[16], line 1\n    print('It's a trap')\n                      ^\nSyntaxError: unterminated string literal (detected at line 1)\n\n\n\n\n\nThe single quote in It's ends the string, and we get a syntax error detecting what should be the closing single quote as opening a new string literal\nHow do we handle the case where we have mixed quotes in a string?\n\nWe use triple quotes, a series of three single or double quotes in a row, see the example below\n\n\n\nprint('''...and then Luke said \"It's a trap\"''')\n\n...and then Luke said \"It's a trap\"\n\n\n\nTriple quoted strings have the added advantage of capturing newlines. To see this, we could rewrite the intro string in Nerves of Steel as\n\n\nprint('''Welcome to Nerves of Steel\n\nEverybody stand up\nStay standing as long as you dare.\nSit down just before you think the time will end. ''')\n\nWelcome to Nerves of Steel\n\nEverybody stand up\nStay standing as long as you dare.\nSit down just before you think the time will end. \n\n\n\n\n\n\n\n\nCaution\n\n\n\nString Delimiters must Match\nYou must using matching delimiters, if we try to mix them we’ll get an error\n\nprint('hello\")\n\n\n  Cell In[19], line 1\n    print('hello\")\n          ^\nSyntaxError: unterminated string literal (detected at line 1)\n\n\n\n\n\n\n\n\n\n\nEscape sequences are another way to include quote characters\nExtends to other symbols with meaning other than their literal character glyph in a string\nDenoted by the \\ character\n\n\n\n\n\n\n\n\n\nEscape Sequence\nMeaning\nEffect\n\n\n\n\n\\\\\nBackslash character (\\)\nEnter a backslash into a string\n\n\n\\'\nSingle Quote (')\nEnter a single quote into the string\n\n\n\\\"\nDouble Quote (\")\nEnter a double quote into the string\n\n\n\\n\nASCII Line Feed/New Line\nEnd this line and take a new one\n\n\n\\t\nASCII Tab\nMove to the right to the next tab stop\n\n\n\\r\nASCII Carriage Return\nReturn the printing position to the start of the line\n\n\n\\a\nASCII Bell\nSound the bell on the terminal\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nASCII\nASCII (short for American Standard Code for Information Interchange) is an old format for character encoding that covers a small range of symbols including the latin alphabet and digits.\nASCII itself is less used today since it only covers around \\(100\\) characters, which is nowhere near enough to cover all modern languages, before you start adding in characters like emojis. However modern text encodings like unicode are typically backwards compatible with ASCII.\nNot all ASCII escape sequences may work on a modern computer. \\a was designed to ring a mechanical bell on old computers. Some modern computers may play a beep while others may do nothing. Similarly \\r is supposed to return the print head of a computer back to the start of the line. This has very limited use cases, and may not be implemented on all systems.\nThe most common escape characters are newline \\n and escaping quotes\n\n\n\n\n\n\n\n\nImportant\n\n\n\nNewline in Python\nPython uses \\n as the newline character. Technically this is known as a line feed and means “go to the next line”. In Linux and similar operating systems this is equivalent to starting a new line, but in windows going to the start of a new line is achieved via \\r\\n, i.e. return to the start of the line, and then feed to the next. Luckily python handles the conversion between the conventions automatically and we can just use \\n regardless of the operating system we are actually running on\n\n\n\n\nStart a python interpreter and answer the following questions\n\nWhat do you think the following quote would print?\nprint('hello\\nworld')\n\nWe would expect this print hello on one line, then world on the next\n\n\n\nhello\nworld\n\n\nWhat do you think the following would print?\n print('Item\\tSales\\ncar\\t50\\nboat\\t10')\n\nWe can see this prints a series of tab seperated lines. So this is essentially a tab seperated table (a similar format to the more familiar comma-seperated table)\n\n\n\nItem Sales\ncar  50\nboat 10\n\n\n\nThe exact spacing of tab characters can depend on the computer system, and it is quite common for text editors to convert tabs to spaces, so this format isn’t the best. We’ll see other ways to format strings later\n\nHow could I use Python escape sequences to print out this message?\n\nand then Luke said “It’s a trap”\n\n\nWe saw how to do this with triple-delimited strings before. Instead we just have to remember to instead use a single-delimiter string and then escape the quotes that actually form the string contents. See,\n\n\n print('and then Luke said \"It\\'s a trap\"')\n\nand then Luke said \"It's a trap\"\n\n\n\n\nSince the string is delimited by single quotes we only have to delimit the one single quote in It's rather than the two double quotes\n\n\n\n\n\n\nWe’ve seen how to output data with print\nWe can also input data with the appropriately named input\nThe code snippet below, takes input from the user and stores it in name\n\n  name = input()\n\nThe program will pause until the user supplies the input, (Try it yourself in the interpreter!)\nWe can add a display prompt to the input statement\n\n  name = input('Enter your name please: ')\n\nThe above should output something like the below when run\n\n\n\nEnter your name please: \n\n\n\nAs mentioned input passes what it receives into the receiving variable.\n\nIf we just immediately press enter this is the empty string i.e. a string containing no characters\n\ninput is another technique for delaying the end of a program, e.g. the below prints a prompt and then holds the program until some input is received\n\ninput('Press enter to continue...')\n\n\nUse python to create a simple program that will issue a personalised greeting. Create a new program (greeter.py) with the following contents\nname = input('Enter your name please: ')\nprint('Hello', name)\nSave the program and execute it to see the output. For me the proram would output,\n\n\n\nEnter your name please: Felix\n\nHello Felix\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nI’ve used colour to emphase what is my input, versus the program’s output\n\n\n\n\n\n\n\n\n\n\ninput returns a string\n\nFine if we want that, but what if we want to handle numbers?\ne.g. if we wanted to have a user-specified egg timer\n\nint is a function that converts the argument to a whole number e.g.\n\ntime_text = input('Enter the cooking time in seconds: ') #receive time in seconds\ntime_int = int(time_next) #perform conversion to number\n\n\n\nThe complete program would then look like,\n  # Example 4.3: Configurable Egg Timer\n  #\n  # Reads in a user specified time to set the timer for\n\n  import time\n\n  time_text = input(\"Enter the cooking time in seconds: \")\n  time_int = int(time_text)\n\n  print(\"Put the egg in boiling water now\")\n  input(\"Press enter to continue once the egg is in...\")\n\n  time.sleep(time_int)\n\n  print(\"Take the egg out now\")\nThis basic pattern works just as well for an alarm as it does for a configurable timer\n\n\n\n\nConsider the previous example, and answer the following questions\n\nHow many variables are used in the program above?\n\ntwo, the first time_text stores the initial text input, while the second time_int contains the converted numeric representation\n\nCould you write the program without the time_text variable?\n\nYes, we could immediately pass the input result to int, e.g.\n\n time_int = int(input('Enter the cooking time in seconds: '))\n\nIt’s an open debate which format is clearer. In the second there’s more to grok on one line, but the whole workflow is there\n\nWhat do you think will happen if the user enters something other than a number?\n\nLet us find out,\n\n\n x = int('kaboom')\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[25], line 1\n----&gt; 1 x = int('kaboom')\n\nValueError: invalid literal for int() with base 10: 'kaboom'\n\n\n\n\nWe get an error, int tries to convert the string 'kaboom' to an integer, which it clearly cant\nThe art of programming to handle invalid input like the above is called error-handling, we’ll see that later\n\n\n\n\n\n\n\nThere are two types of numbers\n\nWhole numbers or integers\n\nAre always held accurately by the computer\n\nReal numbers (or representations of) or floating point\n\nContain a fractional component\nMust be truncated to be stored in memory, so cannot always be stored accurately\n\n\n\n\n\nLearn about the differences between whole numbers and real numbers through the following questions\n\nI’m building a device that can count the number of hairs on your head. Should this be stored as a whole or real number?\n\nInteger, we generally wouldn’t count fractions of a hair\nAlternatively, given how many hairs there are, and that we might not care about being precise, we might instead want to use a real number to store the approximate magnitude\n\nI want to use my hair-counting machine on \\(100\\) people and determine the average number of hairs on all their heads. Should I use this value as a whole or real number?\n\nWe expect that the average will not be a whole number, so we should store it as a real number\nAlternatively, we may not care about getting the number exact down to the fraction, so we could use a whole number to round to the nearest number\n\nI want to keep track of the price of a product in my program. Should I use whole numbers or real numbers?\n\nNaively we would a real number, however as we mentioned real numbers have some uncertainty stored in them\nWhen dealing with financial values we need to maintain that precision\n\nInstead we might then use whole cents\n\nWorks straightforward if we only care about the total\nIf we care about averages, or fractions of a total then we might have to reconsider\n\nThere are techniques used to control the error in a real number calculation\n\n\n\n\nAs you can see the argument of what numerical type to use, requires understanding both the nature of the value itself, and what you want to do with it. You can then consider the properties of the numeric representation and choose the most appropriate one\n\n\n\n\n\n\n\nImportant\n\n\n\nThe way you store a variable depends on what you want to do with it\nAs the discussion above highlights, sometimes the answer to how we want to store data is not the immediate first answer. It’s important to consider not just what the natural representation of a value is, but what it’s purpose in the code is.\nFor example as we discussed above, money is naturally expressed as real numbers. However due to the it’s use case, which requires high precision and also generally a limited range (values of even a trillion are rare, and we typically only consider down to whole cents) compared to the full range of a floating point number we might want to look at alternative representations\n\n\n\n\n\n\n\nReal numbers have a fractional part\n\nTheir representation may not align 1:1 with what was originally input\n\nThe most common way to store real numbers is called floating point\n\nThe floating means that the decimal point moves around in the representation, as opposed to a fixed point representation which has a set number of digits after the decimal point\nUsing more memory to store a float lets us store it with greater precision, but we can never accurately represent all floating point numbers\n\nReal numbers can be defined by range and precision\n\nPrecision governs how precisely a number is stored e.g. a float may be able to store \\(123456789.0\\) or \\(0.123456789\\) but not \\(123456789.987654321\\) because the precision required is too great\nRange determines how much we can slide the decimal point to represent large or small numbers e.g. we could store \\(123456700\\) or \\(0.0001234567\\)\nIn Python floats have \\(15-16\\) digits of precision and can range from \\(10^{308}\\) and \\(10^{-324}\\)\n\nA quirk of floating point is that some apparently simple numbers like \\(0.1\\) can’t be stored exactly\n\n\n\nConduct the following experiments in the python shell to learn about floating points\n\nWhat happens if we try to store a value that can’t be held accurately as a floating-point value?\n\n0.1\n\n0.1\n\n\n\nAbove we said that \\(0.1\\) couldn’t be exactly represented, but that doesn’t match with what we just saw. The answer is because the error in the representation is very small, and print rounds off the answer\n\nDoes the rounding really happen? Run the following and comment on the result\n\n 0.1 + 0.2\n\n0.30000000000000004\n\n\n\nWe expected the answer to be \\(0.3\\) but instead we see a slight error. This is because there is an error accumulation from adding \\(0.1\\) to \\(0.2\\) and the underlying floating point representations\n\n\n\nThese issues are not python specific. They are an inate challenge of trying to represent real numbers on hardware. Modern floating-point numbers are also an internationally recognised standard which lets different programs and hardware talk to each other.\nPython differs from some languages in only providing a single floating point type that is \\(8\\) bytes. In many languages this is referred to as a double-precision floating point or just a double and is one of several floating point types\n\n\n\n\n\n\n\nWarning\n\n\n\nDon’t confuse precision with accuracy\nNumbers don’t become more accurate when they are stored with more precision. Scientists often measure values with a measure of uncertainty which captures how sure they are in the accuracy of their number. There is no point storing a value to \\(15\\) decimal places of precision, if the accuracy of a measurement is only to \\(1-2\\) places, e.g. if we measure with a ruler\nUsing higher precision can result in slower programs that use more memory\n\n\n\nPython automatically creates variables for use in programs\nThe type of a variable is determined by what is stored in it\n\nname = 'Rob'\nage = 25\n\nThe above creates two variables\n\nOne name is a string type\nThe other age is an int or integer type\n\n\n\n\n\nWork through the following following questions to understand how floating-point variables work?\n\nHow do you create a floating point variable?\n\nYou can create a floating point variable by assigning a floating point number e.g. the below creates a variable* x *and assigns it the floating point value \\(1.5\\)\n\n\n x = 1.5\n x\n\n1.5\n\n\nWhat happens if you assign an integer to a floating point variable?\n\nThe below assigns the integer value \\(1.0\\) to a variable y\nIf we print the value back we can see it keeps the decimal, indicating it is a floating point value\n\n\n y = 1.0\n y\n\n1.0\n\n\n\ni.e. by writing the decimal point we coerce the type of y to be floating point\n\nWhat happens when we mix floating point and integers in calculations?\n\nIf we compare the two additions below, we can see that when we add floating points, the addition stays a floating point even if the result is integral\n\n\n 2 + 2\n\n4\n\n\n\n 2.0 + 2.0\n\n4.0\n\n\n\nIf we mix a floating point and integer type we can also see that the result is returned as a floating point (even when the final result is integral)\n\n\n 2 + 2.0\n\n4.0\n\n\n\nLastly what happens if we divide two coprime integers?\nWe see that the result gives the appropriate floating point fraction\n\n\n 1/2\n\n0.5\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nInteger Division\nWhile the last point about division behaviour may seem obvious if you haven’t programmed before you would do well to be careful. In many common languages, division of two integers is treated as integer division. In this case the result is always an integer with the result being rounded according to some scheme. Three common schemes are towards zero, in which the result is always rounded towards the number \\(0\\); towards the nearest, where the result is rounded to the nearest whole number and floored division in which the number is rounded towards negative infinity.\n\n\n\n\n\n\n\n\nDivision\nExample\nInterpretation\n\n\n\n\ntowards zero\n\\(-1/2 = 0\\)\nDiscard decimal digits\n\n\ntowards nearest\n\\(3.2/2 = 2\\)\nMinimise the difference between “true” division and result\n\n\nfloored division\n\\(-1/2 = -1\\)\nRound “down”\n\n\n\nPython lets you perform integer division using floored division behaviour with the // operator e.g.\n\n-1//2\n\n-1\n\n\n\n\n\n\n\n\n\nConverting string to float, works identically to as for int but we use float instead\n\ne.g. We could rewrite the configurable egg timer with floats as,\n\n\ntime_text = input('Enter the cooking time in seconds: ')\ntime_float = float(time_text)\n\n\n\nThe complete program would then look like\n\n# Example 4.4 Ultra-Precise Egg Timer\n#\n# A version of the Configurable Egg Timer using floating point for the input time\n\nimport time\n\ntime_text = input(\"Enter the cooking time in seconds: \")\ntime_float = float(time_text)\n\nprint(\"Put the egg in boiling water now\")\ninput(\"Press enter to continue once the egg is in...\")\n\ntime.sleep(time_float)\n\nprint(\"Take the egg out now\")\n\nThe code is the same except we make the subsitution int \\(\\to\\) float\n\n\n\n\n\n\nAs mentioned before python is an expression evaluator\nAn expression consists of operators and operands\nPython evaluates an expression left to right, and carries out operations according to their order of operations\n\nAnalogous to mathematical order of operations (and includes them) but must extend for programming specific syntax\nAs in maths, parentheses are used to enforce an evaluation order\n\n\n\n\n\nOperator\nUsecase\n\n\n\n\n-\nUnary minus, denotes a negative number\n\n\n*\nMultiplication (inlieu of \\(\\times\\))\n\n\n/\nDivision\n\n\n+\nAddition\n\n\n-\nbinary minus or subtraction\n\n\n\n\nBasic operators and their precedence\n\n\n\nSee if you can work out the values of a, b and c when the following statements are evaluated,\n    a = 1\n    b = 2\n    c = a + b\n\n    c = c * (a + b)\n    b = a + b + c\nThe first three lines give a = \\(1\\), b = \\(2\\) and c = \\(3\\). Substituting those into the second evaluation for c,\n\na = 1\nb = 2\nc = a + b\nc = 3 * (1 + 2)\nc\n\n9\n\n\nSo c is assigned \\(9\\). We then repeat for the second assignment to b to get,\n\nb = 1 + 2 + 9\n\nSo the final values are, a = \\(1\\), b = \\(12\\), c = \\(9\\). If we execute the original cell we can confirm this\n\na = 1\nb = 2\nc = a + b\n\nc = c * (a + b)\nb = a + b + c\n\nprint('a: ', a)\nprint('b: ', b)\nprint('c: ', c)\n\na:  1\nb:  12\nc:  9\n\n\n\n\n\n\n\n\nCaution\n\n\n\nDumb Calculations\nPython won’t try and stop you if you do something that mathematically makes no sense like dividing a number by zero, instead an error is raised, but this won’t occur until your program runs! Therefore when using division you should always take care to make sure you either handling division by zero cases appropriately or preventing them from occuring\n\n1/0\n\n\n---------------------------------------------------------------------------\nZeroDivisionError                         Traceback (most recent call last)\nCell In[38], line 1\n----&gt; 1 1/0\n\nZeroDivisionError: division by zero\n\n\n\nWhen using other languages, they may not raise and error, instead unexpected behaviour may occur including your program crashing.\n\n\n\n\n\n\n\nWe saw floatcan be used to convert a string to a float.\n\nIt can also be used to convert an integer value to a floating point value, e.g.\n\n\n\nz = float(1)\nz\n\n1.0\n\n\n\nIf we want to go the other way we can use int to convert a float to an int.\n\nThe number is rounded towards zero, i.e. fractional components are truncated (see the callout-box above about integer division)\n\n\n\ni = int(2.9)\ni\n\n2\n\n\n\n\nConsider the following program which is designed to calculate the number of pizzas needed for a hackathon with \\(x\\) number of particpants using the heuristic that \\(1\\) pizza can satisfy \\(1.5\\) people\n# Example 4.5: Pizza Order Calculator\n#\n# A basic pizza order calculator based on the heuristic that 1 pizza = 1.5 people fed\n\nstudents_int = int(\n    input(\"How many students are attending? \")\n)  # read in string, convert to int and store\npizza_count = students_int / 1.5  # perform division int -&gt; float\nprint(\"You will need\", pizza_count, \"pizzas\")\nNote, that I’ve modified the code to directly pass the input to int and then to a variable, to demonstrate that it’s possible.\nThe above program has the problem that for any number not divisible by \\(1.5\\), the program recommends ordering a fractional number of pizzas. This is generally not possible, so we need to convert the output to an integer.\n\nModify the program to return an int by calling int directly during the calculation of pizza_count. What potential problems does this solution have?\n # Exercise 4.1.1: Pizza Order Calculator\n #\n # A basic pizza order calculator based on the heuristic that 1 pizza = 1.5 people fed\n\n students_int = int(\n     input(\"How many students are attending? \")\n )  # read in string, convert to int and store\n pizza_count = students_int / 1.5  # perform division int -&gt; float\n print(\"You will need\", pizza_count, \"pizzas\")\n\nThis method has the disadvantage that it will tend to underestimate the number of pizzas needed.\nFor example if we needed to feed \\(40\\) people, the program would give us \\(26\\), which can satisfy, \\(39\\) people, meaning someone goes hungry\n\nModify the program to return an int by calling int to convert the division to an int then adding \\(1\\). Explain how this changes the behaviour\n # Exercise 4.1.2: Pizza Order Calculator\n #\n # A basic pizza order calculator based on the heuristic that 1 pizza = 1.5 people fed\n # Converts the rseult to an integer using int on pizza_count then adding one\n # has the disadvantage it will tend to overestimate the number of pizzas needed\n\n students_int = int(\n     input(\"How many students are attending? \")\n )  # read in string, convert to int and store\n pizza_count = int(students_int / 1.5) + 1  # perform division int -&gt; float\n print(\"You will need\", pizza_count, \"pizzas\")\n\nThis method will tend to add an additional spare pizza or overestimate the number of pizzas needed.\nSince it’s generally better for there to be a little left over than someone go hungry, this behaviour is probably preferred.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nNever assume you know what a program is supposed to do\nWhen faced with a choice like the above for the pizza order calculator for a product being made by a client, you should not decide what the expected behaviour is yourself. For example, in the above the customer may prefer to round down the number of pizzas to reduce cost.\nNever assume you know what the program should do, ask the client\n\n\n\n\n\nWrite a program to convert from Fahrenheit to Centigrade. The formula for this is\n\\[\n\\begin{align}\n\\text{Centrigrade} &= \\frac{\\text{Fahrenheit} - 32}{1.8}\n\\end{align}\n\\]\nOur solution is very similar to the Pizza Calculator, but with some of the text changed. The other major difference is that we want to be able to accept a float value, and output a float value.\n    # Exercise 4.2: Fahrenheit to Celcius\n    #\n    # Converts Fahrenheit to Celcius\n\n    temperature_fahrenheit = float(\n        input(\"Enter a temperature in Fahrenheit: \")\n    )  # read in string, convert to float\n    temperature_centrigrade = (temperature_fahrenheit - 32) / 1.8\n    print(\"The temperature is\", temperature_centrigrade, \"degrees Celcius\")\nA sample output may look like,\n\n\n\nEnter a temperature in Fahrenheit: 0\n\nThe temperature is -17.77777777777778 degrees Celcius\n\n\n\n\n\nLater we’ll see how we can format the output to be a bit more presentable\n\n\n\n\n\n\n\nSnaps contains a function get_weather_temp for to return the temperature of a location in the United States\n\nData is scraped from the US National Weather Service website\nFunction takes the latitude and longitude as an argument\n\n\n\n\n\nThe following program can be used to get the current temperature reading from Seattle using snaps\n\n  # Example 4.6: Seattle Temperature\n  #\n  # Get the current temperature in Seattle\n\n  import snaps\n\n  temp = snaps.get_weather_temp(latitude=47.61, longitude=-122.33)\n\n  print(\"The temperature in Seattle is:\", temp)\n\npygame 2.6.1 (SDL 2.28.4, Python 3.12.3)\nHello from the pygame community. https://www.pygame.org/contribute.html\nThe temperature in Seattle is: 37\n\n\n/home/runner/work/BeginToCodeWithPython/BeginToCodeWithPython/.venv/lib/python3.12/site-packages/pygame/pkgdata.py:25: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools&lt;81.\n  from pkg_resources import resource_stream, resource_exists\n\n\n\n\n\n\n\nWe can also use snaps to get a short description of the current weather\n\n  # Example 4.7: Seattle Weather\n  #\n  # Uses snaps to get a description of the weather in Seattle\n\n  import snaps\n\n  desc = snaps.get_weather_desciption(latitude=47.61, longitude=-122.33)\n  print(\"The conditions are:\", desc)\n\nThe conditions are: Clear\n\n\n\n\n\n\nWrite a program that displays the current weather conditions. If you use the display_text function from snaps, your program can display the current weather and description\nOur solution is written below,\n# Exercise 4.3: Weather Display\n#\n# Displays the Weather in Seattle\n\nimport snaps\n\ntemperature_fahrenheit = snaps.get_weather_temp(latitude=47.61, longitude=-122.33)\ntemperature_string = \"The temperature in Seattle is: \" + str(temperature_fahrenheit)\n\nweather_descr = snaps.get_weather_desciption(latitude=47.61, longitude=-122.33)\nweather_descr_string = \"The conditions are: \" + str(weather_descr)\n\nweather_string = temperature_string + \"\\n\" + weather_descr_string\n\nsnaps.display_message(weather_string, size=100)\n\ninput(\"Press enter to continue...\")\nAs we can see most the actual getting of the temperature and weather data is the same as for the Seattle Temperature and Weather programs. The rest of the work is done to construct the appropriate strings and merge them together so they can be passed to the display_message function for output",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 4: Working With Variables"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/04_WorkingWithVariables/Chapter_04.html#notes",
    "href": "01_ProgrammingFundamentals/04_WorkingWithVariables/Chapter_04.html#notes",
    "title": "Chapter 4: Working With Variables",
    "section": "",
    "text": "Variables let us add memory to python\n\nCan be viewed as an alias for a storage location\n\nVariables in python are created by defining a name, and providing a value, e.g. the below defines a variable total and assigns it the value \\(0\\)\n\n\ntotal = 0\n\n\n\n\n\n\nblock-beta\n    columns 3\n    space\n    title[\"Anatomy of Variable Assignment\"]\n    space\n\n    block:variable\n    columns 1\n        varName[\"total\"]\n        variablebody[\"variable\"]\n        variableDescr[\"(thing to which value assigned)\"]\n    end\n\n    block:equals\n    columns 1\n        equalsSymbol[\"=\"]\n        equalsName[\"equals\"]\n        equalsDescr[\"(means assign)\"]\n    end\n\n    block:argumentblock\n    columns 1\n        zero[\"0\"]\n        zeroName[\"expression\"]\n        zeroDescr[\"(value to assign)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass variablebody BG\nclass variableDescr BG\nclass equalsName BG\nclass equalsDescr BG\nclass zeroName BG\nclass zeroDescr BG\n\n\n\n\n\n\n\nThe above diagramatically breaks down variable assignment. On the left we have the variable, then = which means assignment, followed by the expression to assign\nThe assignment expression does not need to be made of simple primitives, e.g. total = us_sales + world_wide_sales defines the variable total to be equal to the sum of the variables us_sales and world_wide_sales\n\n\n\nStart up a python interpreter, then run the following commands in sequence\n\ntotal = 0\n\n total = 0\n\n\nNo output is generated, the assignment is performed silently\n\ntotal\n\n total\n\n0\n\n\n\n0 output\ntotal has been assigned 0, putting the variable name into the terminal returns the value associated with this value\n\ntotal = total + 10\n\n total = total + 10\n\n\nNo output\nLike with the first statement, variable assignment generates no output\nHere we assign total the value given by the current value of total plus \\(10\\)\n\ntotal\n\n total\n\n10\n\n\n\n10 output\nThe new value of total is printed\n\n\n\n\n\n\nVariables require names\nPython variable names must obey a number of rules\n\nMust start with a letter or _\nCan contain letters, numbers or _ characters\n\nSome valid names are\n\ntotal\nxyz\nt0tal\n\nSome invalid names are\n\n2_be_or_not_to_be\n\nStarts with a number which is not allowed\n\ntot@l\n\n@ is not a valid character for a variable name\n\n\nPython names are case sensitive, i.e. FRED and fred are distinct variables\n\n\n\n\n\n\n\nTip\n\n\n\nCreate Meaningful Names\nDon’t use silly or meaningless names like hello_mom. Use meaningful names that convey information about what they represent like length or length_in_centimetres. The PEP8 style guide, sets out how to write and format python programs. This includes a section on naming conventions\nSome languages recommend using camel case for variable naming. In this format words in a variable are distinguished by capital letters, but the first letter of the variable is lower case, e.g. lengthInCentimetres. Camel case is called this because the capital letters look like the humps of a camel. Either standard works, but when writing python it is best to stick to the python style guides\n\n\n\nPython does not limit the length of variable names\n\nThere should be no performance cost associated with long variable names\nLonger names can be hard to read\nNames should be no longer than they need to convey clear meaning\n\n\n\n\n\nYou’ve already seen that python can generate errors when it is unable to interpret an input. Answer the following questions to investigate how errors can arise in using variables. Assume that total has already been defined\n\nCan you identify an error in the statement below, which is supposed to add \\(10\\) to the variable total?\n\n # clearing saved variables in the notebook\n %reset\n\n\n total = 0\n Total = total + 10\n\n\nVariable names are case-sensitive. Therefore Total and total are distinct variables. So this declares a new variable Total and assigns it the value of total + 10. The value of total itself is unchanged.\nThis is a logic error, it is a legal statement in python that generates the wrong behaviour\n\nLogic errors are some of the hardest errors to deal with since they (typically) don’t stop a program running, they just produce incorrect behaviour\nPython typically cannot warn you about them ahead of time\n\nThis variable misassignment is why python style guides recommend the use of all lowercase letters for variable names\n\n\n\n\n\n\n\nNote\n\n\n\nIdentifying Errors\nOther languages with more strict type systems and variable declarations, may be able to identify logic errors like the one above.\n\n\nHow do we prevent logic errors?\n\nTesting\n\ni.e checking that the actual behaviour of a program matches the expected behaviour\nRun a program with input that will generate a known output when running correctly\n\nVerify the program generates this output\n\n\nTesting doesn’t guarantee a program is correct\n\nTypically hard to check all inputs and use cases\nDoes however give confidence and can provide that a program isn’t correct\n\nTypically tests should be written as the program is created or if using test-driven development the tests are written before the program itself is written\n\nThe statement below also contains a misspelling of the variable total. However, this time the name on the right-hand side of the equals is mispelled. What will happen when this program runs?\n\n # Again clear the notebook variables\n %reset\n\n\n total = 0\n total = Total + 10\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 2\n      1 total = 0\n----&gt; 2 total = Total + 10\n\nNameError: name 'Total' is not defined\n\n\n\n\nIn this case, Total is not defined as a variable, so there is no meaningful way to interpret a value. Hence we would expect an error. Since the error is that Total doesn’t exist, we see a NameError.\n\n\n\n\n\nConsider the Nerves of Steel exercise from Chapter 3. In the game, players must remain standing right up to the moment before they think a random timer will expire\nOne suggestion is that the game might provide more skill if the program told the players how long they had to stand. The game now functions as a “Self-Timer”, the winner is now arguably the person who can best keep track of the time\nThe “game” sequence is\n\nSet the time to remain standing to a random number\nDisplay time to remain standing\nSleep for the time to remain standing\nDisplay a message for the winner\n\nObserve that the time is required to be used in two places, displaying the time remaining and then sleeping for that period of time. This means we need to use a variable to store the value of the time remaining\n# Example 4.1: Self Timer\n#\n# Extends the Nerves of Steel Game from Chapter 3, by adding a skill element\n# with the players being informed of how long they have to stand for\n\nimport random\nimport time\n\nprint(\"Welcome to Self Timer\")\nprint()  # just prints a newline\nprint(\"Everybody stand up\")\nprint(\"Stay standing until you think the time has ended\")\nprint(\"Then sit down\")\nprint(\"Anyone still standing when the time expires loses\")\nprint(\"The last person to sit down before the time ended will win\")\n\nstand_time = random.randint(5, 20)  # generate the time to stand for\n\nprint(\"Stay standing for\", stand_time, \"seconds.\")  # display standing time\ntime.sleep(stand_time)  # sleep for the standing time\nprint(\"****TIMES UP, LAST TO SIT WINS!****\")\n\n\nWelcome to Self Timer\n\nEverybody stand up\nStay standing until you think the time has ended\nThen sit down\nAnyone still standing when the time expires loses\nThe last person to sit down before the time ended will win\nStay standing for 20 seconds.\n****TIMES UP, LAST TO SIT WINS!****\n\n\nMost of the code is just text, but the key takeaway is the line stand_time = random.randint(5, 20) which assigns stand_time the result of random.randint(5, 20), i.e a random number from 5 to 20 inclusive. We then call stand_time is our call to print to display the time, and then sleep for the same amount of time. Observe we couldn’t just write the number into both functions explicitly since it’s randomly generated, we would need to know ahead of time what the value will be\n\n\n\n\n\nVariables can also hold text, e.g. customer_name = 'fred' assigns the string 'fred' to customer_name\nCan use a string variable anywhere we would use a string literal, e.g. message = 'the name is ' + customer_name performs the string concatenation of 'the name is' and the value of customer_name and assigns the result to message, which we can confirm below,\n\n\n  customer_name = \"fred\"\n  message = \"the name is \" + customer_name\n  print(message)\n\nthe name is fred\n\n\n\n\nPython tracks the contents of each variable and only allows operations that make sense. Using the python interpreter experiment with the following combinations of string and number variables.\n\ncustomer_age_in_years = 25\ncustomer_name = 'fred'\n\nAfter entering the above two lines in the interpreter, run the following line\n\ncustomer_age_in_years + customer_name\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[13], line 1\n----&gt; 1 customer_age_in_years + customer_name\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\n\nHere we are trying to add a number and a string, which we saw previously shouldn’t work. The terminal should provide some error output like the below\nNow try the below line\n\ncustomer_age_in_years = 'Fred'\n\nOne might expect the above to generate an error, after all we assign text to a variable that was just storing a number. Instead python simply discards the old numeric value of the variable, and now stores text in customer_age_in_years. You should generally avoid doing this, being able to reason about the type of a variable is typically an important part of safe and effective programming, and the weak typing of python is typically disliked outside of quick prototyping\n\n\n\n\n\n\nNote\n\n\n\nWeak vs Strong Typing\nThe above behaviour is an example of python as a what’s called a weakly typed language. Types are a quite developed part of programming theory that can be discussed later. In some languages, types are enforced to greater degrees of strictness. In some languages (like C) you can assign variables compatible types, i.e. ones that can be converted to the variable’s inate type. In other stricter languages a variable can only hold the exact specified type\nThe more strictly a language enforces its typing system typically the harder it is to generate errors at runtime, however they are often correspondingly more painful to actually write the code in the first place\n\n\n\n\n\n\nPython lets you use either single-quotes (’) or double-quotes (“)\n\nLets us include ’ or ” in a string, by using the alternate delimiter\n\nFor example, compare the two quote snippets,\n\n\nprint(\"It's a trap\")\n\nIt's a trap\n\n\n\nWhereas if we tried to just use single quotes,\n\n\nprint('It's a trap')\n\n\n  Cell In[16], line 1\n    print('It's a trap')\n                      ^\nSyntaxError: unterminated string literal (detected at line 1)\n\n\n\n\n\nThe single quote in It's ends the string, and we get a syntax error detecting what should be the closing single quote as opening a new string literal\nHow do we handle the case where we have mixed quotes in a string?\n\nWe use triple quotes, a series of three single or double quotes in a row, see the example below\n\n\n\nprint('''...and then Luke said \"It's a trap\"''')\n\n...and then Luke said \"It's a trap\"\n\n\n\nTriple quoted strings have the added advantage of capturing newlines. To see this, we could rewrite the intro string in Nerves of Steel as\n\n\nprint('''Welcome to Nerves of Steel\n\nEverybody stand up\nStay standing as long as you dare.\nSit down just before you think the time will end. ''')\n\nWelcome to Nerves of Steel\n\nEverybody stand up\nStay standing as long as you dare.\nSit down just before you think the time will end. \n\n\n\n\n\n\n\n\nCaution\n\n\n\nString Delimiters must Match\nYou must using matching delimiters, if we try to mix them we’ll get an error\n\nprint('hello\")\n\n\n  Cell In[19], line 1\n    print('hello\")\n          ^\nSyntaxError: unterminated string literal (detected at line 1)\n\n\n\n\n\n\n\n\n\n\nEscape sequences are another way to include quote characters\nExtends to other symbols with meaning other than their literal character glyph in a string\nDenoted by the \\ character\n\n\n\n\n\n\n\n\n\nEscape Sequence\nMeaning\nEffect\n\n\n\n\n\\\\\nBackslash character (\\)\nEnter a backslash into a string\n\n\n\\'\nSingle Quote (')\nEnter a single quote into the string\n\n\n\\\"\nDouble Quote (\")\nEnter a double quote into the string\n\n\n\\n\nASCII Line Feed/New Line\nEnd this line and take a new one\n\n\n\\t\nASCII Tab\nMove to the right to the next tab stop\n\n\n\\r\nASCII Carriage Return\nReturn the printing position to the start of the line\n\n\n\\a\nASCII Bell\nSound the bell on the terminal\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nASCII\nASCII (short for American Standard Code for Information Interchange) is an old format for character encoding that covers a small range of symbols including the latin alphabet and digits.\nASCII itself is less used today since it only covers around \\(100\\) characters, which is nowhere near enough to cover all modern languages, before you start adding in characters like emojis. However modern text encodings like unicode are typically backwards compatible with ASCII.\nNot all ASCII escape sequences may work on a modern computer. \\a was designed to ring a mechanical bell on old computers. Some modern computers may play a beep while others may do nothing. Similarly \\r is supposed to return the print head of a computer back to the start of the line. This has very limited use cases, and may not be implemented on all systems.\nThe most common escape characters are newline \\n and escaping quotes\n\n\n\n\n\n\n\n\nImportant\n\n\n\nNewline in Python\nPython uses \\n as the newline character. Technically this is known as a line feed and means “go to the next line”. In Linux and similar operating systems this is equivalent to starting a new line, but in windows going to the start of a new line is achieved via \\r\\n, i.e. return to the start of the line, and then feed to the next. Luckily python handles the conversion between the conventions automatically and we can just use \\n regardless of the operating system we are actually running on\n\n\n\n\nStart a python interpreter and answer the following questions\n\nWhat do you think the following quote would print?\nprint('hello\\nworld')\n\nWe would expect this print hello on one line, then world on the next\n\n\n\nhello\nworld\n\n\nWhat do you think the following would print?\n print('Item\\tSales\\ncar\\t50\\nboat\\t10')\n\nWe can see this prints a series of tab seperated lines. So this is essentially a tab seperated table (a similar format to the more familiar comma-seperated table)\n\n\n\nItem Sales\ncar  50\nboat 10\n\n\n\nThe exact spacing of tab characters can depend on the computer system, and it is quite common for text editors to convert tabs to spaces, so this format isn’t the best. We’ll see other ways to format strings later\n\nHow could I use Python escape sequences to print out this message?\n\nand then Luke said “It’s a trap”\n\n\nWe saw how to do this with triple-delimited strings before. Instead we just have to remember to instead use a single-delimiter string and then escape the quotes that actually form the string contents. See,\n\n\n print('and then Luke said \"It\\'s a trap\"')\n\nand then Luke said \"It's a trap\"\n\n\n\n\nSince the string is delimited by single quotes we only have to delimit the one single quote in It's rather than the two double quotes\n\n\n\n\n\n\nWe’ve seen how to output data with print\nWe can also input data with the appropriately named input\nThe code snippet below, takes input from the user and stores it in name\n\n  name = input()\n\nThe program will pause until the user supplies the input, (Try it yourself in the interpreter!)\nWe can add a display prompt to the input statement\n\n  name = input('Enter your name please: ')\n\nThe above should output something like the below when run\n\n\n\nEnter your name please: \n\n\n\nAs mentioned input passes what it receives into the receiving variable.\n\nIf we just immediately press enter this is the empty string i.e. a string containing no characters\n\ninput is another technique for delaying the end of a program, e.g. the below prints a prompt and then holds the program until some input is received\n\ninput('Press enter to continue...')\n\n\nUse python to create a simple program that will issue a personalised greeting. Create a new program (greeter.py) with the following contents\nname = input('Enter your name please: ')\nprint('Hello', name)\nSave the program and execute it to see the output. For me the proram would output,\n\n\n\nEnter your name please: Felix\n\nHello Felix\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nI’ve used colour to emphase what is my input, versus the program’s output\n\n\n\n\n\n\n\n\n\n\ninput returns a string\n\nFine if we want that, but what if we want to handle numbers?\ne.g. if we wanted to have a user-specified egg timer\n\nint is a function that converts the argument to a whole number e.g.\n\ntime_text = input('Enter the cooking time in seconds: ') #receive time in seconds\ntime_int = int(time_next) #perform conversion to number\n\n\n\nThe complete program would then look like,\n  # Example 4.3: Configurable Egg Timer\n  #\n  # Reads in a user specified time to set the timer for\n\n  import time\n\n  time_text = input(\"Enter the cooking time in seconds: \")\n  time_int = int(time_text)\n\n  print(\"Put the egg in boiling water now\")\n  input(\"Press enter to continue once the egg is in...\")\n\n  time.sleep(time_int)\n\n  print(\"Take the egg out now\")\nThis basic pattern works just as well for an alarm as it does for a configurable timer\n\n\n\n\nConsider the previous example, and answer the following questions\n\nHow many variables are used in the program above?\n\ntwo, the first time_text stores the initial text input, while the second time_int contains the converted numeric representation\n\nCould you write the program without the time_text variable?\n\nYes, we could immediately pass the input result to int, e.g.\n\n time_int = int(input('Enter the cooking time in seconds: '))\n\nIt’s an open debate which format is clearer. In the second there’s more to grok on one line, but the whole workflow is there\n\nWhat do you think will happen if the user enters something other than a number?\n\nLet us find out,\n\n\n x = int('kaboom')\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[25], line 1\n----&gt; 1 x = int('kaboom')\n\nValueError: invalid literal for int() with base 10: 'kaboom'\n\n\n\n\nWe get an error, int tries to convert the string 'kaboom' to an integer, which it clearly cant\nThe art of programming to handle invalid input like the above is called error-handling, we’ll see that later\n\n\n\n\n\n\n\nThere are two types of numbers\n\nWhole numbers or integers\n\nAre always held accurately by the computer\n\nReal numbers (or representations of) or floating point\n\nContain a fractional component\nMust be truncated to be stored in memory, so cannot always be stored accurately\n\n\n\n\n\nLearn about the differences between whole numbers and real numbers through the following questions\n\nI’m building a device that can count the number of hairs on your head. Should this be stored as a whole or real number?\n\nInteger, we generally wouldn’t count fractions of a hair\nAlternatively, given how many hairs there are, and that we might not care about being precise, we might instead want to use a real number to store the approximate magnitude\n\nI want to use my hair-counting machine on \\(100\\) people and determine the average number of hairs on all their heads. Should I use this value as a whole or real number?\n\nWe expect that the average will not be a whole number, so we should store it as a real number\nAlternatively, we may not care about getting the number exact down to the fraction, so we could use a whole number to round to the nearest number\n\nI want to keep track of the price of a product in my program. Should I use whole numbers or real numbers?\n\nNaively we would a real number, however as we mentioned real numbers have some uncertainty stored in them\nWhen dealing with financial values we need to maintain that precision\n\nInstead we might then use whole cents\n\nWorks straightforward if we only care about the total\nIf we care about averages, or fractions of a total then we might have to reconsider\n\nThere are techniques used to control the error in a real number calculation\n\n\n\n\nAs you can see the argument of what numerical type to use, requires understanding both the nature of the value itself, and what you want to do with it. You can then consider the properties of the numeric representation and choose the most appropriate one\n\n\n\n\n\n\n\nImportant\n\n\n\nThe way you store a variable depends on what you want to do with it\nAs the discussion above highlights, sometimes the answer to how we want to store data is not the immediate first answer. It’s important to consider not just what the natural representation of a value is, but what it’s purpose in the code is.\nFor example as we discussed above, money is naturally expressed as real numbers. However due to the it’s use case, which requires high precision and also generally a limited range (values of even a trillion are rare, and we typically only consider down to whole cents) compared to the full range of a floating point number we might want to look at alternative representations\n\n\n\n\n\n\n\nReal numbers have a fractional part\n\nTheir representation may not align 1:1 with what was originally input\n\nThe most common way to store real numbers is called floating point\n\nThe floating means that the decimal point moves around in the representation, as opposed to a fixed point representation which has a set number of digits after the decimal point\nUsing more memory to store a float lets us store it with greater precision, but we can never accurately represent all floating point numbers\n\nReal numbers can be defined by range and precision\n\nPrecision governs how precisely a number is stored e.g. a float may be able to store \\(123456789.0\\) or \\(0.123456789\\) but not \\(123456789.987654321\\) because the precision required is too great\nRange determines how much we can slide the decimal point to represent large or small numbers e.g. we could store \\(123456700\\) or \\(0.0001234567\\)\nIn Python floats have \\(15-16\\) digits of precision and can range from \\(10^{308}\\) and \\(10^{-324}\\)\n\nA quirk of floating point is that some apparently simple numbers like \\(0.1\\) can’t be stored exactly\n\n\n\nConduct the following experiments in the python shell to learn about floating points\n\nWhat happens if we try to store a value that can’t be held accurately as a floating-point value?\n\n0.1\n\n0.1\n\n\n\nAbove we said that \\(0.1\\) couldn’t be exactly represented, but that doesn’t match with what we just saw. The answer is because the error in the representation is very small, and print rounds off the answer\n\nDoes the rounding really happen? Run the following and comment on the result\n\n 0.1 + 0.2\n\n0.30000000000000004\n\n\n\nWe expected the answer to be \\(0.3\\) but instead we see a slight error. This is because there is an error accumulation from adding \\(0.1\\) to \\(0.2\\) and the underlying floating point representations\n\n\n\nThese issues are not python specific. They are an inate challenge of trying to represent real numbers on hardware. Modern floating-point numbers are also an internationally recognised standard which lets different programs and hardware talk to each other.\nPython differs from some languages in only providing a single floating point type that is \\(8\\) bytes. In many languages this is referred to as a double-precision floating point or just a double and is one of several floating point types\n\n\n\n\n\n\n\nWarning\n\n\n\nDon’t confuse precision with accuracy\nNumbers don’t become more accurate when they are stored with more precision. Scientists often measure values with a measure of uncertainty which captures how sure they are in the accuracy of their number. There is no point storing a value to \\(15\\) decimal places of precision, if the accuracy of a measurement is only to \\(1-2\\) places, e.g. if we measure with a ruler\nUsing higher precision can result in slower programs that use more memory\n\n\n\nPython automatically creates variables for use in programs\nThe type of a variable is determined by what is stored in it\n\nname = 'Rob'\nage = 25\n\nThe above creates two variables\n\nOne name is a string type\nThe other age is an int or integer type\n\n\n\n\n\nWork through the following following questions to understand how floating-point variables work?\n\nHow do you create a floating point variable?\n\nYou can create a floating point variable by assigning a floating point number e.g. the below creates a variable* x *and assigns it the floating point value \\(1.5\\)\n\n\n x = 1.5\n x\n\n1.5\n\n\nWhat happens if you assign an integer to a floating point variable?\n\nThe below assigns the integer value \\(1.0\\) to a variable y\nIf we print the value back we can see it keeps the decimal, indicating it is a floating point value\n\n\n y = 1.0\n y\n\n1.0\n\n\n\ni.e. by writing the decimal point we coerce the type of y to be floating point\n\nWhat happens when we mix floating point and integers in calculations?\n\nIf we compare the two additions below, we can see that when we add floating points, the addition stays a floating point even if the result is integral\n\n\n 2 + 2\n\n4\n\n\n\n 2.0 + 2.0\n\n4.0\n\n\n\nIf we mix a floating point and integer type we can also see that the result is returned as a floating point (even when the final result is integral)\n\n\n 2 + 2.0\n\n4.0\n\n\n\nLastly what happens if we divide two coprime integers?\nWe see that the result gives the appropriate floating point fraction\n\n\n 1/2\n\n0.5\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nInteger Division\nWhile the last point about division behaviour may seem obvious if you haven’t programmed before you would do well to be careful. In many common languages, division of two integers is treated as integer division. In this case the result is always an integer with the result being rounded according to some scheme. Three common schemes are towards zero, in which the result is always rounded towards the number \\(0\\); towards the nearest, where the result is rounded to the nearest whole number and floored division in which the number is rounded towards negative infinity.\n\n\n\n\n\n\n\n\nDivision\nExample\nInterpretation\n\n\n\n\ntowards zero\n\\(-1/2 = 0\\)\nDiscard decimal digits\n\n\ntowards nearest\n\\(3.2/2 = 2\\)\nMinimise the difference between “true” division and result\n\n\nfloored division\n\\(-1/2 = -1\\)\nRound “down”\n\n\n\nPython lets you perform integer division using floored division behaviour with the // operator e.g.\n\n-1//2\n\n-1\n\n\n\n\n\n\n\n\n\nConverting string to float, works identically to as for int but we use float instead\n\ne.g. We could rewrite the configurable egg timer with floats as,\n\n\ntime_text = input('Enter the cooking time in seconds: ')\ntime_float = float(time_text)\n\n\n\nThe complete program would then look like\n\n# Example 4.4 Ultra-Precise Egg Timer\n#\n# A version of the Configurable Egg Timer using floating point for the input time\n\nimport time\n\ntime_text = input(\"Enter the cooking time in seconds: \")\ntime_float = float(time_text)\n\nprint(\"Put the egg in boiling water now\")\ninput(\"Press enter to continue once the egg is in...\")\n\ntime.sleep(time_float)\n\nprint(\"Take the egg out now\")\n\nThe code is the same except we make the subsitution int \\(\\to\\) float\n\n\n\n\n\n\nAs mentioned before python is an expression evaluator\nAn expression consists of operators and operands\nPython evaluates an expression left to right, and carries out operations according to their order of operations\n\nAnalogous to mathematical order of operations (and includes them) but must extend for programming specific syntax\nAs in maths, parentheses are used to enforce an evaluation order\n\n\n\n\n\nOperator\nUsecase\n\n\n\n\n-\nUnary minus, denotes a negative number\n\n\n*\nMultiplication (inlieu of \\(\\times\\))\n\n\n/\nDivision\n\n\n+\nAddition\n\n\n-\nbinary minus or subtraction\n\n\n\n\nBasic operators and their precedence\n\n\n\nSee if you can work out the values of a, b and c when the following statements are evaluated,\n    a = 1\n    b = 2\n    c = a + b\n\n    c = c * (a + b)\n    b = a + b + c\nThe first three lines give a = \\(1\\), b = \\(2\\) and c = \\(3\\). Substituting those into the second evaluation for c,\n\na = 1\nb = 2\nc = a + b\nc = 3 * (1 + 2)\nc\n\n9\n\n\nSo c is assigned \\(9\\). We then repeat for the second assignment to b to get,\n\nb = 1 + 2 + 9\n\nSo the final values are, a = \\(1\\), b = \\(12\\), c = \\(9\\). If we execute the original cell we can confirm this\n\na = 1\nb = 2\nc = a + b\n\nc = c * (a + b)\nb = a + b + c\n\nprint('a: ', a)\nprint('b: ', b)\nprint('c: ', c)\n\na:  1\nb:  12\nc:  9\n\n\n\n\n\n\n\n\nCaution\n\n\n\nDumb Calculations\nPython won’t try and stop you if you do something that mathematically makes no sense like dividing a number by zero, instead an error is raised, but this won’t occur until your program runs! Therefore when using division you should always take care to make sure you either handling division by zero cases appropriately or preventing them from occuring\n\n1/0\n\n\n---------------------------------------------------------------------------\nZeroDivisionError                         Traceback (most recent call last)\nCell In[38], line 1\n----&gt; 1 1/0\n\nZeroDivisionError: division by zero\n\n\n\nWhen using other languages, they may not raise and error, instead unexpected behaviour may occur including your program crashing.\n\n\n\n\n\n\n\nWe saw floatcan be used to convert a string to a float.\n\nIt can also be used to convert an integer value to a floating point value, e.g.\n\n\n\nz = float(1)\nz\n\n1.0\n\n\n\nIf we want to go the other way we can use int to convert a float to an int.\n\nThe number is rounded towards zero, i.e. fractional components are truncated (see the callout-box above about integer division)\n\n\n\ni = int(2.9)\ni\n\n2\n\n\n\n\nConsider the following program which is designed to calculate the number of pizzas needed for a hackathon with \\(x\\) number of particpants using the heuristic that \\(1\\) pizza can satisfy \\(1.5\\) people\n# Example 4.5: Pizza Order Calculator\n#\n# A basic pizza order calculator based on the heuristic that 1 pizza = 1.5 people fed\n\nstudents_int = int(\n    input(\"How many students are attending? \")\n)  # read in string, convert to int and store\npizza_count = students_int / 1.5  # perform division int -&gt; float\nprint(\"You will need\", pizza_count, \"pizzas\")\nNote, that I’ve modified the code to directly pass the input to int and then to a variable, to demonstrate that it’s possible.\nThe above program has the problem that for any number not divisible by \\(1.5\\), the program recommends ordering a fractional number of pizzas. This is generally not possible, so we need to convert the output to an integer.\n\nModify the program to return an int by calling int directly during the calculation of pizza_count. What potential problems does this solution have?\n # Exercise 4.1.1: Pizza Order Calculator\n #\n # A basic pizza order calculator based on the heuristic that 1 pizza = 1.5 people fed\n\n students_int = int(\n     input(\"How many students are attending? \")\n )  # read in string, convert to int and store\n pizza_count = students_int / 1.5  # perform division int -&gt; float\n print(\"You will need\", pizza_count, \"pizzas\")\n\nThis method has the disadvantage that it will tend to underestimate the number of pizzas needed.\nFor example if we needed to feed \\(40\\) people, the program would give us \\(26\\), which can satisfy, \\(39\\) people, meaning someone goes hungry\n\nModify the program to return an int by calling int to convert the division to an int then adding \\(1\\). Explain how this changes the behaviour\n # Exercise 4.1.2: Pizza Order Calculator\n #\n # A basic pizza order calculator based on the heuristic that 1 pizza = 1.5 people fed\n # Converts the rseult to an integer using int on pizza_count then adding one\n # has the disadvantage it will tend to overestimate the number of pizzas needed\n\n students_int = int(\n     input(\"How many students are attending? \")\n )  # read in string, convert to int and store\n pizza_count = int(students_int / 1.5) + 1  # perform division int -&gt; float\n print(\"You will need\", pizza_count, \"pizzas\")\n\nThis method will tend to add an additional spare pizza or overestimate the number of pizzas needed.\nSince it’s generally better for there to be a little left over than someone go hungry, this behaviour is probably preferred.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nNever assume you know what a program is supposed to do\nWhen faced with a choice like the above for the pizza order calculator for a product being made by a client, you should not decide what the expected behaviour is yourself. For example, in the above the customer may prefer to round down the number of pizzas to reduce cost.\nNever assume you know what the program should do, ask the client\n\n\n\n\n\nWrite a program to convert from Fahrenheit to Centigrade. The formula for this is\n\\[\n\\begin{align}\n\\text{Centrigrade} &= \\frac{\\text{Fahrenheit} - 32}{1.8}\n\\end{align}\n\\]\nOur solution is very similar to the Pizza Calculator, but with some of the text changed. The other major difference is that we want to be able to accept a float value, and output a float value.\n    # Exercise 4.2: Fahrenheit to Celcius\n    #\n    # Converts Fahrenheit to Celcius\n\n    temperature_fahrenheit = float(\n        input(\"Enter a temperature in Fahrenheit: \")\n    )  # read in string, convert to float\n    temperature_centrigrade = (temperature_fahrenheit - 32) / 1.8\n    print(\"The temperature is\", temperature_centrigrade, \"degrees Celcius\")\nA sample output may look like,\n\n\n\nEnter a temperature in Fahrenheit: 0\n\nThe temperature is -17.77777777777778 degrees Celcius\n\n\n\n\n\nLater we’ll see how we can format the output to be a bit more presentable\n\n\n\n\n\n\n\nSnaps contains a function get_weather_temp for to return the temperature of a location in the United States\n\nData is scraped from the US National Weather Service website\nFunction takes the latitude and longitude as an argument\n\n\n\n\n\nThe following program can be used to get the current temperature reading from Seattle using snaps\n\n  # Example 4.6: Seattle Temperature\n  #\n  # Get the current temperature in Seattle\n\n  import snaps\n\n  temp = snaps.get_weather_temp(latitude=47.61, longitude=-122.33)\n\n  print(\"The temperature in Seattle is:\", temp)\n\npygame 2.6.1 (SDL 2.28.4, Python 3.12.3)\nHello from the pygame community. https://www.pygame.org/contribute.html\nThe temperature in Seattle is: 37\n\n\n/home/runner/work/BeginToCodeWithPython/BeginToCodeWithPython/.venv/lib/python3.12/site-packages/pygame/pkgdata.py:25: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools&lt;81.\n  from pkg_resources import resource_stream, resource_exists\n\n\n\n\n\n\n\nWe can also use snaps to get a short description of the current weather\n\n  # Example 4.7: Seattle Weather\n  #\n  # Uses snaps to get a description of the weather in Seattle\n\n  import snaps\n\n  desc = snaps.get_weather_desciption(latitude=47.61, longitude=-122.33)\n  print(\"The conditions are:\", desc)\n\nThe conditions are: Clear\n\n\n\n\n\n\nWrite a program that displays the current weather conditions. If you use the display_text function from snaps, your program can display the current weather and description\nOur solution is written below,\n# Exercise 4.3: Weather Display\n#\n# Displays the Weather in Seattle\n\nimport snaps\n\ntemperature_fahrenheit = snaps.get_weather_temp(latitude=47.61, longitude=-122.33)\ntemperature_string = \"The temperature in Seattle is: \" + str(temperature_fahrenheit)\n\nweather_descr = snaps.get_weather_desciption(latitude=47.61, longitude=-122.33)\nweather_descr_string = \"The conditions are: \" + str(weather_descr)\n\nweather_string = temperature_string + \"\\n\" + weather_descr_string\n\nsnaps.display_message(weather_string, size=100)\n\ninput(\"Press enter to continue...\")\nAs we can see most the actual getting of the temperature and weather data is the same as for the Seattle Temperature and Weather programs. The rest of the work is done to construct the appropriate strings and merge them together so they can be passed to the display_message function for output",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 4: Working With Variables"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/04_WorkingWithVariables/Chapter_04.html#summary",
    "href": "01_ProgrammingFundamentals/04_WorkingWithVariables/Chapter_04.html#summary",
    "title": "Chapter 4: Working With Variables",
    "section": "Summary",
    "text": "Summary\n\nVariables can be created\n\nVariables are effectively named regions of memory\nVariables must start with a letter or underscore and can only consist of alphanumeric characters or underscores\n\nData can be viewed as two fundamental types, text or numeric\n\nstring is a type for holding text\n\ninput can be used to get strings from the user\nint and float can convert a string to an integer or floating point number respectively\n\nNumeric values have two forms\n\nint for whole numbers with no fractional part\nfloat for real numbers with a fractional part\n\nfloat only approximate real numbers and can be subject to some errors",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 4: Working With Variables"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/04_WorkingWithVariables/Chapter_04.html#questions-and-answers",
    "href": "01_ProgrammingFundamentals/04_WorkingWithVariables/Chapter_04.html#questions-and-answers",
    "title": "Chapter 4: Working With Variables",
    "section": "Questions and Answers",
    "text": "Questions and Answers\n\nWhat happens if I “overwrite” a variable of one type with a value of another type?\n\nPython replaces the old variable with a new one of the same name but the new type\n\nDoes using a long variable name slow the program down?\n\nIf it does it is insignificant, it’s much more important to use a name that clearly conveys meaning\n\nCan we write all our programs using floating point numbers?\n\nYou could, but you should use int where appropriate because float representation is inexact and subject to errors\n\nThese errors mean that it is often hard to compare for exact equality e.g. 1.0 might actually have the representation 1.0000...4\n\n\nCan I stop my program from crashing if someone types in an invalid input?\n\nYes, this is called error handling. This will be covered later in Chapter 6",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 4: Working With Variables"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/02_PythonAndProgramming/Chapter_02.html",
    "href": "01_ProgrammingFundamentals/02_PythonAndProgramming/Chapter_02.html",
    "title": "Chapter 2: Python and Programming",
    "section": "",
    "text": "The ability to solve a program yourself\nConvert that solution into something the computer understands\n\n\n\n\nProgramming is problem solving\nA key part of programming is properly defining the problem and scope\n\nIn real projects this may take the form of a functional design specification\n\nA well defined problem is easy to reason about\n\n\n\n\n\n\n\nTip\n\n\n\nSpecifications must always exist\nOne should never write a program without getting a solid specification first. Defining a specification is essential even(or perhaps especially) when I do a job for a friend\n\n\n\nModern design techniques emphasise prototyping\n\nThe use of successive versions to solicit customer feedback\n\n\n\n\n\n\nThe best programmers are also good communicators\nEffective communication extends to writing\n\nHelps write code that more clearly articulates your point\n\n\n\n\n\n\n\n\nTip\n\n\n\nCommunication leads to the most interesting work\nInteresting tasks go to developers who are good communicators. They can articulate their ideas and liase with customers\n\n\n\n\n\n\n\n\n\nComputers automate instructions\n\nThey follow given instructions\nConvert input data into output data\n\nComputers are typically unware of the veracity of their data\n\nNo inate ability to question, or error recover\n\n\n\n\n\n\n\nblock-beta\n    columns 3\n    space\n    title[\"Examples of Typical Data-Processing Applications\"]\n    space\n\n    block:Input\n    columns 1\n        Inputs\n        radio[\"Radio Signals and Touchpad\"]\n        car[\"Temperature, Pressures, Throttle\"]\n        game[\"Gamepad\"]\n    end\n\n    block:Middle\n    columns 1\n        space\n        phone[\"Mobile Phone\"]\n        carMiddle[\"Car\"]\n        console[\"Console\"]\n    end\n\n    block:Output\n    columns 1\n        Outputs\n        phoneOut[\"Sound, Pictures\"]\n        carOut[\"Fuel Injector, Ignition timings\"]\n        consoleOut[\"Gameplay\"]\n    end\n\n    radio--&gt;phone\n    phone--&gt;phoneOut\n    car--&gt;carMiddle\n    carMiddle--&gt;carOut\n    game--&gt;console\n    console--&gt;consoleOut\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass Inputs BG\nclass Outputs BG\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nSoftware might be a matter of life or death\nSeemingly innocent programs can have real consequences. E.g. a program that calculates drug dosages may be used by a doctor. Therac-25 is the classic example.\n\n\n\n\n\n\n\n\n\n\n---\ntitle: Computers as Data Processors\nconfig:\n  flowchart:\n    htmlLabels: false\n---\nflowchart LR\n\ninput((\"Input\"))\ncomputer[\"Computer\"]\noutput((\"Output\"))\n\ninput--&gt;computer\ncomputer--&gt;output\n\n\n\n\n\n\n\nAs discussed computers can be seen as data transformers\nWe can view this as similar to following a recipe\n\n\n\n\n\n\n---\ntitle: Recipes as Programs\nconfig:\n  flowchart:\n    htmlLabels: false\n---\nflowchart LR\n\nflour((\"Flour\"))\nsugar((\"Sugar\"))\nmilk((\"Milk\"))\neggs((\"Eggs\"))\n\nhuman[\"Human following\n     recipe\"]\n\ncake((\"Cake\"))\n\nflour--&gt;human\nsugar--&gt;human\nmilk--&gt;human\neggs--&gt;human\n\nhuman--&gt;cake\n\n\n\n\n\n\n\n\n\n\nPython is effectively one of the ways we can make a computer do things\n\n\n\n\n\n\n---\ntitle: Python as a Data Processor\nconfig:\n  flowchart:\n    htmlLabels: false\n---\nflowchart LR\n\ninput((\"Python\n        Commands\"))\ncomputer[\"Python Command Shell\"]\noutput((\"Results\"))\n\ninput--&gt;computer\ncomputer--&gt;output\n\n\n\n\n\n\n\nCommands are the input which are processed by the python command shell (the computer) and turned into results (output)\n\n\n\n\nStart up a python interpreter and run the following\n\nhello\n\nhello\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[1], line 1\n----&gt; 1 hello\n\nNameError: name 'hello' is not defined\n\n\n\n\nThe interpreter doesn’t recognise the arbitrary word hello and produces an error message\n\n2\n\n2\n\n2\n\n\n\nThe interpreter echoes a number back out!\n\n2 + 2\n\n2 + 2\n\n4\n\n\n\nThe interpreter evaluates and echoes out the arithmetic!\n\n\n2 + 2 in the previous example is a representation of an expression\nPython can be seen as an expression evaluator. An expression consists of operators that act on operands to produce new output\nWe can break down the 2+2 example from the previous example to\n\n\n\n\n\n\nblock-beta\n    columns 3\n    space\n    title[\"Breakdown of a Simple Expression\"]\n    space\n\n    block:Input\n    columns 1\n        operand1[\"2\"]\n        operand1Word[\"Operand\"]\n        operand1descr[\"(thing to work on)\"]\n    end\n\n    block:Middle\n    columns 1\n        operator[\"+\"]\n        operatorWord[\"Operator\"]\n        operatorDescr[\"(thing to do)\"]\n    end\n\n    block:Output\n    columns 1\n        operand2[\"2\"]\n        operand2Word[\"Operand\"]\n        operand2descr[\"(thing to work on)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass operand2Word BG\nclass operand2descr BG\nclass operand1Word BG\nclass operand1descr BG\nclass operatorWord BG\nclass operatorDescr BG\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAs seen in the previous example, when invalid code is entered into the shell, an error message occurs. The same happens for an incomplete expression. e.g. the following is a shell sequence,\n\n2+\n\n\n  Cell In[4], line 1\n    2+\n      ^\nSyntaxError: invalid syntax\n\n\n\n\n\n\n\n\n\n\nWhat do you think would happen if you tried to evaluate 2+3*4?\n\nWe would expect 14 from the basic mathematical order of operations. Plugging this into the shell,\n\n\n 2 + 3 * 4\n\n14\n\n\nWhat do you think would happen if you tried to evaluate (2+3)*4?\n\nWe would expect 20 from the basic mathematical order of operations. Plugging this into the shell,\n\n\n (2 + 3) * 4\n\n20\n\n\nWhat do you think would happen if you tried to evaluate (2+3*4?\n\nWe might expect a syntax error\nInstead the interpreter, simply goes to a new line, and waits for us to enter the matching parenthesis\nOne such sequence in the shell might be,\n\n\n (2 + 3 * 4\n )\n\n14\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThere a different implementations of the Python Interpreter\nThese notes use a slightly different version of a python interpreter called a Jupyter Notebook to render the inline code. In Jupyter Notebooks code is written in cells and executed cell-by cell. This means that the interpreter can’t wait for the user to provide the missing input, so instead we get the slightly different error message below,\n\n\n\n (2 + 3 * 4\n\n\n  Cell In[8], line 1\n    (2 + 3 * 4\n              ^\nSyntaxError: incomplete input\n\n\n\n\nWhat do you think would happen if you tried to evaluate )2+3*4?\n\nIf we see a right parenthesis before a left parenthesis there is no way to retroactively go back and fix the missing left, like in the previous case where the shell simply waited for us to add the parenthesis\nSo here we would expect a syntax error\n\n\n )2+3*4\n\n\n  Cell In[9], line 1\n    )2+3*4\n    ^\nSyntaxError: unmatched ')'\n\n\n\n\n\n\n\n\n\n\nWe can use the interpreter like this to work line by line because python is a “scripting” language\n\ni.e. The program reads a line and then interprets the output\n\n\n\n\n\n\n\n\nNote\n\n\n\nNot all languages are scripting languages\nNot all languages are scripting languages. Some are converted to low-level hardware instructions. This is called compilation, and in place of an interpreter it requires a compiler to convert the code. Compiled programs are typically faster, since they can be optimised\n\n\n\n\n\n\n\nComputers fundamentally represent data as \\(0\\) or \\(1\\) in binary\n\nWe build up layers of abstract that let us handle concepts like numbers, characters and strings of text\n\nData can be regarded as the stored values representing information\nInformation is thus the interpretation of data, to mean something\n\n\n\n\nPython scripts thus can be considered data processors\n\nThe script is interpreted and converted to output\n\n\n\n\nStart up the python interpreter and run the following\n\n'hello'\n\n 'hello'\n\n'hello'\n\n\n\nLike before with \\(2\\) the word is echoed.\n\n'hello' + ' world'\n\n 'hello' + 'world'\n\n'helloworld'\n\n\n\n“Adding” two words performs a string concatenation\nObserve we explicitly have to include the space character in one of the strings\nA cool observation is that + changes it’s behaviour in response to what it’s arguments are\n\n\n\n\n\n\nWhat do you think would happen if missed the closing quote of a string you were typing?\n\nWe would expect it, to either hang waiting for the closing quote like with the missing left parenthesis, or a syntax error like a right quote. We find,\n\n  'hello\n\n\n  Cell In[12], line 1\n    'hello\n    ^\nSyntaxError: unterminated string literal (detected at line 1)\n\n\n\n\nEOL stands for “End of Line”\nOperands like strings and numbers can’t span multiple lines\nA string literal is just a string there in the code\n\nWhat do you think would happen if you tried to subtract one string from another?\n\nWhile addition of strings can be easily seen as concatenation, there is no meaningful equivalent for substraction.\nWe could think of it as substring removal, but that has a lot of nuance that is hard to capture in a single symbol. We expect an error.\n\n  'hello' - ' world'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[13], line 1\n----&gt; 1 'hello' - ' world'\n\nTypeError: unsupported operand type(s) for -: 'str' and 'str'\n\n\n\nThe error message is somewhat obtuse but simply means that for the operand (-) we can’t subtract a string from another string\nTypeError indicates that something has gone wrong with the type of the data (here the type is string)\n\nWhat do you think would happen if you tried to add a number to a string?\n\nThis one can vary. There a two valid interpretations,\n\nYou can’t add a number to a word\nTreat the number as word, and concatenate it\n\nMost languages, use the former choice and so we make the assumption that python does too\n\n\n 'hello' + 2\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[14], line 1\n----&gt; 1 'hello' + 2\n\nTypeError: can only concatenate str (not \"int\") to str\n\n\n\n\nThe result is as expected, the error tells we can only concatenate a string to another string\n\nWhat do you think would happen if you tried to multiply a string by a number?\n\nAgain there are two interpretations,\n\nYou can’t multiply a word by a number\nYou can consider word * 3 as adding word three lots of word, where adding is string concatenation\n\nLets see what choice python uses,\n\n  'hello' * 3\n\n'hellohellohello'\n\n\nThe moral? Python tries to do something sensible when it can\n\n\n\n\n\n\n\nPython seperates numerical data (e.g. 2) from text data (e.g. '2')\n\nNumerics and text are stored differently\n\nBehaviour of operators depends on the data types fed into them as operands\n\n\n\n\n\n\nA function is behaviour with a distinct name\n\ne.g. “Move left” is name for a distinct behaviour\n\nPython comes bundled with a number of built-in functions\n\n\n\n\n\n\n\nImportant\n\n\n\nFunctions are a critical part of programming languages\nLearning a new language often involves learning the functions it natively supports.\n\n\n\n\n\nord is a short name for ordinal value\n\nBuilt-in function, mean’s “give me the number representing this character”\nLet’s examine the use,\n\nord('W')\n\n87\n\n\n\n\n\n\nStart up a python interpreter, and run the following,\n\nord('W')\n\n ord('W')\n\n87\n\n\n\nThis matches our first example\n\nord(W)\n\n ord(W)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[18], line 1\n----&gt; 1 ord(W)\n\nNameError: name 'W' is not defined\n\n\n\n\nHere we get an error\nord is quite pedantic, requiring it’s argument to be a single character string\n\n\n\nObserve a function is called with the structure (using ord as an example),\n\n\n\n\n\n\nblock-beta\n    columns 4\n    space\n    title[\"Function Call Structure\"]:2\n    space\n\n    block:name\n    columns 1\n        ord[\"ord\"]\n        functionName[\"function name\"]\n        fndescr[\"(thing we want done)\"]\n    end\n\n    block:leftParenthesis\n    columns 1\n        leftP[\"(\"]\n        leftPname[\"Parenthesis\"]\n        space\n    end\n\n    block:argumentblock\n    columns 1\n        argument[\"'W'\"]\n        argumentName[\"argument\"]\n        argumentDescr[\"(thing to give function)\"]\n    end\n\n    block:rightParenthesis\n    columns 1\n        rightP[\")\"]\n        rightPname[\"Parenthesis\"]\n        space\n    end\n\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass ord BG\nclass functionName BG\nclass fndescr BG\nclass leftP BG\nclass leftPname BG\nclass argument BG\nclass argumentName BG\nclass argumentDescr BG\nclass rightP BG\nclass rightPname BG\n\n\n\n\n\n\n\n\n\n\n\nThe chr function is the counterpart to ord\n\nConverts numbers to text\n\n\n  chr(87)\n\n'W'\n\n\n\n\n\nStart up a python interpreter, and run the following,\n\nchr(87)\n\n chr(87)\n\n'W'\n\n\n\nExactly what we saw before, and what we would expect from ord\n\nchr(88)\n\n chr(88)\n\n'X'\n\n\n\nObserve that there is some logical progression.\nX comes after W in the alphabet, and does so in numerical representation\n\n\n\nInternational standards govern text representation\n\nHowever, older languages, software or hardware that predates these standards may not follow them\n\n\n\n\n\n\n\nAs mentioned before, computers store data in binary\nEach \\(0\\) or \\(1\\) is called a bit, a byte is typically a collection of \\(8\\) bits, and the smallest addressable unit of memory\nBytes can be grouped together to represent larger blocks of data\nbin converts a number to a string containing it’s binary representation\n\n\n\nUse the bin function to investigate how data is stored in a computer, start by running,\n\nbin(87)\n\n'0b1010111'\n\n\n\nbin returns a string giving the binary representation\n\ni.e. a string of 1’s and 0’s\n\nThe prefix 0b indicates that the remaining suffix is the binary representation of a number\n\n\n\n\nAnswer the following questions about binary representations\n\nWhat does the binary value of \\(0\\) look like?\n\nWould expect this to also be \\(0\\)\n\n\n bin(0)\n\n'0b0'\n\n\nWhat does the binary value of \\(1\\) look like?\n\nWould also expect this to be \\(1\\)\n\n\n bin(1)\n\n'0b1'\n\n\nWhat does the binary value of \\(2\\) look like?\n\nIn binary, digits are in columns of powers of \\(2\\) i.e. \\(1\\) like before is viewed as \\(1 \\times 2^{0}\\)\n\\(2\\) can be viewed as \\(1 \\times 2^{1} + 0 \\times 2^{0}\\), so we would expect the representation to be \\(10\\)\n\n\n bin(2)\n\n'0b10'\n\n\nWhat do you think the binary value of \\(11\\) means?\n\nIf we consider the above discussion, we expect this to be decimal \\(3\\)\n\n\n 3\n\n3\n\n\nHow does the binary value \\(86\\) differ from the binary value of \\(87\\)?\n\nLets look at 87 first.\n\n\n bin(87)\n\n'0b1010111'\n\n\n\n\\(86\\) differs by one, so we would expect \\(86\\) to be \\(1010110\\)\n\n\n bin(86)\n\n'0b1010110'",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 2: Python and Programming"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/02_PythonAndProgramming/Chapter_02.html#notes",
    "href": "01_ProgrammingFundamentals/02_PythonAndProgramming/Chapter_02.html#notes",
    "title": "Chapter 2: Python and Programming",
    "section": "",
    "text": "The ability to solve a program yourself\nConvert that solution into something the computer understands\n\n\n\n\nProgramming is problem solving\nA key part of programming is properly defining the problem and scope\n\nIn real projects this may take the form of a functional design specification\n\nA well defined problem is easy to reason about\n\n\n\n\n\n\n\nTip\n\n\n\nSpecifications must always exist\nOne should never write a program without getting a solid specification first. Defining a specification is essential even(or perhaps especially) when I do a job for a friend\n\n\n\nModern design techniques emphasise prototyping\n\nThe use of successive versions to solicit customer feedback\n\n\n\n\n\n\nThe best programmers are also good communicators\nEffective communication extends to writing\n\nHelps write code that more clearly articulates your point\n\n\n\n\n\n\n\n\nTip\n\n\n\nCommunication leads to the most interesting work\nInteresting tasks go to developers who are good communicators. They can articulate their ideas and liase with customers\n\n\n\n\n\n\n\n\n\nComputers automate instructions\n\nThey follow given instructions\nConvert input data into output data\n\nComputers are typically unware of the veracity of their data\n\nNo inate ability to question, or error recover\n\n\n\n\n\n\n\nblock-beta\n    columns 3\n    space\n    title[\"Examples of Typical Data-Processing Applications\"]\n    space\n\n    block:Input\n    columns 1\n        Inputs\n        radio[\"Radio Signals and Touchpad\"]\n        car[\"Temperature, Pressures, Throttle\"]\n        game[\"Gamepad\"]\n    end\n\n    block:Middle\n    columns 1\n        space\n        phone[\"Mobile Phone\"]\n        carMiddle[\"Car\"]\n        console[\"Console\"]\n    end\n\n    block:Output\n    columns 1\n        Outputs\n        phoneOut[\"Sound, Pictures\"]\n        carOut[\"Fuel Injector, Ignition timings\"]\n        consoleOut[\"Gameplay\"]\n    end\n\n    radio--&gt;phone\n    phone--&gt;phoneOut\n    car--&gt;carMiddle\n    carMiddle--&gt;carOut\n    game--&gt;console\n    console--&gt;consoleOut\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass Inputs BG\nclass Outputs BG\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nSoftware might be a matter of life or death\nSeemingly innocent programs can have real consequences. E.g. a program that calculates drug dosages may be used by a doctor. Therac-25 is the classic example.\n\n\n\n\n\n\n\n\n\n\n---\ntitle: Computers as Data Processors\nconfig:\n  flowchart:\n    htmlLabels: false\n---\nflowchart LR\n\ninput((\"Input\"))\ncomputer[\"Computer\"]\noutput((\"Output\"))\n\ninput--&gt;computer\ncomputer--&gt;output\n\n\n\n\n\n\n\nAs discussed computers can be seen as data transformers\nWe can view this as similar to following a recipe\n\n\n\n\n\n\n---\ntitle: Recipes as Programs\nconfig:\n  flowchart:\n    htmlLabels: false\n---\nflowchart LR\n\nflour((\"Flour\"))\nsugar((\"Sugar\"))\nmilk((\"Milk\"))\neggs((\"Eggs\"))\n\nhuman[\"Human following\n     recipe\"]\n\ncake((\"Cake\"))\n\nflour--&gt;human\nsugar--&gt;human\nmilk--&gt;human\neggs--&gt;human\n\nhuman--&gt;cake\n\n\n\n\n\n\n\n\n\n\nPython is effectively one of the ways we can make a computer do things\n\n\n\n\n\n\n---\ntitle: Python as a Data Processor\nconfig:\n  flowchart:\n    htmlLabels: false\n---\nflowchart LR\n\ninput((\"Python\n        Commands\"))\ncomputer[\"Python Command Shell\"]\noutput((\"Results\"))\n\ninput--&gt;computer\ncomputer--&gt;output\n\n\n\n\n\n\n\nCommands are the input which are processed by the python command shell (the computer) and turned into results (output)\n\n\n\n\nStart up a python interpreter and run the following\n\nhello\n\nhello\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[1], line 1\n----&gt; 1 hello\n\nNameError: name 'hello' is not defined\n\n\n\n\nThe interpreter doesn’t recognise the arbitrary word hello and produces an error message\n\n2\n\n2\n\n2\n\n\n\nThe interpreter echoes a number back out!\n\n2 + 2\n\n2 + 2\n\n4\n\n\n\nThe interpreter evaluates and echoes out the arithmetic!\n\n\n2 + 2 in the previous example is a representation of an expression\nPython can be seen as an expression evaluator. An expression consists of operators that act on operands to produce new output\nWe can break down the 2+2 example from the previous example to\n\n\n\n\n\n\nblock-beta\n    columns 3\n    space\n    title[\"Breakdown of a Simple Expression\"]\n    space\n\n    block:Input\n    columns 1\n        operand1[\"2\"]\n        operand1Word[\"Operand\"]\n        operand1descr[\"(thing to work on)\"]\n    end\n\n    block:Middle\n    columns 1\n        operator[\"+\"]\n        operatorWord[\"Operator\"]\n        operatorDescr[\"(thing to do)\"]\n    end\n\n    block:Output\n    columns 1\n        operand2[\"2\"]\n        operand2Word[\"Operand\"]\n        operand2descr[\"(thing to work on)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass operand2Word BG\nclass operand2descr BG\nclass operand1Word BG\nclass operand1descr BG\nclass operatorWord BG\nclass operatorDescr BG\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAs seen in the previous example, when invalid code is entered into the shell, an error message occurs. The same happens for an incomplete expression. e.g. the following is a shell sequence,\n\n2+\n\n\n  Cell In[4], line 1\n    2+\n      ^\nSyntaxError: invalid syntax\n\n\n\n\n\n\n\n\n\n\nWhat do you think would happen if you tried to evaluate 2+3*4?\n\nWe would expect 14 from the basic mathematical order of operations. Plugging this into the shell,\n\n\n 2 + 3 * 4\n\n14\n\n\nWhat do you think would happen if you tried to evaluate (2+3)*4?\n\nWe would expect 20 from the basic mathematical order of operations. Plugging this into the shell,\n\n\n (2 + 3) * 4\n\n20\n\n\nWhat do you think would happen if you tried to evaluate (2+3*4?\n\nWe might expect a syntax error\nInstead the interpreter, simply goes to a new line, and waits for us to enter the matching parenthesis\nOne such sequence in the shell might be,\n\n\n (2 + 3 * 4\n )\n\n14\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThere a different implementations of the Python Interpreter\nThese notes use a slightly different version of a python interpreter called a Jupyter Notebook to render the inline code. In Jupyter Notebooks code is written in cells and executed cell-by cell. This means that the interpreter can’t wait for the user to provide the missing input, so instead we get the slightly different error message below,\n\n\n\n (2 + 3 * 4\n\n\n  Cell In[8], line 1\n    (2 + 3 * 4\n              ^\nSyntaxError: incomplete input\n\n\n\n\nWhat do you think would happen if you tried to evaluate )2+3*4?\n\nIf we see a right parenthesis before a left parenthesis there is no way to retroactively go back and fix the missing left, like in the previous case where the shell simply waited for us to add the parenthesis\nSo here we would expect a syntax error\n\n\n )2+3*4\n\n\n  Cell In[9], line 1\n    )2+3*4\n    ^\nSyntaxError: unmatched ')'\n\n\n\n\n\n\n\n\n\n\nWe can use the interpreter like this to work line by line because python is a “scripting” language\n\ni.e. The program reads a line and then interprets the output\n\n\n\n\n\n\n\n\nNote\n\n\n\nNot all languages are scripting languages\nNot all languages are scripting languages. Some are converted to low-level hardware instructions. This is called compilation, and in place of an interpreter it requires a compiler to convert the code. Compiled programs are typically faster, since they can be optimised\n\n\n\n\n\n\n\nComputers fundamentally represent data as \\(0\\) or \\(1\\) in binary\n\nWe build up layers of abstract that let us handle concepts like numbers, characters and strings of text\n\nData can be regarded as the stored values representing information\nInformation is thus the interpretation of data, to mean something\n\n\n\n\nPython scripts thus can be considered data processors\n\nThe script is interpreted and converted to output\n\n\n\n\nStart up the python interpreter and run the following\n\n'hello'\n\n 'hello'\n\n'hello'\n\n\n\nLike before with \\(2\\) the word is echoed.\n\n'hello' + ' world'\n\n 'hello' + 'world'\n\n'helloworld'\n\n\n\n“Adding” two words performs a string concatenation\nObserve we explicitly have to include the space character in one of the strings\nA cool observation is that + changes it’s behaviour in response to what it’s arguments are\n\n\n\n\n\n\nWhat do you think would happen if missed the closing quote of a string you were typing?\n\nWe would expect it, to either hang waiting for the closing quote like with the missing left parenthesis, or a syntax error like a right quote. We find,\n\n  'hello\n\n\n  Cell In[12], line 1\n    'hello\n    ^\nSyntaxError: unterminated string literal (detected at line 1)\n\n\n\n\nEOL stands for “End of Line”\nOperands like strings and numbers can’t span multiple lines\nA string literal is just a string there in the code\n\nWhat do you think would happen if you tried to subtract one string from another?\n\nWhile addition of strings can be easily seen as concatenation, there is no meaningful equivalent for substraction.\nWe could think of it as substring removal, but that has a lot of nuance that is hard to capture in a single symbol. We expect an error.\n\n  'hello' - ' world'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[13], line 1\n----&gt; 1 'hello' - ' world'\n\nTypeError: unsupported operand type(s) for -: 'str' and 'str'\n\n\n\nThe error message is somewhat obtuse but simply means that for the operand (-) we can’t subtract a string from another string\nTypeError indicates that something has gone wrong with the type of the data (here the type is string)\n\nWhat do you think would happen if you tried to add a number to a string?\n\nThis one can vary. There a two valid interpretations,\n\nYou can’t add a number to a word\nTreat the number as word, and concatenate it\n\nMost languages, use the former choice and so we make the assumption that python does too\n\n\n 'hello' + 2\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[14], line 1\n----&gt; 1 'hello' + 2\n\nTypeError: can only concatenate str (not \"int\") to str\n\n\n\n\nThe result is as expected, the error tells we can only concatenate a string to another string\n\nWhat do you think would happen if you tried to multiply a string by a number?\n\nAgain there are two interpretations,\n\nYou can’t multiply a word by a number\nYou can consider word * 3 as adding word three lots of word, where adding is string concatenation\n\nLets see what choice python uses,\n\n  'hello' * 3\n\n'hellohellohello'\n\n\nThe moral? Python tries to do something sensible when it can\n\n\n\n\n\n\n\nPython seperates numerical data (e.g. 2) from text data (e.g. '2')\n\nNumerics and text are stored differently\n\nBehaviour of operators depends on the data types fed into them as operands\n\n\n\n\n\n\nA function is behaviour with a distinct name\n\ne.g. “Move left” is name for a distinct behaviour\n\nPython comes bundled with a number of built-in functions\n\n\n\n\n\n\n\nImportant\n\n\n\nFunctions are a critical part of programming languages\nLearning a new language often involves learning the functions it natively supports.\n\n\n\n\n\nord is a short name for ordinal value\n\nBuilt-in function, mean’s “give me the number representing this character”\nLet’s examine the use,\n\nord('W')\n\n87\n\n\n\n\n\n\nStart up a python interpreter, and run the following,\n\nord('W')\n\n ord('W')\n\n87\n\n\n\nThis matches our first example\n\nord(W)\n\n ord(W)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[18], line 1\n----&gt; 1 ord(W)\n\nNameError: name 'W' is not defined\n\n\n\n\nHere we get an error\nord is quite pedantic, requiring it’s argument to be a single character string\n\n\n\nObserve a function is called with the structure (using ord as an example),\n\n\n\n\n\n\nblock-beta\n    columns 4\n    space\n    title[\"Function Call Structure\"]:2\n    space\n\n    block:name\n    columns 1\n        ord[\"ord\"]\n        functionName[\"function name\"]\n        fndescr[\"(thing we want done)\"]\n    end\n\n    block:leftParenthesis\n    columns 1\n        leftP[\"(\"]\n        leftPname[\"Parenthesis\"]\n        space\n    end\n\n    block:argumentblock\n    columns 1\n        argument[\"'W'\"]\n        argumentName[\"argument\"]\n        argumentDescr[\"(thing to give function)\"]\n    end\n\n    block:rightParenthesis\n    columns 1\n        rightP[\")\"]\n        rightPname[\"Parenthesis\"]\n        space\n    end\n\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass ord BG\nclass functionName BG\nclass fndescr BG\nclass leftP BG\nclass leftPname BG\nclass argument BG\nclass argumentName BG\nclass argumentDescr BG\nclass rightP BG\nclass rightPname BG\n\n\n\n\n\n\n\n\n\n\n\nThe chr function is the counterpart to ord\n\nConverts numbers to text\n\n\n  chr(87)\n\n'W'\n\n\n\n\n\nStart up a python interpreter, and run the following,\n\nchr(87)\n\n chr(87)\n\n'W'\n\n\n\nExactly what we saw before, and what we would expect from ord\n\nchr(88)\n\n chr(88)\n\n'X'\n\n\n\nObserve that there is some logical progression.\nX comes after W in the alphabet, and does so in numerical representation\n\n\n\nInternational standards govern text representation\n\nHowever, older languages, software or hardware that predates these standards may not follow them\n\n\n\n\n\n\n\nAs mentioned before, computers store data in binary\nEach \\(0\\) or \\(1\\) is called a bit, a byte is typically a collection of \\(8\\) bits, and the smallest addressable unit of memory\nBytes can be grouped together to represent larger blocks of data\nbin converts a number to a string containing it’s binary representation\n\n\n\nUse the bin function to investigate how data is stored in a computer, start by running,\n\nbin(87)\n\n'0b1010111'\n\n\n\nbin returns a string giving the binary representation\n\ni.e. a string of 1’s and 0’s\n\nThe prefix 0b indicates that the remaining suffix is the binary representation of a number\n\n\n\n\nAnswer the following questions about binary representations\n\nWhat does the binary value of \\(0\\) look like?\n\nWould expect this to also be \\(0\\)\n\n\n bin(0)\n\n'0b0'\n\n\nWhat does the binary value of \\(1\\) look like?\n\nWould also expect this to be \\(1\\)\n\n\n bin(1)\n\n'0b1'\n\n\nWhat does the binary value of \\(2\\) look like?\n\nIn binary, digits are in columns of powers of \\(2\\) i.e. \\(1\\) like before is viewed as \\(1 \\times 2^{0}\\)\n\\(2\\) can be viewed as \\(1 \\times 2^{1} + 0 \\times 2^{0}\\), so we would expect the representation to be \\(10\\)\n\n\n bin(2)\n\n'0b10'\n\n\nWhat do you think the binary value of \\(11\\) means?\n\nIf we consider the above discussion, we expect this to be decimal \\(3\\)\n\n\n 3\n\n3\n\n\nHow does the binary value \\(86\\) differ from the binary value of \\(87\\)?\n\nLets look at 87 first.\n\n\n bin(87)\n\n'0b1010111'\n\n\n\n\\(86\\) differs by one, so we would expect \\(86\\) to be \\(1010110\\)\n\n\n bin(86)\n\n'0b1010110'",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 2: Python and Programming"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/02_PythonAndProgramming/Chapter_02.html#summary",
    "href": "01_ProgrammingFundamentals/02_PythonAndProgramming/Chapter_02.html#summary",
    "title": "Chapter 2: Python and Programming",
    "section": "Summary",
    "text": "Summary\n\nComputers view data as binary\nComputers process input data into output data\nHumans intepret data as information\nComputers do not naturally understand meaningful or nonsense input or output\nA program is the process of telling a computer how to convert input data into output data\n\nProgramming languages are a way to write these programs that the computer understands\n\nPython is one such language\n\nIt can also be viewed as a program that takes language statements, and then converts them to orders for the computer to carry out\n\nProgrammers create sequences of instructions to describe the task a computer needs to carry out\n\nGood code means knowing what the code needs to do\nFormal requirements solicitation and communication skills are key for programmers",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 2: Python and Programming"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/02_PythonAndProgramming/Chapter_02.html#question-and-answers",
    "href": "01_ProgrammingFundamentals/02_PythonAndProgramming/Chapter_02.html#question-and-answers",
    "title": "Chapter 2: Python and Programming",
    "section": "Question and Answers",
    "text": "Question and Answers\n\nWould a computer “know” that its stupid for someone to have an age of \\(-20\\)?\n\nNo. As far as the computer is concerned, the age valueis just a pattern of bits that represents a number. If we want a computer to reject negative ages, we must actually build that understanding into the program\n\nIf the output from a program is settings for the fuel-injection system on a car, is the output data or information?\n\nAs soon as something starts acting on data, it becomes information. A human being is not doing anything with these values, but they will cause the speed of the engine to change, which might affect humans, so this makes the output information rather than data by the authors opinion\n\nIs the computer stupid because it can’t understand English?\n\nNo, english can be a quite ambiguous languge. The legal profession is an example of somewhere were debate over the semantics of language is tricky\n\nIf I don’t know how to solve a problem, can I write a program to do it?\n\nNo, you need to understand the solution before you can write it and make sure that it does exactly what you want it to do\n\nIs it sensible to assume the customer measures everything in inches?\n\nIt’s never sensible to assume anything about a project. Every assumption increases the chance of a potential disaster\n\nIf the program does the wrong thing, is it my fault or the customer’s fault?\n\n\n\n\nSpecification?\nProgram?\nWhose Fault?\n\n\n\n\nRight\nWrong\nProgrammer\n\n\nWrong\nRight\nCustomer\n\n\nWrong\nWrong\nEveryone",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 2: Python and Programming"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/03_PythonProgramStructure/Chapter_03.html",
    "href": "01_ProgrammingFundamentals/03_PythonProgramStructure/Chapter_03.html",
    "title": "Chapter 3: Python Program Structure",
    "section": "",
    "text": "A program is a sequence of actions performed in order\n\nA script is a type of program that often repeats a series of simple tasks\n\nPython programs are stored as text files, traditionally with a .py extension\n\n\n\n\nTo run a program, you first need to write it. Any text editor should do.\n\n\n\nOpen a text editor and enter the following into the file,\n2+2\nSave the file somewhere appropriate with a name and the .py extension. Then run the program, if you have IDLE you can run it through that. I personally use the command line as\npython path-to-file\nYou may need to use python3 or python3.X depending on how your environment is setup where X is the python subversion. The code should execute but produce no output\n\n\n\n\n\nWhy did the example produce an empty output when run as a program, but \\(4\\) when run through the interpreter?\n\nProgram returns \\(4\\) to the caller, which for the program, is the shell that executes it\nWhat we really want is to output to the user\n\n\n\n\n\n\n\n---\ntitle: Python Data Processing with I/O\nconfig:\n  flowchart:\n    htmlLabels: false\n---\nflowchart LR\n\ninput((\"Python\n        Commands\"))\ncomputer[\"Python Command Shell\"]\noutput((\"Results\"))\nuser[\"User\"]\n\ninput--&gt;computer\ncomputer--&gt;output\nuser &lt;--&gt; computer\n\n\n\n\n\n\n\nWe want the program to be able to interact with the user to provide output, and request input\n\nThe first such function we need is print\n\n\n\n\nWrite a python file (using_print.py) with the following contents\n\nprint(2+2)\n\n4\n\n\nNow run the program. It should produce the same output as above (\\(4\\)). On my machine, running the following in terminal, leads to the output \\(4\\) as expected\npython using_print.py\n4\nNow create a new file (using_print2.py) with the following contents\n\nprint('The answer is: ')\nprint(2 + 2)\n\nThe answer is: \n4\n\n\nSave and run this file. The output should match the above\nObserve here that the program automatically adds a new line, if we want to avoid that we can instead write\n\nprint('The answer is:', 2+2)\n\nThe answer is: 4\n\n\nWrite and run a new file (using_print3.py) containing the above line and check the output matches the above.\nHere we see that one of the ways to call print is to provide a comma seperated list of values. By default print adds a space between these elements\n\n\n\n\n\n\nCaution\n\n\n\nThere are several ways a python program can fail, for example\n\nprint('The answer is: '}\n\n\n  Cell In[4], line 1\n    print('The answer is: '}\n                           ^\nSyntaxError: closing parenthesis '}' does not match opening parenthesis '('\n\n\n\n\nleads to a syntax error, because the wrong parentheses have been used. Or,\n\nPrint(2 + 2)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[5], line 1\n----&gt; 1 Print(2 + 2)\n\nNameError: name 'Print' is not defined\n\n\n\nleads to a NameError because function names are case sensitive, and we have put Print not print. Proper use of tooling can catch these syntax and other errors before you run the code, however sometimes errors slip through and you end up with errors occuring at run time!\n\n\n\n\n\n\n\n\nLibraries provide additional built in functions, like ord and chr already seen\nLibraries can be supplied built-in, i.e. supplied with the python install, or installed later\n\n\n\n\nProvides a source of random numbers\nTo add a library we use the import command, e.g. import random\n\ni.e. import then the name of the library\n\nWe can then use functions from the library with the format, module_name.function_name(arguments)\n\ne.g. for random we can use randint as random.randint(1,6) to generate a random number from \\(1\\) to \\(6\\)\n\n\n\n\nWrite and run a python program containing the following lines\n\nimport random\nprint('You have rolled:', random.randint(1,6))\n\nYou have rolled: 5\n\n\nTry running this program multiple times and see what the output is\n\n\n\n\n\n\nCaution\n\n\n\nModules and the Interpreter\nIf we try calling random.randint without importing random we will get a NameError since neither random or randint will be recognised by the interpreter.\nIf we get the name of the module wrong, e.g. import Random, then we should get a ModuleNotFoundError\n\n\n\nThe python shell and most modern text editors can access documentation about pythons functions to help you with using them\nTypically this is obtained by hovering over the function name. Try this in your setup, in mine I get the documentation:\n\ndef randint(a : int, b : int) -&gt; int\nReturn random integer in range [a,b], including both end points\n\n\n\n\n\nThe time function contains functions for managing dates and times\nThe sleep function lets a program for a given time period\n\nTells the operating system to pause execution of the program for a set time period\nOther programs continue running as normal\n\n\n\n\nWrite and execute the following program\n\nimport time\nprint('I will need to think about that...')\ntime.sleep(5)\nprint('The answer is: 42')\n\nI will need to think about that...\nThe answer is: 42\n\n\nYou should see the program print the first line, pause for about \\(5\\) seconds, then print the second line. The above cell should show the code after all lines have run\n\n\nMake an egg timer program. The program should allow the user to time a 5-minute boiled egg. You can do this by modifying the example sleep program which paused for \\(5\\) seconds. For extra style points, you could make the program print, “Nearly cooked, get your spoon ready,” \\(30\\) seconds before the \\(5\\)-minute deadline. You could even expand this into an interactive recipe program that describes the steps to be performed at each point in the recipe and then pauses until the next step is performed\nCurrently we haven’t been show a way to get input from the user so we can’t add that final step of interactivity. But the first two are fairly simple. There are \\(300\\) seconds in \\(5\\) minutes. So we want to tell the user to put the egg in, then sleep for \\(270\\) seconds, then print our message to get ready, sleep for another \\(30\\) seconds then tell the user to remove the egg.\nThe final code is then, (with sample output)\nimport time\n\nprint('Make sure the water is boiling!!!')\nprint('Drop the egg in...')\ntime.sleep(270)\nprint('Nearly cooked, get your spoon ready')\ntime.sleep(300)\nprint('Egg cooked, remove now.')\n\n\nMake sure the water is boiling!!!\nDrop the egg in...\nNearly cooked, get your spoon ready\nEgg cooked, remove now.\n\n\n\n\n\n\n\n\n\nComments are used to add metadata to code, i.e. extra information that does not impact how the code is run\ne.g. version numbers, authorship attribution, modification dates\nA comment is marked with a # and extends to the end of the line\n\n# Exercise 3.1 Egg Timer Program\n\nimport time\n\nprint(\"Make sure the water is boiling!!!\")\nprint(\"Drop the egg in...\")\ntime.sleep(270)\nprint(\"Nearly cooked, get your spoon ready\")\ntime.sleep(300)\nprint(\"Egg cooked, remove now.\")\n\nComments can be added at the end of statements, e.g.\n\ntime.sleep(300) #sleep while egg cooks (300 seconds or 5 minutes)\n\nThe above comment is good because it explains why the function is called\nA bad comment simply repeats the code\nComments have a maintainence overhead, you must keep them consistent with the surrounding code or they will generate confusion\n\n\n\n\n\nYou can use sleep to delay the end of a program. This can be useful in some environments where the calling window automatically closes after the program finishes execution, sleep lets you actually see the output\n\n\n\n\n\nsnaps is a library provided with the book code that provides simple functions for working with text, images and sound\nUses the pygame library\n\n\n\n\nPygame is a not packaged with python: we have to install it\nNormally this is done through a package manager, pip is a python package manager provided with python\nIn a terminal run one of the following lines,\n\npy -m pip install pygame --user #Windows\npython -m pip install pygame --user #Mac or Linux\n\nYou may need to use python3 instead of python\n\n\n\n\n\n\n\nTip\n\n\n\nInstalling and Managing Packages\nInstalling python packages and python package management is a whole issue. In general one should prefer virtual environments, user installations to isolate packages to the specific project. A program that I use that assists with all of this is called uv. In uv a package is added with the command uv add package-name. Package management and uv is a complicated topic, but to get started look at their homepage which is quite well documented.\n\n\n\n\n\n\nThe snaps library, is a python file contained in the provided book sample code, in each chapter folder with examples.\n\nIf you want to use snaps we could install it, but this is a bit more involved than where we are at right now\nInstead simply copy it into the same folder as any python file that wants to use it\n\n\n\n\n\nsnaps contains a display_message function that takes a string of text and displays it on the screen\nThe first example uses the most basic form of display_message\n\n# Example 3.5.1 Displaying Text via Snaps\n\nimport time\n\nfrom snaps import *\n\ndisplay_message(\"hello world\")\ntime.sleep(5)  # add a sleep so the window doesn't autoclose\n\nThe above creates a window with red text saying ‘Hello World’.\n\nWe’ve added the sleep so the window doesn’t automatically close - see discussion about Delaying the end of a program\n\nThe from snaps import * is an alternate import structure\n\nIt tells us from the module snaps import everything (*)\nThis means we don’t need to use the snaps prefix\nGenerally avoid doing this as it can mean that different packages with the same function names will cause naming clashes\n\nPython functions support optional arguments\n\nThese are arguments that have some default supplied value\nWe can customise these to change function behaviour\n\nThe second example uses these optional arguments to change the size, colour and alignment of the text\n\n# Example 3.5.2 Displaying Text via Snaps\n#\n# Extends the previous example by demonstrating\n# adding color, size, text position\n\nimport time\n\nimport snaps\n\nsnaps.display_message(\n    \"This is smaller text in green on the top left\",\n    color=(0, 255, 0),\n    size=50,\n    horiz=\"left\",\n    vert=\"top\",\n)\ntime.sleep(5)  # add a sleep for 5 seconds so the window doesn't autoclose\n\n\n\n\nLike display_message, the display_image function in snaps can be used to display an image file.\nFunction takes the path to the image and can be an png or jpeg\nText can be overlayed on an image by calling display_message after display_image\nFor example: Displaying Images\nHere we use display_image to render a jpeg, with some overlayed text\n\n# Example 3.6 Display Image\n#\n# display an image using snaps library\n\nimport time\n\nimport snaps\n\nsnaps.display_image(\"Housemartins.jpg\")\nsnaps.display_message(\"Hull Rocks\", color=(255, 255, 255), vert=\"top\")\n\ntime.sleep(5)\n\nAgain note, that sleep is used to prevent the window from closing\nThe order of the display messages matters, try changing the order and seeing the result\n\n\n\n\n\nWe have text and images, the last we need is sound, snaps has the play_sound function for this purpose\nSee the example in Playing Sounds\nHere we use play_sound to play a .wav audio file\n\n# Example 3.7 Play Sound\n#\n# play an audio file using snaps\n\nimport time\n\nimport snaps\n\nsnaps.play_sound(\"ding.wav\")\ntime.sleep(5)\n\nAgain, note we need to use sleep to prevent the program immediately ending, which will make it seem like the sound doesn’t play!\nIf you want to work with audio files, a commonly used program is Audacity\n\n\n\n\n\n\nYou can use the snaps program to add visuals and sound to some of the previous examples\n\n\n\nLets use the snaps program to make a GUI version of our egg timer program\nOur implementation essentially replaces the print with snaps display_message\n# Exercise 3.2 Improved Egg Timer\n#\n# Reimplements the Egg Timer Exercise using the snaps library\n# to add a visual and audio component\n\nimport time\n\nimport snaps\n\nsnaps.display_image(\"egg_timer_background.png\")\nsnaps.display_message(\n    \"Drop the egg in boiling water\", color=(255, 0, 0), vert=\"top\", size=100\n)\ntime.sleep(270)\nsnaps.display_message(\n    \"Nearly cooked, get your spoon ready!\", color=(0, 0, 255), size=100\n)\ntime.sleep(30)\nsnaps.play_sound(\"ding.wav\")\nsnaps.display_message(\n    \"Egg cooked, remove now.\", color=(0, 255, 0), vert=\"bottom\", size=100\n)\ntime.sleep(30)\n\nWe first set the background using display_image\n\nThis means the text will appear over the top of the background image\n\nWe then display the initial message\n\nThis is displayed in red, at the top, we adjust the size of the text to \\(100\\) so the text fits on the window\n\nWe then sleep for the first \\(4.5\\) minutes\nWe then inform the user that there is \\(30\\) seconds to go, like in the original code.\n\nThis time the text is displayed in blue, and migrates to the middle of the screen\n\nWe then sleep again for the last \\(30\\) seconds\nFinally we first play a sound to alert the user\nWe then display the message that the egg is ready\n\nThis time at the bottom and in red\n\nWe then sleep for \\(30\\) seconds so the user has time to notice and hear the sound\n\n\n\n\nUse the random number generator and sleep to make a high-low party game. The game works like this,\n\nThe program displays a number between \\(1\\) and \\(10\\) inclusive\nThe program then sleeps for \\(20\\) seconds. While the program is asleep, the players are invited to decide if the next number is higher or lower than the number just printed. Players who chose high stand on the right. Players who chose low stand on the left\nThe program then displays a second number between \\(1\\) and \\(10\\), and anyone who was wrong is eliminated from the game. The program is then re-run with the players that are left until you have a winner\n\nFor fun we use snaps for our implementation to make this visual\n# Exercise 3.3 High-Low\n#\n# Implements the High-Low Party game\n# Generates a random number in the interval [1, 10]\n# Sleeps for a period of time\n# Shows another number\n# Players are asked to guess if this second number will be higher or lower\n\nimport random\nimport time\n\nimport snaps\n\nsnaps.display_message(\"The first number is...\")\ntime.sleep(5)  # sleep so people can read the first message\nsnaps.display_message(random.randint(1, 10))\ntime.sleep(3)  # leave time to read the number\nsnaps.display_message(\"Will the next be higher or lower?\")\n\n# sleep for 20 seconds total, with a message to raise the tension with 5s left\ntime.sleep(15)\nsnaps.display_message(\"The second number is...\")\ntime.sleep(5)\n\nsnaps.display_message(random.randint(1, 10))\ntime.sleep(10)  # leave time for the players to read\n\nObserve that we have to wrap the display_message calls with calls to sleep to ensure that there is time for the user to read the messages\nThe output of (a terminal implementation of the program) should look something like,\n\n\n\nThe first number is:  10\nWill the next be higher or lower?\nThe second number is:  1\n\n\n\n\n\nUse the random number generator and sleep to make a Nerves of Steel game. This game works like this\n\nThe program displays “Players Stand”\nThe program sleeps for a random time between \\(5\\) and \\(20\\) seconds. While the program is sleeping, players can sit down. Keep track of the last person to sit down\nThe program displays “Last to sit down wins.” Players still standing are eliminated, and the winner is the last person to sit down\n\nAgain for fun we’ll use snaps to make a basic window.\n# Exercise 3.4 Nerves of Steel\n#\n# Implements the Nerves of Steel Party Game\n# Players stand\n# Generates a random time interval\n# All players standing after the time interval expires lose\n# Last to sit down before the interval expires wins\n\nimport random\nimport time\n\nimport snaps\n\nsnaps.display_message(\"Players Stand\")\ntime.sleep(random.randint(5, 20))\nsnaps.display_message(\"Last to sit down wins\", color=(0, 255, 0))\n\ntime.sleep(5)  # so program doesn't immediately end\n\nWe add a sleep at the end so the players have time to read the text. We also switch the final text from the initial red to green to celebrate the winner\nThe output of a terminal-based implementation might look like,\n\n\n\nPlayers Stand\nLast to sit down wins",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 3: Python Program Structure"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/03_PythonProgramStructure/Chapter_03.html#notes",
    "href": "01_ProgrammingFundamentals/03_PythonProgramStructure/Chapter_03.html#notes",
    "title": "Chapter 3: Python Program Structure",
    "section": "",
    "text": "A program is a sequence of actions performed in order\n\nA script is a type of program that often repeats a series of simple tasks\n\nPython programs are stored as text files, traditionally with a .py extension\n\n\n\n\nTo run a program, you first need to write it. Any text editor should do.\n\n\n\nOpen a text editor and enter the following into the file,\n2+2\nSave the file somewhere appropriate with a name and the .py extension. Then run the program, if you have IDLE you can run it through that. I personally use the command line as\npython path-to-file\nYou may need to use python3 or python3.X depending on how your environment is setup where X is the python subversion. The code should execute but produce no output\n\n\n\n\n\nWhy did the example produce an empty output when run as a program, but \\(4\\) when run through the interpreter?\n\nProgram returns \\(4\\) to the caller, which for the program, is the shell that executes it\nWhat we really want is to output to the user\n\n\n\n\n\n\n\n---\ntitle: Python Data Processing with I/O\nconfig:\n  flowchart:\n    htmlLabels: false\n---\nflowchart LR\n\ninput((\"Python\n        Commands\"))\ncomputer[\"Python Command Shell\"]\noutput((\"Results\"))\nuser[\"User\"]\n\ninput--&gt;computer\ncomputer--&gt;output\nuser &lt;--&gt; computer\n\n\n\n\n\n\n\nWe want the program to be able to interact with the user to provide output, and request input\n\nThe first such function we need is print\n\n\n\n\nWrite a python file (using_print.py) with the following contents\n\nprint(2+2)\n\n4\n\n\nNow run the program. It should produce the same output as above (\\(4\\)). On my machine, running the following in terminal, leads to the output \\(4\\) as expected\npython using_print.py\n4\nNow create a new file (using_print2.py) with the following contents\n\nprint('The answer is: ')\nprint(2 + 2)\n\nThe answer is: \n4\n\n\nSave and run this file. The output should match the above\nObserve here that the program automatically adds a new line, if we want to avoid that we can instead write\n\nprint('The answer is:', 2+2)\n\nThe answer is: 4\n\n\nWrite and run a new file (using_print3.py) containing the above line and check the output matches the above.\nHere we see that one of the ways to call print is to provide a comma seperated list of values. By default print adds a space between these elements\n\n\n\n\n\n\nCaution\n\n\n\nThere are several ways a python program can fail, for example\n\nprint('The answer is: '}\n\n\n  Cell In[4], line 1\n    print('The answer is: '}\n                           ^\nSyntaxError: closing parenthesis '}' does not match opening parenthesis '('\n\n\n\n\nleads to a syntax error, because the wrong parentheses have been used. Or,\n\nPrint(2 + 2)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[5], line 1\n----&gt; 1 Print(2 + 2)\n\nNameError: name 'Print' is not defined\n\n\n\nleads to a NameError because function names are case sensitive, and we have put Print not print. Proper use of tooling can catch these syntax and other errors before you run the code, however sometimes errors slip through and you end up with errors occuring at run time!\n\n\n\n\n\n\n\n\nLibraries provide additional built in functions, like ord and chr already seen\nLibraries can be supplied built-in, i.e. supplied with the python install, or installed later\n\n\n\n\nProvides a source of random numbers\nTo add a library we use the import command, e.g. import random\n\ni.e. import then the name of the library\n\nWe can then use functions from the library with the format, module_name.function_name(arguments)\n\ne.g. for random we can use randint as random.randint(1,6) to generate a random number from \\(1\\) to \\(6\\)\n\n\n\n\nWrite and run a python program containing the following lines\n\nimport random\nprint('You have rolled:', random.randint(1,6))\n\nYou have rolled: 5\n\n\nTry running this program multiple times and see what the output is\n\n\n\n\n\n\nCaution\n\n\n\nModules and the Interpreter\nIf we try calling random.randint without importing random we will get a NameError since neither random or randint will be recognised by the interpreter.\nIf we get the name of the module wrong, e.g. import Random, then we should get a ModuleNotFoundError\n\n\n\nThe python shell and most modern text editors can access documentation about pythons functions to help you with using them\nTypically this is obtained by hovering over the function name. Try this in your setup, in mine I get the documentation:\n\ndef randint(a : int, b : int) -&gt; int\nReturn random integer in range [a,b], including both end points\n\n\n\n\n\nThe time function contains functions for managing dates and times\nThe sleep function lets a program for a given time period\n\nTells the operating system to pause execution of the program for a set time period\nOther programs continue running as normal\n\n\n\n\nWrite and execute the following program\n\nimport time\nprint('I will need to think about that...')\ntime.sleep(5)\nprint('The answer is: 42')\n\nI will need to think about that...\nThe answer is: 42\n\n\nYou should see the program print the first line, pause for about \\(5\\) seconds, then print the second line. The above cell should show the code after all lines have run\n\n\nMake an egg timer program. The program should allow the user to time a 5-minute boiled egg. You can do this by modifying the example sleep program which paused for \\(5\\) seconds. For extra style points, you could make the program print, “Nearly cooked, get your spoon ready,” \\(30\\) seconds before the \\(5\\)-minute deadline. You could even expand this into an interactive recipe program that describes the steps to be performed at each point in the recipe and then pauses until the next step is performed\nCurrently we haven’t been show a way to get input from the user so we can’t add that final step of interactivity. But the first two are fairly simple. There are \\(300\\) seconds in \\(5\\) minutes. So we want to tell the user to put the egg in, then sleep for \\(270\\) seconds, then print our message to get ready, sleep for another \\(30\\) seconds then tell the user to remove the egg.\nThe final code is then, (with sample output)\nimport time\n\nprint('Make sure the water is boiling!!!')\nprint('Drop the egg in...')\ntime.sleep(270)\nprint('Nearly cooked, get your spoon ready')\ntime.sleep(300)\nprint('Egg cooked, remove now.')\n\n\nMake sure the water is boiling!!!\nDrop the egg in...\nNearly cooked, get your spoon ready\nEgg cooked, remove now.\n\n\n\n\n\n\n\n\n\nComments are used to add metadata to code, i.e. extra information that does not impact how the code is run\ne.g. version numbers, authorship attribution, modification dates\nA comment is marked with a # and extends to the end of the line\n\n# Exercise 3.1 Egg Timer Program\n\nimport time\n\nprint(\"Make sure the water is boiling!!!\")\nprint(\"Drop the egg in...\")\ntime.sleep(270)\nprint(\"Nearly cooked, get your spoon ready\")\ntime.sleep(300)\nprint(\"Egg cooked, remove now.\")\n\nComments can be added at the end of statements, e.g.\n\ntime.sleep(300) #sleep while egg cooks (300 seconds or 5 minutes)\n\nThe above comment is good because it explains why the function is called\nA bad comment simply repeats the code\nComments have a maintainence overhead, you must keep them consistent with the surrounding code or they will generate confusion\n\n\n\n\n\nYou can use sleep to delay the end of a program. This can be useful in some environments where the calling window automatically closes after the program finishes execution, sleep lets you actually see the output\n\n\n\n\n\nsnaps is a library provided with the book code that provides simple functions for working with text, images and sound\nUses the pygame library\n\n\n\n\nPygame is a not packaged with python: we have to install it\nNormally this is done through a package manager, pip is a python package manager provided with python\nIn a terminal run one of the following lines,\n\npy -m pip install pygame --user #Windows\npython -m pip install pygame --user #Mac or Linux\n\nYou may need to use python3 instead of python\n\n\n\n\n\n\n\nTip\n\n\n\nInstalling and Managing Packages\nInstalling python packages and python package management is a whole issue. In general one should prefer virtual environments, user installations to isolate packages to the specific project. A program that I use that assists with all of this is called uv. In uv a package is added with the command uv add package-name. Package management and uv is a complicated topic, but to get started look at their homepage which is quite well documented.\n\n\n\n\n\n\nThe snaps library, is a python file contained in the provided book sample code, in each chapter folder with examples.\n\nIf you want to use snaps we could install it, but this is a bit more involved than where we are at right now\nInstead simply copy it into the same folder as any python file that wants to use it\n\n\n\n\n\nsnaps contains a display_message function that takes a string of text and displays it on the screen\nThe first example uses the most basic form of display_message\n\n# Example 3.5.1 Displaying Text via Snaps\n\nimport time\n\nfrom snaps import *\n\ndisplay_message(\"hello world\")\ntime.sleep(5)  # add a sleep so the window doesn't autoclose\n\nThe above creates a window with red text saying ‘Hello World’.\n\nWe’ve added the sleep so the window doesn’t automatically close - see discussion about Delaying the end of a program\n\nThe from snaps import * is an alternate import structure\n\nIt tells us from the module snaps import everything (*)\nThis means we don’t need to use the snaps prefix\nGenerally avoid doing this as it can mean that different packages with the same function names will cause naming clashes\n\nPython functions support optional arguments\n\nThese are arguments that have some default supplied value\nWe can customise these to change function behaviour\n\nThe second example uses these optional arguments to change the size, colour and alignment of the text\n\n# Example 3.5.2 Displaying Text via Snaps\n#\n# Extends the previous example by demonstrating\n# adding color, size, text position\n\nimport time\n\nimport snaps\n\nsnaps.display_message(\n    \"This is smaller text in green on the top left\",\n    color=(0, 255, 0),\n    size=50,\n    horiz=\"left\",\n    vert=\"top\",\n)\ntime.sleep(5)  # add a sleep for 5 seconds so the window doesn't autoclose\n\n\n\n\nLike display_message, the display_image function in snaps can be used to display an image file.\nFunction takes the path to the image and can be an png or jpeg\nText can be overlayed on an image by calling display_message after display_image\nFor example: Displaying Images\nHere we use display_image to render a jpeg, with some overlayed text\n\n# Example 3.6 Display Image\n#\n# display an image using snaps library\n\nimport time\n\nimport snaps\n\nsnaps.display_image(\"Housemartins.jpg\")\nsnaps.display_message(\"Hull Rocks\", color=(255, 255, 255), vert=\"top\")\n\ntime.sleep(5)\n\nAgain note, that sleep is used to prevent the window from closing\nThe order of the display messages matters, try changing the order and seeing the result\n\n\n\n\n\nWe have text and images, the last we need is sound, snaps has the play_sound function for this purpose\nSee the example in Playing Sounds\nHere we use play_sound to play a .wav audio file\n\n# Example 3.7 Play Sound\n#\n# play an audio file using snaps\n\nimport time\n\nimport snaps\n\nsnaps.play_sound(\"ding.wav\")\ntime.sleep(5)\n\nAgain, note we need to use sleep to prevent the program immediately ending, which will make it seem like the sound doesn’t play!\nIf you want to work with audio files, a commonly used program is Audacity\n\n\n\n\n\n\nYou can use the snaps program to add visuals and sound to some of the previous examples\n\n\n\nLets use the snaps program to make a GUI version of our egg timer program\nOur implementation essentially replaces the print with snaps display_message\n# Exercise 3.2 Improved Egg Timer\n#\n# Reimplements the Egg Timer Exercise using the snaps library\n# to add a visual and audio component\n\nimport time\n\nimport snaps\n\nsnaps.display_image(\"egg_timer_background.png\")\nsnaps.display_message(\n    \"Drop the egg in boiling water\", color=(255, 0, 0), vert=\"top\", size=100\n)\ntime.sleep(270)\nsnaps.display_message(\n    \"Nearly cooked, get your spoon ready!\", color=(0, 0, 255), size=100\n)\ntime.sleep(30)\nsnaps.play_sound(\"ding.wav\")\nsnaps.display_message(\n    \"Egg cooked, remove now.\", color=(0, 255, 0), vert=\"bottom\", size=100\n)\ntime.sleep(30)\n\nWe first set the background using display_image\n\nThis means the text will appear over the top of the background image\n\nWe then display the initial message\n\nThis is displayed in red, at the top, we adjust the size of the text to \\(100\\) so the text fits on the window\n\nWe then sleep for the first \\(4.5\\) minutes\nWe then inform the user that there is \\(30\\) seconds to go, like in the original code.\n\nThis time the text is displayed in blue, and migrates to the middle of the screen\n\nWe then sleep again for the last \\(30\\) seconds\nFinally we first play a sound to alert the user\nWe then display the message that the egg is ready\n\nThis time at the bottom and in red\n\nWe then sleep for \\(30\\) seconds so the user has time to notice and hear the sound\n\n\n\n\nUse the random number generator and sleep to make a high-low party game. The game works like this,\n\nThe program displays a number between \\(1\\) and \\(10\\) inclusive\nThe program then sleeps for \\(20\\) seconds. While the program is asleep, the players are invited to decide if the next number is higher or lower than the number just printed. Players who chose high stand on the right. Players who chose low stand on the left\nThe program then displays a second number between \\(1\\) and \\(10\\), and anyone who was wrong is eliminated from the game. The program is then re-run with the players that are left until you have a winner\n\nFor fun we use snaps for our implementation to make this visual\n# Exercise 3.3 High-Low\n#\n# Implements the High-Low Party game\n# Generates a random number in the interval [1, 10]\n# Sleeps for a period of time\n# Shows another number\n# Players are asked to guess if this second number will be higher or lower\n\nimport random\nimport time\n\nimport snaps\n\nsnaps.display_message(\"The first number is...\")\ntime.sleep(5)  # sleep so people can read the first message\nsnaps.display_message(random.randint(1, 10))\ntime.sleep(3)  # leave time to read the number\nsnaps.display_message(\"Will the next be higher or lower?\")\n\n# sleep for 20 seconds total, with a message to raise the tension with 5s left\ntime.sleep(15)\nsnaps.display_message(\"The second number is...\")\ntime.sleep(5)\n\nsnaps.display_message(random.randint(1, 10))\ntime.sleep(10)  # leave time for the players to read\n\nObserve that we have to wrap the display_message calls with calls to sleep to ensure that there is time for the user to read the messages\nThe output of (a terminal implementation of the program) should look something like,\n\n\n\nThe first number is:  10\nWill the next be higher or lower?\nThe second number is:  1\n\n\n\n\n\nUse the random number generator and sleep to make a Nerves of Steel game. This game works like this\n\nThe program displays “Players Stand”\nThe program sleeps for a random time between \\(5\\) and \\(20\\) seconds. While the program is sleeping, players can sit down. Keep track of the last person to sit down\nThe program displays “Last to sit down wins.” Players still standing are eliminated, and the winner is the last person to sit down\n\nAgain for fun we’ll use snaps to make a basic window.\n# Exercise 3.4 Nerves of Steel\n#\n# Implements the Nerves of Steel Party Game\n# Players stand\n# Generates a random time interval\n# All players standing after the time interval expires lose\n# Last to sit down before the interval expires wins\n\nimport random\nimport time\n\nimport snaps\n\nsnaps.display_message(\"Players Stand\")\ntime.sleep(random.randint(5, 20))\nsnaps.display_message(\"Last to sit down wins\", color=(0, 255, 0))\n\ntime.sleep(5)  # so program doesn't immediately end\n\nWe add a sleep at the end so the players have time to read the text. We also switch the final text from the initial red to green to celebrate the winner\nThe output of a terminal-based implementation might look like,\n\n\n\nPlayers Stand\nLast to sit down wins",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 3: Python Program Structure"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/03_PythonProgramStructure/Chapter_03.html#summary",
    "href": "01_ProgrammingFundamentals/03_PythonProgramStructure/Chapter_03.html#summary",
    "title": "Chapter 3: Python Program Structure",
    "section": "Summary",
    "text": "Summary\n\nPython code can be run line by line through a shell, or as a program\nA program is a sequence of statements stored in one or more files\nThe print functions lets a program display output to the user as text\nLibraries contain other useable functions\n\nThey are accessed via import\nrandom is library for random numbers\n\nrandint generates random integers over an interval\n\ntime manages dates and times\n\nsleep lets a program pause for a specified number of seconds\n\n\nPrograms can and should contain comments\n\nComments are ignored by the interpreter\nProvide valuable metadata to the reader\nComments start with # and continue to the end of the line",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 3: Python Program Structure"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/03_PythonProgramStructure/Chapter_03.html#question-and-answers",
    "href": "01_ProgrammingFundamentals/03_PythonProgramStructure/Chapter_03.html#question-and-answers",
    "title": "Chapter 3: Python Program Structure",
    "section": "Question and Answers",
    "text": "Question and Answers\n\nWould a user ever use the Python Command Shell?\n\nThe command shell is very useful for programmers. Programmers can toy with code to check the output. Typically a user won’t interact with the shell but a program instead\n\nWhat would happen if two libraries contain a function with the same name?\n\nIf we use the import library approach nothing. Since functions are namespaced by their library we would simply have library1.function and library2.function\ne.g. we might have user.menu and system.menu\nIf we use the from library import * function then we might have an issue as the names will clash\n\nCan I make comments more than one line long?\n\nSeveral languages support multiline comments (e.g. Java, C, C#), these are comments that by default span multiple lines\nPython requires you to use multiple #, i.e. one for each line\n\nThis is referred to as only supporting single line comments\n\nLater we’ll see a syntax for adding multiline strings that can be used for documentation in a similar way to multiline comments\n\nCan a python program run on any computer?\n\nYes and No. If a computer has a python interpreter installed then code should be able to run on it. However, there are caveats, the computer might require the same version of python and any libraries used some of which may be hardware or software dependent, e.g. a library might be specifically written to utilise the Windows API\n\nIs the python language the same on every machine?\n\nAgain Yes and No. Every computer should have the same core language, however different computers may have different versions of the same language which have slightly different feature sets. In fact it is often common for the same computer to manage several different python versions in different virtual environments\nMore common is for different computers to rely on libraries, that may not be commonly shared and may rely on hardware or software specific features to run.\n\nCan I use Snaps in my program?\n\nYes, it is provided by the book author to be used",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 3: Python Program Structure"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/05_MakingDecisions/Chapter_05.html",
    "href": "01_ProgrammingFundamentals/05_MakingDecisions/Chapter_05.html",
    "title": "Chapter 5: Making Decisions",
    "section": "",
    "text": "Caution\n\n\n\nA number of the code examples in this use the file siren.wav, this can be found in the corresponding chapter in the samples submodule. For space reasons we haven’t uploaded it to the github\n\n\n\n\n\nBoolean values are a type that is used to distinguish between values that are True or False\nFor example, we could use an int to count the number of hairs on a person’s head, but a bool to indicate if they are bald\n\n\n\n\nSimply declare a variable with a value of True or False\n\nPython will infer the type\n\nFor example, to declare a true valued boolean,\n\nit_is_time_to_get_up = True\n\nwe can then set the value to false,\n\nit_is_time_to_get_up = False\n\nNote that True and False are python keywords, and are case-sensitive, e.g. true and false will not work as expected\n\n\n\n\nOpen up the python interpreter and work through the following questions to understand booleans\n\nWhat do you think would happen if you printed the contents of a boolean value?\n\nit_is_time_to_get_up = True\nprint(it_is_time_to_get_up)\n\nTrue\n\n\n\nPython will try to print out something meaningful, for a boolean this is either True or False\n\nWhat do you think would happen if you gave the word True to the input function?\nx = input(\"True or False: \")\nTrue or False: True\n\ninput returns it’s input as a string, so in this case x will not be a bool but rather a string with the value \"True\"\n\nIs there a python function called bool that will convert things into Boolean, just like there are int and float functions?\n\nYes there is, consistent behaviour with bool. Consider the following examples\n\n\nprint(bool(1))\nprint(bool(0))\nprint(bool(0.0))\nprint(bool(0.1))\nprint(bool(''))\nprint(bool('Hello'))\n\nTrue\nFalse\nFalse\nTrue\nFalse\nTrue\n\n\n\nWe can see that non-zero numbers evaluate True while zero, evaluates as False Similarly the empty string evaluates False while a non-empty string evaluates as True\n\nWhat happens if a program combines bool values with other values?\n\nWe should already expect that if we try to mix incompatible data that an error should be generated\n\n\n 'Hello' + True\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 'Hello' + True\n\nTypeError: can only concatenate str (not \"bool\") to str\n\n\n\n\nWe can see that we cannot concatenate a boolean value to a string\nThe behaviour can be a little less intuitive with numbers though,\n\n\n1 + True\n\n2\n\n\n\nTrue is implicitly converted to the integer value \\(1\\)\n\n\n1 + False\n\n1\n\n\n\nSimilarly, False is implicitly converted to the integer value \\(0\\)\nWe can see that numeric operations on bool thus have well-allowed behaviour\nString operations (i.e. textual data) are not compatible\n\n\n\n\n\n\nNormally we don’t declare a boolean with True or False explicitly but instead as the result of evaluating an expression\n\nSome expressions evaluate to True or False which naturally suits being stored in a boolean\n\nConsider a simple alarm clock,\n\nWe can get the time through the time library we’ve seen before\n  import time\n\n  current_time = time.localtime()\n\n  hour = current_time.tm_hour\ntime.localtime returns an object containing information about the current time.\n\nThis different blocks of information are called attributes, below is a list of the attributes contained in the object returned by localtime\n\n\n\n\n\n\n\n\n\n\nAttribute\nValue\n\n\n\n\ntm_year\nYear (for example, 2017)\n\n\ntm_mon\nMonth (in the range 1 … 12, 1 represents January)\n\n\ntm_mday\nDay in the Month (in the range 1 … month length)\n\n\ntm_hour\nHour in the Day (in the range 0 … 23)\n\n\ntm_min\nMinute in the Hour ( in the range 0 … 59)\n\n\ntm_sec\nSeconds in the Minute ( in the range 0 … 59)\n\n\ntm_wday\nDay of the Week (in the range 0 … 6 with Monday as 0)\n\n\ntm_yday\nDay in the Year (in the range 0 … 364 or 365 depending on if the year is a leap year)\n\n\n\n\nAn example of a localtime object might look like,\n\n\n\n\nAttribute\nValue\n\n\n\n\ntm_year\n2017\n\n\ntm_mon\n7\n\n\ntm_mday\n19\n\n\ntm_hour\n11\n\n\ntm_min\n40\n\n\ntm_sec\n30\n\n\ntm_wday\n2\n\n\ntm_yday\n200\n\n\n\n\n\nLets make a clock that displays only the hour value, using localtime. These one-handed clocks are supposed promote a more relaxed attitude. Create a new program (OneHandedClock.py) and copy the below text.\n\n    # Example 5.1: One Handed Clock\n    #\n    # Uses time to display the hour\n\n    import time\n\n    current_time = time.localtime()\n    hour = current_time.tm_hour\n\n    print(\"The hour is\", hour)\n\nThe hour is 13\n\n\nRun the program, it should print out the current hour\n\n\n\nImprove the previous example to produce a more fully featured clock that reports the time, and date when run\nWe can use the table above to grab the correct attributes. We then simply need to format the attribute as nessecary. The final program is given below\n\n    # Exercise 5.1: Improved Clock\n    #\n    # An improved clock that displays the date and time when run\n\n    import time\n\n    current_datetime = time.localtime()\n\n    day = current_datetime.tm_mday\n    month = current_datetime.tm_mon\n    year = current_datetime.tm_year\n    print(\"The date is\", day, \"/\", month, \"/\", year)\n\n    seconds = current_datetime.tm_sec\n    minutes = current_datetime.tm_min\n    hours = current_datetime.tm_hour\n    print(\"The time is\", hours, \":\", minutes, \":\", seconds)\n\nThe date is 10 / 1 / 2026\nThe time is 13 : 42 : 21\n\n\n\n\n\n\n\nWe’ve seen expressions as being made of operators and operands\nOne type of operator is a comparison operator\n\nReturns a value that is True or False, e.g.\n\n\n\n\n\n\n\nblock-beta\n    columns 3\n    space\n    title[\"Breakdown of an Example Comparison Expression\"]\n    space\n\n    block:Input\n    columns 1\n        operand1[\"hour\"]\n        operand1Word[\"Operand\"]\n        operand1descr[\"(thing to work on)\"]\n    end\n\n    block:Middle\n    columns 1\n        operator[\"&gt;\"]\n        operatorWord[\"Operator\"]\n        operatorDescr[\"(thing to do)\"]\n    end\n\n    block:Output\n    columns 1\n        operand2[\"6\"]\n        operand2Word[\"Operand\"]\n        operand2descr[\"(thing to work on)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass operand2Word BG\nclass operand2descr BG\nclass operand1Word BG\nclass operand1descr BG\nclass operatorWord BG\nclass operatorDescr BG\n\n\n\n\n\n\n\n\n\nBelow is a table of the common comparison operators\n\n\n\n\n\n\n\n\n\nOperator\nName\nEffect\n\n\n\n\n\\(&gt;\\)\nGreater than\nTrue if the left argument is greater than the right, else False\n\n\n\\(&lt;\\)\nLess than\nTrue if the left argument less than the right, else False\n\n\n\\(&gt;=\\)\nGreater than or Equal\nAs for Greater than but also True if the left argument equals the right\n\n\n\\(&lt;=\\)\nLess than or Equal\nAs for Less than but also True if the left argument equals the right\n\n\n\\(==\\)\nEquals\nTrue if the left argument equals the right argument, else False\n\n\n\\(!=\\)\nNot Equals\nTrue if the left argument does not equal the right argument, else False\n\n\n\n\nA program can use a comparison operator to set a boolean variable, e.g. the below code fragment which sets the boolean variable it_is_time_to_get_up to True if the variable hour is greater than \\(6\\) else sets it to False\n\n    it_is_time_to_get_up = hour &gt; 6\n\n\nUse the python interpreter to work through the following questions in order to understand Comparison Operators\n\nHow does the equality operator work?\n\nThe equality operator evaluates to True if the two operands hold the same value\n\n\n1 == 1\n\nTrue\n\n\n\nThe equality operator can be used to compare strings and bools\n\n\n 'Rob' == 'Rob'\n\nTrue\n\n\n\n True == True\n\nTrue\n\n\nHow do I remember which relational operator to use?\n\nPractice, patience and muscle memory\n\nCan we apply relational operators between other types of expressions?\n\nYes. For example, the \\(&gt;\\) and \\(&lt;\\) operators when used to compare strings will use an alphabetic ordering, e.g.\n\n'Alice' &lt; 'Brian'\n\nTrue\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nEquality and Floating-point Values\nIn Chapter 4 we noted that floating points only approximate a specific real-value. These approximations can cause issues when using comparison operators, e.g.\n\nx = 0.3\ny = 0.1 + 0.2\nx == y\n\nFalse\n\n\n\nThe variables x and y should both notionally store \\(0.3\\), but the equality shows they are unequal. This is because the addition of \\(0.1\\) and \\(0.2\\) actually leads to y storing the slightly inaccurate \\(0.3000...4\\)\nIf comparing floating-point numbers for equality, the best approach is to check that the values are appropriately close\n\n\n\n\nPython provides the type function, type(x) returns the type of the variable x, especially useful for investigating the type of values returned by library functions you’ve never seen before\n\n\n\n\n\n\n\nWhat if we want to combine boolean expressions to create a new boolean expression\ne.g. An alarm might want to go off when the hour is after \\(7\\) and the minute is after \\(30\\)\nPython provides logic operators for combining boolean expressions\n\n\n\nUse the python interpreter to answer the following questions and investigate boolean operators\n\nWhat does the following expression evaluate too?\n\nnot True\n\nFalse\n\n\n\nnot inverts the value of a boolean, so True is converted to False\n\nHow about this expression?\n\nTrue and True\n\nTrue\n\n\n\nand is True iff both arguments are True as is the case above, so the result is True\n\nHow about this expression?\n\nTrue and False\n\nFalse\n\n\n\nSince one of the arguments is False and will evaluate to False\n\nHow about this expression?\n\nTrue or False\n\nTrue\n\n\n\nSince one of the arguments is True or will evaluate to True\n\nSo far, the examples have only used boolean values. What happens if we mix boolean and numeric values?\n\n True and 1\n\n1\n\n\n\nRecall that python can convert numeric expressions to boolean ones, this implicitly happens to the \\(1\\) in the above. So we would expect and to return True. However ,instead \\(1\\) is returned. This is due to some odd python behaviour\n\nPython sees True \\(\\rightarrow\\) result of and implied by second argument\n\nSo simply returns the second argument, since the truthfulness of \\(1\\), is equivalent to the original expression\n\nIf we flip the arguments, we should see this more clearly\n\n  1 and True\n\nTrue\n\n\n\nThis time the above expressions should return True\n\nThe same behaviour will also occur with or\n\n  1 or False\n\n1\n\n\n\nHere the or operator short-circuits on \\(1\\), so returns \\(1\\)\n\n\n  0 or True\n\nTrue\n\n\n\nHere the or evaluates the first argument as false, so cannot short-circuit, the second argument is returned, i.e True\n\n\n\n\n\nLet us now use and to try construct an expression that will correctly evaluate when the time is after \\(7:30\\), naively we might expect,\n\n    it_is_time_to_get_up = hour &gt; 6 and minute &gt; 29\n\nWe can use a truth table to check,\n\n\n\n\nHour\nMinute\nDesired\nOutput\n\n\n\n\n6\n0\nFalse\nFalse\n\n\n7\n29\nFalse\nFalse\n\n\n7\n30\nTrue\nTrue\n\n\n8\n0\nTrue\nFalse\n\n\n\n\nWe can see in the last case the result is not what we want!\n\nhour &gt; 7 is true, but minute &gt; 29 is false, so we need to be more precise,\n\n\n    it_is_time_to_get_up = (hour &gt; 7) or (hour == 7 and minute &gt; 29)\n\nWe use brackets to make the expression more readable\nHere we use short-circuiting, if the the hour is greater than \\(7\\) we don’t need to check the minutes value\n\n\n\n\n\n\n\nWarning\n\n\n\nBe Careful with Logic Operations\nWhen working with boolean operations you should always check that the logic matches what you expect!\n\n\n\n\n\n\n\n\nSuppose we want a program to tell me if it’s time to get out of bed\nNeed the ability to run code if a boolean condition is met\n\nCan do so using the aptly named if operator\n\n\n\n\n\nCreate a new python program (SimpleAlarmClock.py) with the following contents\n\n\n# Example 5.2: Simple Alarm Clock\n#\n# Demonstrates `if` using a simple alarm clock\n\nimport time\n\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminute = current_time.tm_sec\n\nit_is_time_to_get_up = (hour &gt; 7) or (hour == 7 and minute &gt; 29)\n\nif it_is_time_to_get_up:\n    print(\"IT IS TIME TO GET UP\")\n\nIT IS TIME TO GET UP\n\n\n\nThe program should print IT IS TIME TO GET UP only if the time is after \\(7:30\\)\nThe if construct starts with the word if, following by a boolean value called the condition, then a :\nAny statements we want to execute if the if is True are then written below the if and indented one level\n\n\n\n\n\nCondition is a term for the expression that controls which branch of the if is executed\nIf the condition evaluates True the indented branch is run\nIf the condition evluates False the indented branch is skipped\nWe could simply the above code by including the check directly in the if rather than an intermediate variable\n\n\nif (hour &gt; 7) or (hour == 7 and minutes &gt; 29):\n    print(\"IT IS TIME TO GET UP\")\n\nIT IS TIME TO GET UP\n\n\n\n\n\n\nWhat if we want multiple statements to run after an if statement\nWe just write them as a sequence of indented statements\n\n\n\nLet us improve the previous example to also play a sound if it’s time to get up. Create a program (SirenAlarmClock.py) with the contents below\n# Example 5.3: Siren Alarm Clock\n#\n# Improves the Simple Alarm Clock to also play a sound\n\nimport time\n\nimport snaps\n\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminute = current_time.tm_min\n\nif (hour &gt; 7) or (hour == 7 and minute &gt; 29):\n    snaps.display_message(\"TIME TO GET UP\")\n    snaps.play_sound(\"siren.wav\")\n    # pause the program to give time for the sound to play\n    time.sleep(10)\nThis program now runs three statements in the if\n\nFirst a message is displayed\nSecond a sound is played\nThird the program sleeps so the sound has time to play\n\n\nIf we want something to run regardless of the if condition, we write it either before or after the if statement\n\n\n\n\nAdd to the simple Alarm Clock, by making it so the program will always print the current time regardless of if the alarm goes off. Create a new program (AlarmClockWithTimeDisplay.py). Enter the following contents,\n\n# Example 5.4: Alarm Clock with Time Display\n#\n# A variant of Alarm Clock to also always display the time\n\nimport time\n\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminute = current_time.tm_min\n\nif (hour &gt; 7) or (hour == 7 and minute &gt; 29):\n    print(\"TIME TO GET UP\")\n    print(\"RISE AND SHINE\")\n    print(\"THE EARLY BIRD GETS THE WORM\")\nprint(\"The time is\", hour, \":\", minute)\n\nTIME TO GET UP\nRISE AND SHINE\nTHE EARLY BIRD GETS THE WORM\nThe time is 13 : 42\n\n\n\nThe program above will always print the current time, regardless of if the alarm block is run\n\n\n\n\n\n\n\nCaution\n\n\n\nIndented Text can cause Big Problems\nAs seen above, python uses indentation for control flow, this has the advantage in that it follows normal code style practices, but has some pitfalls\n\nIf the indention is wrong the program won’t run\n\ni.e. if one line is indented four spaces, and the next three an error will be thrown\n\nimport time\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminutes = current_time.tm_min\n\nif (hour &gt; 7) or (hour == 7 and minute &gt; 29):\n  print(\"IT IS TIME TO GET UP\")\n      print(\"The early bird gets the worm...\")\n\n\n  Cell In[24], line 8\n    print(\"The early bird gets the worm...\")\n    ^\nIndentationError: unexpected indent\n\n\n\n\n\nA more insidious error, occurs if one mixes tabs and spaces in the indentation, since the code may appear to be fine until it attempts to run\n\n import time\n current_time = time.localtime()\n hour = current_time.tm_hour\n minutes = current_time.tm_min\n\n if (hour &gt; 7) or (hour == 7 and minute &gt; 29):\n     print(\"IT IS TIME TO GET UP\")\n     print(\"The early bird gets the worm...\")\n\nIT IS TIME TO GET UP\nThe early bird gets the worm...\n\n\n\nMost programmers and even text editors will automatically convert one style of indentation to the other (commonly tabs to spaces, but sometimes spaces to tabs) to avoid this issue\n\nIn the above code, my editor converted the second line which was indented with spaces to a tab to match the previous line\n\n\n\n\n\n\n\n\n\n\nFormally, an if has a structure like\n\n\n\n\n\n\nblock-beta\n    columns 4\n    space\n    title[\"Breakdown of an if statement\"]:2\n    space\n\n    block:Input\n    columns 1\n        if[\"if\"]\n        ifDescr[\"(start of the if construction)\"]\n    end\n\n    block:Condition\n    columns 1\n        condition[\"condition\"]\n        conditionDescr[\"(value that is true or false)\"]\n    end\n\n    block:Colon\n    columns 1\n        colon[\":\"]\n        colonDescr[\"colon\"]\n    end\n\n    block:Suite\n    columns 1\n        suite[\"suite\"]\n        suiteDescr[\"statements\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass condition BG\nclass conditionDescr BG\nclass colon BG\nclass colonDescr BG\nclass suite BG\nclass suiteDescr BG\nclass if BG\nclass ifDescr BG\n\n\n\n\n\n\n\nThere are two ways to write the suite\n\nA set of indented statements on the lines proceeding the if\nA set of statements on the same line as the if each seperated by a semicolon (;) e.g.\n if (hour &gt; 6): print('IT IS TIME TO GET UP'); print('THE EARLY BIRD GETS THE WORM')\n\n\n\n\n\n\n\n\nWarning\n\n\n\nYou can’t combine inline if statements, with indented if statements, e.g.\n\n    import time\n    current_time = time.localtime()\n    hour = current_time.tm_hour\n    minutes = current_time.tm_min\n\n    if (hour &gt; 7) or (hour == 7 and minute &gt; 29): print(\"IT IS TIME TO GET UP\"); print(\"RISE AND SHINE\")\n        print(\"The early bird gets the worm...\")\n\n\n  Cell In[26], line 7\n    print(\"The early bird gets the worm...\")\n    ^\nIndentationError: unexpected indent\n\n\n\n\n\n\n\n\nUse the python interpreter to answer the following questions to understand conditional statements\n\nCan we work with conditional statements using the python shell?\n\nYes you can, type the following into the shell,\n\nif True:\n\nThe shell may display ... instead of &gt;&gt;&gt; or, omit &gt;&gt;&gt; and indent\n\nIn the first case we can indent ourselves to write the suite\nIn the second we simply write the suite\n\nOnce done writing the if statement, simply deindent\nTry write the following in the shell, and verify the output\n\n  if True:\n      print('True')\n      print('Still True')\n\nTrue\nStill True\n\n\n\nHow many spaces must you indent a suite of Python statements controlled by an if statement?\n\nThere is no approved value, but it must be consistent\ni.e. if the first indentation is four, then all future indentations must also be four\n\nCommon choices are 4, 8 or 2\n\n\n\n\n\n\n\n\nSometimes we want conditional behaviour on both the True and False branches\nelse is a keyword that lets us add behaviour that executes when an if evaluates as False\n\n\n\nModify the Simple Alarm Clock to now print a message telling us to go back to bed if it before our alarm should go off. Write a new program (SimpleAlarmClockWithElse.py) with the following contents,\n\n# Example 5.5: Simple Alarm Clock\n#\n# Variant of the Simple Alarm Clock\n# that modifies the output depending on if its time to get up\n\nimport time\n\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminute = current_time.tm_min\n\nif (hour &gt; 7) or (hour == 7 and minute &gt; 29):\n    print(\"IT IS TIME TO GET UP\")\nelse:\n    print(\"Go back to bed\")\n\nIT IS TIME TO GET UP\n\n\n\nObserve that only one line of the paired if-else statements is printed\n\n\n\n\nWork through the following questions to understand if constructions\n\nMust an if construction have an else part?\n\nNo, we saw when first working with if that we could exclude the else in that case no additional code runs if the if evaluates False\n\nWhat happens if a condition is never True?\n\nIt simply never executes\n\n\n\n\n\n\n\nThe if statement can be used to compare strings, as seen with the comparison operators\n\n\n\nThe following program uses the equality operator and an if statement to greet a person if their name matches. What is a potential issue with this program?\n# Example 5.6: Broken Greeter\n#\n# A Greeter program using string matching\n# Identify the issues with this program\n\nname = input(\"Enter your name: \")\n\nif name == \"Rob\":\n    print(\"Hello, Oh great one\")\n\nThe equality operator checks against the string \"Rob\" exactly\ni.e. it is case sensitive, if we write \"ROB\", or \"rob\" or some variation thereof, the statement will not match.\n\nWe can fix this by using the string method upper, this converts all forms of the word \"rob\" to \"ROB\" which we can reliably check against. The new program looks like\n# Example 5.7: Uppercase Greeter\n#\n# A Greeter program using string matching\n# Fixes the issues with Example 5.6 by using\n# str.upper()\n\nname = input(\"Enter your name: \")\n\nif name.upper() == \"ROB\":\n    print(\"Hello, Oh great one\")\n\nWe could also use the string method lower to compare against an all lowercase word\n\n\n\n\nConsider the following questions to learn about methods and functions\n\nHow do lower() and upper() work?\n\nPython types are objects that provide methods.\nMethods are called like functions\n\nWhy do we have to write lower() and not lower?\n\nLeave the parentheses off, and see what happens\n\n  name = 'Rob'\n  name.upper\n\n&lt;function str.upper()&gt;\n\n\nWe are instead returned a description of the method itself\n\nWhat’s the difference between functions and methods?\n\nThey are used the same way, but they differ in where they are created\nFunctions are not associated any specific object\nMethods are bound as attributes of objects\n\n\n\n\n\n\n\nYou can nest conditions, e.g. if you want to perform sequential checks\n\n\n\nLet us demonstrate nested if through a greeter which requires a follow on code word to confirm the identity of the user. Create a program (CodedGreeter.py) with the following contents\n# Example 5.8: Coded Greeter\n#\n# Asks the user for a follow on code to confirm their ID\n# before the program greets them\n\nname = input(\"Enter your name: \")\n\nif name.upper() == \"ROB\":\n    code = input(\"Enter the codeword: \")\n    if code == \"secret\":\n        print(\"Hello, Oh great one\")\n    else:\n        print(\"Begone. Imposter\")\n\nPlay around with the above code to see what happens for various input combinations.\nYou should see if the first input is not a variant of \"rob\" the second prompt never occurs and the program ends.\nAdjust the above by writing a new program (CodedGreeterWithOuterElse.py)*\n\n# Example 5.9: Coded Greeter with Outer Else\n#\n# Asks the user for a follow on code to confirm their ID\n# before the program greets them\n# Has an additional outer else clause for the case that the nested\n# if does not run\n\nname = input(\"Enter your name: \")\n\nif name.upper() == \"ROB\":\n    code = input(\"Enter the codeword: \")\n    if code == \"secret\":\n        print(\"Hello, Oh great one\")\n    else:\n        print(\"Begone. Imposter\")\nelse:\n    print(\"You are not Rob. Shame.\")\n\nThe above code uses a second else clause, attached to the first outer, if condition\nThis means that it will run whenever the original name is not some variant of \"ROB\"\n\n\n\n\n\n\n\nImprove the Alarm Clock. Make the alarm display the date as well as the time, and let the user sleep in on the weekends.\nOur implementation is given below,\n# Exercise 4.2: Advanced Alarm Clock\n#\n# An Advanced Alarm Combining the Behaviour\n# of most increments of the alarm clock\n# and allowing you to sleep in on weekends\n\nimport time\n\nimport snaps\n\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminute = current_time.tm_min\nday = current_time.tm_mday\nmonth = current_time.tm_mon\nis_weekend = current_time.tm_wday &gt;= 5\n\ndate_message = \"The date is \" + str(day) + \"/\" + str(month)\ntime_message = \"The time is \" + str(hour) + \":\" + str(minute)\n\nmsg = \"\"\nup_hour = 7 + is_weekend  # get to sleep in an extra hour on weekends\n\nif (hour &gt; up_hour) or (hour == up_hour and minute &gt; 29):\n    msg = msg + \"TIME TO GET UP\"\n    snaps.play_sound(\"siren.wav\")\nelse:\n    msg = msg + \"Go back to bed!\"\nmsg = msg + \"\\n\" + date_message + \"\\n\" + time_message\nsnaps.display_message(msg, size=50)\ntime.sleep(10)  # leave time for the sound and to read\nMost of the text simply exists to correctly create the final message we will display on the screen. The most important parts are, is_weekend = current_time.tm_wday &gt;= 5 which uses the fact that Saturday and Sunday have the value \\(5\\) and \\(6\\) in the current_time.tm_wday attribute (A number representing the day in the week) to set a boolean flag. We then use the fact that True acts numerically as one, and False acts numerically as zero to let us sleep in an hour on the weekend using up_hour = 7 + is_weekend which is \\(8\\) on weekends and \\(7\\) on weekdays.\nWe then run through the code as we have for most of the alarm clock cases, using an else clause to ensure we always have a message for the user, and appending the date and time message to this output.\nLastly we pass the method to snaps for display\n\n\n\n\n\n\nIn this next section we’ll write our first semi-sophisticated program\n\n\nScenario:\nA local theme park wants you to write a program that will let users check if they meet the age requirements to go on a ride. They provide the following table covering the current rides\n\n\n\n\n\n\n\nRide\nRestrictions\n\n\n\n\nScenic River Cruise\nNone\n\n\nCarnival Carousel\nAt least 3 years old\n\n\nJungle Adventure Water Splash\nAt least 6 years old\n\n\nDownhill Mountain Run\nAt least 12 years old\n\n\nThe Regurgitator\nAt least 12 years old and less than 70\n\n\n\n\n\n\n\nWe will use a simple text interface\n\nWelcome to our Theme Park\n\nThese are the available rides\n\n1. Scenic River Cruise\n2. Carnival Carousel\n3. Jungle Adventure Water Splash\n4. Downhill Mountain Run\n5. The Regurgitator\n\nPlease enter the ride you want: 1\nYou have selected the Scenic River Cruise\nThere are no age limits for this ride\n\n\n\n\n\n\nImportant\n\n\n\nDesign the User Interface with the Customer\nThe UI can be the most important and most difficult part of design because it can be very subjective. Ultimately the Customer is the one paying and so they should be involved in the UI design throughout!\n\n\n\n\n\n\nWe have a UI design, now we need to implement it\nOur code starts as below,\n\n# Example 5.10: Ride Selector Start\n#\n# The basic shell of the Ride Selector UI\n\nprint(\"\"\"Welcome to our Theme Park\n      These are the available ride:\n\n      1. Scenic River Cruise\n      2. Carnival Carousel\n      3. Jungle Adventure Water Splash\n      4. Downhill Mountain Run\n      5. The Regurgitator\n      \"\"\")\n\nride_number_text = input(\"Please enter the ride number you want: \")\nride_number = int(ride_number_text)\n\nif ride_number == 1:\n    print(\"You have selected Scenic River Cruise\")\n    print(\"There are no age limits for this ride\")\n\nWe first print out our Menu, using a triple-delimited string so we can multiline it\nThen we implement the menu using a series of if statements.\n\nFor the first case (Scenci River Cruise) we don’t need the user’s age so we can output the result immediately\n\nFor other rides the user needs to supply their age, so we continue,\n\nelse:  # need to get the age of the user\n    age_text = input(\"Please enter your age: \")\n    age = int(age_text)\n\nWe have to get the age using another input pair\nThis should already be familiar to you\n\n\n\n\nOnce we have the age, we need to compare against the restrictions for the selected ride\nWe can do this with a nested series of if statements which\n\nFirst selects the appropriate ride\nChecks the age against the ride’s age requirements\n\n\n    if ride_number == 2:\n        print(\"You have selected the Carnival Carousel\")\n        if age &gt;= 3:\n            print(\"You can go on the ride\")\n        else:\n            print(\"Sorry, you are too young\")\n    if ride_number == 3:\n        print(\"You have selected Jungle Adventure Water Splash\")\n        if age &gt;= 6:\n            print(\"You can go on the ride\")\n        else:\n            print(\"Sorry, you are too young\")\n\nDownhill Mountain Splash (ride number 4) can be implemented exactly as above\n\n\n\n\n\n\n\nTip\n\n\n\nReduce duplicated Code\nYou may have noticed that the above statement appears to have a bunch of duplicated code. The rough structure is,\nselect ride\nif age of user is greater than or equal to the rides min age\n    Inform the user they can go on the ride\nelse:\n    Inform the user they cannot go on the ride\nProgrammers typically don’t like to repeat themselves as it increases the number of ways a program can go wrong. So ideally we would like a way were we could write something like the above once and have the appropriate checks be carried out, and the message printed without having to write it out for every case. We’ll look at some ways to do this later in the book.\n\n\n\n\n\n\nThe last ride introduces an additional check, we have a minimum and a maximum age.\n\nNeed to introduce another layer nested conditional to differentiate between the too old and too young case\n\n\n    if ride_number == 5:\n        print(\"You have selected The Regurgitator\")\n        if age &gt;= 12:\n            # first check age not too low\n            if age &gt; 70:\n                # Age is too old\n                print(\"Sorry, you are too old\")\n            else:\n                # In the valid range\n                print(\"You can go on the ride\")\n        else:\n            # Age is too young\n            print(\"Sorry, you are too young\")\n\nYou can see the final Program (Ride Selector)\n\n\n\n\n\n\nWe can add some extra quality to our implementation using snaps\nsnaps get_string method\n\n# Example 5.11: Snaps get_string function\n#\n# Demonstrates using the get_string function\n# in snaps to get user input via a graphical\n# interface\n\nimport time\n\nimport snaps\n\nname = snaps.get_string(\"Enter your name: \")\nsnaps.display_message(\"Hello \" + name)\n\ntime.sleep(5)\n\n\n\n\n\n\nImportant\n\n\n\nAs written, the snaps get_string method on my machine, did not work when running Pygame 2. I had to modify the method to the following,\ndef get_string(prompt, size=50, margin=20,\n               color=(255, 0, 0), horiz='left', vert='center',\n               max_line_length=20):\n    '''\n    Reads a string from the user\n    '''\n\n    setup()\n\n    result = ''\n    cursor_char = '*'\n    cursor = None\n\n    def redraw():\n        clear_display()\n\n        render_message(prompt+result, margin=margin, size=size,\n                       horiz=horiz, vert=vert, color=color, cursor=cursor)\n\n    def cursor_flip():\n        nonlocal cursor\n\n    # create a timer for the cursor\n\n    cursor_event = pygame.USEREVENT+1\n\n    pygame.time.set_timer(cursor_event,500)\n    pygame.key.start_text_input()\n\n    while True:\n        event = pygame.event.wait()\n\n        if event.type == cursor_event:\n            if cursor:\n                cursor = None\n            else:\n                cursor = cursor_char\n            redraw()\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_RETURN:\n                break\n            elif event.key == pygame.K_BACKSPACE:\n                if len(result) &gt; 0:\n                    result = result[:-1]\n                    redraw()\n        elif event.type == pygame.TEXTINPUT:\n            if len(result) &lt; max_line_length:\n                result += event.text\n                redraw()\n\n    # disable the timer for the cursor\n    pygame.time.set_timer(cursor_event,0)\n    return result\nI won’t go into detail on explaining the changes since it’s above the level we’ve currently been discussing but if you have issues with the running any of the snaps get_string programs in this book, I would recommend trying the above replacement to the function\n\n\n\nUsing the above and some optional arguments to play around with text placement we can create the start of a GUI implementation of the Ride Selector Program\n\n\n\nThe below program is the outline for an implementation of the Ride Selector Program using snaps to provide a GUI\n# Example 5.12: Theme Park Snaps Display\n#\n# Reimplments the shell of the Ride Selector Menu using Snaps\n\nimport time\nimport snaps\n\n\nsnaps.display_image(\"themepark.png\")\n\nprompt = \"\"\"Welcome to our Theme Park\n      These are the available ride:\n\n      1. Scenic River Cruise\n      2. Carnival Carousel\n      3. Jungle Adventure Water Splash\n      4. Downhill Mountain Run\n      5. The Regurgitator\n\n      Select your ride: \"\"\"\n\nride_number_text = snaps.get_string(prompt, vert=\"bottom\", max_line_length=3)\nconfirm = \"Ride \" + ride_number_text\n\nsnaps.display_message(confirm)\ntime.sleep(5) #gives user time to read the output\n\n\n\nUsing the previous example, complete the ride selector program. Extending its features where reasonable\nWe’ll reimplement all the features of the original text-based interface, but add in the siren sound effect if the user is unable to ride the ride. Otherwise this proceeds as with most of our conversions to snaps. We replace print with snaps.display_message and introduce some work to build the string that we want to send to snaps.display_message. In this case we create a string that is nicely formatted to output\n\nThe ride number the user selected\nThe name of the ride\nA message letting them know if they are allowed to ride\n\nOur final implementation can be found in the file ThemeParkSnapsDisplay.py, or read from down below, observe the usual use of the time.sleep function to prevent the window from immediately closing\n# Exercise 5.3: Snaps Ride Selector\n#\n# Reimplments the entirety of the Theme Park Ride Selector using\n# a snaps interface, and adds some audio ques to warn the user\n# when they are ineligable for ride\n\nimport time\nimport snaps\n\n\nsnaps.display_image(\"themepark.png\")\n\nprompt = \"\"\"Welcome to our Theme Park\n      These are the available ride:\n\n      1. Scenic River Cruise\n      2. Carnival Carousel\n      3. Jungle Adventure Water Splash\n      4. Downhill Mountain Run\n      5. The Regurgitator\n\n      Select your ride: \"\"\"\n\nride_number_text = snaps.get_string(prompt, vert=\"bottom\", max_line_length=3)\nconfirm = \"Ride \" + ride_number_text\n\nsnaps.display_message(confirm)\ntime.sleep(2)  # gives user time to read the output\n\nride_number = int(ride_number_text)\n\nif ride_number == 1:\n    msg = confirm + \"\\nScenic River Cruise\\n\\nThere are no age limits for this ride\"\n    snaps.display_message(msg, size=100)\nelse:  # need to get the age of the user\n    age_text = snaps.get_string(\n        \"Please enter your age: \", vert=\"bottom\", max_line_length=3\n    )\n    age = int(age_text)\n\n    if ride_number == 2:\n        msg = confirm + \"\\nCarnival Cruise\"\n        if age &gt;= 3:\n            msg = msg + \"\\n\\nYou can go on the ride\"\n            snaps.display_message(msg, size=100)\n        else:\n            snaps.play_sound(\"siren.wav\")\n            msg = msg + \"\\n\\nSorry, you are too young\"\n            snaps.display_message(msg, size=100)\n    if ride_number == 3:\n        msg = confirm + \"\\nJungle Adventure Water Splash\"\n        if age &gt;= 6:\n            msg = msg + \"\\n\\nYou can go on the ride\"\n            snaps.display_message(msg, size=100)\n        else:\n            msg = msg + \"\\n\\nSorry, you are too young\"\n            snaps.play_sound(\"siren.wav\")\n            snaps.display_message(msg, size=100)\n    if ride_number == 4:\n        msg = confirm + \"\\nDownhill Mountain Run\"\n        if age &gt;= 12:\n            msg = msg + \"\\n\\nYou can go on the ride\"\n            snaps.display_message(msg, size=100)\n        else:\n            msg = msg + \"\\n\\nSorry, you are too young\"\n            snaps.play_sound(\"siren.wav\")\n            snaps.display_message(msg, size=100)\n    if ride_number == 5:\n        msg = confirm + \"\\nThe Regurgitator\"\n        if age &gt;= 12:\n            # first check age not too lowe\n            if age &gt; 70:\n                # Age is too old\n                msg = msg + \"\\n\\nSorry, you are too old\"\n                snaps.play_sound(\"siren.wav\")\n                snaps.display_message(msg, size=100)\n            else:\n                msg = msg + \"\\n\\nYou can go on the ride\"\n                snaps.display_message(msg, size=100)\n        else:\n            msg = msg + \"\\n\\nSorry, you are too young\"\n            snaps.display_message(msg, size=100)\ntime.sleep(5)\n\n\n\nUsing snaps and the weather functions it includes, write a simple program to remind the user to wrap up warm, wear sunscreen etc.\nWe’ll use the basic outline of the solution in the book,\n#EG5-14 Weather Helper\n\nimport snaps\n\ntemp = snaps.get_weather_temp(latitude=47.61, longitude=-122.33)\nprint(\"The temperature is:\", temp)\n\nif temp &lt; 40:\n    print(\"Wear a coat - it is cold out there\")\nelif temp &gt; 70:\n    print(\"Remember to wear sunscreen\")\nThe first step is to convert the print statements to instead use the snaps, display_message function. This requires us to do the usual work of building the string before we display it. Next we also want to display an image, either a sun or a snowflake depending on if the weather is hot or cold. Since we’re grabbing some new images, we run into an issue that snaps doesn’t work to rescale the images out of the box. We can fix this by adding the line image = image.convert_alpha() before the image = pygame.transform.smoothscale(image, window_size) line in display_image in snaps. Our final program (Weather Helper) looks like,\n# Exercise 5.4 Weather Helper\n#\n# Simple Weather Program that reminds the user about\n# the weather conditions, with helpful text and\n# pictures\n\nimport time\nimport snaps\n\ntemp = snaps.get_weather_temp(latitude=47.61, longitude=-122.33)\nconditions = snaps.get_weather_desciption(latitude=47.61, longitude=-122.33)\n\nif temp is None or conditions is None:\n    msg = \"Could not retrieve Weather...\"\nelse:\n    msg = \"The temperature is: \" + str(temp)\n    if temp &lt; 40:\n        msg = msg + \"\\n\\nWear a coat - it is cold out there\"\n        snaps.display_image(\"snowflake.png\")\n    elif temp &gt; 70:\n        msg = msg + \"\\n\\nRemember to wear sunscreen\"\n        snaps.display_image(\"sun.png\")\n    msg = msg + \"\\n\\nThe weather is \" + conditions\n\nsnaps.display_message(msg, size=100, color=\"red\")\ntime.sleep(5)\nIgnore the line if temp is None or conditions is None, this is some error handling code we’ll look at in a latter chapter. Notice that since no matter which path we go through the if, elif chain we’ll post a message at the end. So we use the branch code in order to set up the appropriate message, while the call to display_message sits outside the loop, so we don’t have to call it on every path.\n\n\n\nUsing randint and if statements write a fortune teller program that gives random fortunes to the user\nWe’ll expand on the prototype given by providing two additional statements, one relating to the future and the other relating to the wealth. We’ll follow the structure of using random.randint(1, 6) to simulate rolling a six-sided die, but spice it up by using if-elif-else clauses to play with the relative weighting of different statements.\n\n# Exercise 5.5 Fortune Teller Program\n#\n# A simple program that uses random numbers to generate a sequence of\n# fortunes for the user\n\nimport random\n\n# Meeting someone\nif random.randint(1, 6) &lt; 4:\n    print(\"You will meet a tall, dark stranger\")\nelse:\n    print(\"Nobody unexpected will enter your life\")\n\n# Money\nresult = random.randint(1, 6)\nif result == 1:\n    print(\"I see untold riches in your future\")\nelif result &lt;= 3:\n    print(\"A life of comfort is coming\")\nelif result &lt; 6:\n    print(\"You would do well to husband your wealth\")\nelse:\n    print(\"I see a future lived on the streets...\")\n\n# Advice\nresult = random.randint(1, 6)\nif result &lt;= 2:\n    print(\"Sometimes the answers to our future, come from the past\")\nelif result &lt; 6:\n    print(\"To define your future, avoid getting hung up on the past\")\nelse:\n    print(\"You will soon face a decision that will redefine everything\")\n\nNobody unexpected will enter your life\nI see a future lived on the streets...\nTo define your future, avoid getting hung up on the past\n\n\nWe use a mix of ==, &lt;= and &lt; operators to emphasise the clarity of the branching. This implementation is quite simple (because the exercise does not personally interest me that much) Feel free to expand on my solution",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 5: Making Decisions"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/05_MakingDecisions/Chapter_05.html#notes",
    "href": "01_ProgrammingFundamentals/05_MakingDecisions/Chapter_05.html#notes",
    "title": "Chapter 5: Making Decisions",
    "section": "",
    "text": "Caution\n\n\n\nA number of the code examples in this use the file siren.wav, this can be found in the corresponding chapter in the samples submodule. For space reasons we haven’t uploaded it to the github\n\n\n\n\n\nBoolean values are a type that is used to distinguish between values that are True or False\nFor example, we could use an int to count the number of hairs on a person’s head, but a bool to indicate if they are bald\n\n\n\n\nSimply declare a variable with a value of True or False\n\nPython will infer the type\n\nFor example, to declare a true valued boolean,\n\nit_is_time_to_get_up = True\n\nwe can then set the value to false,\n\nit_is_time_to_get_up = False\n\nNote that True and False are python keywords, and are case-sensitive, e.g. true and false will not work as expected\n\n\n\n\nOpen up the python interpreter and work through the following questions to understand booleans\n\nWhat do you think would happen if you printed the contents of a boolean value?\n\nit_is_time_to_get_up = True\nprint(it_is_time_to_get_up)\n\nTrue\n\n\n\nPython will try to print out something meaningful, for a boolean this is either True or False\n\nWhat do you think would happen if you gave the word True to the input function?\nx = input(\"True or False: \")\nTrue or False: True\n\ninput returns it’s input as a string, so in this case x will not be a bool but rather a string with the value \"True\"\n\nIs there a python function called bool that will convert things into Boolean, just like there are int and float functions?\n\nYes there is, consistent behaviour with bool. Consider the following examples\n\n\nprint(bool(1))\nprint(bool(0))\nprint(bool(0.0))\nprint(bool(0.1))\nprint(bool(''))\nprint(bool('Hello'))\n\nTrue\nFalse\nFalse\nTrue\nFalse\nTrue\n\n\n\nWe can see that non-zero numbers evaluate True while zero, evaluates as False Similarly the empty string evaluates False while a non-empty string evaluates as True\n\nWhat happens if a program combines bool values with other values?\n\nWe should already expect that if we try to mix incompatible data that an error should be generated\n\n\n 'Hello' + True\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 'Hello' + True\n\nTypeError: can only concatenate str (not \"bool\") to str\n\n\n\n\nWe can see that we cannot concatenate a boolean value to a string\nThe behaviour can be a little less intuitive with numbers though,\n\n\n1 + True\n\n2\n\n\n\nTrue is implicitly converted to the integer value \\(1\\)\n\n\n1 + False\n\n1\n\n\n\nSimilarly, False is implicitly converted to the integer value \\(0\\)\nWe can see that numeric operations on bool thus have well-allowed behaviour\nString operations (i.e. textual data) are not compatible\n\n\n\n\n\n\nNormally we don’t declare a boolean with True or False explicitly but instead as the result of evaluating an expression\n\nSome expressions evaluate to True or False which naturally suits being stored in a boolean\n\nConsider a simple alarm clock,\n\nWe can get the time through the time library we’ve seen before\n  import time\n\n  current_time = time.localtime()\n\n  hour = current_time.tm_hour\ntime.localtime returns an object containing information about the current time.\n\nThis different blocks of information are called attributes, below is a list of the attributes contained in the object returned by localtime\n\n\n\n\n\n\n\n\n\n\nAttribute\nValue\n\n\n\n\ntm_year\nYear (for example, 2017)\n\n\ntm_mon\nMonth (in the range 1 … 12, 1 represents January)\n\n\ntm_mday\nDay in the Month (in the range 1 … month length)\n\n\ntm_hour\nHour in the Day (in the range 0 … 23)\n\n\ntm_min\nMinute in the Hour ( in the range 0 … 59)\n\n\ntm_sec\nSeconds in the Minute ( in the range 0 … 59)\n\n\ntm_wday\nDay of the Week (in the range 0 … 6 with Monday as 0)\n\n\ntm_yday\nDay in the Year (in the range 0 … 364 or 365 depending on if the year is a leap year)\n\n\n\n\nAn example of a localtime object might look like,\n\n\n\n\nAttribute\nValue\n\n\n\n\ntm_year\n2017\n\n\ntm_mon\n7\n\n\ntm_mday\n19\n\n\ntm_hour\n11\n\n\ntm_min\n40\n\n\ntm_sec\n30\n\n\ntm_wday\n2\n\n\ntm_yday\n200\n\n\n\n\n\nLets make a clock that displays only the hour value, using localtime. These one-handed clocks are supposed promote a more relaxed attitude. Create a new program (OneHandedClock.py) and copy the below text.\n\n    # Example 5.1: One Handed Clock\n    #\n    # Uses time to display the hour\n\n    import time\n\n    current_time = time.localtime()\n    hour = current_time.tm_hour\n\n    print(\"The hour is\", hour)\n\nThe hour is 13\n\n\nRun the program, it should print out the current hour\n\n\n\nImprove the previous example to produce a more fully featured clock that reports the time, and date when run\nWe can use the table above to grab the correct attributes. We then simply need to format the attribute as nessecary. The final program is given below\n\n    # Exercise 5.1: Improved Clock\n    #\n    # An improved clock that displays the date and time when run\n\n    import time\n\n    current_datetime = time.localtime()\n\n    day = current_datetime.tm_mday\n    month = current_datetime.tm_mon\n    year = current_datetime.tm_year\n    print(\"The date is\", day, \"/\", month, \"/\", year)\n\n    seconds = current_datetime.tm_sec\n    minutes = current_datetime.tm_min\n    hours = current_datetime.tm_hour\n    print(\"The time is\", hours, \":\", minutes, \":\", seconds)\n\nThe date is 10 / 1 / 2026\nThe time is 13 : 42 : 21\n\n\n\n\n\n\n\nWe’ve seen expressions as being made of operators and operands\nOne type of operator is a comparison operator\n\nReturns a value that is True or False, e.g.\n\n\n\n\n\n\n\nblock-beta\n    columns 3\n    space\n    title[\"Breakdown of an Example Comparison Expression\"]\n    space\n\n    block:Input\n    columns 1\n        operand1[\"hour\"]\n        operand1Word[\"Operand\"]\n        operand1descr[\"(thing to work on)\"]\n    end\n\n    block:Middle\n    columns 1\n        operator[\"&gt;\"]\n        operatorWord[\"Operator\"]\n        operatorDescr[\"(thing to do)\"]\n    end\n\n    block:Output\n    columns 1\n        operand2[\"6\"]\n        operand2Word[\"Operand\"]\n        operand2descr[\"(thing to work on)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass operand2Word BG\nclass operand2descr BG\nclass operand1Word BG\nclass operand1descr BG\nclass operatorWord BG\nclass operatorDescr BG\n\n\n\n\n\n\n\n\n\nBelow is a table of the common comparison operators\n\n\n\n\n\n\n\n\n\nOperator\nName\nEffect\n\n\n\n\n\\(&gt;\\)\nGreater than\nTrue if the left argument is greater than the right, else False\n\n\n\\(&lt;\\)\nLess than\nTrue if the left argument less than the right, else False\n\n\n\\(&gt;=\\)\nGreater than or Equal\nAs for Greater than but also True if the left argument equals the right\n\n\n\\(&lt;=\\)\nLess than or Equal\nAs for Less than but also True if the left argument equals the right\n\n\n\\(==\\)\nEquals\nTrue if the left argument equals the right argument, else False\n\n\n\\(!=\\)\nNot Equals\nTrue if the left argument does not equal the right argument, else False\n\n\n\n\nA program can use a comparison operator to set a boolean variable, e.g. the below code fragment which sets the boolean variable it_is_time_to_get_up to True if the variable hour is greater than \\(6\\) else sets it to False\n\n    it_is_time_to_get_up = hour &gt; 6\n\n\nUse the python interpreter to work through the following questions in order to understand Comparison Operators\n\nHow does the equality operator work?\n\nThe equality operator evaluates to True if the two operands hold the same value\n\n\n1 == 1\n\nTrue\n\n\n\nThe equality operator can be used to compare strings and bools\n\n\n 'Rob' == 'Rob'\n\nTrue\n\n\n\n True == True\n\nTrue\n\n\nHow do I remember which relational operator to use?\n\nPractice, patience and muscle memory\n\nCan we apply relational operators between other types of expressions?\n\nYes. For example, the \\(&gt;\\) and \\(&lt;\\) operators when used to compare strings will use an alphabetic ordering, e.g.\n\n'Alice' &lt; 'Brian'\n\nTrue\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nEquality and Floating-point Values\nIn Chapter 4 we noted that floating points only approximate a specific real-value. These approximations can cause issues when using comparison operators, e.g.\n\nx = 0.3\ny = 0.1 + 0.2\nx == y\n\nFalse\n\n\n\nThe variables x and y should both notionally store \\(0.3\\), but the equality shows they are unequal. This is because the addition of \\(0.1\\) and \\(0.2\\) actually leads to y storing the slightly inaccurate \\(0.3000...4\\)\nIf comparing floating-point numbers for equality, the best approach is to check that the values are appropriately close\n\n\n\n\nPython provides the type function, type(x) returns the type of the variable x, especially useful for investigating the type of values returned by library functions you’ve never seen before\n\n\n\n\n\n\n\nWhat if we want to combine boolean expressions to create a new boolean expression\ne.g. An alarm might want to go off when the hour is after \\(7\\) and the minute is after \\(30\\)\nPython provides logic operators for combining boolean expressions\n\n\n\nUse the python interpreter to answer the following questions and investigate boolean operators\n\nWhat does the following expression evaluate too?\n\nnot True\n\nFalse\n\n\n\nnot inverts the value of a boolean, so True is converted to False\n\nHow about this expression?\n\nTrue and True\n\nTrue\n\n\n\nand is True iff both arguments are True as is the case above, so the result is True\n\nHow about this expression?\n\nTrue and False\n\nFalse\n\n\n\nSince one of the arguments is False and will evaluate to False\n\nHow about this expression?\n\nTrue or False\n\nTrue\n\n\n\nSince one of the arguments is True or will evaluate to True\n\nSo far, the examples have only used boolean values. What happens if we mix boolean and numeric values?\n\n True and 1\n\n1\n\n\n\nRecall that python can convert numeric expressions to boolean ones, this implicitly happens to the \\(1\\) in the above. So we would expect and to return True. However ,instead \\(1\\) is returned. This is due to some odd python behaviour\n\nPython sees True \\(\\rightarrow\\) result of and implied by second argument\n\nSo simply returns the second argument, since the truthfulness of \\(1\\), is equivalent to the original expression\n\nIf we flip the arguments, we should see this more clearly\n\n  1 and True\n\nTrue\n\n\n\nThis time the above expressions should return True\n\nThe same behaviour will also occur with or\n\n  1 or False\n\n1\n\n\n\nHere the or operator short-circuits on \\(1\\), so returns \\(1\\)\n\n\n  0 or True\n\nTrue\n\n\n\nHere the or evaluates the first argument as false, so cannot short-circuit, the second argument is returned, i.e True\n\n\n\n\n\nLet us now use and to try construct an expression that will correctly evaluate when the time is after \\(7:30\\), naively we might expect,\n\n    it_is_time_to_get_up = hour &gt; 6 and minute &gt; 29\n\nWe can use a truth table to check,\n\n\n\n\nHour\nMinute\nDesired\nOutput\n\n\n\n\n6\n0\nFalse\nFalse\n\n\n7\n29\nFalse\nFalse\n\n\n7\n30\nTrue\nTrue\n\n\n8\n0\nTrue\nFalse\n\n\n\n\nWe can see in the last case the result is not what we want!\n\nhour &gt; 7 is true, but minute &gt; 29 is false, so we need to be more precise,\n\n\n    it_is_time_to_get_up = (hour &gt; 7) or (hour == 7 and minute &gt; 29)\n\nWe use brackets to make the expression more readable\nHere we use short-circuiting, if the the hour is greater than \\(7\\) we don’t need to check the minutes value\n\n\n\n\n\n\n\nWarning\n\n\n\nBe Careful with Logic Operations\nWhen working with boolean operations you should always check that the logic matches what you expect!\n\n\n\n\n\n\n\n\nSuppose we want a program to tell me if it’s time to get out of bed\nNeed the ability to run code if a boolean condition is met\n\nCan do so using the aptly named if operator\n\n\n\n\n\nCreate a new python program (SimpleAlarmClock.py) with the following contents\n\n\n# Example 5.2: Simple Alarm Clock\n#\n# Demonstrates `if` using a simple alarm clock\n\nimport time\n\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminute = current_time.tm_sec\n\nit_is_time_to_get_up = (hour &gt; 7) or (hour == 7 and minute &gt; 29)\n\nif it_is_time_to_get_up:\n    print(\"IT IS TIME TO GET UP\")\n\nIT IS TIME TO GET UP\n\n\n\nThe program should print IT IS TIME TO GET UP only if the time is after \\(7:30\\)\nThe if construct starts with the word if, following by a boolean value called the condition, then a :\nAny statements we want to execute if the if is True are then written below the if and indented one level\n\n\n\n\n\nCondition is a term for the expression that controls which branch of the if is executed\nIf the condition evaluates True the indented branch is run\nIf the condition evluates False the indented branch is skipped\nWe could simply the above code by including the check directly in the if rather than an intermediate variable\n\n\nif (hour &gt; 7) or (hour == 7 and minutes &gt; 29):\n    print(\"IT IS TIME TO GET UP\")\n\nIT IS TIME TO GET UP\n\n\n\n\n\n\nWhat if we want multiple statements to run after an if statement\nWe just write them as a sequence of indented statements\n\n\n\nLet us improve the previous example to also play a sound if it’s time to get up. Create a program (SirenAlarmClock.py) with the contents below\n# Example 5.3: Siren Alarm Clock\n#\n# Improves the Simple Alarm Clock to also play a sound\n\nimport time\n\nimport snaps\n\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminute = current_time.tm_min\n\nif (hour &gt; 7) or (hour == 7 and minute &gt; 29):\n    snaps.display_message(\"TIME TO GET UP\")\n    snaps.play_sound(\"siren.wav\")\n    # pause the program to give time for the sound to play\n    time.sleep(10)\nThis program now runs three statements in the if\n\nFirst a message is displayed\nSecond a sound is played\nThird the program sleeps so the sound has time to play\n\n\nIf we want something to run regardless of the if condition, we write it either before or after the if statement\n\n\n\n\nAdd to the simple Alarm Clock, by making it so the program will always print the current time regardless of if the alarm goes off. Create a new program (AlarmClockWithTimeDisplay.py). Enter the following contents,\n\n# Example 5.4: Alarm Clock with Time Display\n#\n# A variant of Alarm Clock to also always display the time\n\nimport time\n\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminute = current_time.tm_min\n\nif (hour &gt; 7) or (hour == 7 and minute &gt; 29):\n    print(\"TIME TO GET UP\")\n    print(\"RISE AND SHINE\")\n    print(\"THE EARLY BIRD GETS THE WORM\")\nprint(\"The time is\", hour, \":\", minute)\n\nTIME TO GET UP\nRISE AND SHINE\nTHE EARLY BIRD GETS THE WORM\nThe time is 13 : 42\n\n\n\nThe program above will always print the current time, regardless of if the alarm block is run\n\n\n\n\n\n\n\nCaution\n\n\n\nIndented Text can cause Big Problems\nAs seen above, python uses indentation for control flow, this has the advantage in that it follows normal code style practices, but has some pitfalls\n\nIf the indention is wrong the program won’t run\n\ni.e. if one line is indented four spaces, and the next three an error will be thrown\n\nimport time\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminutes = current_time.tm_min\n\nif (hour &gt; 7) or (hour == 7 and minute &gt; 29):\n  print(\"IT IS TIME TO GET UP\")\n      print(\"The early bird gets the worm...\")\n\n\n  Cell In[24], line 8\n    print(\"The early bird gets the worm...\")\n    ^\nIndentationError: unexpected indent\n\n\n\n\n\nA more insidious error, occurs if one mixes tabs and spaces in the indentation, since the code may appear to be fine until it attempts to run\n\n import time\n current_time = time.localtime()\n hour = current_time.tm_hour\n minutes = current_time.tm_min\n\n if (hour &gt; 7) or (hour == 7 and minute &gt; 29):\n     print(\"IT IS TIME TO GET UP\")\n     print(\"The early bird gets the worm...\")\n\nIT IS TIME TO GET UP\nThe early bird gets the worm...\n\n\n\nMost programmers and even text editors will automatically convert one style of indentation to the other (commonly tabs to spaces, but sometimes spaces to tabs) to avoid this issue\n\nIn the above code, my editor converted the second line which was indented with spaces to a tab to match the previous line\n\n\n\n\n\n\n\n\n\n\nFormally, an if has a structure like\n\n\n\n\n\n\nblock-beta\n    columns 4\n    space\n    title[\"Breakdown of an if statement\"]:2\n    space\n\n    block:Input\n    columns 1\n        if[\"if\"]\n        ifDescr[\"(start of the if construction)\"]\n    end\n\n    block:Condition\n    columns 1\n        condition[\"condition\"]\n        conditionDescr[\"(value that is true or false)\"]\n    end\n\n    block:Colon\n    columns 1\n        colon[\":\"]\n        colonDescr[\"colon\"]\n    end\n\n    block:Suite\n    columns 1\n        suite[\"suite\"]\n        suiteDescr[\"statements\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass condition BG\nclass conditionDescr BG\nclass colon BG\nclass colonDescr BG\nclass suite BG\nclass suiteDescr BG\nclass if BG\nclass ifDescr BG\n\n\n\n\n\n\n\nThere are two ways to write the suite\n\nA set of indented statements on the lines proceeding the if\nA set of statements on the same line as the if each seperated by a semicolon (;) e.g.\n if (hour &gt; 6): print('IT IS TIME TO GET UP'); print('THE EARLY BIRD GETS THE WORM')\n\n\n\n\n\n\n\n\nWarning\n\n\n\nYou can’t combine inline if statements, with indented if statements, e.g.\n\n    import time\n    current_time = time.localtime()\n    hour = current_time.tm_hour\n    minutes = current_time.tm_min\n\n    if (hour &gt; 7) or (hour == 7 and minute &gt; 29): print(\"IT IS TIME TO GET UP\"); print(\"RISE AND SHINE\")\n        print(\"The early bird gets the worm...\")\n\n\n  Cell In[26], line 7\n    print(\"The early bird gets the worm...\")\n    ^\nIndentationError: unexpected indent\n\n\n\n\n\n\n\n\nUse the python interpreter to answer the following questions to understand conditional statements\n\nCan we work with conditional statements using the python shell?\n\nYes you can, type the following into the shell,\n\nif True:\n\nThe shell may display ... instead of &gt;&gt;&gt; or, omit &gt;&gt;&gt; and indent\n\nIn the first case we can indent ourselves to write the suite\nIn the second we simply write the suite\n\nOnce done writing the if statement, simply deindent\nTry write the following in the shell, and verify the output\n\n  if True:\n      print('True')\n      print('Still True')\n\nTrue\nStill True\n\n\n\nHow many spaces must you indent a suite of Python statements controlled by an if statement?\n\nThere is no approved value, but it must be consistent\ni.e. if the first indentation is four, then all future indentations must also be four\n\nCommon choices are 4, 8 or 2\n\n\n\n\n\n\n\n\nSometimes we want conditional behaviour on both the True and False branches\nelse is a keyword that lets us add behaviour that executes when an if evaluates as False\n\n\n\nModify the Simple Alarm Clock to now print a message telling us to go back to bed if it before our alarm should go off. Write a new program (SimpleAlarmClockWithElse.py) with the following contents,\n\n# Example 5.5: Simple Alarm Clock\n#\n# Variant of the Simple Alarm Clock\n# that modifies the output depending on if its time to get up\n\nimport time\n\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminute = current_time.tm_min\n\nif (hour &gt; 7) or (hour == 7 and minute &gt; 29):\n    print(\"IT IS TIME TO GET UP\")\nelse:\n    print(\"Go back to bed\")\n\nIT IS TIME TO GET UP\n\n\n\nObserve that only one line of the paired if-else statements is printed\n\n\n\n\nWork through the following questions to understand if constructions\n\nMust an if construction have an else part?\n\nNo, we saw when first working with if that we could exclude the else in that case no additional code runs if the if evaluates False\n\nWhat happens if a condition is never True?\n\nIt simply never executes\n\n\n\n\n\n\n\nThe if statement can be used to compare strings, as seen with the comparison operators\n\n\n\nThe following program uses the equality operator and an if statement to greet a person if their name matches. What is a potential issue with this program?\n# Example 5.6: Broken Greeter\n#\n# A Greeter program using string matching\n# Identify the issues with this program\n\nname = input(\"Enter your name: \")\n\nif name == \"Rob\":\n    print(\"Hello, Oh great one\")\n\nThe equality operator checks against the string \"Rob\" exactly\ni.e. it is case sensitive, if we write \"ROB\", or \"rob\" or some variation thereof, the statement will not match.\n\nWe can fix this by using the string method upper, this converts all forms of the word \"rob\" to \"ROB\" which we can reliably check against. The new program looks like\n# Example 5.7: Uppercase Greeter\n#\n# A Greeter program using string matching\n# Fixes the issues with Example 5.6 by using\n# str.upper()\n\nname = input(\"Enter your name: \")\n\nif name.upper() == \"ROB\":\n    print(\"Hello, Oh great one\")\n\nWe could also use the string method lower to compare against an all lowercase word\n\n\n\n\nConsider the following questions to learn about methods and functions\n\nHow do lower() and upper() work?\n\nPython types are objects that provide methods.\nMethods are called like functions\n\nWhy do we have to write lower() and not lower?\n\nLeave the parentheses off, and see what happens\n\n  name = 'Rob'\n  name.upper\n\n&lt;function str.upper()&gt;\n\n\nWe are instead returned a description of the method itself\n\nWhat’s the difference between functions and methods?\n\nThey are used the same way, but they differ in where they are created\nFunctions are not associated any specific object\nMethods are bound as attributes of objects\n\n\n\n\n\n\n\nYou can nest conditions, e.g. if you want to perform sequential checks\n\n\n\nLet us demonstrate nested if through a greeter which requires a follow on code word to confirm the identity of the user. Create a program (CodedGreeter.py) with the following contents\n# Example 5.8: Coded Greeter\n#\n# Asks the user for a follow on code to confirm their ID\n# before the program greets them\n\nname = input(\"Enter your name: \")\n\nif name.upper() == \"ROB\":\n    code = input(\"Enter the codeword: \")\n    if code == \"secret\":\n        print(\"Hello, Oh great one\")\n    else:\n        print(\"Begone. Imposter\")\n\nPlay around with the above code to see what happens for various input combinations.\nYou should see if the first input is not a variant of \"rob\" the second prompt never occurs and the program ends.\nAdjust the above by writing a new program (CodedGreeterWithOuterElse.py)*\n\n# Example 5.9: Coded Greeter with Outer Else\n#\n# Asks the user for a follow on code to confirm their ID\n# before the program greets them\n# Has an additional outer else clause for the case that the nested\n# if does not run\n\nname = input(\"Enter your name: \")\n\nif name.upper() == \"ROB\":\n    code = input(\"Enter the codeword: \")\n    if code == \"secret\":\n        print(\"Hello, Oh great one\")\n    else:\n        print(\"Begone. Imposter\")\nelse:\n    print(\"You are not Rob. Shame.\")\n\nThe above code uses a second else clause, attached to the first outer, if condition\nThis means that it will run whenever the original name is not some variant of \"ROB\"\n\n\n\n\n\n\n\nImprove the Alarm Clock. Make the alarm display the date as well as the time, and let the user sleep in on the weekends.\nOur implementation is given below,\n# Exercise 4.2: Advanced Alarm Clock\n#\n# An Advanced Alarm Combining the Behaviour\n# of most increments of the alarm clock\n# and allowing you to sleep in on weekends\n\nimport time\n\nimport snaps\n\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminute = current_time.tm_min\nday = current_time.tm_mday\nmonth = current_time.tm_mon\nis_weekend = current_time.tm_wday &gt;= 5\n\ndate_message = \"The date is \" + str(day) + \"/\" + str(month)\ntime_message = \"The time is \" + str(hour) + \":\" + str(minute)\n\nmsg = \"\"\nup_hour = 7 + is_weekend  # get to sleep in an extra hour on weekends\n\nif (hour &gt; up_hour) or (hour == up_hour and minute &gt; 29):\n    msg = msg + \"TIME TO GET UP\"\n    snaps.play_sound(\"siren.wav\")\nelse:\n    msg = msg + \"Go back to bed!\"\nmsg = msg + \"\\n\" + date_message + \"\\n\" + time_message\nsnaps.display_message(msg, size=50)\ntime.sleep(10)  # leave time for the sound and to read\nMost of the text simply exists to correctly create the final message we will display on the screen. The most important parts are, is_weekend = current_time.tm_wday &gt;= 5 which uses the fact that Saturday and Sunday have the value \\(5\\) and \\(6\\) in the current_time.tm_wday attribute (A number representing the day in the week) to set a boolean flag. We then use the fact that True acts numerically as one, and False acts numerically as zero to let us sleep in an hour on the weekend using up_hour = 7 + is_weekend which is \\(8\\) on weekends and \\(7\\) on weekdays.\nWe then run through the code as we have for most of the alarm clock cases, using an else clause to ensure we always have a message for the user, and appending the date and time message to this output.\nLastly we pass the method to snaps for display\n\n\n\n\n\n\nIn this next section we’ll write our first semi-sophisticated program\n\n\nScenario:\nA local theme park wants you to write a program that will let users check if they meet the age requirements to go on a ride. They provide the following table covering the current rides\n\n\n\n\n\n\n\nRide\nRestrictions\n\n\n\n\nScenic River Cruise\nNone\n\n\nCarnival Carousel\nAt least 3 years old\n\n\nJungle Adventure Water Splash\nAt least 6 years old\n\n\nDownhill Mountain Run\nAt least 12 years old\n\n\nThe Regurgitator\nAt least 12 years old and less than 70\n\n\n\n\n\n\n\nWe will use a simple text interface\n\nWelcome to our Theme Park\n\nThese are the available rides\n\n1. Scenic River Cruise\n2. Carnival Carousel\n3. Jungle Adventure Water Splash\n4. Downhill Mountain Run\n5. The Regurgitator\n\nPlease enter the ride you want: 1\nYou have selected the Scenic River Cruise\nThere are no age limits for this ride\n\n\n\n\n\n\nImportant\n\n\n\nDesign the User Interface with the Customer\nThe UI can be the most important and most difficult part of design because it can be very subjective. Ultimately the Customer is the one paying and so they should be involved in the UI design throughout!\n\n\n\n\n\n\nWe have a UI design, now we need to implement it\nOur code starts as below,\n\n# Example 5.10: Ride Selector Start\n#\n# The basic shell of the Ride Selector UI\n\nprint(\"\"\"Welcome to our Theme Park\n      These are the available ride:\n\n      1. Scenic River Cruise\n      2. Carnival Carousel\n      3. Jungle Adventure Water Splash\n      4. Downhill Mountain Run\n      5. The Regurgitator\n      \"\"\")\n\nride_number_text = input(\"Please enter the ride number you want: \")\nride_number = int(ride_number_text)\n\nif ride_number == 1:\n    print(\"You have selected Scenic River Cruise\")\n    print(\"There are no age limits for this ride\")\n\nWe first print out our Menu, using a triple-delimited string so we can multiline it\nThen we implement the menu using a series of if statements.\n\nFor the first case (Scenci River Cruise) we don’t need the user’s age so we can output the result immediately\n\nFor other rides the user needs to supply their age, so we continue,\n\nelse:  # need to get the age of the user\n    age_text = input(\"Please enter your age: \")\n    age = int(age_text)\n\nWe have to get the age using another input pair\nThis should already be familiar to you\n\n\n\n\nOnce we have the age, we need to compare against the restrictions for the selected ride\nWe can do this with a nested series of if statements which\n\nFirst selects the appropriate ride\nChecks the age against the ride’s age requirements\n\n\n    if ride_number == 2:\n        print(\"You have selected the Carnival Carousel\")\n        if age &gt;= 3:\n            print(\"You can go on the ride\")\n        else:\n            print(\"Sorry, you are too young\")\n    if ride_number == 3:\n        print(\"You have selected Jungle Adventure Water Splash\")\n        if age &gt;= 6:\n            print(\"You can go on the ride\")\n        else:\n            print(\"Sorry, you are too young\")\n\nDownhill Mountain Splash (ride number 4) can be implemented exactly as above\n\n\n\n\n\n\n\nTip\n\n\n\nReduce duplicated Code\nYou may have noticed that the above statement appears to have a bunch of duplicated code. The rough structure is,\nselect ride\nif age of user is greater than or equal to the rides min age\n    Inform the user they can go on the ride\nelse:\n    Inform the user they cannot go on the ride\nProgrammers typically don’t like to repeat themselves as it increases the number of ways a program can go wrong. So ideally we would like a way were we could write something like the above once and have the appropriate checks be carried out, and the message printed without having to write it out for every case. We’ll look at some ways to do this later in the book.\n\n\n\n\n\n\nThe last ride introduces an additional check, we have a minimum and a maximum age.\n\nNeed to introduce another layer nested conditional to differentiate between the too old and too young case\n\n\n    if ride_number == 5:\n        print(\"You have selected The Regurgitator\")\n        if age &gt;= 12:\n            # first check age not too low\n            if age &gt; 70:\n                # Age is too old\n                print(\"Sorry, you are too old\")\n            else:\n                # In the valid range\n                print(\"You can go on the ride\")\n        else:\n            # Age is too young\n            print(\"Sorry, you are too young\")\n\nYou can see the final Program (Ride Selector)\n\n\n\n\n\n\nWe can add some extra quality to our implementation using snaps\nsnaps get_string method\n\n# Example 5.11: Snaps get_string function\n#\n# Demonstrates using the get_string function\n# in snaps to get user input via a graphical\n# interface\n\nimport time\n\nimport snaps\n\nname = snaps.get_string(\"Enter your name: \")\nsnaps.display_message(\"Hello \" + name)\n\ntime.sleep(5)\n\n\n\n\n\n\nImportant\n\n\n\nAs written, the snaps get_string method on my machine, did not work when running Pygame 2. I had to modify the method to the following,\ndef get_string(prompt, size=50, margin=20,\n               color=(255, 0, 0), horiz='left', vert='center',\n               max_line_length=20):\n    '''\n    Reads a string from the user\n    '''\n\n    setup()\n\n    result = ''\n    cursor_char = '*'\n    cursor = None\n\n    def redraw():\n        clear_display()\n\n        render_message(prompt+result, margin=margin, size=size,\n                       horiz=horiz, vert=vert, color=color, cursor=cursor)\n\n    def cursor_flip():\n        nonlocal cursor\n\n    # create a timer for the cursor\n\n    cursor_event = pygame.USEREVENT+1\n\n    pygame.time.set_timer(cursor_event,500)\n    pygame.key.start_text_input()\n\n    while True:\n        event = pygame.event.wait()\n\n        if event.type == cursor_event:\n            if cursor:\n                cursor = None\n            else:\n                cursor = cursor_char\n            redraw()\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_RETURN:\n                break\n            elif event.key == pygame.K_BACKSPACE:\n                if len(result) &gt; 0:\n                    result = result[:-1]\n                    redraw()\n        elif event.type == pygame.TEXTINPUT:\n            if len(result) &lt; max_line_length:\n                result += event.text\n                redraw()\n\n    # disable the timer for the cursor\n    pygame.time.set_timer(cursor_event,0)\n    return result\nI won’t go into detail on explaining the changes since it’s above the level we’ve currently been discussing but if you have issues with the running any of the snaps get_string programs in this book, I would recommend trying the above replacement to the function\n\n\n\nUsing the above and some optional arguments to play around with text placement we can create the start of a GUI implementation of the Ride Selector Program\n\n\n\nThe below program is the outline for an implementation of the Ride Selector Program using snaps to provide a GUI\n# Example 5.12: Theme Park Snaps Display\n#\n# Reimplments the shell of the Ride Selector Menu using Snaps\n\nimport time\nimport snaps\n\n\nsnaps.display_image(\"themepark.png\")\n\nprompt = \"\"\"Welcome to our Theme Park\n      These are the available ride:\n\n      1. Scenic River Cruise\n      2. Carnival Carousel\n      3. Jungle Adventure Water Splash\n      4. Downhill Mountain Run\n      5. The Regurgitator\n\n      Select your ride: \"\"\"\n\nride_number_text = snaps.get_string(prompt, vert=\"bottom\", max_line_length=3)\nconfirm = \"Ride \" + ride_number_text\n\nsnaps.display_message(confirm)\ntime.sleep(5) #gives user time to read the output\n\n\n\nUsing the previous example, complete the ride selector program. Extending its features where reasonable\nWe’ll reimplement all the features of the original text-based interface, but add in the siren sound effect if the user is unable to ride the ride. Otherwise this proceeds as with most of our conversions to snaps. We replace print with snaps.display_message and introduce some work to build the string that we want to send to snaps.display_message. In this case we create a string that is nicely formatted to output\n\nThe ride number the user selected\nThe name of the ride\nA message letting them know if they are allowed to ride\n\nOur final implementation can be found in the file ThemeParkSnapsDisplay.py, or read from down below, observe the usual use of the time.sleep function to prevent the window from immediately closing\n# Exercise 5.3: Snaps Ride Selector\n#\n# Reimplments the entirety of the Theme Park Ride Selector using\n# a snaps interface, and adds some audio ques to warn the user\n# when they are ineligable for ride\n\nimport time\nimport snaps\n\n\nsnaps.display_image(\"themepark.png\")\n\nprompt = \"\"\"Welcome to our Theme Park\n      These are the available ride:\n\n      1. Scenic River Cruise\n      2. Carnival Carousel\n      3. Jungle Adventure Water Splash\n      4. Downhill Mountain Run\n      5. The Regurgitator\n\n      Select your ride: \"\"\"\n\nride_number_text = snaps.get_string(prompt, vert=\"bottom\", max_line_length=3)\nconfirm = \"Ride \" + ride_number_text\n\nsnaps.display_message(confirm)\ntime.sleep(2)  # gives user time to read the output\n\nride_number = int(ride_number_text)\n\nif ride_number == 1:\n    msg = confirm + \"\\nScenic River Cruise\\n\\nThere are no age limits for this ride\"\n    snaps.display_message(msg, size=100)\nelse:  # need to get the age of the user\n    age_text = snaps.get_string(\n        \"Please enter your age: \", vert=\"bottom\", max_line_length=3\n    )\n    age = int(age_text)\n\n    if ride_number == 2:\n        msg = confirm + \"\\nCarnival Cruise\"\n        if age &gt;= 3:\n            msg = msg + \"\\n\\nYou can go on the ride\"\n            snaps.display_message(msg, size=100)\n        else:\n            snaps.play_sound(\"siren.wav\")\n            msg = msg + \"\\n\\nSorry, you are too young\"\n            snaps.display_message(msg, size=100)\n    if ride_number == 3:\n        msg = confirm + \"\\nJungle Adventure Water Splash\"\n        if age &gt;= 6:\n            msg = msg + \"\\n\\nYou can go on the ride\"\n            snaps.display_message(msg, size=100)\n        else:\n            msg = msg + \"\\n\\nSorry, you are too young\"\n            snaps.play_sound(\"siren.wav\")\n            snaps.display_message(msg, size=100)\n    if ride_number == 4:\n        msg = confirm + \"\\nDownhill Mountain Run\"\n        if age &gt;= 12:\n            msg = msg + \"\\n\\nYou can go on the ride\"\n            snaps.display_message(msg, size=100)\n        else:\n            msg = msg + \"\\n\\nSorry, you are too young\"\n            snaps.play_sound(\"siren.wav\")\n            snaps.display_message(msg, size=100)\n    if ride_number == 5:\n        msg = confirm + \"\\nThe Regurgitator\"\n        if age &gt;= 12:\n            # first check age not too lowe\n            if age &gt; 70:\n                # Age is too old\n                msg = msg + \"\\n\\nSorry, you are too old\"\n                snaps.play_sound(\"siren.wav\")\n                snaps.display_message(msg, size=100)\n            else:\n                msg = msg + \"\\n\\nYou can go on the ride\"\n                snaps.display_message(msg, size=100)\n        else:\n            msg = msg + \"\\n\\nSorry, you are too young\"\n            snaps.display_message(msg, size=100)\ntime.sleep(5)\n\n\n\nUsing snaps and the weather functions it includes, write a simple program to remind the user to wrap up warm, wear sunscreen etc.\nWe’ll use the basic outline of the solution in the book,\n#EG5-14 Weather Helper\n\nimport snaps\n\ntemp = snaps.get_weather_temp(latitude=47.61, longitude=-122.33)\nprint(\"The temperature is:\", temp)\n\nif temp &lt; 40:\n    print(\"Wear a coat - it is cold out there\")\nelif temp &gt; 70:\n    print(\"Remember to wear sunscreen\")\nThe first step is to convert the print statements to instead use the snaps, display_message function. This requires us to do the usual work of building the string before we display it. Next we also want to display an image, either a sun or a snowflake depending on if the weather is hot or cold. Since we’re grabbing some new images, we run into an issue that snaps doesn’t work to rescale the images out of the box. We can fix this by adding the line image = image.convert_alpha() before the image = pygame.transform.smoothscale(image, window_size) line in display_image in snaps. Our final program (Weather Helper) looks like,\n# Exercise 5.4 Weather Helper\n#\n# Simple Weather Program that reminds the user about\n# the weather conditions, with helpful text and\n# pictures\n\nimport time\nimport snaps\n\ntemp = snaps.get_weather_temp(latitude=47.61, longitude=-122.33)\nconditions = snaps.get_weather_desciption(latitude=47.61, longitude=-122.33)\n\nif temp is None or conditions is None:\n    msg = \"Could not retrieve Weather...\"\nelse:\n    msg = \"The temperature is: \" + str(temp)\n    if temp &lt; 40:\n        msg = msg + \"\\n\\nWear a coat - it is cold out there\"\n        snaps.display_image(\"snowflake.png\")\n    elif temp &gt; 70:\n        msg = msg + \"\\n\\nRemember to wear sunscreen\"\n        snaps.display_image(\"sun.png\")\n    msg = msg + \"\\n\\nThe weather is \" + conditions\n\nsnaps.display_message(msg, size=100, color=\"red\")\ntime.sleep(5)\nIgnore the line if temp is None or conditions is None, this is some error handling code we’ll look at in a latter chapter. Notice that since no matter which path we go through the if, elif chain we’ll post a message at the end. So we use the branch code in order to set up the appropriate message, while the call to display_message sits outside the loop, so we don’t have to call it on every path.\n\n\n\nUsing randint and if statements write a fortune teller program that gives random fortunes to the user\nWe’ll expand on the prototype given by providing two additional statements, one relating to the future and the other relating to the wealth. We’ll follow the structure of using random.randint(1, 6) to simulate rolling a six-sided die, but spice it up by using if-elif-else clauses to play with the relative weighting of different statements.\n\n# Exercise 5.5 Fortune Teller Program\n#\n# A simple program that uses random numbers to generate a sequence of\n# fortunes for the user\n\nimport random\n\n# Meeting someone\nif random.randint(1, 6) &lt; 4:\n    print(\"You will meet a tall, dark stranger\")\nelse:\n    print(\"Nobody unexpected will enter your life\")\n\n# Money\nresult = random.randint(1, 6)\nif result == 1:\n    print(\"I see untold riches in your future\")\nelif result &lt;= 3:\n    print(\"A life of comfort is coming\")\nelif result &lt; 6:\n    print(\"You would do well to husband your wealth\")\nelse:\n    print(\"I see a future lived on the streets...\")\n\n# Advice\nresult = random.randint(1, 6)\nif result &lt;= 2:\n    print(\"Sometimes the answers to our future, come from the past\")\nelif result &lt; 6:\n    print(\"To define your future, avoid getting hung up on the past\")\nelse:\n    print(\"You will soon face a decision that will redefine everything\")\n\nNobody unexpected will enter your life\nI see a future lived on the streets...\nTo define your future, avoid getting hung up on the past\n\n\nWe use a mix of ==, &lt;= and &lt; operators to emphasise the clarity of the branching. This implementation is quite simple (because the exercise does not personally interest me that much) Feel free to expand on my solution",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 5: Making Decisions"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/05_MakingDecisions/Chapter_05.html#summary",
    "href": "01_ProgrammingFundamentals/05_MakingDecisions/Chapter_05.html#summary",
    "title": "Chapter 5: Making Decisions",
    "section": "Summary",
    "text": "Summary\n\nPython can work with boolean values\n\nBool values are either True or False\n\nComparison operators compare expressions to generate boolean values\nif is used to control program execution in response to boolean expressions\n\nif executes code if a condition is True\n\nLogic operators and, or and not are used to create new boolean expressions from existing ones\n\nand is True if both expressions are True else False\nor is True if either expression is True else False\nnot flips the truth of a boolean expression\n\ne.g. True \\(\\rightarrow\\) False\nFalse \\(\\rightarrow\\) True",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 5: Making Decisions"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/05_MakingDecisions/Chapter_05.html#questions-and-answers",
    "href": "01_ProgrammingFundamentals/05_MakingDecisions/Chapter_05.html#questions-and-answers",
    "title": "Chapter 5: Making Decisions",
    "section": "Questions and Answers",
    "text": "Questions and Answers\n\nDoes the use of Boolean values mean a program will always do the same thing given the same data inputs?\n\nIt is very important that given the same inputs (including any inputs from a source of randomness) a program behaves the same way\n\nWill the computer always do the right thing when we write programs that make decisions?\n\nA computer running a program is only as correct as the program that was written. Formally verifing anything but the most trivial program as being correct is very difficult (and the problem in general is not-computable (see The Halting Problem))\nIt is typically the responsibility of the programmer to to ensure a program behaves correctly (in conjuction with the customer.) Even in cases where a user inputs wrong data, the customer would probably expect the programmer to build into the program the appropriate checks to deal with these wrong data inputs\n\nIs there a limit to how many if conditions you can nest inside each other?\n\nNo, the python interpreter should be able to handle many many layers of nested if statements. Most people will emphasise that if you’re finding that you’re needing to write heavily nested code (the exact number of what constitutes heavy is debated but \\(3\\) is a rough guide) you should look at if there’s a better way to write",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 5: Making Decisions"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/07_UsingFunctions/Chapter_07.html",
    "href": "01_ProgrammingFundamentals/07_UsingFunctions/Chapter_07.html",
    "title": "Chapter 7: Using Functions to Simplify Programs",
    "section": "",
    "text": "A function is a named chunk of code\n\nCan be thought of as like a variable containing code rather than a value\nConsider the simple function\n\n\n  def greeter():\n      print(\"Hello\")\n\n\nPrint’s the message \"Hello\"\nCalled by the function name, then parentheses, e.g.\n\n\n  greeter()\n\nHello\n\n\n\nfunctions must be defined before they can be called\n\n\n\n\nUse a python interpreter to work through the following questions to understand python functions\nEnter the following program into the interpreter\ndef greeter():\n     print(\"Hello\")\n\nWhy did the interpreter not print \"Hello\"?\n\nBecause the print statement is stored as part of the greeter function\n\nHow do I tell Python that I’ve finished entering the greeter function?\n\nThe same way you close a loop or an if statement, by deindenting and adding an empty line\n\nHow do I make a call to the greeter function?\n\n greeter()\n\nHello\n\n\n\nThe same way you call any other function. Write the function name and a parenthesised list of parameters. In this case the list is empty. Once called the function runs all the statements contained in its definition.\n\n\nNow consider the following code snippet\n\nx = greeter\nx()\n\nHello\n\n\nObserve that we can treat functions like variables. We can assign them to other labels/variables in this case x is set to the value of greeter. We can then call x as if it where greeter\nThe ability to treat functions as variables is a powerful feature we will explore more in Chapter 12\n\n\n\nExamine the following code block and and answer the following questions to understand how functions work. (You can run the code at Pathfinder.py)\n\n# Example 7.1: Pathfinder\n#\n# Sample Program to demonstrate function flow\n\n\ndef m2():\n    print(\"the\")\n\n\ndef m3():\n    print(\"sat on\")\n    m2()\n\n\ndef m1():\n    m2()\n    print(\"cat\")\n    m3()\n    print(\"mat\")\n\n\nm1()\n\nthe\ncat\nsat on\nthe\nmat\n\n\n\nWhat will the program display when it runs?\n\nStep through the program one statement at a time\nFirst m1 is called\n\nm1 calls m2\n\nm2 prints \"the\"\nm2 ends and control returns to m1\n\nm1’s next statement prints \"cat\"\nm1’s next statement calls m3\n\nm3 prints \"sat on\"\nm3 calls m2\n\nm2 prints \"the\"\nm2 ends and control returns to m3\n\nm3 ends and control returns to m1\n\nm1 prints \"mat\"\nm1 and thus the program ends\n\nThe final output is thus:\n\n the\n cat\n sat on\n the\n mat\nWhat happens if a function calls itself? For example what if m1 called m1\n\nLet’s try changing m1 to the following,\n\n  def m1():\n      m1()\n\n  m1()\n\n\n---------------------------------------------------------------------------\nRecursionError                            Traceback (most recent call last)\nCell In[6], line 4\n      1 def m1():\n      2     m1()\n----&gt; 4 m1()\n\nCell In[6], line 2, in m1()\n      1 def m1():\n----&gt; 2     m1()\n\nCell In[6], line 2, in m1()\n      1 def m1():\n----&gt; 2     m1()\n\n    [... skipping similar frames: m1 at line 2 (2975 times)]\n\nCell In[6], line 2, in m1()\n      1 def m1():\n----&gt; 2     m1()\n\nRecursionError: maximum recursion depth exceeded\n\n\n\nThe code generates a RecursionError!\n\nA function that calls itself is called a rescursive function\nLike an infinite loop infinite recursion occurs when a function calls itself with no condition to stop\nEventually the computer cannot allocate more memory to track the function calls\n\nThis can be dangerous so Python prematurely limits the “depth” of recursive calls a function can make\n\n\nFormally with recursion:\n\nEach time a function is called Python stores the return address (where the code goes back to) on the “stack”\n\nThe stack is special memory responsible for managing the program\nWhen a function finishes the program grabs the return of the stack and looks at the address to to determine where to run\n\nCalling and exiting functions thus grows and shrinks the stack\n\nUp to a limit defined by Python at which point a recursion error occurs\n\n\nRecursive functions are a powerful and elegant technique in many cases\n\nHowever, often it is better to use simple loop structures\nRecursion more of interest for theory\n\n\n\n\n\n\n\n\n\n\n\nblock-beta\n    columns 7\n\n    classDef BG stroke:transparent, fill:transparent\n\n\n    space\n    space\n    title[\"Breakdown of a Function Definition\"]:3\n    space\n    space\n\n    class title BG\n\n    block:Def\n    columns 1\n        def[\"def\"]\n        defDescr[\"(start of function definition)\"]\n    end\n\n    class def BG\n    class defDescr BG\n\n\n    block:Name\n    columns 1\n        name[\"name\"]\n        nameDescr[\"(name of the function)\"]\n    end\n\n    class name BG\n    class nameDescr BG\n\n    block:LeftP\n    columns 1\n        leftP[\"(\"]\n        leftPDescr[\" \"]\n    end\n\n    class leftP BG\n    class leftPDescr BG\n\n    block:Parameters\n    columns 1\n        parameters[\"parameters\"]\n        parametersDescr[\"(items to feed into the function)\"]\n    end\n\n    class parameters BG\n    class parametersDescr BG\n\n    block:RightP\n    columns 1\n        rightP[\")\"]\n        rightPDescr[\" \"]\n    end\n\n    class rightP BG\n    class rightPDescr BG\n\n    block:Colon\n    columns 1\n        colon[\":\"]\n        colonDescr[\"colon\"]\n    end\n\n    class colon BG\n    class colonDescr BG\n\n    block:Suite\n    columns 1\n        suite[\"Statement block\"]\n        suiteDescr[\"(statements)\"]\n    end\n\n    class suite BG\n    class suiteDescr BG\n\n\n\n\n\n\n\ndef tells python we’re defining a function\n\nAs opposed to calling an existing one\n\nspace then name of the function\n\nSame naming rules as for variables\nfunctions do things, i.e. the are naturally associated with verbs\n\nUnlike variables with are things i.e. nouns\n\ne.g. display_menu names a function which takes the action to display a menu\n\nThen parameters in a parenthese-enclosed, comma-delimited list\n\nNo space between name and left parenthesis\nParameters feed extra information for the function to work on\nParameter list can be empty (as we’ve seen)\n\nThen colon\nFollowed by indented set of statements associated with the function\n\nCalled the function body\n\n\n\n\n\n\nFunctions can receive data to work on through parameters\nE.g. we can parameterise our times table code\n\n  def print_times_table(times_value):\n      count = 1\n      while count &lt;  13:\n          result = count * times_value\n          print(count, 'times', times_value, 'equals', result)\n          count = count + 1\n\nWe can then call with different times_value to print the respective times table\n\n\n    print_times_table(5)\n    print_times_table(99)\n\n1 times 5 equals 5\n2 times 5 equals 10\n3 times 5 equals 15\n4 times 5 equals 20\n5 times 5 equals 25\n6 times 5 equals 30\n7 times 5 equals 35\n8 times 5 equals 40\n9 times 5 equals 45\n10 times 5 equals 50\n11 times 5 equals 55\n12 times 5 equals 60\n1 times 99 equals 99\n2 times 99 equals 198\n3 times 99 equals 297\n4 times 99 equals 396\n5 times 99 equals 495\n6 times 99 equals 594\n7 times 99 equals 693\n8 times 99 equals 792\n9 times 99 equals 891\n10 times 99 equals 990\n11 times 99 equals 1089\n12 times 99 equals 1188\n\n\n\n\n\nA parameter is the name assigned to a value passed to a function\nAn argument is the specific value passed when a function is called\ne.g. in the above print_times_table function:\n\nThe parameter is times_value\nBut a specific argument is \\(5\\) or \\(99\\)\n\nConsider it as the phrase “we call the function passing the arguments to the parameters”\n\n\n\nFind out more about arguments and parameters by answering the following questions\n\nWhat would the following program do?\n\n # Example 7.2: Times Tables\n #\n # Demonstrates function parameters through a\n # Times Table function that takes in an argument to\n # determine which times table is printed\n\n def print_times_table(times_value):\n     count = 1\n     while count &lt; 13:\n         result = count * times_value\n         print(count, \"times\", times_value, \"equals\", result)\n         count = count + 1\n\n print_times_table(6)\n\n1 times 6 equals 6\n2 times 6 equals 12\n3 times 6 equals 18\n4 times 6 equals 24\n5 times 6 equals 30\n6 times 6 equals 36\n7 times 6 equals 42\n8 times 6 equals 48\n9 times 6 equals 54\n10 times 6 equals 60\n11 times 6 equals 66\n12 times 6 equals 72\n\n\n\nThe above should print out the times table for \\(6\\)\n\nWhat would happen if we changed the call of the print_times_table function to the one below that has a string as the argument? Would the program fail?\n\n print_times_table(\"six\")\n\n1 times six equals six\n2 times six equals sixsix\n3 times six equals sixsixsix\n4 times six equals sixsixsixsix\n5 times six equals sixsixsixsixsix\n6 times six equals sixsixsixsixsixsix\n7 times six equals sixsixsixsixsixsixsix\n8 times six equals sixsixsixsixsixsixsixsix\n9 times six equals sixsixsixsixsixsixsixsixsix\n10 times six equals sixsixsixsixsixsixsixsixsixsix\n11 times six equals sixsixsixsixsixsixsixsixsixsixsix\n12 times six equals sixsixsixsixsixsixsixsixsixsixsixsix\n\n\n\nRecall that multiplication between strings and numbers is defined in python as the repeated concatenation of the string with itself\nThe above thus prints a triangle of increasingly concatenated \"six\"\nThis behaviour while semantically correct by the python language is not logically correct. Really we would expect an error to occur\n\nHow do we make the print_times_table function work with integer parameters only?\n\nFirst: is it a problem?\n\nIf this function is wrapped in a higher level function that does the error handling we can probably forget it\n\nSecond: If it is a problem, what is the way to fix it?\n\nPrint a warning message?\nStop the program?\nHande the error locally? (within the function)\n\nIn this case let’s throw an error if the type is not an integer\n\nThe isinstance function lets you type check an item\nAccepts two arguments, item to test, and the type to match\nReturns True if item is that type else False\n\n\n\n # Example 7.3: Safe Times Tables\n #\n # A version of Times Tables that uses isinstance\n # to ensure that argument is an integer\n\n\n def print_times_table(times_value):\n     if not isinstance(times_value, int):\n         raise Exception(\"print_times_table requires an integer argument\")\n     count = 1\n     while count &lt; 13:\n         result = count * times_value\n         print(count, \"times\", times_value, \"equals\", result)\n         count = count + 1\n\n\n print_times_table(\"six\")\n\n\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\nCell In[11], line 17\n     13         print(count, \"times\", times_value, \"equals\", result)\n     14         count = count + 1\n---&gt; 17 print_times_table(\"six\")\n\nCell In[11], line 9, in print_times_table(times_value)\n      7 def print_times_table(times_value):\n      8     if not isinstance(times_value, int):\n----&gt; 9         raise Exception(\"print_times_table requires an integer argument\")\n     10     count = 1\n     11     while count &lt; 13:\n\nException: print_times_table requires an integer argument\n\n\n\n\nSafeTimesTable.py shown above demonstrates using isinstance to raise an exception\nException can be thought of as an object that holds the error description\n\nstring argument describes the error\n\nraise creates and throws it\n\n\n\n\n\n\n\nfunctions can have multiple parameters\n\ne.g. what if we want to adjust the length of the times table\n\n\n  # Example 7.4: Two Parameter Times Table\n  #\n  # Demonstrates a multi-parameter function through a variable\n  # length times table program\n\n\n  def print_times_table(times_value, limit):\n      count = 1\n      while count &lt; limit + 1:\n          result = times_value * count\n          print(count, \"times\", times_value, \"equals\", result)\n          count = count + 1\n\n\nThe above uses times_value to control which times table is printed, and limit controls the length\n\nThe full code is given in TwoParameterTimesTable.py\n\nAn example call is then,\n\n\n  print_times_table(6,5)\n\n1 times 6 equals 6\n2 times 6 equals 12\n3 times 6 equals 18\n4 times 6 equals 24\n5 times 6 equals 30\n\n\n\nThe above prints the first \\(5\\) entries of the \\(6\\) times tables\n\n\n\n\n\n\nConsider the call,\n\n  print_times_table(12, 7)\n\n1 times 12 equals 12\n2 times 12 equals 24\n3 times 12 equals 36\n4 times 12 equals 48\n5 times 12 equals 60\n6 times 12 equals 72\n7 times 12 equals 84\n\n\nThe above, to the unfamiliar user makes it unclear if its a \\(12\\) times table of length \\(7\\) or a times table for \\(7\\) of length \\(12\\)\n\nThis is because the arguments are passed as positional parameters\n\ni.e. order the arguments go in, controls which parameter they are assigned too\n\n\nYou can also pass arguments to functions by specifying the parameter name, e.g.\n\n  print_times_table(times_value=12, limit=7)\n\n1 times 12 equals 12\n2 times 12 equals 24\n3 times 12 equals 36\n4 times 12 equals 48\n5 times 12 equals 60\n6 times 12 equals 72\n7 times 12 equals 84\n\n\n\nThis is called keyword arguments, because we specify the arguments associated parameter by its name\n\n\n\n\n\n\n\n\nWarning\n\n\n\nDon’t mix positional and keyword arguments\nPython lets you mix positional and keyword arguments in a call to a function. This can make it hard to work out what is assigned to what. You should either use all positional arguments (when obvious) or all keyword arguments\nBeware that positional arguments must preceed all keyword arguments\n\n\n\n\n\n\nOur original implementation of print_times_table assumed the length was \\(12\\)\nThe second version allowed us to specify the length, but no longer assumes that it is \\(12\\)\nDefault parameters let us combine both behaviours\n\n  # Example 7.5: Default Parameters\n  #\n  # Demonstrates default arguments by capturing the single\n  # argument times table code in the two parameter version\n\n\n  def print_times_table(times_value, limit=12):\n      count = 1\n      while count &lt; 13:\n          result = times_value * count\n          print(count, \"times\", times_value, \"equals\", result)\n          count = count + 1\n\n\nIf an argument is not provided to a parameter with a default argument, the default is used, e.g. the below call implicitly uses limit = 12\n\n  print_times_table(times_value=7)\n\n1 times 7 equals 7\n2 times 7 equals 14\n3 times 7 equals 21\n4 times 7 equals 28\n5 times 7 equals 35\n6 times 7 equals 42\n7 times 7 equals 49\n8 times 7 equals 56\n9 times 7 equals 63\n10 times 7 equals 70\n11 times 7 equals 77\n12 times 7 equals 84\n\n\n\nMost modern python editors and tooling can read function definitions, and highlight and default arguments\n\n\n\n\n\n\n\nTip\n\n\n\nWhy use named arguments and default parameters?\nNamed arguments and default parameters help make functions clearer in intent. Reduce the possibility of getting arguments confused or mixed up. Makes it easy to define “standard” behaviour for a function\n\n\n\n\n\nWhat does it mean when we pass the value of an argument to a function parameter? Consider the following program\n\n# Example 7.6 Parameters as Values\n#\n# Demonstrates how python handles passing values to a function\n\n\ndef what_would_I_do(input_value):\n    input_value = 99  # noqa: F841\n\n\ntest = 0\nwhat_would_I_do(test)\nprint(\"The value of test is\", test)\n\nThe value of test is 0\n\n\nThe function accepts a single value and sets it to \\(99\\). We then call the function with the value of test which has been set to \\(0\\). We then print the value of test after the function call\nAnswer the following question,\n\nWhat would this program print when it runs?\n\nThe program follows this sequence\n\ntest is set to \\(0\\)\nwhat_would_I_do is called, being passed the value of test which is \\(0\\)\nIn what_whould_I_do, input_value is initially set to \\(0\\)\ninput_value is set to \\(99\\)\nwhat_would_I_do then ends\nThe value of test is printed\n\nThe main observation here is that the value of test is passed to the function not test itself\n\ntest is unchanged outside the function\n\n\n\n\n\n\nWrite a function teletype_print that slowly writes out an input string. Use a for loop to loop over the contents of the string and the time library to delay the output. Use a default argument with a value of \\(0.1\\) to control the print speed. Use the random library to add a random amount of noise to the specified delay\nThe final function is given in the example TeletypePrinter.py, but we’ll work through the code in parts\n\nWe first import the modules we need\n\n# Exercise 7.1: Teletype Printer\n#\n# Emulates the slow speed of a teletype printer\n# by using a for loop and time to slowly loop over\n# an input string\n\nimport random\nimport time\n\nWe then define our function signature, text is left as something that must be supplied while delay is given a default value of \\(0.5\\) (purely to make the delay more obvious than the \\(0.1\\) suggested in the original book)\nWe then add a jitter to the delay from \\(1/10\\) through to the full size of the delay, by generating a random number\n\nWe then randomly generate a \\(0\\) or a \\(1\\) and use that to determine if the jitter is added or removed from the delay\n\n\ndef teletype_printer(text, delay=0.5):\n    jitter = delay / random.randint(1, 10)\n    if random.randint(0, 1):\n        delay = delay + jitter\n    else:\n        delay = delay - jitter\n\nWe then loop over the string, printing each character\n\nWe have to override the print default arguments\n\nend determines what is printed after each call to print, we set end to the empty string so that all the characters are printed on the same line\nSetting flush to False ensures the interpreter prints each character as it is called rather than waiting for the end of a line\n\n\nAfter the loop we now have to print an empty line to get the new line\n\n    for ch in text:\n        print(ch, end=\"\", flush=True)\n        time.sleep(delay)\n    print(\"\")\n\nLastly we demonstrate the function being called with it’s default values on the word \"hello\"\n\nteletype_printer(\"hello\")\n\n\nhello\n\n\n\n\n\nUse the function you wrote for a teletype output to add some style to the Fortune Teller Program\nOur solution is given in TeletypeFortuneTeller.py and repeated below\n# Exercise 7.2 Teletype Fortune Teller\n#\n# Version of the Fortune Teller Program that uses the teletype_printer function\n# to delay the output\n\nimport random\nimport time\n\n\ndef teletype_printer(text, delay=0.25):\n    jitter = delay / random.randint(1, 10)\n    if random.randint(0, 1):\n        delay = delay + jitter\n    else:\n        delay = delay - jitter\n\n    for ch in text:\n        print(ch, end=\"\", flush=True)\n        time.sleep(delay)\n    print(\"\")\n\n\nteletype_printer(\"...\", delay=0.5)\n# Meeting someone\nif random.randint(1, 6) &lt; 4:\n    teletype_printer(\"You will meet a tall, dark stranger\")\nelse:\n    teletype_printer(\"Nobody unexpected will enter your life\")\n\nteletype_printer(\"...\", delay=0.5)\n# Money\nresult = random.randint(1, 6)\nif result == 1:\n    teletype_printer(\"I see untold riches in your future\")\nelif result &lt;= 3:\n    teletype_printer(\"A life of comfort is coming\")\nelif result &lt; 6:\n    teletype_printer(\"You would do well to husband your wealth\")\nelse:\n    teletype_printer(\"I see a future lived on the streets...\")\n\nteletype_printer(\"...\", delay=0.5)\n# Advice\nresult = random.randint(1, 6)\nif result &lt;= 2:\n    teletype_printer(\"Sometimes the answers to our future, come from the past\")\nelif result &lt; 6:\n    teletype_printer(\"To define your future, avoid getting hung up on the past\")\nelse:\n    teletype_printer(\"You will soon face a decision that will redefine everything\")\nWe basically copy across the teletype_printer function from the previous exercise and replace the previous print statements with the new function. For fun we change the default delay to a lower number so the prints occur faster but between advice add a new\nteletype_printer(\"...\", delay=0.5)\ncall, with a longer delay that makes it look like the fortune teller is thinking between each piece of advice\n\n\n\n\n\nFunctions can return values, e.g.\n\nname = input('Enter your name please: ')\n\nHere name is assigned the value returned by the function input\nFunctions return values via the return keyword, e.g. the function below, returns the value \\(1\\)\n\n\ndef return_one():\n    return 1\n\nreturn_one()\n\n1\n\n\n\n\nTake a look look at the return in the following function and the attached program to answer the following questions\n\ndef get_value(prompt, value_min, value_max):\n    return 1\n    return 2\n\nride_number = get_value(prompt=\"Please enter the ride you want:\", value_min=1, value_max=5)\nprint(\"You have selected ride\", ride_number)\n\nYou have selected ride 1\n\n\n\nWhat would the above program print?\n\nThe function returns at the first return which in this case is \\(1\\), so the returned value is \\(1\\)\nThe second return is never reached\n\nWhat would the program below print? Would it run correctly?\n\n def get_value(prompt, value_min, value_max):\n     return\n\n ride_number = get_value(prompt=\"Please enter the ride number you want:\", value_min=1, value_max=5)\n print(\"You have selected ride:\", ride_number)\n\nYou have selected ride: None\n\n\n\nreturn ends the function without returning a value\nA distinct value None is returned\n\nRepresents the lack of a usable value\n\nNone is also returned when a function ends without hitting a return statement\n\nCan a function contain multiple return statements?\n\nYes! We already saw this with the first question\nA program exits from a function as soon as it reaches a return\n\n\n\nThe program below gives a generic function that asks the user for an integer with a client specified prompt between a range of value_min and value_max (inclusive)\n\n# Example 7.7: Get Value\n#\n# Demonstrates function returns through a program\n# that receives and validates an integer\n\n\ndef get_value(prompt, value_min, value_max):\n    while True:\n        number_text = input(prompt)\n        try:\n            number = int(number_text)\n        except ValueError:\n            print(\"Invalid number text. Please enter digits.\")\n            continue\n        if number &lt; value_min:\n            print(\"Value too small\")\n            print(\"The minimum value is\", value_min)\n            continue\n        elif number &gt; value_max:\n            print(\"Value too large\")\n            print(\"The maximum value is\", value_max)\n            continue\n        return number\n\n#Example usage\nride_number = get_value(\n    prompt=\"Please enter the ride number you want: \", value_min=1, value_max=5\n)\n\nprint(\"You have selected ride: \", ride_number)\n\nAn example interaction might proceed as follows\n\n\n\n\nPlease enter the ride number you want:  6 \n\nValue too large\n\nThe maximum value is 5\n\nPlease enter the ride number you want:  3 \n\nYou have selected ride: 3\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nDesigning Functions\nThinking about how to break a program down into functions is an important part of the design process. Functions are typically defined first in terms of their behaviour and then their header (i.e. name, parameters and return values).\nFunction reduce the amount of repeated code that needs to be written. Don’t start by creating too many functions but when you find yourself repeating yourself, it’s a good sign to start writing a function\n\nAny changes can now be made in one place - the function\nFunctions provide testable components for a larger piece of software\n\nThey are effectively mini-programs\nTests run the function for some input and check the output against some expected output\nTests are typically written alongside the code itself, and mean that as the code is developed and modified we can ensure it still works\n\n\n\n\n\n\n\n\n\nFunctions have what is called a local namespace\n\nIf we declare a variable i in one function we can declare another variable i in a second function, e.g. (LocalVariables.py)\n\n\n\n    # Example 7.8 Local Variables\n    #\n    # Demonstrates the local namespaces of functions\n\n\n    def func_2():\n        i = 99  # noqa: F841\n\n\n    def func_1():\n        i = 0\n        func_2()\n        print(\"The value of i is: \", i)\n\n\n    func_1()\n\nThe value of i is:  0\n\n\n\nHere func_1 sets its version of i to \\(0\\), the calls func_2 which defines its own version of i to \\(99\\)\nWhen we return to func_1 we are dealing with func_1’s version of i which still has the value \\(0\\)\n\n\n\n\n\nAny variable declared outside a function is a global variable\nCan be implicitly accessed by any function\n\nSee the program (GlobalVariables.py) below\n\n\n  # Example 7.9 Global Variables\n  #\n  # Demonstrates using global variables in functions\n\n  cheese = 99\n\n\n  def func():\n      print(\"Global cheese is:\", cheese)\n\n\n  func()\n\nGlobal cheese is: 99\n\n\nIf we define a new variable inside a function, with the same name as a global variable the global variable is hidden or shadowed\n\nSee the program (ShadowingGlobalVariables.py)\n\n\n  # Example 7.10 Shadowing Global Variables\n  #\n  # Demonstrates local variables shadowing a\n  # global variable\n\n  cheese = 99\n\n\n  def func():\n      cheese = 100\n      print(\"Local cheese is:\", cheese)\n\n\n  func()\n  print(\"Global cheese is:\", cheese)\n\nLocal cheese is: 100\nGlobal cheese is: 99\n\n\n\nWe can see in the above that inside func we can’t see the value of the global cheese\n\nBut what if we want to update a global variable inside a function?\n\nCan use the global keyword to connect the variable in a function to the global counterpart, see StoringGlobalVariables.py\n\n\n  # Example 7.11 Storing Global Variables\n  #\n  # Demonstrates storing a global variables in a\n  # variable in a function. Also shows updating a global\n  # variable\n\n  cheese = 99\n\n\n  def func():\n      global cheese  # use the global variable\n      print(\"Global cheese is:\", cheese)\n      cheese = 100\n\n\n  func()\n  print(\"Global cheese is:\", cheese)\n\nGlobal cheese is: 99\nGlobal cheese is: 100\n\n\nObserve in the above program we first connect func to the global variable cheese\n\nThe print shows that func’s cheese has the same value as the global cheese\n\nWe then change the value of cheese in func and can see that this is propagated back to the global context\nThe use of the global keyword makes it clear when we are intending to use global variables\n\nHowever shadowing can cause confusion\n\n\n\n\n\n\n\n\nWarning\n\n\n\nUse global data with care\nGlobal data, while useful can make programs hard to debug. Global variables connect all the functions that rely on them. Changes (and by extension error) can propagate through to all the functions that depend on the variable. You should therefore limit and be clear when you use global variables\n\n\n\n\n\n\n\nIt is useful to write functions to capture common, reusable functionality\nFor example: Collecting valid user data\n\n\n\n\nThe simplest case, is getting a string from the user\n\nSimply want to prevent the user interrupting the program\nAlso useful to provide a generic standard prompt if the user doesn’t want to provide one every time, i.e. default argument\n\nStart by defining the function header\n\nread_text(prompt=\"Please enter some text: \")\n\nThe implementation is then pretty similar to what we’ve developed before, (the full example in InputFunctions.py contains some additional lines of code to demonstrate the use of the function)\n\n\n# Read Text\n#\n# A simple function for getting validated strings from a user\n\n\ndef read_text(prompt=\"Please enter some text: \"):\n    while True:\n        try:\n            result = input(prompt)\n            break  # stop loop if no exception\n        except KeyboardInterrupt:\n            print(\"Please enter text\")\n    return result\n\n\n\nUse the read_text function to answer the following questions\n\nWhat is the result variable used to accomplish?\n\nLocal variable storing the user input to be returned\n\nWhat stops the function from repeating continously?\n\nThe break statement ends the loop one a string has been entered\nOnce the loop finishes the rest of the function is linear and will end\n\nWhy does the text reading loop repeat after the exception has been handled?\n\nThe function reaches the end of the loop block (look at the indentation of the return)\nThe loop condition is while True so unless stopped by the break which requires the program to successfully read a string, the loop will run again\n\n\n\n\n\n\n\nPython has a convention for adding comments that describe a function\nThese can be automatically read and displayed by Python tooling\n\nEnables automatic documentation generation\n\nA string literal immediately after the function header but before any other code is interpreted as a functions docstring, e.g.\n\ndef read_line(prompt):\n    'Displays a prompt and reads in a string of text'\n\nThe above is single-line comment that provides a simple description of the function\nThe alternate below, is a multiline comment which can provide more detail,\n\ndef read_text(prompt=\"Please enter some text: \"):\n    \"\"\"\n    Displays a prompt and reads in a string of text.\n    Keyboard Interrupts are ignored\n\n    prompt: str\n        prompt the user sees before entering text\n\n    return: str\n        returns a string containing the string input by the user\n    \"\"\"\n\nNote the use of triple quotes to write a string over multiple lines\nHere we describe the function, it’s parameters and the return in detail\n\nOur descriptions of parameters and returns explain both what they mean, and also the expected type\n\n\n\n\n\n\n\n\nTip\n\n\n\nUse a standard docstring convention\nThere are a number of standard formats used for docstrings. Two common ones being google and numpy\nThe advantage of using a common format is that it means that not only can we generate and display information about functions in code (see below for information about pydoc) but that there exists many tools for converting these standard formats into reference documentation that can be hosted or shared (e.g. on a website.)\nYou could of course define your own format, but then you might need to roll your own tooling if you ever wanted to publish your own reference documentation.\nIn these notes and the included code snippets we have generally stuck to using the numpy convention\n\n\n\n\n\nThe pydoc library is designed to read function docstrings\n\nFor example if we use it on the standard library function print\n\n\n  import pydoc\n\n  pydoc.help(print)\n\nHelp on built-in function print in module builtins:\n\nprint(*args, sep=' ', end='\\n', file=None, flush=False)\n    Prints the values to a stream, or to sys.stdout by default.\n\n    sep\n      string inserted between values, default a space.\n    end\n      string appended after the last value, default a newline.\n    file\n      a file-like object (stream); defaults to the current sys.stdout.\n    flush\n      whether to forcibly flush the stream.\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nForm a habit of documenting your code\nNowadays, programmers try to package the documentation with the code writing process. Sometimes this extends to the concept of documentation-as-code. Whenever you write a function, you should get into the habit of writing documentation.\n\n\n\n\n\n\n\nThe next function in our set of input functions is one to handle receiving a numbers\n\nMore specifically floating point numbers\n\nWe can break this down into steps\n\nFirst we get a valid string from the user\n\nWe can reuse read_text\n\nWe check that it’s a valid number\n\nWrap the extra functionality\n\n\n\n\ndef read_float(prompt):\n    \"\"\"\n    Displays a prompt and reads in a number\n\n    Keyboard interrupts are ignored\n    Invalid numbers are rejected\n\n    Parameters\n    ----------\n    prompt : str\n        Prompt the user sees before giving input\n\n    Returns\n    -------\n    float\n        The input value\n\n    See Also\n    --------\n    read_float_ranged : reads a float restricted to a closed interval\n    \"\"\"\n    while True:\n        try:\n            number_text = read_text(prompt)\n            result = float(number_text)\n            break\n        except ValueError:\n            print(\"Please enter a number\")\n    return result\n\n\nAn example usage is (mirrored in InputFunctions.py)\n\nage = read_float(\"Please enter your age: \")\nprint(age)\n\nWhich the user might see as,\n\n\nprint(\"Please enter your age: \\033[31m 32.7 \\033[0m\")\nprint(32.7)\n\n\nPlease enter your age:  32.7 \n\n32.7\n\n\n\n\n\nWe can then create a specialised version of read_float that uses it as a component to get a float restricted to a user specified range\n\n\ndef read_float_ranged(prompt, min_value, max_value):\n    \"\"\"\n    Displays a prompt and reads in a number between\n    min_value and max_value (inclusive)\n\n    Keyboard interrupts are ignored\n    Invalid numbers or out of range numbers are rejected\n\n    min_value: float minimum value (inclusive)\n    max_value: float maximum value (inclusive)\n\n    return: float\n    value input by user in the range [min_value, max_value]\n    \"\"\"\n    while True:\n        result = read_float(prompt)\n        if result &lt; min_value:\n            print(\"That number is too low\")\n            print(\"The minimum value is\", min_value)\n            continue\n        elif result &gt; max_value:\n            print(\"That value is too large\")\n            print(\"The maximum value is\", max_value)\n            continue\n        break  # if here have a valid number\n    return result\n\n\nLike with the read_float we use a previous function (here read_float) to capture existing error-handling and input handling code\n\nThen add in the extra functionality\nExample usage (again seen in the complete file InputFunctions.py)\n\n  age = read_float_ranged(\"Please enter your age\", min_value=5, max_value=90)\n  print(age)\nObserve how we have used each function as a reusable component in the next more specific function\n\nWe can do this because we cleanly define the responsibilities of each function\n\n\n\n\n\nLet’s examine the final function read_float_ranged in more detail to capture all the things we’ve built up. Answer the following questions\n\nWhy doesn’t this function have code to capture exceptions?\n\nNo, The two exception types we care about KeyboardInterrupt and ValueError are handled by read_text (via read_float) and read_float respectively\n\nWill chaining these functions together slow down the program?\n\nThere would probably be some slow down, since each time we have to call a function there is some setup and teardown\nHowever, the slow down would be miniscule\nThe improved readability and compartmentalisation has advantages in readability and maintability for the user\n\nThis practice of building higher-level functions out of smaller “lower level” functions is very common\n\n\nWhat would happen if a programmer reversed the minimum and maximum values?\n\nThe program would not work, it would require a number that is greater than what it thinks is the min (actually max) and less than what it thinks is the max (actually the min). These are incompatible conditions and the program would never be able to exit the function (or interrupt it)\nThere are three options\n\nFix the program so it swaps min and max if they are reversed\nDocuments that it’s not expected to work and leaves it to the user to ensure that the case doesn’t arise.\nRaises an exception for the caller to handle. (Our implementation in InputFunctions.py) uses the former technique\n if min_value &gt; max_value:\n     raise Exception(\"Min value is greater than max value\")\n\nIt is good ettiquette to document exceptions raised in the function documentation\n\n\n\n\n\n\n\n\nIdeally we want to write our functions once and be able to reuse them\n\nThe most basic way would be to simply copy them into a new file each time we need them\n\nA more complete method is to write our own module\n\nWe create a file BTCInput.py\nSo long as we include this file in the same directory as our new project we can include the functions the same way we would use time or random via\n  import BTCInput\nWe then call the functions as for any other module e.g.\n  age = BTCInput.read_float_ranged(\"Enter your age: \", min_value=5, max_value=90)\n\nIf we want to avoid having to write the module name every time we call a function we can use the from keyword\n\nAllows us to import specific components into the global namespace\nAlternatively can import all components of a module using *\n\nTypically avoid this, it carries a high risk of name clashes between functions defined in different modules\n\n\n\n#option 1: import function\nfrom BTCInput import read_float_ranged\nage = read_float_ranged(\"Enter your age: \", min_value=5, max_value=90)\n\n#option 2: import all\nfrom BTCInput import *\nage = read_float_ranged(\"Enter your age: \", min_value=5, max_value=90)\n\n\nRewrite the following programs to use BTCInput for input\n\nGreeter\nUltra Precise Egg Timer\nPizza Order Calculator\nFahrenheit To Celcius\nRide Selector\nUser-Selected Times Table\n\n\n\n\n\n\n\nNote\n\n\n\nWe’ve linked to where each of these programs are first referenced, but we’ll generally try to update the most comprehensive version of the respective program. We use the version of BTCInput.py included in Chapter 8 of the original code (see samples in the repo) since it offers a more complete set of validation functions based on the discussion above.\nTo correctly setup BTCInput.py ensure the variable DEBUG_MODE = FALSE\n\n\n\nGreeter\n\nThis change is straight forward, we replace input with read_text\n\n # Exercise 7.2.1: Greeter\n # An implementation of Greeter than uses BTCInput for validation\n\n import BTCInput\n\n name = BTCInput.read_text(\"Enter your name please: \")\n print(\"Hello\", name)\nUltra Precise Egg Timer\n\nWe can combine the original code that reads in the egg boiling time and the float conversion to one call to the BTCInput function read_float. Note that we don’t change the second input which just asks the user to press enter, since really we’re looking for any input from the user\n\n # Exercise 7.2.2 Ultra-Precise Egg Timer\n #\n # Implementation of Ultra-Precise Egg Timer using BTCInput\n\n import time\n import BTCInput\n\n egg_time = BTCInput.read_float(\"Enter the cooking time in seconds: \")\n\n print(\"Put the egg in boiling water now\")\n input(\"Press enter to continue once the egg is in...\")\n\n time.sleep(egg_time)\n\n print(\"Take the egg out now\")\nPizza Order Calculator\n\nAgain we simply replace the int(input()) structure with the BTCInput equivalent, BTCInput.read_int\n\n # Exercise 7.2.3: Pizza Order Calculator\n #\n # Implementation of Pizza Order Calculator that uses BTCInput\n\n import BTCInput\n\n students_int = BTCInput.read_int(\"How many students are attending? \")\n\n pizza_count = int(students_int / 1.5) + 1  # perform division int -&gt; float\n print(\"You will need\", pizza_count, \"pizzas\")\nFahrenheit To Celcius\n\nAgain a simple replacement, here float(input(...)) becomes BTCInput.read_float()\n\n # Exercise 7.2.4: Fahrenheit to Celcius\n #\n # Version of Fahrenheit to Celcius that uses BTCInput\n\n import BTCInput\n\n temperature_fahrenheit = BTCInput.read_float(\"Enter a temperature in Fahrenheit: \")\n temperature_centrigrade = (temperature_fahrenheit - 32) / 1.8\n print(\"The temperature is\", temperature_centrigrade, \"degrees Celcius\")\nRide Selector\n\nThe implementation is based on the Full input validated version of Ride Selector in Chapter 6\nThere are two important changes, first to ensure the user selects a valid theme park ride option, we use BTCInput.read_int_ranged\n  ride_number = BTCInput.read_int_ranged(\n      \"Please enter the ride number you want: \", 0, 5\n  )\nRemember that \\(0\\) is a number we’ve chosen to represent quitting the program\nSecond the ensure the user adds an age, here even though we have a valid age range, this is for being able to ride\n\nWe still want to accept those ages, and then inform the user of the issue\nSo here we use BTCInput.read_int (note unranged)\n\n  age = BTCInput.read_int(\"Please enter your age: \")\n\nUser Selected Times Tables\n\nHere we can remove all the validation code we wrote and simply replace it with the BTCInput.read_int_ranged call\nThis highlights the advantage of functions, the final program is much cleaner and easier to read\n  # Exercise 7.2.6 Tables Tables\n  #\n  # Variant of the User Selected Times Tables Tutor that uses BTCInput for\n  # validation\n\n  import BTCInput\n\n  count = 1\n  times_value = BTCInput.read_int(\"Please enter a times table between 2-12 (inclusive): \")\n\n  while count &lt; 13:\n      result = count * times_value\n      print(count, \"times\", times_value, \"equals\", result)\n      count = count + 1\n\n\n\n\n\n\n\n\nMost python development environments support a debugger\nA debugger is a program designed to help you identify (and solve) bugs or problems in your program\nThis section will introduce concepts of a debugger\n\nThe book discusses the specifics of using the debugger packaged in IDLE\nThe notes here discuss generics\n\nA debugger runs code like normal, but supports extra tools and techniques for interrogating the internal state of a program\nA breakpoint causes the program being run in the debugger to pause when it reaches the line where the break occurs.\n\nbreakpoints allow the programmer to halt the program at a desired point (typically close to where a problem occurs) and inspect variable contents\n\n\n\n\n\n\n\n\nNote\n\n\n\nBreakpoints vs break\nA breakpoint is different to the break keyword\n\nbreak is used to immediately escape a loop structure in a running program\nA breakpoint is used to pause the execution of a program at a specific point when it is being debugged\n\n\n\n\n\nUse the following example, found in InvestigateTheDebugger.py as the basis to learn the debugger\n# Example 7.14 Investigate the Debugger\n#\n# A sample code for practicing with the debugger\n\n\ndef increment_function(input_value):\n    result = input_value + 1\n    return result\n\n\nx = 99\ny = increment_function(x)\nprint(\"The answer is:\", y)\nUsing your debugger, set a breakpoint on the line x = 99\n\nIn VSCode for my setup with the python extensions I simply click on the line, left of the line number, a red circle appears indicating a breakpoint\n\nTo clear the breakpoint just click on it again\n\nThen run your program using the debugger\n\nIn VSCode I simply go to the Run and Debug tab, and click the Run and Debug button\n\nI then select from a dropdown menu, python debugger followed by debug the current file\n\nThe code starts running then stops at the breakpoint\nOn the left a panel shows the call stack\n\nThe call stack shows the sequence of function calls we are in\n\nAbove a panel shows the contents of variables\n\nBroken up into a tab for\n\nLocal variables\nGlobal variables\nThere are also tabs for special and function variables which can be ignored for now\n\n\nA control panel shows at the top of the program, the options are as follows,\n\nGo continues running the program\nStep Over goes to the next line in the program\n\nIf the line the program is on is a function, the program will calculate the results of the function and then go to the line after the program\n\nStep In goes to the next line in the program, if the program is on a function, the debugger will step into the function and go through it line by line\n\nThis includes opening any files where a function is defined in another file\n\nStep Out completes the current function and goes to the line after it\nRestart restarts the program\nStop immediately stops the program\n\n\nUse the step function to watch how python flows through this program, observe the call stack and the variable values when you step into increment_function\n\nObserve what happens when you step into print\n\nDepending on the debugger it may or may not step into the print function\nUse Step Out to leave print\nUse Step Out again, the program should end",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 7: Using Functions to Simplify Programs"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/07_UsingFunctions/Chapter_07.html#notes",
    "href": "01_ProgrammingFundamentals/07_UsingFunctions/Chapter_07.html#notes",
    "title": "Chapter 7: Using Functions to Simplify Programs",
    "section": "",
    "text": "A function is a named chunk of code\n\nCan be thought of as like a variable containing code rather than a value\nConsider the simple function\n\n\n  def greeter():\n      print(\"Hello\")\n\n\nPrint’s the message \"Hello\"\nCalled by the function name, then parentheses, e.g.\n\n\n  greeter()\n\nHello\n\n\n\nfunctions must be defined before they can be called\n\n\n\n\nUse a python interpreter to work through the following questions to understand python functions\nEnter the following program into the interpreter\ndef greeter():\n     print(\"Hello\")\n\nWhy did the interpreter not print \"Hello\"?\n\nBecause the print statement is stored as part of the greeter function\n\nHow do I tell Python that I’ve finished entering the greeter function?\n\nThe same way you close a loop or an if statement, by deindenting and adding an empty line\n\nHow do I make a call to the greeter function?\n\n greeter()\n\nHello\n\n\n\nThe same way you call any other function. Write the function name and a parenthesised list of parameters. In this case the list is empty. Once called the function runs all the statements contained in its definition.\n\n\nNow consider the following code snippet\n\nx = greeter\nx()\n\nHello\n\n\nObserve that we can treat functions like variables. We can assign them to other labels/variables in this case x is set to the value of greeter. We can then call x as if it where greeter\nThe ability to treat functions as variables is a powerful feature we will explore more in Chapter 12\n\n\n\nExamine the following code block and and answer the following questions to understand how functions work. (You can run the code at Pathfinder.py)\n\n# Example 7.1: Pathfinder\n#\n# Sample Program to demonstrate function flow\n\n\ndef m2():\n    print(\"the\")\n\n\ndef m3():\n    print(\"sat on\")\n    m2()\n\n\ndef m1():\n    m2()\n    print(\"cat\")\n    m3()\n    print(\"mat\")\n\n\nm1()\n\nthe\ncat\nsat on\nthe\nmat\n\n\n\nWhat will the program display when it runs?\n\nStep through the program one statement at a time\nFirst m1 is called\n\nm1 calls m2\n\nm2 prints \"the\"\nm2 ends and control returns to m1\n\nm1’s next statement prints \"cat\"\nm1’s next statement calls m3\n\nm3 prints \"sat on\"\nm3 calls m2\n\nm2 prints \"the\"\nm2 ends and control returns to m3\n\nm3 ends and control returns to m1\n\nm1 prints \"mat\"\nm1 and thus the program ends\n\nThe final output is thus:\n\n the\n cat\n sat on\n the\n mat\nWhat happens if a function calls itself? For example what if m1 called m1\n\nLet’s try changing m1 to the following,\n\n  def m1():\n      m1()\n\n  m1()\n\n\n---------------------------------------------------------------------------\nRecursionError                            Traceback (most recent call last)\nCell In[6], line 4\n      1 def m1():\n      2     m1()\n----&gt; 4 m1()\n\nCell In[6], line 2, in m1()\n      1 def m1():\n----&gt; 2     m1()\n\nCell In[6], line 2, in m1()\n      1 def m1():\n----&gt; 2     m1()\n\n    [... skipping similar frames: m1 at line 2 (2975 times)]\n\nCell In[6], line 2, in m1()\n      1 def m1():\n----&gt; 2     m1()\n\nRecursionError: maximum recursion depth exceeded\n\n\n\nThe code generates a RecursionError!\n\nA function that calls itself is called a rescursive function\nLike an infinite loop infinite recursion occurs when a function calls itself with no condition to stop\nEventually the computer cannot allocate more memory to track the function calls\n\nThis can be dangerous so Python prematurely limits the “depth” of recursive calls a function can make\n\n\nFormally with recursion:\n\nEach time a function is called Python stores the return address (where the code goes back to) on the “stack”\n\nThe stack is special memory responsible for managing the program\nWhen a function finishes the program grabs the return of the stack and looks at the address to to determine where to run\n\nCalling and exiting functions thus grows and shrinks the stack\n\nUp to a limit defined by Python at which point a recursion error occurs\n\n\nRecursive functions are a powerful and elegant technique in many cases\n\nHowever, often it is better to use simple loop structures\nRecursion more of interest for theory\n\n\n\n\n\n\n\n\n\n\n\nblock-beta\n    columns 7\n\n    classDef BG stroke:transparent, fill:transparent\n\n\n    space\n    space\n    title[\"Breakdown of a Function Definition\"]:3\n    space\n    space\n\n    class title BG\n\n    block:Def\n    columns 1\n        def[\"def\"]\n        defDescr[\"(start of function definition)\"]\n    end\n\n    class def BG\n    class defDescr BG\n\n\n    block:Name\n    columns 1\n        name[\"name\"]\n        nameDescr[\"(name of the function)\"]\n    end\n\n    class name BG\n    class nameDescr BG\n\n    block:LeftP\n    columns 1\n        leftP[\"(\"]\n        leftPDescr[\" \"]\n    end\n\n    class leftP BG\n    class leftPDescr BG\n\n    block:Parameters\n    columns 1\n        parameters[\"parameters\"]\n        parametersDescr[\"(items to feed into the function)\"]\n    end\n\n    class parameters BG\n    class parametersDescr BG\n\n    block:RightP\n    columns 1\n        rightP[\")\"]\n        rightPDescr[\" \"]\n    end\n\n    class rightP BG\n    class rightPDescr BG\n\n    block:Colon\n    columns 1\n        colon[\":\"]\n        colonDescr[\"colon\"]\n    end\n\n    class colon BG\n    class colonDescr BG\n\n    block:Suite\n    columns 1\n        suite[\"Statement block\"]\n        suiteDescr[\"(statements)\"]\n    end\n\n    class suite BG\n    class suiteDescr BG\n\n\n\n\n\n\n\ndef tells python we’re defining a function\n\nAs opposed to calling an existing one\n\nspace then name of the function\n\nSame naming rules as for variables\nfunctions do things, i.e. the are naturally associated with verbs\n\nUnlike variables with are things i.e. nouns\n\ne.g. display_menu names a function which takes the action to display a menu\n\nThen parameters in a parenthese-enclosed, comma-delimited list\n\nNo space between name and left parenthesis\nParameters feed extra information for the function to work on\nParameter list can be empty (as we’ve seen)\n\nThen colon\nFollowed by indented set of statements associated with the function\n\nCalled the function body\n\n\n\n\n\n\nFunctions can receive data to work on through parameters\nE.g. we can parameterise our times table code\n\n  def print_times_table(times_value):\n      count = 1\n      while count &lt;  13:\n          result = count * times_value\n          print(count, 'times', times_value, 'equals', result)\n          count = count + 1\n\nWe can then call with different times_value to print the respective times table\n\n\n    print_times_table(5)\n    print_times_table(99)\n\n1 times 5 equals 5\n2 times 5 equals 10\n3 times 5 equals 15\n4 times 5 equals 20\n5 times 5 equals 25\n6 times 5 equals 30\n7 times 5 equals 35\n8 times 5 equals 40\n9 times 5 equals 45\n10 times 5 equals 50\n11 times 5 equals 55\n12 times 5 equals 60\n1 times 99 equals 99\n2 times 99 equals 198\n3 times 99 equals 297\n4 times 99 equals 396\n5 times 99 equals 495\n6 times 99 equals 594\n7 times 99 equals 693\n8 times 99 equals 792\n9 times 99 equals 891\n10 times 99 equals 990\n11 times 99 equals 1089\n12 times 99 equals 1188\n\n\n\n\n\nA parameter is the name assigned to a value passed to a function\nAn argument is the specific value passed when a function is called\ne.g. in the above print_times_table function:\n\nThe parameter is times_value\nBut a specific argument is \\(5\\) or \\(99\\)\n\nConsider it as the phrase “we call the function passing the arguments to the parameters”\n\n\n\nFind out more about arguments and parameters by answering the following questions\n\nWhat would the following program do?\n\n # Example 7.2: Times Tables\n #\n # Demonstrates function parameters through a\n # Times Table function that takes in an argument to\n # determine which times table is printed\n\n def print_times_table(times_value):\n     count = 1\n     while count &lt; 13:\n         result = count * times_value\n         print(count, \"times\", times_value, \"equals\", result)\n         count = count + 1\n\n print_times_table(6)\n\n1 times 6 equals 6\n2 times 6 equals 12\n3 times 6 equals 18\n4 times 6 equals 24\n5 times 6 equals 30\n6 times 6 equals 36\n7 times 6 equals 42\n8 times 6 equals 48\n9 times 6 equals 54\n10 times 6 equals 60\n11 times 6 equals 66\n12 times 6 equals 72\n\n\n\nThe above should print out the times table for \\(6\\)\n\nWhat would happen if we changed the call of the print_times_table function to the one below that has a string as the argument? Would the program fail?\n\n print_times_table(\"six\")\n\n1 times six equals six\n2 times six equals sixsix\n3 times six equals sixsixsix\n4 times six equals sixsixsixsix\n5 times six equals sixsixsixsixsix\n6 times six equals sixsixsixsixsixsix\n7 times six equals sixsixsixsixsixsixsix\n8 times six equals sixsixsixsixsixsixsixsix\n9 times six equals sixsixsixsixsixsixsixsixsix\n10 times six equals sixsixsixsixsixsixsixsixsixsix\n11 times six equals sixsixsixsixsixsixsixsixsixsixsix\n12 times six equals sixsixsixsixsixsixsixsixsixsixsixsix\n\n\n\nRecall that multiplication between strings and numbers is defined in python as the repeated concatenation of the string with itself\nThe above thus prints a triangle of increasingly concatenated \"six\"\nThis behaviour while semantically correct by the python language is not logically correct. Really we would expect an error to occur\n\nHow do we make the print_times_table function work with integer parameters only?\n\nFirst: is it a problem?\n\nIf this function is wrapped in a higher level function that does the error handling we can probably forget it\n\nSecond: If it is a problem, what is the way to fix it?\n\nPrint a warning message?\nStop the program?\nHande the error locally? (within the function)\n\nIn this case let’s throw an error if the type is not an integer\n\nThe isinstance function lets you type check an item\nAccepts two arguments, item to test, and the type to match\nReturns True if item is that type else False\n\n\n\n # Example 7.3: Safe Times Tables\n #\n # A version of Times Tables that uses isinstance\n # to ensure that argument is an integer\n\n\n def print_times_table(times_value):\n     if not isinstance(times_value, int):\n         raise Exception(\"print_times_table requires an integer argument\")\n     count = 1\n     while count &lt; 13:\n         result = count * times_value\n         print(count, \"times\", times_value, \"equals\", result)\n         count = count + 1\n\n\n print_times_table(\"six\")\n\n\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\nCell In[11], line 17\n     13         print(count, \"times\", times_value, \"equals\", result)\n     14         count = count + 1\n---&gt; 17 print_times_table(\"six\")\n\nCell In[11], line 9, in print_times_table(times_value)\n      7 def print_times_table(times_value):\n      8     if not isinstance(times_value, int):\n----&gt; 9         raise Exception(\"print_times_table requires an integer argument\")\n     10     count = 1\n     11     while count &lt; 13:\n\nException: print_times_table requires an integer argument\n\n\n\n\nSafeTimesTable.py shown above demonstrates using isinstance to raise an exception\nException can be thought of as an object that holds the error description\n\nstring argument describes the error\n\nraise creates and throws it\n\n\n\n\n\n\n\nfunctions can have multiple parameters\n\ne.g. what if we want to adjust the length of the times table\n\n\n  # Example 7.4: Two Parameter Times Table\n  #\n  # Demonstrates a multi-parameter function through a variable\n  # length times table program\n\n\n  def print_times_table(times_value, limit):\n      count = 1\n      while count &lt; limit + 1:\n          result = times_value * count\n          print(count, \"times\", times_value, \"equals\", result)\n          count = count + 1\n\n\nThe above uses times_value to control which times table is printed, and limit controls the length\n\nThe full code is given in TwoParameterTimesTable.py\n\nAn example call is then,\n\n\n  print_times_table(6,5)\n\n1 times 6 equals 6\n2 times 6 equals 12\n3 times 6 equals 18\n4 times 6 equals 24\n5 times 6 equals 30\n\n\n\nThe above prints the first \\(5\\) entries of the \\(6\\) times tables\n\n\n\n\n\n\nConsider the call,\n\n  print_times_table(12, 7)\n\n1 times 12 equals 12\n2 times 12 equals 24\n3 times 12 equals 36\n4 times 12 equals 48\n5 times 12 equals 60\n6 times 12 equals 72\n7 times 12 equals 84\n\n\nThe above, to the unfamiliar user makes it unclear if its a \\(12\\) times table of length \\(7\\) or a times table for \\(7\\) of length \\(12\\)\n\nThis is because the arguments are passed as positional parameters\n\ni.e. order the arguments go in, controls which parameter they are assigned too\n\n\nYou can also pass arguments to functions by specifying the parameter name, e.g.\n\n  print_times_table(times_value=12, limit=7)\n\n1 times 12 equals 12\n2 times 12 equals 24\n3 times 12 equals 36\n4 times 12 equals 48\n5 times 12 equals 60\n6 times 12 equals 72\n7 times 12 equals 84\n\n\n\nThis is called keyword arguments, because we specify the arguments associated parameter by its name\n\n\n\n\n\n\n\n\nWarning\n\n\n\nDon’t mix positional and keyword arguments\nPython lets you mix positional and keyword arguments in a call to a function. This can make it hard to work out what is assigned to what. You should either use all positional arguments (when obvious) or all keyword arguments\nBeware that positional arguments must preceed all keyword arguments\n\n\n\n\n\n\nOur original implementation of print_times_table assumed the length was \\(12\\)\nThe second version allowed us to specify the length, but no longer assumes that it is \\(12\\)\nDefault parameters let us combine both behaviours\n\n  # Example 7.5: Default Parameters\n  #\n  # Demonstrates default arguments by capturing the single\n  # argument times table code in the two parameter version\n\n\n  def print_times_table(times_value, limit=12):\n      count = 1\n      while count &lt; 13:\n          result = times_value * count\n          print(count, \"times\", times_value, \"equals\", result)\n          count = count + 1\n\n\nIf an argument is not provided to a parameter with a default argument, the default is used, e.g. the below call implicitly uses limit = 12\n\n  print_times_table(times_value=7)\n\n1 times 7 equals 7\n2 times 7 equals 14\n3 times 7 equals 21\n4 times 7 equals 28\n5 times 7 equals 35\n6 times 7 equals 42\n7 times 7 equals 49\n8 times 7 equals 56\n9 times 7 equals 63\n10 times 7 equals 70\n11 times 7 equals 77\n12 times 7 equals 84\n\n\n\nMost modern python editors and tooling can read function definitions, and highlight and default arguments\n\n\n\n\n\n\n\nTip\n\n\n\nWhy use named arguments and default parameters?\nNamed arguments and default parameters help make functions clearer in intent. Reduce the possibility of getting arguments confused or mixed up. Makes it easy to define “standard” behaviour for a function\n\n\n\n\n\nWhat does it mean when we pass the value of an argument to a function parameter? Consider the following program\n\n# Example 7.6 Parameters as Values\n#\n# Demonstrates how python handles passing values to a function\n\n\ndef what_would_I_do(input_value):\n    input_value = 99  # noqa: F841\n\n\ntest = 0\nwhat_would_I_do(test)\nprint(\"The value of test is\", test)\n\nThe value of test is 0\n\n\nThe function accepts a single value and sets it to \\(99\\). We then call the function with the value of test which has been set to \\(0\\). We then print the value of test after the function call\nAnswer the following question,\n\nWhat would this program print when it runs?\n\nThe program follows this sequence\n\ntest is set to \\(0\\)\nwhat_would_I_do is called, being passed the value of test which is \\(0\\)\nIn what_whould_I_do, input_value is initially set to \\(0\\)\ninput_value is set to \\(99\\)\nwhat_would_I_do then ends\nThe value of test is printed\n\nThe main observation here is that the value of test is passed to the function not test itself\n\ntest is unchanged outside the function\n\n\n\n\n\n\nWrite a function teletype_print that slowly writes out an input string. Use a for loop to loop over the contents of the string and the time library to delay the output. Use a default argument with a value of \\(0.1\\) to control the print speed. Use the random library to add a random amount of noise to the specified delay\nThe final function is given in the example TeletypePrinter.py, but we’ll work through the code in parts\n\nWe first import the modules we need\n\n# Exercise 7.1: Teletype Printer\n#\n# Emulates the slow speed of a teletype printer\n# by using a for loop and time to slowly loop over\n# an input string\n\nimport random\nimport time\n\nWe then define our function signature, text is left as something that must be supplied while delay is given a default value of \\(0.5\\) (purely to make the delay more obvious than the \\(0.1\\) suggested in the original book)\nWe then add a jitter to the delay from \\(1/10\\) through to the full size of the delay, by generating a random number\n\nWe then randomly generate a \\(0\\) or a \\(1\\) and use that to determine if the jitter is added or removed from the delay\n\n\ndef teletype_printer(text, delay=0.5):\n    jitter = delay / random.randint(1, 10)\n    if random.randint(0, 1):\n        delay = delay + jitter\n    else:\n        delay = delay - jitter\n\nWe then loop over the string, printing each character\n\nWe have to override the print default arguments\n\nend determines what is printed after each call to print, we set end to the empty string so that all the characters are printed on the same line\nSetting flush to False ensures the interpreter prints each character as it is called rather than waiting for the end of a line\n\n\nAfter the loop we now have to print an empty line to get the new line\n\n    for ch in text:\n        print(ch, end=\"\", flush=True)\n        time.sleep(delay)\n    print(\"\")\n\nLastly we demonstrate the function being called with it’s default values on the word \"hello\"\n\nteletype_printer(\"hello\")\n\n\nhello\n\n\n\n\n\nUse the function you wrote for a teletype output to add some style to the Fortune Teller Program\nOur solution is given in TeletypeFortuneTeller.py and repeated below\n# Exercise 7.2 Teletype Fortune Teller\n#\n# Version of the Fortune Teller Program that uses the teletype_printer function\n# to delay the output\n\nimport random\nimport time\n\n\ndef teletype_printer(text, delay=0.25):\n    jitter = delay / random.randint(1, 10)\n    if random.randint(0, 1):\n        delay = delay + jitter\n    else:\n        delay = delay - jitter\n\n    for ch in text:\n        print(ch, end=\"\", flush=True)\n        time.sleep(delay)\n    print(\"\")\n\n\nteletype_printer(\"...\", delay=0.5)\n# Meeting someone\nif random.randint(1, 6) &lt; 4:\n    teletype_printer(\"You will meet a tall, dark stranger\")\nelse:\n    teletype_printer(\"Nobody unexpected will enter your life\")\n\nteletype_printer(\"...\", delay=0.5)\n# Money\nresult = random.randint(1, 6)\nif result == 1:\n    teletype_printer(\"I see untold riches in your future\")\nelif result &lt;= 3:\n    teletype_printer(\"A life of comfort is coming\")\nelif result &lt; 6:\n    teletype_printer(\"You would do well to husband your wealth\")\nelse:\n    teletype_printer(\"I see a future lived on the streets...\")\n\nteletype_printer(\"...\", delay=0.5)\n# Advice\nresult = random.randint(1, 6)\nif result &lt;= 2:\n    teletype_printer(\"Sometimes the answers to our future, come from the past\")\nelif result &lt; 6:\n    teletype_printer(\"To define your future, avoid getting hung up on the past\")\nelse:\n    teletype_printer(\"You will soon face a decision that will redefine everything\")\nWe basically copy across the teletype_printer function from the previous exercise and replace the previous print statements with the new function. For fun we change the default delay to a lower number so the prints occur faster but between advice add a new\nteletype_printer(\"...\", delay=0.5)\ncall, with a longer delay that makes it look like the fortune teller is thinking between each piece of advice\n\n\n\n\n\nFunctions can return values, e.g.\n\nname = input('Enter your name please: ')\n\nHere name is assigned the value returned by the function input\nFunctions return values via the return keyword, e.g. the function below, returns the value \\(1\\)\n\n\ndef return_one():\n    return 1\n\nreturn_one()\n\n1\n\n\n\n\nTake a look look at the return in the following function and the attached program to answer the following questions\n\ndef get_value(prompt, value_min, value_max):\n    return 1\n    return 2\n\nride_number = get_value(prompt=\"Please enter the ride you want:\", value_min=1, value_max=5)\nprint(\"You have selected ride\", ride_number)\n\nYou have selected ride 1\n\n\n\nWhat would the above program print?\n\nThe function returns at the first return which in this case is \\(1\\), so the returned value is \\(1\\)\nThe second return is never reached\n\nWhat would the program below print? Would it run correctly?\n\n def get_value(prompt, value_min, value_max):\n     return\n\n ride_number = get_value(prompt=\"Please enter the ride number you want:\", value_min=1, value_max=5)\n print(\"You have selected ride:\", ride_number)\n\nYou have selected ride: None\n\n\n\nreturn ends the function without returning a value\nA distinct value None is returned\n\nRepresents the lack of a usable value\n\nNone is also returned when a function ends without hitting a return statement\n\nCan a function contain multiple return statements?\n\nYes! We already saw this with the first question\nA program exits from a function as soon as it reaches a return\n\n\n\nThe program below gives a generic function that asks the user for an integer with a client specified prompt between a range of value_min and value_max (inclusive)\n\n# Example 7.7: Get Value\n#\n# Demonstrates function returns through a program\n# that receives and validates an integer\n\n\ndef get_value(prompt, value_min, value_max):\n    while True:\n        number_text = input(prompt)\n        try:\n            number = int(number_text)\n        except ValueError:\n            print(\"Invalid number text. Please enter digits.\")\n            continue\n        if number &lt; value_min:\n            print(\"Value too small\")\n            print(\"The minimum value is\", value_min)\n            continue\n        elif number &gt; value_max:\n            print(\"Value too large\")\n            print(\"The maximum value is\", value_max)\n            continue\n        return number\n\n#Example usage\nride_number = get_value(\n    prompt=\"Please enter the ride number you want: \", value_min=1, value_max=5\n)\n\nprint(\"You have selected ride: \", ride_number)\n\nAn example interaction might proceed as follows\n\n\n\n\nPlease enter the ride number you want:  6 \n\nValue too large\n\nThe maximum value is 5\n\nPlease enter the ride number you want:  3 \n\nYou have selected ride: 3\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nDesigning Functions\nThinking about how to break a program down into functions is an important part of the design process. Functions are typically defined first in terms of their behaviour and then their header (i.e. name, parameters and return values).\nFunction reduce the amount of repeated code that needs to be written. Don’t start by creating too many functions but when you find yourself repeating yourself, it’s a good sign to start writing a function\n\nAny changes can now be made in one place - the function\nFunctions provide testable components for a larger piece of software\n\nThey are effectively mini-programs\nTests run the function for some input and check the output against some expected output\nTests are typically written alongside the code itself, and mean that as the code is developed and modified we can ensure it still works\n\n\n\n\n\n\n\n\n\nFunctions have what is called a local namespace\n\nIf we declare a variable i in one function we can declare another variable i in a second function, e.g. (LocalVariables.py)\n\n\n\n    # Example 7.8 Local Variables\n    #\n    # Demonstrates the local namespaces of functions\n\n\n    def func_2():\n        i = 99  # noqa: F841\n\n\n    def func_1():\n        i = 0\n        func_2()\n        print(\"The value of i is: \", i)\n\n\n    func_1()\n\nThe value of i is:  0\n\n\n\nHere func_1 sets its version of i to \\(0\\), the calls func_2 which defines its own version of i to \\(99\\)\nWhen we return to func_1 we are dealing with func_1’s version of i which still has the value \\(0\\)\n\n\n\n\n\nAny variable declared outside a function is a global variable\nCan be implicitly accessed by any function\n\nSee the program (GlobalVariables.py) below\n\n\n  # Example 7.9 Global Variables\n  #\n  # Demonstrates using global variables in functions\n\n  cheese = 99\n\n\n  def func():\n      print(\"Global cheese is:\", cheese)\n\n\n  func()\n\nGlobal cheese is: 99\n\n\nIf we define a new variable inside a function, with the same name as a global variable the global variable is hidden or shadowed\n\nSee the program (ShadowingGlobalVariables.py)\n\n\n  # Example 7.10 Shadowing Global Variables\n  #\n  # Demonstrates local variables shadowing a\n  # global variable\n\n  cheese = 99\n\n\n  def func():\n      cheese = 100\n      print(\"Local cheese is:\", cheese)\n\n\n  func()\n  print(\"Global cheese is:\", cheese)\n\nLocal cheese is: 100\nGlobal cheese is: 99\n\n\n\nWe can see in the above that inside func we can’t see the value of the global cheese\n\nBut what if we want to update a global variable inside a function?\n\nCan use the global keyword to connect the variable in a function to the global counterpart, see StoringGlobalVariables.py\n\n\n  # Example 7.11 Storing Global Variables\n  #\n  # Demonstrates storing a global variables in a\n  # variable in a function. Also shows updating a global\n  # variable\n\n  cheese = 99\n\n\n  def func():\n      global cheese  # use the global variable\n      print(\"Global cheese is:\", cheese)\n      cheese = 100\n\n\n  func()\n  print(\"Global cheese is:\", cheese)\n\nGlobal cheese is: 99\nGlobal cheese is: 100\n\n\nObserve in the above program we first connect func to the global variable cheese\n\nThe print shows that func’s cheese has the same value as the global cheese\n\nWe then change the value of cheese in func and can see that this is propagated back to the global context\nThe use of the global keyword makes it clear when we are intending to use global variables\n\nHowever shadowing can cause confusion\n\n\n\n\n\n\n\n\nWarning\n\n\n\nUse global data with care\nGlobal data, while useful can make programs hard to debug. Global variables connect all the functions that rely on them. Changes (and by extension error) can propagate through to all the functions that depend on the variable. You should therefore limit and be clear when you use global variables\n\n\n\n\n\n\n\nIt is useful to write functions to capture common, reusable functionality\nFor example: Collecting valid user data\n\n\n\n\nThe simplest case, is getting a string from the user\n\nSimply want to prevent the user interrupting the program\nAlso useful to provide a generic standard prompt if the user doesn’t want to provide one every time, i.e. default argument\n\nStart by defining the function header\n\nread_text(prompt=\"Please enter some text: \")\n\nThe implementation is then pretty similar to what we’ve developed before, (the full example in InputFunctions.py contains some additional lines of code to demonstrate the use of the function)\n\n\n# Read Text\n#\n# A simple function for getting validated strings from a user\n\n\ndef read_text(prompt=\"Please enter some text: \"):\n    while True:\n        try:\n            result = input(prompt)\n            break  # stop loop if no exception\n        except KeyboardInterrupt:\n            print(\"Please enter text\")\n    return result\n\n\n\nUse the read_text function to answer the following questions\n\nWhat is the result variable used to accomplish?\n\nLocal variable storing the user input to be returned\n\nWhat stops the function from repeating continously?\n\nThe break statement ends the loop one a string has been entered\nOnce the loop finishes the rest of the function is linear and will end\n\nWhy does the text reading loop repeat after the exception has been handled?\n\nThe function reaches the end of the loop block (look at the indentation of the return)\nThe loop condition is while True so unless stopped by the break which requires the program to successfully read a string, the loop will run again\n\n\n\n\n\n\n\nPython has a convention for adding comments that describe a function\nThese can be automatically read and displayed by Python tooling\n\nEnables automatic documentation generation\n\nA string literal immediately after the function header but before any other code is interpreted as a functions docstring, e.g.\n\ndef read_line(prompt):\n    'Displays a prompt and reads in a string of text'\n\nThe above is single-line comment that provides a simple description of the function\nThe alternate below, is a multiline comment which can provide more detail,\n\ndef read_text(prompt=\"Please enter some text: \"):\n    \"\"\"\n    Displays a prompt and reads in a string of text.\n    Keyboard Interrupts are ignored\n\n    prompt: str\n        prompt the user sees before entering text\n\n    return: str\n        returns a string containing the string input by the user\n    \"\"\"\n\nNote the use of triple quotes to write a string over multiple lines\nHere we describe the function, it’s parameters and the return in detail\n\nOur descriptions of parameters and returns explain both what they mean, and also the expected type\n\n\n\n\n\n\n\n\nTip\n\n\n\nUse a standard docstring convention\nThere are a number of standard formats used for docstrings. Two common ones being google and numpy\nThe advantage of using a common format is that it means that not only can we generate and display information about functions in code (see below for information about pydoc) but that there exists many tools for converting these standard formats into reference documentation that can be hosted or shared (e.g. on a website.)\nYou could of course define your own format, but then you might need to roll your own tooling if you ever wanted to publish your own reference documentation.\nIn these notes and the included code snippets we have generally stuck to using the numpy convention\n\n\n\n\n\nThe pydoc library is designed to read function docstrings\n\nFor example if we use it on the standard library function print\n\n\n  import pydoc\n\n  pydoc.help(print)\n\nHelp on built-in function print in module builtins:\n\nprint(*args, sep=' ', end='\\n', file=None, flush=False)\n    Prints the values to a stream, or to sys.stdout by default.\n\n    sep\n      string inserted between values, default a space.\n    end\n      string appended after the last value, default a newline.\n    file\n      a file-like object (stream); defaults to the current sys.stdout.\n    flush\n      whether to forcibly flush the stream.\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nForm a habit of documenting your code\nNowadays, programmers try to package the documentation with the code writing process. Sometimes this extends to the concept of documentation-as-code. Whenever you write a function, you should get into the habit of writing documentation.\n\n\n\n\n\n\n\nThe next function in our set of input functions is one to handle receiving a numbers\n\nMore specifically floating point numbers\n\nWe can break this down into steps\n\nFirst we get a valid string from the user\n\nWe can reuse read_text\n\nWe check that it’s a valid number\n\nWrap the extra functionality\n\n\n\n\ndef read_float(prompt):\n    \"\"\"\n    Displays a prompt and reads in a number\n\n    Keyboard interrupts are ignored\n    Invalid numbers are rejected\n\n    Parameters\n    ----------\n    prompt : str\n        Prompt the user sees before giving input\n\n    Returns\n    -------\n    float\n        The input value\n\n    See Also\n    --------\n    read_float_ranged : reads a float restricted to a closed interval\n    \"\"\"\n    while True:\n        try:\n            number_text = read_text(prompt)\n            result = float(number_text)\n            break\n        except ValueError:\n            print(\"Please enter a number\")\n    return result\n\n\nAn example usage is (mirrored in InputFunctions.py)\n\nage = read_float(\"Please enter your age: \")\nprint(age)\n\nWhich the user might see as,\n\n\nprint(\"Please enter your age: \\033[31m 32.7 \\033[0m\")\nprint(32.7)\n\n\nPlease enter your age:  32.7 \n\n32.7\n\n\n\n\n\nWe can then create a specialised version of read_float that uses it as a component to get a float restricted to a user specified range\n\n\ndef read_float_ranged(prompt, min_value, max_value):\n    \"\"\"\n    Displays a prompt and reads in a number between\n    min_value and max_value (inclusive)\n\n    Keyboard interrupts are ignored\n    Invalid numbers or out of range numbers are rejected\n\n    min_value: float minimum value (inclusive)\n    max_value: float maximum value (inclusive)\n\n    return: float\n    value input by user in the range [min_value, max_value]\n    \"\"\"\n    while True:\n        result = read_float(prompt)\n        if result &lt; min_value:\n            print(\"That number is too low\")\n            print(\"The minimum value is\", min_value)\n            continue\n        elif result &gt; max_value:\n            print(\"That value is too large\")\n            print(\"The maximum value is\", max_value)\n            continue\n        break  # if here have a valid number\n    return result\n\n\nLike with the read_float we use a previous function (here read_float) to capture existing error-handling and input handling code\n\nThen add in the extra functionality\nExample usage (again seen in the complete file InputFunctions.py)\n\n  age = read_float_ranged(\"Please enter your age\", min_value=5, max_value=90)\n  print(age)\nObserve how we have used each function as a reusable component in the next more specific function\n\nWe can do this because we cleanly define the responsibilities of each function\n\n\n\n\n\nLet’s examine the final function read_float_ranged in more detail to capture all the things we’ve built up. Answer the following questions\n\nWhy doesn’t this function have code to capture exceptions?\n\nNo, The two exception types we care about KeyboardInterrupt and ValueError are handled by read_text (via read_float) and read_float respectively\n\nWill chaining these functions together slow down the program?\n\nThere would probably be some slow down, since each time we have to call a function there is some setup and teardown\nHowever, the slow down would be miniscule\nThe improved readability and compartmentalisation has advantages in readability and maintability for the user\n\nThis practice of building higher-level functions out of smaller “lower level” functions is very common\n\n\nWhat would happen if a programmer reversed the minimum and maximum values?\n\nThe program would not work, it would require a number that is greater than what it thinks is the min (actually max) and less than what it thinks is the max (actually the min). These are incompatible conditions and the program would never be able to exit the function (or interrupt it)\nThere are three options\n\nFix the program so it swaps min and max if they are reversed\nDocuments that it’s not expected to work and leaves it to the user to ensure that the case doesn’t arise.\nRaises an exception for the caller to handle. (Our implementation in InputFunctions.py) uses the former technique\n if min_value &gt; max_value:\n     raise Exception(\"Min value is greater than max value\")\n\nIt is good ettiquette to document exceptions raised in the function documentation\n\n\n\n\n\n\n\n\nIdeally we want to write our functions once and be able to reuse them\n\nThe most basic way would be to simply copy them into a new file each time we need them\n\nA more complete method is to write our own module\n\nWe create a file BTCInput.py\nSo long as we include this file in the same directory as our new project we can include the functions the same way we would use time or random via\n  import BTCInput\nWe then call the functions as for any other module e.g.\n  age = BTCInput.read_float_ranged(\"Enter your age: \", min_value=5, max_value=90)\n\nIf we want to avoid having to write the module name every time we call a function we can use the from keyword\n\nAllows us to import specific components into the global namespace\nAlternatively can import all components of a module using *\n\nTypically avoid this, it carries a high risk of name clashes between functions defined in different modules\n\n\n\n#option 1: import function\nfrom BTCInput import read_float_ranged\nage = read_float_ranged(\"Enter your age: \", min_value=5, max_value=90)\n\n#option 2: import all\nfrom BTCInput import *\nage = read_float_ranged(\"Enter your age: \", min_value=5, max_value=90)\n\n\nRewrite the following programs to use BTCInput for input\n\nGreeter\nUltra Precise Egg Timer\nPizza Order Calculator\nFahrenheit To Celcius\nRide Selector\nUser-Selected Times Table\n\n\n\n\n\n\n\nNote\n\n\n\nWe’ve linked to where each of these programs are first referenced, but we’ll generally try to update the most comprehensive version of the respective program. We use the version of BTCInput.py included in Chapter 8 of the original code (see samples in the repo) since it offers a more complete set of validation functions based on the discussion above.\nTo correctly setup BTCInput.py ensure the variable DEBUG_MODE = FALSE\n\n\n\nGreeter\n\nThis change is straight forward, we replace input with read_text\n\n # Exercise 7.2.1: Greeter\n # An implementation of Greeter than uses BTCInput for validation\n\n import BTCInput\n\n name = BTCInput.read_text(\"Enter your name please: \")\n print(\"Hello\", name)\nUltra Precise Egg Timer\n\nWe can combine the original code that reads in the egg boiling time and the float conversion to one call to the BTCInput function read_float. Note that we don’t change the second input which just asks the user to press enter, since really we’re looking for any input from the user\n\n # Exercise 7.2.2 Ultra-Precise Egg Timer\n #\n # Implementation of Ultra-Precise Egg Timer using BTCInput\n\n import time\n import BTCInput\n\n egg_time = BTCInput.read_float(\"Enter the cooking time in seconds: \")\n\n print(\"Put the egg in boiling water now\")\n input(\"Press enter to continue once the egg is in...\")\n\n time.sleep(egg_time)\n\n print(\"Take the egg out now\")\nPizza Order Calculator\n\nAgain we simply replace the int(input()) structure with the BTCInput equivalent, BTCInput.read_int\n\n # Exercise 7.2.3: Pizza Order Calculator\n #\n # Implementation of Pizza Order Calculator that uses BTCInput\n\n import BTCInput\n\n students_int = BTCInput.read_int(\"How many students are attending? \")\n\n pizza_count = int(students_int / 1.5) + 1  # perform division int -&gt; float\n print(\"You will need\", pizza_count, \"pizzas\")\nFahrenheit To Celcius\n\nAgain a simple replacement, here float(input(...)) becomes BTCInput.read_float()\n\n # Exercise 7.2.4: Fahrenheit to Celcius\n #\n # Version of Fahrenheit to Celcius that uses BTCInput\n\n import BTCInput\n\n temperature_fahrenheit = BTCInput.read_float(\"Enter a temperature in Fahrenheit: \")\n temperature_centrigrade = (temperature_fahrenheit - 32) / 1.8\n print(\"The temperature is\", temperature_centrigrade, \"degrees Celcius\")\nRide Selector\n\nThe implementation is based on the Full input validated version of Ride Selector in Chapter 6\nThere are two important changes, first to ensure the user selects a valid theme park ride option, we use BTCInput.read_int_ranged\n  ride_number = BTCInput.read_int_ranged(\n      \"Please enter the ride number you want: \", 0, 5\n  )\nRemember that \\(0\\) is a number we’ve chosen to represent quitting the program\nSecond the ensure the user adds an age, here even though we have a valid age range, this is for being able to ride\n\nWe still want to accept those ages, and then inform the user of the issue\nSo here we use BTCInput.read_int (note unranged)\n\n  age = BTCInput.read_int(\"Please enter your age: \")\n\nUser Selected Times Tables\n\nHere we can remove all the validation code we wrote and simply replace it with the BTCInput.read_int_ranged call\nThis highlights the advantage of functions, the final program is much cleaner and easier to read\n  # Exercise 7.2.6 Tables Tables\n  #\n  # Variant of the User Selected Times Tables Tutor that uses BTCInput for\n  # validation\n\n  import BTCInput\n\n  count = 1\n  times_value = BTCInput.read_int(\"Please enter a times table between 2-12 (inclusive): \")\n\n  while count &lt; 13:\n      result = count * times_value\n      print(count, \"times\", times_value, \"equals\", result)\n      count = count + 1\n\n\n\n\n\n\n\n\nMost python development environments support a debugger\nA debugger is a program designed to help you identify (and solve) bugs or problems in your program\nThis section will introduce concepts of a debugger\n\nThe book discusses the specifics of using the debugger packaged in IDLE\nThe notes here discuss generics\n\nA debugger runs code like normal, but supports extra tools and techniques for interrogating the internal state of a program\nA breakpoint causes the program being run in the debugger to pause when it reaches the line where the break occurs.\n\nbreakpoints allow the programmer to halt the program at a desired point (typically close to where a problem occurs) and inspect variable contents\n\n\n\n\n\n\n\n\nNote\n\n\n\nBreakpoints vs break\nA breakpoint is different to the break keyword\n\nbreak is used to immediately escape a loop structure in a running program\nA breakpoint is used to pause the execution of a program at a specific point when it is being debugged\n\n\n\n\n\nUse the following example, found in InvestigateTheDebugger.py as the basis to learn the debugger\n# Example 7.14 Investigate the Debugger\n#\n# A sample code for practicing with the debugger\n\n\ndef increment_function(input_value):\n    result = input_value + 1\n    return result\n\n\nx = 99\ny = increment_function(x)\nprint(\"The answer is:\", y)\nUsing your debugger, set a breakpoint on the line x = 99\n\nIn VSCode for my setup with the python extensions I simply click on the line, left of the line number, a red circle appears indicating a breakpoint\n\nTo clear the breakpoint just click on it again\n\nThen run your program using the debugger\n\nIn VSCode I simply go to the Run and Debug tab, and click the Run and Debug button\n\nI then select from a dropdown menu, python debugger followed by debug the current file\n\nThe code starts running then stops at the breakpoint\nOn the left a panel shows the call stack\n\nThe call stack shows the sequence of function calls we are in\n\nAbove a panel shows the contents of variables\n\nBroken up into a tab for\n\nLocal variables\nGlobal variables\nThere are also tabs for special and function variables which can be ignored for now\n\n\nA control panel shows at the top of the program, the options are as follows,\n\nGo continues running the program\nStep Over goes to the next line in the program\n\nIf the line the program is on is a function, the program will calculate the results of the function and then go to the line after the program\n\nStep In goes to the next line in the program, if the program is on a function, the debugger will step into the function and go through it line by line\n\nThis includes opening any files where a function is defined in another file\n\nStep Out completes the current function and goes to the line after it\nRestart restarts the program\nStop immediately stops the program\n\n\nUse the step function to watch how python flows through this program, observe the call stack and the variable values when you step into increment_function\n\nObserve what happens when you step into print\n\nDepending on the debugger it may or may not step into the print function\nUse Step Out to leave print\nUse Step Out again, the program should end",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 7: Using Functions to Simplify Programs"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/07_UsingFunctions/Chapter_07.html#summary",
    "href": "01_ProgrammingFundamentals/07_UsingFunctions/Chapter_07.html#summary",
    "title": "Chapter 7: Using Functions to Simplify Programs",
    "section": "Summary",
    "text": "Summary\n\nFunctions allow us to reuse blocks of code\nFunctions consist of a header describing the function and the code\n\nHeader supplies function and parameter names (including their default values if specified)\n\nFunctions are called with arguments passed to the parameters\nParameters are value copied objects the function can work on\n\nThis means changes are local to the function\n\nFunctions can return a value via the return function\nNone is returned when a function finishes without an explicit return value\nVariables defined in a function are local to that function\n\nCannot be accessed outside the function\n\nVariables declared outside any function are called global variables\n\nCan be read by functions\nCan be modified by functions via the global keyword\n\nLocal variables can shadow global variables if they share the same name\nA function can contain a string as the first statement\n\nThis is called the docstring and documents the behaviour of the function\n\nFunctions can be imported into another python file that has access to the file they are defined in",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 7: Using Functions to Simplify Programs"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/07_UsingFunctions/Chapter_07.html#questions-and-answers",
    "href": "01_ProgrammingFundamentals/07_UsingFunctions/Chapter_07.html#questions-and-answers",
    "title": "Chapter 7: Using Functions to Simplify Programs",
    "section": "Questions and Answers",
    "text": "Questions and Answers\n\nDoes using functions in programs slow down the program?\n\nNot noticably. The slight cost of setting up and tearing down functions is minimal\n\nCan I use functions to spread work around a group of programmers?\n\nYes, packaging functions into modules is a very common way for programmers to share code including functions\nAlternatively when building programs together, programmers may define the function headers together, and then each can work on implementing different functions seperately\n\nHow do I come up with names for my functions?\n\nFunctions should typically be verbs that describe what action they do, e.g. read_string reads a string. Where reasonable also try to indicate what it returns\n\nCan functions in libraries use global variables?\n\nGlobal variables are those declared at file scope\nLibrary files can contain global variables\nThey can be used by the functions in those files\nBut they cannot be shared across files\n\nShould I put all my functions in modules/libraries?\n\nProbably not all of your functions\nGood for common utility functions that have quite broad use cases\nA common pattern in larger applications is to split functions into files that group together natural sets of logic",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 7: Using Functions to Simplify Programs"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/09_UsingClasses/Chapter_09.html",
    "href": "02_AdvancedProgramming/09_UsingClasses/Chapter_09.html",
    "title": "Chapter 9: Use Classes to Store Data",
    "section": "",
    "text": "Let’s develop a lightweight program to store contact details\n\nNames\nAddresses\nTelephone Numbers\n\nWe storyboard the interface\n  Tiny Contacts\n\n  1. New Contact\n  2. Find Contact\n  3. Exit Program\n\n  Enter your command:\nWe then want to extend the storyboard to the different interface options\n  Create new contact\n\n  Enter the contact name: Rob Miles\n  Enter the contact address: 18 Pussycat Mews, London, NE1 410S\n  Enter the contact phone: +44(1234) 56789\n\n  Contact record stored for Rob Miles\nThe matching storyboard for find is then,\n  Find Contact\n\n  Enter the contact name: Rob Miles\n  Name: Rob Miles\n  Address: 18 Pussycat Mews, London, NE1 410S\n  Phone: +44(1234) 56789\n\nWith a matching storyboard for a contact not existing\n    Find Contact\n\n    Enter the contact name: Fred Bloggs\n    This name was not found\n\n\n\n\n\nWe start by making a prototype\n\nWe stub out the functions with mock messages\n\nThis is good for demoing to the customer for their feedback\n\nAlso helps to start working out how the structure should flow\n\n  # Example 9.1 Tiny Contacts Prototype\n  #\n  # Simple stub implementation of the Tiny Contacts Prototype\n\n  import BTCInput\n\n\n  def new_contact():\n      \"\"\"\n      Creates and adds a new contact to the contact book\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Create the new contact\")\n      BTCInput.read_text(\"Enter the contact name: \")\n      BTCInput.read_text(\"Enter the contact address: \")\n      BTCInput.read_text(\"Enter the contact phone: \")\n\n\n  def find_contact():\n      \"\"\"\n      Displays the contact matching a user-specified name\n\n      Prompts the user for a name, and searches the contacts list.\n      If the contact is found in the list, their full contact details\n      are displayed\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Find contact\")\n      name = BTCInput.read_text(\"Enter the contact name: \")\n      if name == \"Rob Miles\":\n          print(\"Name: Rob Miles\")\n          print(\"Address: 18 Pussycat News, London, NE1 410S\")\n          print(\"Phone: +44(1234) 56789\")\n      else:\n          print(\"This name was not found.\")\n\n\n  menu = \"\"\"Tiny Contacts\n\n  1. New Contact\n  2. Find Contact\n  3. Exit Program\n\n  Enter your command:\"\"\"\n\n  while True:\n      command = BTCInput.read_int_ranged(prompt=menu, min_value=1, max_value=3)\n      if command == 1:\n          new_contact()\n      elif command == 2:\n          find_contact()\n      elif command == 3:\n          break\n      else:\n          raise ValueError(\"Unexpected command id found: \" + str(command))\n\n\n\nThe code above doesn’t introduce any new concepts, but it’s worth examining in detail to make sure you understand how all the parts work. Work through the following questions.\n\nIs this code familiar?\n\nIt should be!, It is very similar to the ride-selector and Ice Cream Sales programs\nThis menu structure is very common for imperative programs\n\nThe value returned by the read_text functions are ignored by the program. Is this legal?\n\nYes, it is perfectly legal.\nread_text is from the BTCInput library, it returns a user-provided string\n\nWe have yet to decide how we store this, so we simply discard it\nWe emulate the behaviour of getting a contact, but not the process of storing it yet\n\n\nHow does the program stop?\n\nThe main loop contains a special option that is used for exiting the program. This is achieved by calling break to get out of the loop, after which the program will finish\n\nIsn’t the prototype a bit basic? Why don’t you make it store data?\n\nThe prototype is not designed to be functional\n\nWe minimise the initial work so that if the customer backs out we haven’t wasted too much time\nWe want to make it clear that the program is a prototype, so that the customer won’t immediately want to use it\n\n\nHow is the telephone number stored?\n\nOur plan is store the number as a string\nWhile referred to as a number, telephone numbers typically have additional characters that make them much more like strings (e.g. +)\n\n\n\n\n\n\n\nStart with storing Contact Details\nSimplest implementation is to maintain a list for each different type of information we store\n\nthe \\(i\\)-th contact them has it’s details in the \\(i\\)-th index of each list\n\n  names = []\n  addresses = []\n  telephones = []\n\n  def new_contact():\n      \"\"\"\n      Creates and adds a new contact to the contact book\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Create the new contact\")\n      names.append(BTCInput.read_text(\"Enter the contact name: \"))\n      addresses.append(BTCInput.read_text(\"Enter the contact address: \"))\n      telephones.append(BTCInput.read_text(\"Enter the contact phone: \"))\nTo find items we then get the index from the names list and use that to access the corresponding indices in the addresses and telephones\n  def find_contact():\n      \"\"\"\n      Displays the contact matching a user-specified name\n\n      Prompts the user for a name, and searches the contacts list.\n      If the contact is found in the list, their full contact details\n      are displayed\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Find contact\")\n      search_name = BTCInput.read_text(\"Enter the contact name: \")\n      search_name = search_name.strip()\n      search_name = search_name.lower()\n      name_index = 0\n      for name in names:\n          name = name.strip()\n          name = name.lower()\n          if name == search_name:\n              break\n          name_index = name_index + 1\n\n      if name_position &lt; len(names):\n          print(\"Name: \", names[name_index])\n          print(\"Address: \", addresses[name_index])\n          print(\"Telephone: \", telephones[name_index])\n      else:\n          print(\"This name was not found\")\nYou can view the complete program all put together in TinyContactsParallelLists.py\n\n\n\nThe find_contact function is probably one of the more sophisticated pieces of code we’ve written. Work through the following questions to make sure you understand what is going on.\n\nHow does this code work?\n\nWe look through the names list until we find a match\nOnce we’ve found it we can immediately stop looking\n\nKeeping track of the index that we’ve been looking at\n\n\nWhat is the name_index variable used for?\n\nThe name_position variable is used to track which index of the names list matches the name we’re trying to find\nWe use this to then grab the address and phone from the addresses and telephones arrays\nThis technique is called parallel lists\n\nHow does the function know if a name has been found?\n\nIf we reach the end of the list without finding a match, then name_index ends the loop as one past the actual last valid index of the loop\n\nWe can check this with len\nWe use an if condition to check this\n\n\nWhat do the calls of strip and lower do?\n\nThese functions normalise the input, so that any extra whitespace or variations in upper and lower case are removed\n\nCan we save the user from having to type in all the names when they search?\n\nYes, we can. We could use startswith to find a name that starts with whatever the user inputs\nThis means they might only need to put in the first name\nThere are more sophisticated search techniques that we could use, but they are outside the scope of this discussion\n  if name.startswith(search_name):\n      break\n\nThe above is integrated into the complete program in TinyContactsQuickSearch.py\n\n\n\n\n\n\n\n\nAn issue with this set-up is we have to ensure that the parallel lists stay aligned\nFor example if we sort the names list alphabetically, we have to ensure we make the same transformations to the addresses and telephones lists\nWe instead would prefer to have one object or container that holds all three values together\nOne option is to use a tuple or a list\n\nBut then we have to remember how values are stored\n\nAlternative is the class\nIn object-oriented programming we use classes to define and construct objects\n\nA class is a type, an object is the instance\n\n\n\n\nOpen the python interpreter and work through the following steps and questions to understand classes\nEnter the statements below\n\nclass Contact:\n    \"\"\"\n    Stores Contact Information\n\n    Attributes\n    ----------\n    name : str\n        Contact Name\n    address : str\n        Contact's postal or street address.\n    telephone : str\n        Contact phone number (stored as a string).\n    \"\"\"\n\n    pass\n\nThe line class Contact: begins a class definition - The class contents is given as an indented block - We use pass To make an empty placeholder class\n\nWhy does the name Contact begin with a capital letter?\n\nIt’s convention, in python\n\nVariables and functions start with lowercase letters\nClasses start with uppercase letters\n\n\nWhy does the Contact class contain a Python pass statement?\n\nThe class definition expects an indented block\nWe haven’t yet decided the contents of the class so we use pass to give an placeholder statement\nWe can create an instance of a Contact with\n\n  x = Contact()\n\n\nThis looks like a function call. Are we calling a function here?\n\nTechnically this is a call to a function called a constructor\nWhich is responsible for creating an intance of a Contact\nBy using capital letters it’s clear that this is an object instantiation\n\nWhat’s an instance?\n\nAn instance is the realisation of a class\nClass is the design, object is the actual thing\nYou can add data attributes to an instance\n\n  x.name = \"Rob Miles\"\n\n\nWhat’s a data attribute?\n\nProvide information about a specific instance\nFor a contact we would want it to have name, address, and phone\nmethods can also be thought of as attributes\nYou can use and manipulate data attributes\n\n  print(x.name)\n  x.name = x.name + \" is a star\"\n  print(x.name)\n\nRob Miles\nRob Miles is a star\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAttributes in Python classes can be confusing\nThe ability to add attributes to an instance is not common across programming languages. For example Java, c# and c++ all prevent this.\nIn these languages a class definition must be fully specified including the attributes before it can be instantiated.\nBoth this static definition and pythons dynamic definitions have it’s advantages and disadvantages. The latter is easier for prototyping and development, but the former is much more type-safe\n\n\n\n\n\n\n\nWe can use the Contact class to eliminate the needs for multiple lists (see TinyContactsClass.py highlighted below)\n  contacts = []\n\n\n  def new_contact():\n      \"\"\"\n      Creates and adds a new contact to the contact book\n\n      Returns\n      -------\n      None\n\n      See Also\n      --------\n      Contact : class for storing contact information\n      \"\"\"\n      print(\"Create the new contact\")\n      new_contact = Contact()\n      new_contact.name = BTCInput.read_text(\"Enter the contact name: \")\n      new_contact.address = BTCInput.read_text(\"Enter the contact address: \")\n      new_contact.telephone = BTCInput.read_text(\"Enter the contact phone: \")\n      contacts.append(new_contact)\n\n\n  def find_contact():\n      \"\"\"\n      Displays the contact matching a user-specified name\n\n      Prompts the user for a name, and searches the contacts list.\n      If the contact is found in the list, their full contact details\n      are displayed\n\n      Returns\n      -------\n      None\n\n      Notes\n      -----\n      Matches any name prefixed by the search name\n      \"\"\"\n      print(\"Find contact\")\n      search_name = BTCInput.read_text(\"Enter the contact name: \")\n      search_name = search_name.strip()\n      search_name = search_name.lower()\n      result = None\n      for contact in contacts:\n          name = contact.name\n          name = name.strip()\n          name = name.lower()\n          if name.startswith(search_name):\n              result = contact\n              break\n\n\n\nAnswer the following questions about the new find_contact implementation\n\nHow does this code work?\n\nThis functions like the previous search, we look for a contact that has a match to the search name\nRather than use the index of the match, we set a reference to the object itself iin the variable* result\nWe use None to indicate no match was found\n\nWhat does the value None mean?\n\nNone in python is used to refer to a value that does not exist\nSemantically here it is used to indicate that no match was found\n\n\n\n\n\nThis program has a fault in that if multiple contacts have the same name as an existing one only the first one will be returned. Modify the program to correct this problem\nWe have two solutions that we could use,\n\nWhen a duplicate name is encountered we simply replace the old one\n\nThis is the simplest approach, however it is quite common for people to have the same names\n\nThe program returns all the valid matches\n\nThis is a bit more complicated\nOur search function now rather than returning one Contact returns a list containing all matching Contacts\nWe only have to change the find_contacts function (the full code is given in TinyContactsDuplicates.py)\n  def find_contact():\n      \"\"\"\n      Displays the contact matching a user-specified name\n\n      Prompts the user for a name, and searches the contacts list.\n      If the contact is found in the list, their full contact details\n      are displayed\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Find contact\")\n      search_name = BTCInput.read_text(\"Enter the contact name: \")\n      search_name = search_name.strip()\n      search_name = search_name.lower()\n      results = []\n      for contact in contacts:\n          name = contact.name\n          name = name.strip()\n          name = name.lower()\n          if name.startswith(search_name):\n              results.append(contact)\n\n      if len(results) &gt; 0:\n          for result in results:\n              print(\"Name: \", result.name)\n              print(\"Address: \", result.address)\n              print(\"Telephone: \", result.telephone, \"\\n\")\n      else:\n          print(\"This name was not found\")\n\n\n\n\n\n\n\n\nImportant\n\n\n\nLook for problems when you receive the specification\nWhen you discuss a specification there’s no guarantee ambiguities like how to deal with duplicate names will be discussed. You will need to consider cases like this that may arise and define the behaviour for them. This behaviour will need to match what the client expects to happen. The best way to make sure that happens is to make sure that is included in the specification\n\n\n\n\n\n\n\nIt might be quite common for contacts to change their contact details\nWe would like to be able to update an existing contact\nThe new interface\n  Tiny Contacts\n\n  1. New Contact\n  2. Find Contact\n  3. Edit Contact\n  4. Exit Program\n\n  Enter your command:\nWe then storyboard out the program,\n\nOur storyboard will be slightly different to the book implementation to better handle duplicates\n\n  Edit Contact\n  Enter the contact name: Rob\n  Found 1 match\n\n  Name: Robert Miles\n  Address: 18 Pussycat News, London, NE1 410S\n  Telephone: +44(1234) 56789\n\n  Edit this contact? (1 - Yes, 0 - No): 1\n\n  Enter new name or . to leave unchanged: .\n  Enter new address or . to leave unchanged: .\n  Enter new telephone or . to leave unchanged: +44 (1482) 465079\nThe edit program first needs us to find search for the contact we wish to edit\nWe then report the number of matches found\nFor each match, we then print the current details and ask the user if this is the contact they want to edit\nWe then give the user the option of editing each attribute or leaving it unchanged with .\n\n\n\n\nOur program is starting to get some structure\n\nGood time to consider a refactor\n\nWe now have two features that need to search for a contact by name\n\nFind and display a contact\nFind and edit a contact\n\nOne option is to copy the find_contact for edit_contact and replace the display code by the edit code\n\nNow we have to maintain two different copies of the search functionality\nEasy for these to become desynchronised if in the future we want to change how the search works (or need to fix a book)\n\nFor our refactor, we’ll do the following\n\nFactor out a core find_contacts function that takes a search name and returns the matches\nChange the name of the old find_contact function to display_contacts function\n\nHere’s the book’s implementation, (we’ll use something different in our implementation to account for duplicates)\n  def find_contact(search_name):\n      \"\"\"\n      Finds the contacts with the matching name\n\n      Parameters\n      ----------\n      search_name : str\n          Name to search for (uses prefix matching)\n\n      Returns\n      -------\n      list[Contact]\n          list of contacts matching the `search_name`, if no\n          matches exist the list is empty\n      \"\"\"\n      search_name = search_name.strip().lower()\n      result = None\n      for contact in contacts:\n          name = contact.name.strip().lower()\n          if name.startswith(search_name):\n              return result\n      return None\n\n\n\nAnswer the following questions, about this new version of find_contact\n\nWhy does the function contain two return statements?\n\nOnly one return will actually be executed\nIf a match is found then the match is returned\nIf not then the program will exit the for loop at which point it encounters the second return and returns None\n\nWhat would happen if another program tried to use the return value of the find_contact function, and the find_contact function had returned None\n\nDepends on what the function tries to do\nIf the function tried to something with that value, then an exception is thrown\n\n  x = None #emulate failed find from find_contact\n  print(x.address)\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[5], line 2\n      1 x = None #emulate failed find from find_contact\n----&gt; 2 print(x.address)\n\nAttributeError: 'NoneType' object has no attribute 'address'\n\n\n\nSince find_contact documents that it can return None it is the responsibility of the consumer of the function to ensure they don’t misuse the None\n\n\n\n\n\n\n\nfind_contact searches through contacts for a match\nReturned object is a reference to the memory object\ne.g. rob = find_contact(\"Rob Miles\") graphically looks like,\n\n\n\n\n\n\n---\nconfig:\n  flowchart:\n    htmlLabels: false\n---\n\n\nflowchart TD\n    A@{shape: tag-doc, label: \"Rob\"}\n    B@{shape: div-rect, label: \"Name: Rob Miles\n    Address: 18 Pussycat Mews, London, NE 410S\n    Telephone: +44(1234) 5678\"}\n\n    A--&gt;B\n\n\n\n\n\n\n\nWe have multiple references to an object, e.g. test = rob creates a new reference test\n\n\n\n\n\n\n---\nconfig:\n  flowchart:\n    htmlLabels: false\n---\n\n\nflowchart TD\n    A@{shape: tag-doc, label: \"Rob\"}\n    B@{shape: div-rect, label: \"Name: Rob Miles\n    Address: 18 Pussycat Mews ..\n    Telephone: +44(1234) 5678\"}\n    C@{shape: tag-doc, label: \"test\"}\n\n    A--&gt;B\n    C--&gt;B\n\n\n\n\n\n\n\nChanges from one reference to the underlying memory object are seen in the other references\ne.g. test.name = \"Robert Miles Man of Mystery\" gives the state as,\n\n\n\n\n\n\n---\nconfig:\n  flowchart:\n    htmlLabels: false\n---\n\n\nflowchart TD\n    A@{shape: tag-doc, label: \"Rob\"}\n    B@{shape: div-rect, label: \"Name: Rob Miles Man ...\n    Address: 18 Pussycat Mews ..\n    Telephone: +44(1234) 5678\"}\n    C@{shape: tag-doc, label: \"test\"}\n\n    A--&gt;B\n    C--&gt;B\n\n\n\n\n\n\n\nThis behaviour is sometimes referred to as shallow copying since we have multiple copies of the object, but they are not distinct, changes are propagated between all the references\n\nThere is only one memory object\n\n\n\n\nThe figure below illustrates how lists and references work. It shows a Tiny Contacts data store with three contacts registered. Each of the tags in the contacts list refers to a different Contact instance in the memory. Work through the following questions to develop your understanding of references\n\n\n\n\n\n---\nconfig:\nflowchart:\n    htmlLabels: false\n---\n\n\n    flowchart TD\n\n        subgraph Contacts\n            A@{shape: tag-doc, label: \"0\"}\n            B@{shape: tag-doc, label: \"1\"}\n            C@{shape: tag-doc, label: \"2\"}\n        end\n\n        A1@{shape: div-rect, label: \"Name: Fred Smith\n        Address: 1605 Main St,\n        New York\n        Telephone: (560) 567-5209\"}\n\n        B1@{shape: div-rect, label: \"Name: Joe Bloggs\n        Address: 2312 Pine Street,\n        Seattle\n        Telephone: (453) 545-1232\"}\n\n        C1@{shape: div-rect, label: \"Name: Rob Miles\n        Address: 18 Pussycat Mews,\n         London, NE1 410S\n        Telephone: +44(1234) 5678\"}\n        D@{shape: tag-doc, label: \"rob\"}\n\n        A--&gt;A1\n        B--&gt;B1\n        C--&gt;C1\n        D--&gt;C1\n\n\n\n\n\n\n\nThe diagram contains four references. How many data objects does it contain?\n\nThere are three data objects, the Contact items themselves\nOne (Rob Miles) is referenced by the list index \\(2\\) and the variable rob\n\nWhat would happen if the program performed the following statement?\n contacts[0] = contacts[1]\n\nThe \\(0\\) index in the list now references the same memory object as that in the \\(1\\) index, the state now looks like,\n\n\n\n\n\n\n\nflowchart TD\n    subgraph Contacts\n        A@{shape: tag-doc, label: \"0\"}\n        B@{shape: tag-doc, label: \"1\"}\n        C@{shape: tag-doc, label: \"2\"}\n    end\n\n    A1@{shape: div-rect, label: \"Name: Fred Smith\n    Address: 1605 Main St,\n    New York\n    Telephone: (560) 567-5209\"}\n\n    B1@{shape: div-rect, label: \"Name: Joe Bloggs\n    Address: 2312 Pine Street,\n    Seattle\n    Telephone: (453) 545-1232\"}\n\n    C1@{shape: div-rect, label: \"Name: Rob Miles\n    Address: 18 Pussycat Mews,\n    London, NE1 410S\n    Telephone: +44(1234) 5678\"}\n    D@{shape: tag-doc, label: \"rob\"}\n\n    A--&gt;B1\n    B--&gt;B1\n    C--&gt;C1\n    D--&gt;C1\n\n\n\n\n\n\n\nLooping through the list would thus refer to the Joe Bloggs Contact twice\nNote that we have now lost the reference to Fred Smith, we can never get it back!\n\nUnreferenced memory objects will be removed by python in a process called garbage collection\n\nReferences make it easy to work with large data objects\n\nAvoid the need to create expensive copies\n\n\n\n\n\n\nEverything in Python is an object\n30 is an instance of an int\nThe following creates a reference age to 30\n\n  age = 30\n\nWhich we can visualise,\n\n\n\n\n\n\n    flowchart TD\n        A@{shape: tag-doc, label: \"age\"}\n\n        A1[\"`int\n            30`\"]\n\n        A--&gt;A1\n\n\n\n\n\n\n\nand verify,\n\n  type(age)\n\nint\n\n\ntype is a built-in function\n\nTakes a reference as an argument\nReturns the type of the referenced object\n\nNow, suppose we define another reference temp via\n\n  temp = age\n\nWhich we can again visualise as,\n\n\n\n\n\n\n    flowchart TD\n        A@{shape: tag-doc, label: \"age\"}\n        B@{shape: tag-doc, label: \"temp\"}\n\n        A1[\"`int\n            30`\"]\n\n        A--&gt;A1\n        B--&gt;A1\n\n\n\n\n\n\n\nage and temp now refer to the same object instance\nWhat happens if we assign temp a new value?\n\n  temp = 99\n  print(age)\n  print(temp)\n\n30\n99\n\n\nSo we have the final state,\n\n\n\n\n\n\n    flowchart TD\n        A@{shape: tag-doc, label: \"age\"}\n        B@{shape: tag-doc, label: \"temp\"}\n\n        A1[\"`int\n            30`\"]\n        B1[\"`int\n            99`\"]\n\n        A--&gt;A1\n        B--&gt;B1\n\n\n\n\n\n\n\nage has not been modified\nInstead a new int with a value of \\(99\\) was created\nThis is because int is an immutable type\n\ni.e. once an int has been created its value can’t be reassigned\nValue assignments thus create a new instance of an int\n\nstring is also an immutable type\n\n  name = \"Rob\"\n  temp = name\n  print(\"temp is\", temp, \"name is\", name)\n  temp = \"Fred\"\n  print(\"temp is now\", temp, \"name is now\", name)\n\ntemp is Rob name is Rob\ntemp is now Fred name is now Rob\n\n\n\n\nWhy does python use immutable data types?\n\nFor some procedures, like simple numerical calculations, treating variables as values is often the most desired approach, e.g.\n  pi = 3.1415\n  x = pi\n  x = 99.99\nWe don’t want the above to accidently change the value of the constant pi\n\n\n\n\n\n\n\n\nImportant\n\n\n\nProgramming Languages work with values differently\nLanguages handle the distinction between references and values differently. References make it easy to work with large data as the objects remain stationary in memory. However value types make it easy to perform data manipulation with types such as int, bool, float and string\nC# has a similar concept of value types. Java has primitive types, C++ has references. Python implements int, bool, float and string are immutable types, and behave like values\nRemember that the tuple collection type is also immutable\n\n\n\n\n\n\n\nOnce we have found a reference we can read and modify the attributes\nOur program implementation, uses a simple interface optionally modify each attribute one at a time\n\nNeed to read a user string for each modifiable atttribute\nOur duplicates implementation also needs to read an int to indicate if we want to modify a specific contact (and print the current contact)\n\nThe book implementation is,\ndef edit_contact():\n  \"\"\"\n  Reads in a name to search for an then allows the user\n  to edit the details of that contact. If there is no\n  contact, the function displays a message indicating\n  that the name was not found\n  \"\"\"\n\n  print(\"Edit Contact\")\n  search_name = read_text(\"Enter the contact name: \")\n  contact=find_contact(search_name)\n  if contact != None:\n      print(\"Name: \", contact.name)\n      new_name = read_text(\"Enter new name or . to leave unchanged\")\n      if new_name != '.':\n          contact.name = new_name\n      new_address = read_text(\"Enter new address or . to leave unchanged\")\n      if new_address != '.':\n          contact.address = new_address\n      new_phone = read_text(\"Enter new phone or . to leave unchanged\")\n      if new_phone != '.':\n          contact.telephone = new_phone\n  else:\n      print(\"This name was not found\")\nEditing as configured performs modifications of the live data\n\nReferred to as in-place because it occurs on the original object not a copy\n\nCan’t easily rollback if there is an error or ask the user wishes to cancel\nTo do so, edit_contact would need to work on a copy of the data\n\n\n\n\n\n\n\nWarning\n\n\n\nMissing Attributes\nedit_function calls find_contact to match a given name. find_contact returns None if no match is found. However, another possible fault in a contact is returned without all the attributes defined, e.g. a contact with a name but no address. Then the program would fail, as the code below demonstrates\n\nclass Contact:\n    pass\n\n# fake contact \"returned without address\"\ncontact = Contact()\ncontact.name = \"Hello\"\n\n# Attempt to access address\nprint(\"contact address is\", contact.address)\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[11], line 9\n      6 contact.name = \"Hello\"\n      8 # Attempt to access address\n----&gt; 9 print(\"contact address is\", contact.address)\n\nAttributeError: 'Contact' object has no attribute 'address'\n\n\n\nSome programming languages e.g. Java, C#, C++ check for these errors before a program executes. Python does not. This means that minor typos e.g. writing adress instead of address can lead to runtime errors\n\n\n\n\n\n\n\nWe saw in Chapter 8 that we can save and load data to files\n\nThere we used a human-readable text representation\n\nWe could replicate this for large class based structures\n\ne.g. write out all attributes as comma, seperated values\n\nPython provides a process called pickling for storing large data structures\n\npickled data is stored as binary\nData is therefore computer-readable and more compressed than human text\n\nPickling is done through the pickle library, import it to use it\n  import pickle\njpeg, mp3, zip are all different formats of binary data\n\nCommonly a file extension is used to identify what a binary file represents\ne.g.\n\nmyhouse.jpg\ntrack1.mp3\n\nDifferent programs are written to work with different binary file formats\n\n.txt defines a generic text file\n.py defines a text file that is valid python code\nTechnically text is also a binary file, just with those binary values associated to human-readable characters\nPython programs can use the b mode flag to read files as binary, e.g.\n  out_file = open(\"contacts.pickle\", \"wb\")\n\nThe above opens the file contacts.pickle for writing (w) as a binary file (b)\n.pickle indicates the file is a pickled python data object\n\npickle supplies the dump function to write a data structure to a file\n\nThe file must be opened for writing in binary\n\n  pickle.dump(contacts, out_file)\n\ncontacts is the variable to pickle\nout_file is the variable storing the file save the data to\n\nYou can open and modify pickle files\n\nWhile they may contain some readable text, they will also contain a mix of improperly rendered binary\n\n(Unless you have a specially set up text editor like a hexadecimal reader)\n\n\n\n\n\n\nPickled content of the Tiny Contacts app, a mix of human-readable characters and improperly rendered binary is displayed\n\n\n\n\n\n\n\n\nCaution\n\n\n\nBe careful modifying pickle files by hand\nPickle files are not designed to be human-readable. While most text editors will happily let you edit and save a pickle file this is very likely to end up in you breaking the binary format and the file no longer loading properly\n\n\n\nsave_contacts below saves the contacts list into a given file (passed as a path name)\n\nAs in Chapter 8 we use with to handle managing the file access\n\ndef save_contacts(file_name):\n  \"\"\"\n  Saves the contacts to the given file name\n\n  Contacts are stored in binary as a pickled file\n\n  Parameters\n  ----------\n  file_name : str\n      string giving the path to the file to store the contacts data in\n\n  Returns\n  -------\n  None\n\n  Raises\n  ------\n      Exceptions are raised if contacts could not be saved\n\n  See Also\n  --------\n  load_contacts : loads contacts from a pickled file\n  \"\"\"\n  print(\"save contacts\")\n  with open(file_name, \"wb\") as out_file:\n      pickle.dump(contacts, out_file)\n\nThis function does not perform any exception handling\nThis will cause the program to crash if the save fails\n\nProbably fine for a program of this size\nNote: You should never hide a failed save from the user!\n\nIf we wanted to handle exceptions, we would do that in the code outside save_contacts\n\n\n\n\n\n\npickle provides load to read a pickle file\n\nreturns the reconstructed data object\nAs a result, needs only the file\n\nfile needs to be open for reading r and in binary mode b\n  def load_contacts(file_name):\n      \"\"\"\n      Loads the contacts from the given file\n\n      Contacts are stored in binary as a pickled file\n\n      Parameters\n      ----------\n      file_name : str\n          string giving the path to the file where the contacts data is stored\n\n      Returns\n      -------\n      None\n          Contact detail is loaded into the global contacts value\n\n      Raises\n      ------\n          Exceptions if contacts failed to load\n\n      See Also\n      --------\n      save_contacts : saves contacts to a pickled file\n      \"\"\"\n      global contacts #connect to the global contacts variable\n      print(\"load contacts\")\n      with open(file_name, \"rb\") as input_file:\n          contacts=pickle.load(input_file)\n\n\n\nWork through the following questions to make sure you understand how load_contacts works\n\nWhat does the global contacts statement do? Why do we need it only in the load function and not the save function?\n\nThe load_contacts function is used to modify the values of the contacts variable\nThe contacts holds all the current contacts, held in the program\nsave_contacts needs the reference to find the list\n\nDoes not modify the list itself\n\nload_contacts does modify the contacts list\n\nNeed to explicitly link to the global variable to write to it\n\n\nHow does the pickle load function know what kind of data to make when loading?\n\nThe information is encoded in the pickle file\nIn a pickle file you should be able to identify the data attributes (name etc.) and their values\nAlso contains the class name\nload looks for matching classes in the program loading the data\n\nConstructs object instances based on those classes\nMeans the class Contact must be defined before pickle is used to load any contact data\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nVersion Control\nPickle is a tool called a serialiser because it converts a data structure is a serial stream (i.e. ordered sequence of data) that can be sent to another program and/or stored in a file.\nThis introduces the need for version control. If the design of a class e.g. Contact (say we added an email attribute) then all previously pickled data may no longer load since the class definition is mismatched. To resolve this you need to version control both the version of the class and the pickled files so that data can be migrated (or converted) between versions\n\n\n\n\n\n\n\nLet’s add the save and load functionality to the Tiny Contacts Program\nThere are two options for how we implement this,\n\nThe user manually declares they want to save and load\nWe hardcode a data file\n\nLoad from this file on program start\nSave to this file as part of the exit process\n\n\nFor a small contacts app the user probably doesn’t want to manually have to handle saving and loading files\nMore likely to want to have it “just work”\n\nWe’ll go with option 2\n\nThe new interface now looks like below (see our full implementation which contains an example pickle file)\n  # Example 9.7 Tiny Contacts with Load and Save\n  import pickle\n\n  #Load contacts from file or create empty list if it fails to load\n  file_name = \"contacts.pickle\"\n  try:\n      load_contacts(file_name)\n  except:\n      print(\"Contacts file not found\")\n      contacts=[]\n\n  while True:\n      command = BTCInput.read_int_ranged(prompt=menu, min_value=1, max_value=4)\n      if command == 1:\n          new_contact()\n      elif command == 2:\n          display_contact()\n      elif command == 3:\n          edit_contact()\n      elif command == 4:\n          save_contacts(file_name) #save contacts on exit\n          break\n      else:\n          raise ValueError(\"Unexpected value encountered\")\n\n\n\nConsider the following questions about the code above\n\nWhat happens if the load_contacts function raises an exception?\n\nload_contacts raises an exception if the contacts file can’t be found, or if the load function in pickle fails\nIn this case the exception is caught, an error message is printed and an empty contacts list is created\n\nWhy does the program not catch the exceptions raised by save_contacts?\n\nYou could add this if you wanted\nIf the program crashes, the user should probably expect the save failed\nSince they were trying to quit anyway they probably don’t care\nMy implementation adds try...except block that prints an error message if the save fails (as the book suggests you consider)\n\nWhy does the program use a variable for the file name of the pickled file?\n\nThe contacts are held in a file called* contacts.pickle\nThis file is used in two places* load_contacts and save_contacts\n\nWe could put the string literal in both places\nInstead use a variable\nMeans we can change the file name in one place and the program works\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nAvoiding Magic Constants\nA magic constant is a literal value that appears in multiple places in code without an apparent reason. For example if we just used contacts.pickle that would be a magic constant. The string is a constant but there is no context to explain what the value means. Magic constants are problematic because they are hard to find and if we want to change them we have to find all the places they’re used and then resolve the issue of does this 2 correspond to this magic constant or another magic constant\nIt is a good idea to instead put these constants in a variable so that we need only change the value in one place and we can clearly explain what the constant means\n\n\n\n\n\n\n\nTiny Contacts builds the Contact instance after we create one\n  new_contact = Contact()\n  new_contact.name = BTCInput.read_text(\"Enter the contact name: \")\n  new_contact.address = BTCInput.read_text(\"Enter the contact address: \")\n  new_contact.telephon = BTCInput.read_text(\"Enter the contact phone: \")\nThis makes the program fragile\n\nWe could misspell an attribute\nForget to set one\n\nIdeally want to create a Contact and ensure values are set as part of creation\nWe can do so with a Constructor, a special method called to create the object\n\nAlso sometimes called an initialiser method\n\nA method attribute is like a data attribute but as an attached function\n\n\n\n\nHeld inside a python class\nNamed __init__\n\npython uses “dunder methods” marked __function_name__ to mark special functions defined by the language\n\n\n\n\nOpen the python interpreter and work through the following steps to create an understand an initialiser, answering the questions\nType the below code in to define a class\n\nclass InitPrint:\n    def __init__(self):\n        print(\"you made an InitPrint instance\")\n\nThe above defines the class InitPrint it defines an initialiser method that prints a method. Note the double underscore before and after the init are required, as is the parameter self. The last line of the class is an empty line\n\nThe initialiser looks remarkably like a function why is that?\n\nAn initialiser is a function that is called when a class instance is created.\nType in the code below, which creates an instance of InitPrint and assigns it to the variable x,observe that the __init__ method is called even without us explicitly putting it\n\n  x = InitPrint()\n\nyou made an InitPrint instance\n\n\n\nHow is the __init__ function made to run?\n\nIt is handled by the python interpreter and how objects are constructed\nIt will run each time an instance of the InitPrint class is created\n\n\n\nNow define the InitName class as below\n\n  class InitName:\n      def __init__(self, new_name):\n          self.name = new_name\n\n\nThe initialiser can take arguments like any other function, here it takes new_name\nInitialiser no longer prints a message but rather sets a name attribute on the variable self\nself is a reference to the object running the method\n\nIn the initialiser this is the object being created\nself is always the first parameter of a method, and must be included\n\nNow replicate the code below to see how the new __init__ method works\n\n  x = InitName(\"Fred\")\n  print(x.name)\n\nFred\n\n\nWhen creating an InitName object we now have to pass the new_name parameter\nObserve we don’t explicitly pass self\n\nOnce an initialiser is defined, it is the only way to create an instance\n\nAttempting otherwise leads to an error, e.g. if we exclude the new_name\n\n\n  y = InitName()\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[16], line 1\n----&gt; 1 y = InitName()\n\nTypeError: InitName.__init__() missing 1 required positional argument: 'new_name'\n\n\n\nThis is a way of enforcing that an object is created with a full set of attributes\nOur Contact class, should accept three parameters\n\n  class Contact:\n      def __init__(self, name, address, telephone):\n          \"\"\"\n          Create a new Contact instance\n\n          Parameters\n          ----------\n          name : str\n              Contact Name\n          address : str\n              Contact's postal or street address\n          telephone : str\n              Contact phone number (stored as a string)\n          \"\"\"\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n\n\n\n\n\nWork through the following questions to ensure you understand the __init__ method\n\nIt looks like you’ve written the assignments in the initialiser so that a value is assigned to itself. What’s going on?\n\nConsider a statement\n  self.telephone = telephone\nThis looks like assigning telephone to telephone it, does not\nThe left is the telephone atrribute on the self object\nThe right is the telephone parameter passed to the initialiser\nPython variable names are namespaced\n\nnamespaces are regions in which names are uniquely identified\n\nOne namespace is the local namespace of the __init__ method\nThe other namespace is the attribute namespace of the self object\nnamespaces allow different contexts to use the same variable name distinct from each other\nGenerally it is convention to give initialiser parameters the same name as their associated object attributes\n\nWhat happens if the user of the constructor supplies silly arguments to it?\n\nCurrently the constructor doesn’t validate the input\ne.g. we could pass name a number, empty string or even None\n\nStill generates a Contact\n\nYou can add error handling code to the constructor and raise exceptions if the provided values are invalid\n\nFor a more robust application this might be required\nFor a small toy program we can generally expect valid input\n\n\n\n\nIf we want to create a new Contact now we can just call,\n\n\n    rob = Contact(name = \"Rob Miles\", address=\"18 Pussycat Mews, London, NE1 410S\", telephone=\"+44(1234) 56789\")\n\n\nWe can integrate this into our Tiny Contacts implementation\n  def new_contact():\n      \"\"\"\n      Creates and adds a new contact to the contact book\n\n      Returns\n      -------\n      None\n\n      See Also\n      --------\n      Contact : class for storing contact information\n      \"\"\"\n      print(\"Create new contact\")\n      name = BTCInput.read_text(\"Enter the contact name: \")\n      address = BTCInput.read_text(\"Enter the contact address: \")\n      telephone = BTCInput.read_text(\"Enter the contact phone: \")\n      new_contact = Contact(name=name, address=address, telephone=telephone)\n      contacts.append(new_contact)\n\n\n\n\n\n\nThe __init__ method supports default arguments\nFor example if we don’t want to make the telephone mandatory we could write\n\n  class Contact:\n      def __init__(self, name, address, telephone=\"No Telephone\"):\n          \"\"\"\n          Create a new Contact instance\n\n          Parameters\n          ----------\n          name : str\n              Contact Name\n          address : str\n              Contact's postal or street address\n          telephone : str\n              Contact phone number (stored as a string)\n          \"\"\"\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n\nWe could then create create a Contact as,\n\n  rob = Contact(name=\"Rob Miles\", address=\"18 Pussycat Mews, London, NE1 410S\")\n  print(rob.telephone)\n\nNo Telephone\n\n\n\nObserve that the telephone attribute still exists and has the default value \"No Telephone\"\n\n\n\n\n\n\n\n\nA Dictionary is another collection type like list and tuple\nDictionaries store data as key-value pairs\n\nA value is looked up by its key\nYou can think of a list as a dictionary where the key is the index\n\n\n\n\n\nLet’s consider creating a dictionary for a coffee shop\nWe want to key coffee products to their price (value)\nWe create an empty dictionary using {}\n\n  prices = {}\n\nItems can be added using the indexing operator to assign a value,\n\n  prices[\"latte\"] = 3.5\n  prices[\"latte\"]\n\n3.5\n\n\nWe can see prices has the key latte and the associated value of \\(3.5\\)\nWe can redefine dictionary values as for lists\n\n  prices[\"latte\"] = 3.6\n  prices[\"latte\"]\n\n3.6\n\n\nKeys are case-sensitive and must be spelled correctly, else a KeyError occurs,\n\n  prices[\"Latte\"]\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[24], line 1\n----&gt; 1 prices[\"Latte\"]\n\nKeyError: 'Latte'\n\n\n\nWe can search a dictionary for keys using the in operator\n\n  print('latte' in prices)\n  print('flat white' in prices)\n\nTrue\nFalse\n\n\nWe can print an entire dictionary just like with lists and tuples\n\n  prices[\"espresso\"] = 3.0\n  prices[\"tea\"] = 2.5\n  prices\n\n{'latte': 3.6, 'espresso': 3.0, 'tea': 2.5}\n\n\nObserve that the key-value pairs are printed with the format key : value\nWe can also create a dictionary with value using the same syntax like the printed output\n\n  prices = {'Latte' : 3.6, 'Espresso' : 3.0, \"Tea\" : 2.5, \"Americano\" : 2.5}\n\n\n\n\n\n\nDictionary elements use the \"key:item\" format\nKeys and values can be a mix of types, e.g. str, int, float e.g.,\n\n  access_control = {1234 : \"complete\", 1111 : \"limited\", 4342 : \"limited\"}\n\nValues can be duplicated\nBut keys must be unique\nConsider a dictionary that controls access to a burglar alarm\n\nUsers provide an access code\nCode keys a dictionary\nAccess is determined by the value in the dictionary\nA missing key (code) indicates no access permissions\n\n  # Example 9.9 Alarm Access Control\n  #\n  # Demonstrates the use of a dictionary as a lookup table to translate\n  # keys into associated values\n\n  import BTCInput\n\n  access_control = {1234: \"complete\", 1111: \"limited\", 4342: \"limited\"}\n\n  access_code = BTCInput.read_int(\"Enter your access code: \")\n  if access_code in access_control:\n      print(\"You have\", access_control[access_code], \"access\")\n  else:\n      print(\"You are not allowed access\")\nWe can delete dictionary entries using the del keyword, e.g.\n\n  del(access_control[1111])\n  print(access_control[1111])\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[29], line 2\n      1 del(access_control[1111])\n----&gt; 2 print(access_control[1111])\n\nKeyError: 1111\n\n\n\nThe KeyError above shows that the key-value has been eliminated\ndel can also be used to remove elements of a list\ndel will raise an exception if the object being deleted doesn’t exist\n\n\n\n\n\nWe’ve seen that programs can use dictionaries as lookup tables\nCan also return a dictionary from a function\n\ne.g. our Pirates Treasure map from Chapter 8 could use a dict instead\n\n\n  # Example 9.10: Pirate Treasure Dictionary\n  #\n  # Implementation of the Pirates Treasure map that uses a\n  # dictionary rather than a tuple to provide contextual\n  # key-value pairs\n\n\n  def get_treasure_location():\n      \"\"\"\n      Get the location of the treasure\n\n      Returns\n      -------\n      dict\n          Dictionary containing the location of the treasure, containing\n          the following keys\n\n          `\"start\"` : str\n\n              landmark to start at\n\n          `\"n\"` : int\n\n              number of paces to walk north relative to the\n              start\n\n          `\"e\"` : int\n\n              number of paces to walk east relative to the\n              start\n      \"\"\"\n      return {\"start\": \"The old oak tree\", \"n\": 20, \"e\": 30}\n\n\n  location = get_treasure_location()\n  print(\n      \"Start at\",\n      location[\"start\"],\n      \"walk\",\n      location[\"n\"],\n      \"paces north, and\",\n      location[\"e\"],\n      \"paces east\",\n  )\n\nStart at The old oak tree walk 20 paces north, and 30 paces east\n\n\nDictionaries let us assign contextual meaning to the returned parameters\nHarder to work with than tuple unpacking though\n\n\n\n\n\nWe could use dictionaries to store contacts in Tiny Contacts\n\nRather than use a class we could represent a contact with a dictionary like\n\n  rob_contact = {\"name\" : \"Rob Miles\", \"address\" : \"18 Pussycat Mews\", \"telephone\" : \"+44(1234) 56789\"}\n\n\nBut the we lost some of the nice class behaviours\n\nlike attributes being accessible via Contact.name etc. and we would instead have to use the string literal keys everywhere\n\n\nAnother option is storing the contacts themselves in a dictionary rather than a list\n\n contact_dictionary = {}\n rob = Contact(name = \"Rob Miles\", address = \"18 Pussycat Mews\", telephone = \"+44(1234) 56789\")\n contact_dictionary[rob.name] = rob\n print(contact_dictionary)\n\n{'Rob Miles': &lt;__main__.Contact object at 0x7f75d49bc740&gt;}\n\n\nWe can then search for a contact by just querying the key\n\n  contact_dictionary[\"Rob Miles\"]\n\n&lt;__main__.Contact at 0x7f75d49bc740&gt;\n\n\nHowever the user would have to type the correct full name\n\nAlso case sensitive\nWe could fix the case sensitivity by rather than using the name directly using a normalised key\n\nsuch as by using strip().lower() to strip excess whitespace and convert to lowercase\n\n\nOur current implementation uses startswith to provide more flexible matching\nIn general though, dictionaries provide fast queries for finding objects when we can easily use the key as a unique identifier\n\n\n\n\n\n\nThe Tiny contacts program is a useful template for any kind of program that stores data and lets a user work with it. You can even add some of the sorting and data-processing features from the ice-cream sales program to make applications that not only store data but let you do interesting things with it.\nExpand on the Tiny Contacts Program to implement the following,\n\nThe Tiny Contacts program will print all contacts if the find_contacts search string is blank, document this for the user\nAdd the sorting features from the ice-cream sales program to print contacts in alphabetical order\nIdentify more common between functions in Tiny Contacts and see what further refactors you can make\n\nThe first step is straightforward. We update the program is two places. First we document the behaviour in the responsible function, find_contacts\ndef find_contacts(search_name):\n    \"\"\"\n    Finds the contacts with the matching name\n\n    If the empty string is given, all contacts\n    are matched\n\n    Parameters\n    ----------\n    search_name : str\n        Name to search for (uses prefix matching)\n\n    Returns\n    -------\n    list[Contact]\n        list of contacts matching `search_name`, if no\n        matches exist the list is empty\n    \"\"\"\n    search_name = search_name.strip().lower()\n    results = []\n    for contact in contacts:\n        name = contact.name.strip().lower()\n        if name.startswith(search_name):\n            results.append(contact)\n    return results\nThis helps anyone who in the future has to edit or maintain our code. However it doesn’t provide much help to the user of the program. So we also document this in the user facing code (display_contacts)\ndef display_contacts():\n    \"\"\"\n    Prompts the user for a contact name and\n    displays all matching contacts\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_contact : displays a single contact\n    \"\"\"\n    print(\"Find contact\")\n    contacts = find_contacts(\n        BTCInput.read_text(\"Enter the contact name (Press enter to display all): \")\n    )\n    if len(contacts) &gt; 0:\n        for contact in contacts:\n            display_contact(contact)\n    else:\n        print(\"This name was not found\")\nThe relevant line being,\n    BTCInput.read_text(\"Enter the contact name (Press enter to display all): \")\nTo add the sorting functionality we first need to put the sorting code in,\ndef sort_contacts():\n    \"\"\"\n    sorts the contacts list into alphabetical order\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"Sort contacts\")\n    for sort_pass in range(0, len(contacts)):\n        done_swap = False\n        for count in range(0, len(contacts) - 1 - sort_pass):\n            if contacts[count].name &gt; contacts[count + 1].name:\n                temp = contacts[count]\n                contacts[count] = contacts[count + 1]\n                contacts[count + 1] = temp\n                done_swap = True\n        if not done_swap:\n            break\nThis code is basically the same as the sorting code in the ice-cream stand example except there might be something that looks odd. namely the line\ncontacts[count].name &gt; contacts[count + 1].name\nThis is because we want to sort the Contact objects alphabetical on the name field. So we have to compare against this field. contacts[count] is a reference to the Contact object stored at the index count so we can access the attributes on the underlying object\nWe then need to include the sorting option in the display menu\nmenu = \"\"\"Tiny Contacts\n\n1. New Contact\n2. Find Contact\n3. Edit Contact\n4. Sort Contacts\n5. Exit Program\n\nEnter your command: \"\"\"\n\nfile_name = \"contacts.pickle\"\ntry:\n    load_contacts(file_name)\nexcept:  # noqa: E722\n    print(\"Contacts file not found\")\n    contacts = []\n\nwhile True:\n    command = BTCInput.read_int_ranged(prompt=menu, min_value=1, max_value=5)\n    if command == 1:\n        new_contact()\n    elif command == 2:\n        display_contacts()\n    elif command == 3:\n        edit_contacts()\n    elif command == 4:\n        sort_contacts()\n    elif command == 5:\n        try:\n            save_contacts(file_name)\n        except:  # noqa: E722\n            print(\"Contacts failed to save\")\n        break\n    else:\n        raise ValueError(\"Unexpected command id found: \" + str(command))\nTo answer the final question of what functionality we can pull out we can see that both display_contacts and edit_contacts contain code for displaying an individual Contact. We can pull this code out into a distinct display_contact function responsible for displaying a single Contact. We can then update display_contacts and edit_contacts to defer the display functionality to display_contact\ndef display_contact(contact):\n    \"\"\"\n    Displays the Contact details for the supplied contact\n\n    Parameters\n    ----------\n    contact : Contact\n        contact to display\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_contacts : Displays all contacts matching a search name\n    \"\"\"\n    print(\"Name:\", contact.name)\n    print(\"Address:\", contact.address)\n    print(\"Telephone:\", contact.telephone, \"\\n\")\nThe new display_contacts now looks like,\ndef display_contacts():\n    \"\"\"\n    Prompts the user for a contact name and\n    displays all matching contacts\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_contact : displays a single contact\n    \"\"\"\n    print(\"Find contact\")\n    contacts = find_contacts(\n        BTCInput.read_text(\"Enter the contact name (Press enter to display all): \")\n    )\n    if len(contacts) &gt; 0:\n        for contact in contacts:\n            display_contact(contact)\n    else:\n        print(\"This name was not found\")\nand edit_contacts looks similar\n\n\n\nThis Chapter also contains two further examples which demonstrate building data storage applications that handle more functionality than tiny contacts.\nDue to the size of the discussion required for each exercise they are linked on a seperate page\n\n\nFocuses on demonstrating adding additional functionality to a basic storage application for data interrogation\n\nDevelops an application that can store music tracks\nImplements searching and sorting based on length of the track\nSupports the ability to create and save playlists\nPlaylists can be interrogated for their total length\nThe program can suggest playlists that match the user’s target runtime\n\n\n\n\nDemonstrates working with larger more complicated objects in data storage\n\nDevelops and application for storing recipes\nUsers can search for recipes by their name or their ingredients\nSupports different mechanisms for viewing details about a recipe\n\nViewing the ingredients\nViewing the steps\nSteping through the recipe, step by step\n\n\nYou are encouraged to work through or examine these exercises",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 9: Use Classes to Store Data"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/09_UsingClasses/Chapter_09.html#notes",
    "href": "02_AdvancedProgramming/09_UsingClasses/Chapter_09.html#notes",
    "title": "Chapter 9: Use Classes to Store Data",
    "section": "",
    "text": "Let’s develop a lightweight program to store contact details\n\nNames\nAddresses\nTelephone Numbers\n\nWe storyboard the interface\n  Tiny Contacts\n\n  1. New Contact\n  2. Find Contact\n  3. Exit Program\n\n  Enter your command:\nWe then want to extend the storyboard to the different interface options\n  Create new contact\n\n  Enter the contact name: Rob Miles\n  Enter the contact address: 18 Pussycat Mews, London, NE1 410S\n  Enter the contact phone: +44(1234) 56789\n\n  Contact record stored for Rob Miles\nThe matching storyboard for find is then,\n  Find Contact\n\n  Enter the contact name: Rob Miles\n  Name: Rob Miles\n  Address: 18 Pussycat Mews, London, NE1 410S\n  Phone: +44(1234) 56789\n\nWith a matching storyboard for a contact not existing\n    Find Contact\n\n    Enter the contact name: Fred Bloggs\n    This name was not found\n\n\n\n\n\nWe start by making a prototype\n\nWe stub out the functions with mock messages\n\nThis is good for demoing to the customer for their feedback\n\nAlso helps to start working out how the structure should flow\n\n  # Example 9.1 Tiny Contacts Prototype\n  #\n  # Simple stub implementation of the Tiny Contacts Prototype\n\n  import BTCInput\n\n\n  def new_contact():\n      \"\"\"\n      Creates and adds a new contact to the contact book\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Create the new contact\")\n      BTCInput.read_text(\"Enter the contact name: \")\n      BTCInput.read_text(\"Enter the contact address: \")\n      BTCInput.read_text(\"Enter the contact phone: \")\n\n\n  def find_contact():\n      \"\"\"\n      Displays the contact matching a user-specified name\n\n      Prompts the user for a name, and searches the contacts list.\n      If the contact is found in the list, their full contact details\n      are displayed\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Find contact\")\n      name = BTCInput.read_text(\"Enter the contact name: \")\n      if name == \"Rob Miles\":\n          print(\"Name: Rob Miles\")\n          print(\"Address: 18 Pussycat News, London, NE1 410S\")\n          print(\"Phone: +44(1234) 56789\")\n      else:\n          print(\"This name was not found.\")\n\n\n  menu = \"\"\"Tiny Contacts\n\n  1. New Contact\n  2. Find Contact\n  3. Exit Program\n\n  Enter your command:\"\"\"\n\n  while True:\n      command = BTCInput.read_int_ranged(prompt=menu, min_value=1, max_value=3)\n      if command == 1:\n          new_contact()\n      elif command == 2:\n          find_contact()\n      elif command == 3:\n          break\n      else:\n          raise ValueError(\"Unexpected command id found: \" + str(command))\n\n\n\nThe code above doesn’t introduce any new concepts, but it’s worth examining in detail to make sure you understand how all the parts work. Work through the following questions.\n\nIs this code familiar?\n\nIt should be!, It is very similar to the ride-selector and Ice Cream Sales programs\nThis menu structure is very common for imperative programs\n\nThe value returned by the read_text functions are ignored by the program. Is this legal?\n\nYes, it is perfectly legal.\nread_text is from the BTCInput library, it returns a user-provided string\n\nWe have yet to decide how we store this, so we simply discard it\nWe emulate the behaviour of getting a contact, but not the process of storing it yet\n\n\nHow does the program stop?\n\nThe main loop contains a special option that is used for exiting the program. This is achieved by calling break to get out of the loop, after which the program will finish\n\nIsn’t the prototype a bit basic? Why don’t you make it store data?\n\nThe prototype is not designed to be functional\n\nWe minimise the initial work so that if the customer backs out we haven’t wasted too much time\nWe want to make it clear that the program is a prototype, so that the customer won’t immediately want to use it\n\n\nHow is the telephone number stored?\n\nOur plan is store the number as a string\nWhile referred to as a number, telephone numbers typically have additional characters that make them much more like strings (e.g. +)\n\n\n\n\n\n\n\nStart with storing Contact Details\nSimplest implementation is to maintain a list for each different type of information we store\n\nthe \\(i\\)-th contact them has it’s details in the \\(i\\)-th index of each list\n\n  names = []\n  addresses = []\n  telephones = []\n\n  def new_contact():\n      \"\"\"\n      Creates and adds a new contact to the contact book\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Create the new contact\")\n      names.append(BTCInput.read_text(\"Enter the contact name: \"))\n      addresses.append(BTCInput.read_text(\"Enter the contact address: \"))\n      telephones.append(BTCInput.read_text(\"Enter the contact phone: \"))\nTo find items we then get the index from the names list and use that to access the corresponding indices in the addresses and telephones\n  def find_contact():\n      \"\"\"\n      Displays the contact matching a user-specified name\n\n      Prompts the user for a name, and searches the contacts list.\n      If the contact is found in the list, their full contact details\n      are displayed\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Find contact\")\n      search_name = BTCInput.read_text(\"Enter the contact name: \")\n      search_name = search_name.strip()\n      search_name = search_name.lower()\n      name_index = 0\n      for name in names:\n          name = name.strip()\n          name = name.lower()\n          if name == search_name:\n              break\n          name_index = name_index + 1\n\n      if name_position &lt; len(names):\n          print(\"Name: \", names[name_index])\n          print(\"Address: \", addresses[name_index])\n          print(\"Telephone: \", telephones[name_index])\n      else:\n          print(\"This name was not found\")\nYou can view the complete program all put together in TinyContactsParallelLists.py\n\n\n\nThe find_contact function is probably one of the more sophisticated pieces of code we’ve written. Work through the following questions to make sure you understand what is going on.\n\nHow does this code work?\n\nWe look through the names list until we find a match\nOnce we’ve found it we can immediately stop looking\n\nKeeping track of the index that we’ve been looking at\n\n\nWhat is the name_index variable used for?\n\nThe name_position variable is used to track which index of the names list matches the name we’re trying to find\nWe use this to then grab the address and phone from the addresses and telephones arrays\nThis technique is called parallel lists\n\nHow does the function know if a name has been found?\n\nIf we reach the end of the list without finding a match, then name_index ends the loop as one past the actual last valid index of the loop\n\nWe can check this with len\nWe use an if condition to check this\n\n\nWhat do the calls of strip and lower do?\n\nThese functions normalise the input, so that any extra whitespace or variations in upper and lower case are removed\n\nCan we save the user from having to type in all the names when they search?\n\nYes, we can. We could use startswith to find a name that starts with whatever the user inputs\nThis means they might only need to put in the first name\nThere are more sophisticated search techniques that we could use, but they are outside the scope of this discussion\n  if name.startswith(search_name):\n      break\n\nThe above is integrated into the complete program in TinyContactsQuickSearch.py\n\n\n\n\n\n\n\n\nAn issue with this set-up is we have to ensure that the parallel lists stay aligned\nFor example if we sort the names list alphabetically, we have to ensure we make the same transformations to the addresses and telephones lists\nWe instead would prefer to have one object or container that holds all three values together\nOne option is to use a tuple or a list\n\nBut then we have to remember how values are stored\n\nAlternative is the class\nIn object-oriented programming we use classes to define and construct objects\n\nA class is a type, an object is the instance\n\n\n\n\nOpen the python interpreter and work through the following steps and questions to understand classes\nEnter the statements below\n\nclass Contact:\n    \"\"\"\n    Stores Contact Information\n\n    Attributes\n    ----------\n    name : str\n        Contact Name\n    address : str\n        Contact's postal or street address.\n    telephone : str\n        Contact phone number (stored as a string).\n    \"\"\"\n\n    pass\n\nThe line class Contact: begins a class definition - The class contents is given as an indented block - We use pass To make an empty placeholder class\n\nWhy does the name Contact begin with a capital letter?\n\nIt’s convention, in python\n\nVariables and functions start with lowercase letters\nClasses start with uppercase letters\n\n\nWhy does the Contact class contain a Python pass statement?\n\nThe class definition expects an indented block\nWe haven’t yet decided the contents of the class so we use pass to give an placeholder statement\nWe can create an instance of a Contact with\n\n  x = Contact()\n\n\nThis looks like a function call. Are we calling a function here?\n\nTechnically this is a call to a function called a constructor\nWhich is responsible for creating an intance of a Contact\nBy using capital letters it’s clear that this is an object instantiation\n\nWhat’s an instance?\n\nAn instance is the realisation of a class\nClass is the design, object is the actual thing\nYou can add data attributes to an instance\n\n  x.name = \"Rob Miles\"\n\n\nWhat’s a data attribute?\n\nProvide information about a specific instance\nFor a contact we would want it to have name, address, and phone\nmethods can also be thought of as attributes\nYou can use and manipulate data attributes\n\n  print(x.name)\n  x.name = x.name + \" is a star\"\n  print(x.name)\n\nRob Miles\nRob Miles is a star\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAttributes in Python classes can be confusing\nThe ability to add attributes to an instance is not common across programming languages. For example Java, c# and c++ all prevent this.\nIn these languages a class definition must be fully specified including the attributes before it can be instantiated.\nBoth this static definition and pythons dynamic definitions have it’s advantages and disadvantages. The latter is easier for prototyping and development, but the former is much more type-safe\n\n\n\n\n\n\n\nWe can use the Contact class to eliminate the needs for multiple lists (see TinyContactsClass.py highlighted below)\n  contacts = []\n\n\n  def new_contact():\n      \"\"\"\n      Creates and adds a new contact to the contact book\n\n      Returns\n      -------\n      None\n\n      See Also\n      --------\n      Contact : class for storing contact information\n      \"\"\"\n      print(\"Create the new contact\")\n      new_contact = Contact()\n      new_contact.name = BTCInput.read_text(\"Enter the contact name: \")\n      new_contact.address = BTCInput.read_text(\"Enter the contact address: \")\n      new_contact.telephone = BTCInput.read_text(\"Enter the contact phone: \")\n      contacts.append(new_contact)\n\n\n  def find_contact():\n      \"\"\"\n      Displays the contact matching a user-specified name\n\n      Prompts the user for a name, and searches the contacts list.\n      If the contact is found in the list, their full contact details\n      are displayed\n\n      Returns\n      -------\n      None\n\n      Notes\n      -----\n      Matches any name prefixed by the search name\n      \"\"\"\n      print(\"Find contact\")\n      search_name = BTCInput.read_text(\"Enter the contact name: \")\n      search_name = search_name.strip()\n      search_name = search_name.lower()\n      result = None\n      for contact in contacts:\n          name = contact.name\n          name = name.strip()\n          name = name.lower()\n          if name.startswith(search_name):\n              result = contact\n              break\n\n\n\nAnswer the following questions about the new find_contact implementation\n\nHow does this code work?\n\nThis functions like the previous search, we look for a contact that has a match to the search name\nRather than use the index of the match, we set a reference to the object itself iin the variable* result\nWe use None to indicate no match was found\n\nWhat does the value None mean?\n\nNone in python is used to refer to a value that does not exist\nSemantically here it is used to indicate that no match was found\n\n\n\n\n\nThis program has a fault in that if multiple contacts have the same name as an existing one only the first one will be returned. Modify the program to correct this problem\nWe have two solutions that we could use,\n\nWhen a duplicate name is encountered we simply replace the old one\n\nThis is the simplest approach, however it is quite common for people to have the same names\n\nThe program returns all the valid matches\n\nThis is a bit more complicated\nOur search function now rather than returning one Contact returns a list containing all matching Contacts\nWe only have to change the find_contacts function (the full code is given in TinyContactsDuplicates.py)\n  def find_contact():\n      \"\"\"\n      Displays the contact matching a user-specified name\n\n      Prompts the user for a name, and searches the contacts list.\n      If the contact is found in the list, their full contact details\n      are displayed\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Find contact\")\n      search_name = BTCInput.read_text(\"Enter the contact name: \")\n      search_name = search_name.strip()\n      search_name = search_name.lower()\n      results = []\n      for contact in contacts:\n          name = contact.name\n          name = name.strip()\n          name = name.lower()\n          if name.startswith(search_name):\n              results.append(contact)\n\n      if len(results) &gt; 0:\n          for result in results:\n              print(\"Name: \", result.name)\n              print(\"Address: \", result.address)\n              print(\"Telephone: \", result.telephone, \"\\n\")\n      else:\n          print(\"This name was not found\")\n\n\n\n\n\n\n\n\nImportant\n\n\n\nLook for problems when you receive the specification\nWhen you discuss a specification there’s no guarantee ambiguities like how to deal with duplicate names will be discussed. You will need to consider cases like this that may arise and define the behaviour for them. This behaviour will need to match what the client expects to happen. The best way to make sure that happens is to make sure that is included in the specification\n\n\n\n\n\n\n\nIt might be quite common for contacts to change their contact details\nWe would like to be able to update an existing contact\nThe new interface\n  Tiny Contacts\n\n  1. New Contact\n  2. Find Contact\n  3. Edit Contact\n  4. Exit Program\n\n  Enter your command:\nWe then storyboard out the program,\n\nOur storyboard will be slightly different to the book implementation to better handle duplicates\n\n  Edit Contact\n  Enter the contact name: Rob\n  Found 1 match\n\n  Name: Robert Miles\n  Address: 18 Pussycat News, London, NE1 410S\n  Telephone: +44(1234) 56789\n\n  Edit this contact? (1 - Yes, 0 - No): 1\n\n  Enter new name or . to leave unchanged: .\n  Enter new address or . to leave unchanged: .\n  Enter new telephone or . to leave unchanged: +44 (1482) 465079\nThe edit program first needs us to find search for the contact we wish to edit\nWe then report the number of matches found\nFor each match, we then print the current details and ask the user if this is the contact they want to edit\nWe then give the user the option of editing each attribute or leaving it unchanged with .\n\n\n\n\nOur program is starting to get some structure\n\nGood time to consider a refactor\n\nWe now have two features that need to search for a contact by name\n\nFind and display a contact\nFind and edit a contact\n\nOne option is to copy the find_contact for edit_contact and replace the display code by the edit code\n\nNow we have to maintain two different copies of the search functionality\nEasy for these to become desynchronised if in the future we want to change how the search works (or need to fix a book)\n\nFor our refactor, we’ll do the following\n\nFactor out a core find_contacts function that takes a search name and returns the matches\nChange the name of the old find_contact function to display_contacts function\n\nHere’s the book’s implementation, (we’ll use something different in our implementation to account for duplicates)\n  def find_contact(search_name):\n      \"\"\"\n      Finds the contacts with the matching name\n\n      Parameters\n      ----------\n      search_name : str\n          Name to search for (uses prefix matching)\n\n      Returns\n      -------\n      list[Contact]\n          list of contacts matching the `search_name`, if no\n          matches exist the list is empty\n      \"\"\"\n      search_name = search_name.strip().lower()\n      result = None\n      for contact in contacts:\n          name = contact.name.strip().lower()\n          if name.startswith(search_name):\n              return result\n      return None\n\n\n\nAnswer the following questions, about this new version of find_contact\n\nWhy does the function contain two return statements?\n\nOnly one return will actually be executed\nIf a match is found then the match is returned\nIf not then the program will exit the for loop at which point it encounters the second return and returns None\n\nWhat would happen if another program tried to use the return value of the find_contact function, and the find_contact function had returned None\n\nDepends on what the function tries to do\nIf the function tried to something with that value, then an exception is thrown\n\n  x = None #emulate failed find from find_contact\n  print(x.address)\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[5], line 2\n      1 x = None #emulate failed find from find_contact\n----&gt; 2 print(x.address)\n\nAttributeError: 'NoneType' object has no attribute 'address'\n\n\n\nSince find_contact documents that it can return None it is the responsibility of the consumer of the function to ensure they don’t misuse the None\n\n\n\n\n\n\n\nfind_contact searches through contacts for a match\nReturned object is a reference to the memory object\ne.g. rob = find_contact(\"Rob Miles\") graphically looks like,\n\n\n\n\n\n\n---\nconfig:\n  flowchart:\n    htmlLabels: false\n---\n\n\nflowchart TD\n    A@{shape: tag-doc, label: \"Rob\"}\n    B@{shape: div-rect, label: \"Name: Rob Miles\n    Address: 18 Pussycat Mews, London, NE 410S\n    Telephone: +44(1234) 5678\"}\n\n    A--&gt;B\n\n\n\n\n\n\n\nWe have multiple references to an object, e.g. test = rob creates a new reference test\n\n\n\n\n\n\n---\nconfig:\n  flowchart:\n    htmlLabels: false\n---\n\n\nflowchart TD\n    A@{shape: tag-doc, label: \"Rob\"}\n    B@{shape: div-rect, label: \"Name: Rob Miles\n    Address: 18 Pussycat Mews ..\n    Telephone: +44(1234) 5678\"}\n    C@{shape: tag-doc, label: \"test\"}\n\n    A--&gt;B\n    C--&gt;B\n\n\n\n\n\n\n\nChanges from one reference to the underlying memory object are seen in the other references\ne.g. test.name = \"Robert Miles Man of Mystery\" gives the state as,\n\n\n\n\n\n\n---\nconfig:\n  flowchart:\n    htmlLabels: false\n---\n\n\nflowchart TD\n    A@{shape: tag-doc, label: \"Rob\"}\n    B@{shape: div-rect, label: \"Name: Rob Miles Man ...\n    Address: 18 Pussycat Mews ..\n    Telephone: +44(1234) 5678\"}\n    C@{shape: tag-doc, label: \"test\"}\n\n    A--&gt;B\n    C--&gt;B\n\n\n\n\n\n\n\nThis behaviour is sometimes referred to as shallow copying since we have multiple copies of the object, but they are not distinct, changes are propagated between all the references\n\nThere is only one memory object\n\n\n\n\nThe figure below illustrates how lists and references work. It shows a Tiny Contacts data store with three contacts registered. Each of the tags in the contacts list refers to a different Contact instance in the memory. Work through the following questions to develop your understanding of references\n\n\n\n\n\n---\nconfig:\nflowchart:\n    htmlLabels: false\n---\n\n\n    flowchart TD\n\n        subgraph Contacts\n            A@{shape: tag-doc, label: \"0\"}\n            B@{shape: tag-doc, label: \"1\"}\n            C@{shape: tag-doc, label: \"2\"}\n        end\n\n        A1@{shape: div-rect, label: \"Name: Fred Smith\n        Address: 1605 Main St,\n        New York\n        Telephone: (560) 567-5209\"}\n\n        B1@{shape: div-rect, label: \"Name: Joe Bloggs\n        Address: 2312 Pine Street,\n        Seattle\n        Telephone: (453) 545-1232\"}\n\n        C1@{shape: div-rect, label: \"Name: Rob Miles\n        Address: 18 Pussycat Mews,\n         London, NE1 410S\n        Telephone: +44(1234) 5678\"}\n        D@{shape: tag-doc, label: \"rob\"}\n\n        A--&gt;A1\n        B--&gt;B1\n        C--&gt;C1\n        D--&gt;C1\n\n\n\n\n\n\n\nThe diagram contains four references. How many data objects does it contain?\n\nThere are three data objects, the Contact items themselves\nOne (Rob Miles) is referenced by the list index \\(2\\) and the variable rob\n\nWhat would happen if the program performed the following statement?\n contacts[0] = contacts[1]\n\nThe \\(0\\) index in the list now references the same memory object as that in the \\(1\\) index, the state now looks like,\n\n\n\n\n\n\n\nflowchart TD\n    subgraph Contacts\n        A@{shape: tag-doc, label: \"0\"}\n        B@{shape: tag-doc, label: \"1\"}\n        C@{shape: tag-doc, label: \"2\"}\n    end\n\n    A1@{shape: div-rect, label: \"Name: Fred Smith\n    Address: 1605 Main St,\n    New York\n    Telephone: (560) 567-5209\"}\n\n    B1@{shape: div-rect, label: \"Name: Joe Bloggs\n    Address: 2312 Pine Street,\n    Seattle\n    Telephone: (453) 545-1232\"}\n\n    C1@{shape: div-rect, label: \"Name: Rob Miles\n    Address: 18 Pussycat Mews,\n    London, NE1 410S\n    Telephone: +44(1234) 5678\"}\n    D@{shape: tag-doc, label: \"rob\"}\n\n    A--&gt;B1\n    B--&gt;B1\n    C--&gt;C1\n    D--&gt;C1\n\n\n\n\n\n\n\nLooping through the list would thus refer to the Joe Bloggs Contact twice\nNote that we have now lost the reference to Fred Smith, we can never get it back!\n\nUnreferenced memory objects will be removed by python in a process called garbage collection\n\nReferences make it easy to work with large data objects\n\nAvoid the need to create expensive copies\n\n\n\n\n\n\nEverything in Python is an object\n30 is an instance of an int\nThe following creates a reference age to 30\n\n  age = 30\n\nWhich we can visualise,\n\n\n\n\n\n\n    flowchart TD\n        A@{shape: tag-doc, label: \"age\"}\n\n        A1[\"`int\n            30`\"]\n\n        A--&gt;A1\n\n\n\n\n\n\n\nand verify,\n\n  type(age)\n\nint\n\n\ntype is a built-in function\n\nTakes a reference as an argument\nReturns the type of the referenced object\n\nNow, suppose we define another reference temp via\n\n  temp = age\n\nWhich we can again visualise as,\n\n\n\n\n\n\n    flowchart TD\n        A@{shape: tag-doc, label: \"age\"}\n        B@{shape: tag-doc, label: \"temp\"}\n\n        A1[\"`int\n            30`\"]\n\n        A--&gt;A1\n        B--&gt;A1\n\n\n\n\n\n\n\nage and temp now refer to the same object instance\nWhat happens if we assign temp a new value?\n\n  temp = 99\n  print(age)\n  print(temp)\n\n30\n99\n\n\nSo we have the final state,\n\n\n\n\n\n\n    flowchart TD\n        A@{shape: tag-doc, label: \"age\"}\n        B@{shape: tag-doc, label: \"temp\"}\n\n        A1[\"`int\n            30`\"]\n        B1[\"`int\n            99`\"]\n\n        A--&gt;A1\n        B--&gt;B1\n\n\n\n\n\n\n\nage has not been modified\nInstead a new int with a value of \\(99\\) was created\nThis is because int is an immutable type\n\ni.e. once an int has been created its value can’t be reassigned\nValue assignments thus create a new instance of an int\n\nstring is also an immutable type\n\n  name = \"Rob\"\n  temp = name\n  print(\"temp is\", temp, \"name is\", name)\n  temp = \"Fred\"\n  print(\"temp is now\", temp, \"name is now\", name)\n\ntemp is Rob name is Rob\ntemp is now Fred name is now Rob\n\n\n\n\nWhy does python use immutable data types?\n\nFor some procedures, like simple numerical calculations, treating variables as values is often the most desired approach, e.g.\n  pi = 3.1415\n  x = pi\n  x = 99.99\nWe don’t want the above to accidently change the value of the constant pi\n\n\n\n\n\n\n\n\nImportant\n\n\n\nProgramming Languages work with values differently\nLanguages handle the distinction between references and values differently. References make it easy to work with large data as the objects remain stationary in memory. However value types make it easy to perform data manipulation with types such as int, bool, float and string\nC# has a similar concept of value types. Java has primitive types, C++ has references. Python implements int, bool, float and string are immutable types, and behave like values\nRemember that the tuple collection type is also immutable\n\n\n\n\n\n\n\nOnce we have found a reference we can read and modify the attributes\nOur program implementation, uses a simple interface optionally modify each attribute one at a time\n\nNeed to read a user string for each modifiable atttribute\nOur duplicates implementation also needs to read an int to indicate if we want to modify a specific contact (and print the current contact)\n\nThe book implementation is,\ndef edit_contact():\n  \"\"\"\n  Reads in a name to search for an then allows the user\n  to edit the details of that contact. If there is no\n  contact, the function displays a message indicating\n  that the name was not found\n  \"\"\"\n\n  print(\"Edit Contact\")\n  search_name = read_text(\"Enter the contact name: \")\n  contact=find_contact(search_name)\n  if contact != None:\n      print(\"Name: \", contact.name)\n      new_name = read_text(\"Enter new name or . to leave unchanged\")\n      if new_name != '.':\n          contact.name = new_name\n      new_address = read_text(\"Enter new address or . to leave unchanged\")\n      if new_address != '.':\n          contact.address = new_address\n      new_phone = read_text(\"Enter new phone or . to leave unchanged\")\n      if new_phone != '.':\n          contact.telephone = new_phone\n  else:\n      print(\"This name was not found\")\nEditing as configured performs modifications of the live data\n\nReferred to as in-place because it occurs on the original object not a copy\n\nCan’t easily rollback if there is an error or ask the user wishes to cancel\nTo do so, edit_contact would need to work on a copy of the data\n\n\n\n\n\n\n\nWarning\n\n\n\nMissing Attributes\nedit_function calls find_contact to match a given name. find_contact returns None if no match is found. However, another possible fault in a contact is returned without all the attributes defined, e.g. a contact with a name but no address. Then the program would fail, as the code below demonstrates\n\nclass Contact:\n    pass\n\n# fake contact \"returned without address\"\ncontact = Contact()\ncontact.name = \"Hello\"\n\n# Attempt to access address\nprint(\"contact address is\", contact.address)\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[11], line 9\n      6 contact.name = \"Hello\"\n      8 # Attempt to access address\n----&gt; 9 print(\"contact address is\", contact.address)\n\nAttributeError: 'Contact' object has no attribute 'address'\n\n\n\nSome programming languages e.g. Java, C#, C++ check for these errors before a program executes. Python does not. This means that minor typos e.g. writing adress instead of address can lead to runtime errors\n\n\n\n\n\n\n\nWe saw in Chapter 8 that we can save and load data to files\n\nThere we used a human-readable text representation\n\nWe could replicate this for large class based structures\n\ne.g. write out all attributes as comma, seperated values\n\nPython provides a process called pickling for storing large data structures\n\npickled data is stored as binary\nData is therefore computer-readable and more compressed than human text\n\nPickling is done through the pickle library, import it to use it\n  import pickle\njpeg, mp3, zip are all different formats of binary data\n\nCommonly a file extension is used to identify what a binary file represents\ne.g.\n\nmyhouse.jpg\ntrack1.mp3\n\nDifferent programs are written to work with different binary file formats\n\n.txt defines a generic text file\n.py defines a text file that is valid python code\nTechnically text is also a binary file, just with those binary values associated to human-readable characters\nPython programs can use the b mode flag to read files as binary, e.g.\n  out_file = open(\"contacts.pickle\", \"wb\")\n\nThe above opens the file contacts.pickle for writing (w) as a binary file (b)\n.pickle indicates the file is a pickled python data object\n\npickle supplies the dump function to write a data structure to a file\n\nThe file must be opened for writing in binary\n\n  pickle.dump(contacts, out_file)\n\ncontacts is the variable to pickle\nout_file is the variable storing the file save the data to\n\nYou can open and modify pickle files\n\nWhile they may contain some readable text, they will also contain a mix of improperly rendered binary\n\n(Unless you have a specially set up text editor like a hexadecimal reader)\n\n\n\n\n\n\nPickled content of the Tiny Contacts app, a mix of human-readable characters and improperly rendered binary is displayed\n\n\n\n\n\n\n\n\nCaution\n\n\n\nBe careful modifying pickle files by hand\nPickle files are not designed to be human-readable. While most text editors will happily let you edit and save a pickle file this is very likely to end up in you breaking the binary format and the file no longer loading properly\n\n\n\nsave_contacts below saves the contacts list into a given file (passed as a path name)\n\nAs in Chapter 8 we use with to handle managing the file access\n\ndef save_contacts(file_name):\n  \"\"\"\n  Saves the contacts to the given file name\n\n  Contacts are stored in binary as a pickled file\n\n  Parameters\n  ----------\n  file_name : str\n      string giving the path to the file to store the contacts data in\n\n  Returns\n  -------\n  None\n\n  Raises\n  ------\n      Exceptions are raised if contacts could not be saved\n\n  See Also\n  --------\n  load_contacts : loads contacts from a pickled file\n  \"\"\"\n  print(\"save contacts\")\n  with open(file_name, \"wb\") as out_file:\n      pickle.dump(contacts, out_file)\n\nThis function does not perform any exception handling\nThis will cause the program to crash if the save fails\n\nProbably fine for a program of this size\nNote: You should never hide a failed save from the user!\n\nIf we wanted to handle exceptions, we would do that in the code outside save_contacts\n\n\n\n\n\n\npickle provides load to read a pickle file\n\nreturns the reconstructed data object\nAs a result, needs only the file\n\nfile needs to be open for reading r and in binary mode b\n  def load_contacts(file_name):\n      \"\"\"\n      Loads the contacts from the given file\n\n      Contacts are stored in binary as a pickled file\n\n      Parameters\n      ----------\n      file_name : str\n          string giving the path to the file where the contacts data is stored\n\n      Returns\n      -------\n      None\n          Contact detail is loaded into the global contacts value\n\n      Raises\n      ------\n          Exceptions if contacts failed to load\n\n      See Also\n      --------\n      save_contacts : saves contacts to a pickled file\n      \"\"\"\n      global contacts #connect to the global contacts variable\n      print(\"load contacts\")\n      with open(file_name, \"rb\") as input_file:\n          contacts=pickle.load(input_file)\n\n\n\nWork through the following questions to make sure you understand how load_contacts works\n\nWhat does the global contacts statement do? Why do we need it only in the load function and not the save function?\n\nThe load_contacts function is used to modify the values of the contacts variable\nThe contacts holds all the current contacts, held in the program\nsave_contacts needs the reference to find the list\n\nDoes not modify the list itself\n\nload_contacts does modify the contacts list\n\nNeed to explicitly link to the global variable to write to it\n\n\nHow does the pickle load function know what kind of data to make when loading?\n\nThe information is encoded in the pickle file\nIn a pickle file you should be able to identify the data attributes (name etc.) and their values\nAlso contains the class name\nload looks for matching classes in the program loading the data\n\nConstructs object instances based on those classes\nMeans the class Contact must be defined before pickle is used to load any contact data\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nVersion Control\nPickle is a tool called a serialiser because it converts a data structure is a serial stream (i.e. ordered sequence of data) that can be sent to another program and/or stored in a file.\nThis introduces the need for version control. If the design of a class e.g. Contact (say we added an email attribute) then all previously pickled data may no longer load since the class definition is mismatched. To resolve this you need to version control both the version of the class and the pickled files so that data can be migrated (or converted) between versions\n\n\n\n\n\n\n\nLet’s add the save and load functionality to the Tiny Contacts Program\nThere are two options for how we implement this,\n\nThe user manually declares they want to save and load\nWe hardcode a data file\n\nLoad from this file on program start\nSave to this file as part of the exit process\n\n\nFor a small contacts app the user probably doesn’t want to manually have to handle saving and loading files\nMore likely to want to have it “just work”\n\nWe’ll go with option 2\n\nThe new interface now looks like below (see our full implementation which contains an example pickle file)\n  # Example 9.7 Tiny Contacts with Load and Save\n  import pickle\n\n  #Load contacts from file or create empty list if it fails to load\n  file_name = \"contacts.pickle\"\n  try:\n      load_contacts(file_name)\n  except:\n      print(\"Contacts file not found\")\n      contacts=[]\n\n  while True:\n      command = BTCInput.read_int_ranged(prompt=menu, min_value=1, max_value=4)\n      if command == 1:\n          new_contact()\n      elif command == 2:\n          display_contact()\n      elif command == 3:\n          edit_contact()\n      elif command == 4:\n          save_contacts(file_name) #save contacts on exit\n          break\n      else:\n          raise ValueError(\"Unexpected value encountered\")\n\n\n\nConsider the following questions about the code above\n\nWhat happens if the load_contacts function raises an exception?\n\nload_contacts raises an exception if the contacts file can’t be found, or if the load function in pickle fails\nIn this case the exception is caught, an error message is printed and an empty contacts list is created\n\nWhy does the program not catch the exceptions raised by save_contacts?\n\nYou could add this if you wanted\nIf the program crashes, the user should probably expect the save failed\nSince they were trying to quit anyway they probably don’t care\nMy implementation adds try...except block that prints an error message if the save fails (as the book suggests you consider)\n\nWhy does the program use a variable for the file name of the pickled file?\n\nThe contacts are held in a file called* contacts.pickle\nThis file is used in two places* load_contacts and save_contacts\n\nWe could put the string literal in both places\nInstead use a variable\nMeans we can change the file name in one place and the program works\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nAvoiding Magic Constants\nA magic constant is a literal value that appears in multiple places in code without an apparent reason. For example if we just used contacts.pickle that would be a magic constant. The string is a constant but there is no context to explain what the value means. Magic constants are problematic because they are hard to find and if we want to change them we have to find all the places they’re used and then resolve the issue of does this 2 correspond to this magic constant or another magic constant\nIt is a good idea to instead put these constants in a variable so that we need only change the value in one place and we can clearly explain what the constant means\n\n\n\n\n\n\n\nTiny Contacts builds the Contact instance after we create one\n  new_contact = Contact()\n  new_contact.name = BTCInput.read_text(\"Enter the contact name: \")\n  new_contact.address = BTCInput.read_text(\"Enter the contact address: \")\n  new_contact.telephon = BTCInput.read_text(\"Enter the contact phone: \")\nThis makes the program fragile\n\nWe could misspell an attribute\nForget to set one\n\nIdeally want to create a Contact and ensure values are set as part of creation\nWe can do so with a Constructor, a special method called to create the object\n\nAlso sometimes called an initialiser method\n\nA method attribute is like a data attribute but as an attached function\n\n\n\n\nHeld inside a python class\nNamed __init__\n\npython uses “dunder methods” marked __function_name__ to mark special functions defined by the language\n\n\n\n\nOpen the python interpreter and work through the following steps to create an understand an initialiser, answering the questions\nType the below code in to define a class\n\nclass InitPrint:\n    def __init__(self):\n        print(\"you made an InitPrint instance\")\n\nThe above defines the class InitPrint it defines an initialiser method that prints a method. Note the double underscore before and after the init are required, as is the parameter self. The last line of the class is an empty line\n\nThe initialiser looks remarkably like a function why is that?\n\nAn initialiser is a function that is called when a class instance is created.\nType in the code below, which creates an instance of InitPrint and assigns it to the variable x,observe that the __init__ method is called even without us explicitly putting it\n\n  x = InitPrint()\n\nyou made an InitPrint instance\n\n\n\nHow is the __init__ function made to run?\n\nIt is handled by the python interpreter and how objects are constructed\nIt will run each time an instance of the InitPrint class is created\n\n\n\nNow define the InitName class as below\n\n  class InitName:\n      def __init__(self, new_name):\n          self.name = new_name\n\n\nThe initialiser can take arguments like any other function, here it takes new_name\nInitialiser no longer prints a message but rather sets a name attribute on the variable self\nself is a reference to the object running the method\n\nIn the initialiser this is the object being created\nself is always the first parameter of a method, and must be included\n\nNow replicate the code below to see how the new __init__ method works\n\n  x = InitName(\"Fred\")\n  print(x.name)\n\nFred\n\n\nWhen creating an InitName object we now have to pass the new_name parameter\nObserve we don’t explicitly pass self\n\nOnce an initialiser is defined, it is the only way to create an instance\n\nAttempting otherwise leads to an error, e.g. if we exclude the new_name\n\n\n  y = InitName()\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[16], line 1\n----&gt; 1 y = InitName()\n\nTypeError: InitName.__init__() missing 1 required positional argument: 'new_name'\n\n\n\nThis is a way of enforcing that an object is created with a full set of attributes\nOur Contact class, should accept three parameters\n\n  class Contact:\n      def __init__(self, name, address, telephone):\n          \"\"\"\n          Create a new Contact instance\n\n          Parameters\n          ----------\n          name : str\n              Contact Name\n          address : str\n              Contact's postal or street address\n          telephone : str\n              Contact phone number (stored as a string)\n          \"\"\"\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n\n\n\n\n\nWork through the following questions to ensure you understand the __init__ method\n\nIt looks like you’ve written the assignments in the initialiser so that a value is assigned to itself. What’s going on?\n\nConsider a statement\n  self.telephone = telephone\nThis looks like assigning telephone to telephone it, does not\nThe left is the telephone atrribute on the self object\nThe right is the telephone parameter passed to the initialiser\nPython variable names are namespaced\n\nnamespaces are regions in which names are uniquely identified\n\nOne namespace is the local namespace of the __init__ method\nThe other namespace is the attribute namespace of the self object\nnamespaces allow different contexts to use the same variable name distinct from each other\nGenerally it is convention to give initialiser parameters the same name as their associated object attributes\n\nWhat happens if the user of the constructor supplies silly arguments to it?\n\nCurrently the constructor doesn’t validate the input\ne.g. we could pass name a number, empty string or even None\n\nStill generates a Contact\n\nYou can add error handling code to the constructor and raise exceptions if the provided values are invalid\n\nFor a more robust application this might be required\nFor a small toy program we can generally expect valid input\n\n\n\n\nIf we want to create a new Contact now we can just call,\n\n\n    rob = Contact(name = \"Rob Miles\", address=\"18 Pussycat Mews, London, NE1 410S\", telephone=\"+44(1234) 56789\")\n\n\nWe can integrate this into our Tiny Contacts implementation\n  def new_contact():\n      \"\"\"\n      Creates and adds a new contact to the contact book\n\n      Returns\n      -------\n      None\n\n      See Also\n      --------\n      Contact : class for storing contact information\n      \"\"\"\n      print(\"Create new contact\")\n      name = BTCInput.read_text(\"Enter the contact name: \")\n      address = BTCInput.read_text(\"Enter the contact address: \")\n      telephone = BTCInput.read_text(\"Enter the contact phone: \")\n      new_contact = Contact(name=name, address=address, telephone=telephone)\n      contacts.append(new_contact)\n\n\n\n\n\n\nThe __init__ method supports default arguments\nFor example if we don’t want to make the telephone mandatory we could write\n\n  class Contact:\n      def __init__(self, name, address, telephone=\"No Telephone\"):\n          \"\"\"\n          Create a new Contact instance\n\n          Parameters\n          ----------\n          name : str\n              Contact Name\n          address : str\n              Contact's postal or street address\n          telephone : str\n              Contact phone number (stored as a string)\n          \"\"\"\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n\nWe could then create create a Contact as,\n\n  rob = Contact(name=\"Rob Miles\", address=\"18 Pussycat Mews, London, NE1 410S\")\n  print(rob.telephone)\n\nNo Telephone\n\n\n\nObserve that the telephone attribute still exists and has the default value \"No Telephone\"\n\n\n\n\n\n\n\n\nA Dictionary is another collection type like list and tuple\nDictionaries store data as key-value pairs\n\nA value is looked up by its key\nYou can think of a list as a dictionary where the key is the index\n\n\n\n\n\nLet’s consider creating a dictionary for a coffee shop\nWe want to key coffee products to their price (value)\nWe create an empty dictionary using {}\n\n  prices = {}\n\nItems can be added using the indexing operator to assign a value,\n\n  prices[\"latte\"] = 3.5\n  prices[\"latte\"]\n\n3.5\n\n\nWe can see prices has the key latte and the associated value of \\(3.5\\)\nWe can redefine dictionary values as for lists\n\n  prices[\"latte\"] = 3.6\n  prices[\"latte\"]\n\n3.6\n\n\nKeys are case-sensitive and must be spelled correctly, else a KeyError occurs,\n\n  prices[\"Latte\"]\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[24], line 1\n----&gt; 1 prices[\"Latte\"]\n\nKeyError: 'Latte'\n\n\n\nWe can search a dictionary for keys using the in operator\n\n  print('latte' in prices)\n  print('flat white' in prices)\n\nTrue\nFalse\n\n\nWe can print an entire dictionary just like with lists and tuples\n\n  prices[\"espresso\"] = 3.0\n  prices[\"tea\"] = 2.5\n  prices\n\n{'latte': 3.6, 'espresso': 3.0, 'tea': 2.5}\n\n\nObserve that the key-value pairs are printed with the format key : value\nWe can also create a dictionary with value using the same syntax like the printed output\n\n  prices = {'Latte' : 3.6, 'Espresso' : 3.0, \"Tea\" : 2.5, \"Americano\" : 2.5}\n\n\n\n\n\n\nDictionary elements use the \"key:item\" format\nKeys and values can be a mix of types, e.g. str, int, float e.g.,\n\n  access_control = {1234 : \"complete\", 1111 : \"limited\", 4342 : \"limited\"}\n\nValues can be duplicated\nBut keys must be unique\nConsider a dictionary that controls access to a burglar alarm\n\nUsers provide an access code\nCode keys a dictionary\nAccess is determined by the value in the dictionary\nA missing key (code) indicates no access permissions\n\n  # Example 9.9 Alarm Access Control\n  #\n  # Demonstrates the use of a dictionary as a lookup table to translate\n  # keys into associated values\n\n  import BTCInput\n\n  access_control = {1234: \"complete\", 1111: \"limited\", 4342: \"limited\"}\n\n  access_code = BTCInput.read_int(\"Enter your access code: \")\n  if access_code in access_control:\n      print(\"You have\", access_control[access_code], \"access\")\n  else:\n      print(\"You are not allowed access\")\nWe can delete dictionary entries using the del keyword, e.g.\n\n  del(access_control[1111])\n  print(access_control[1111])\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[29], line 2\n      1 del(access_control[1111])\n----&gt; 2 print(access_control[1111])\n\nKeyError: 1111\n\n\n\nThe KeyError above shows that the key-value has been eliminated\ndel can also be used to remove elements of a list\ndel will raise an exception if the object being deleted doesn’t exist\n\n\n\n\n\nWe’ve seen that programs can use dictionaries as lookup tables\nCan also return a dictionary from a function\n\ne.g. our Pirates Treasure map from Chapter 8 could use a dict instead\n\n\n  # Example 9.10: Pirate Treasure Dictionary\n  #\n  # Implementation of the Pirates Treasure map that uses a\n  # dictionary rather than a tuple to provide contextual\n  # key-value pairs\n\n\n  def get_treasure_location():\n      \"\"\"\n      Get the location of the treasure\n\n      Returns\n      -------\n      dict\n          Dictionary containing the location of the treasure, containing\n          the following keys\n\n          `\"start\"` : str\n\n              landmark to start at\n\n          `\"n\"` : int\n\n              number of paces to walk north relative to the\n              start\n\n          `\"e\"` : int\n\n              number of paces to walk east relative to the\n              start\n      \"\"\"\n      return {\"start\": \"The old oak tree\", \"n\": 20, \"e\": 30}\n\n\n  location = get_treasure_location()\n  print(\n      \"Start at\",\n      location[\"start\"],\n      \"walk\",\n      location[\"n\"],\n      \"paces north, and\",\n      location[\"e\"],\n      \"paces east\",\n  )\n\nStart at The old oak tree walk 20 paces north, and 30 paces east\n\n\nDictionaries let us assign contextual meaning to the returned parameters\nHarder to work with than tuple unpacking though\n\n\n\n\n\nWe could use dictionaries to store contacts in Tiny Contacts\n\nRather than use a class we could represent a contact with a dictionary like\n\n  rob_contact = {\"name\" : \"Rob Miles\", \"address\" : \"18 Pussycat Mews\", \"telephone\" : \"+44(1234) 56789\"}\n\n\nBut the we lost some of the nice class behaviours\n\nlike attributes being accessible via Contact.name etc. and we would instead have to use the string literal keys everywhere\n\n\nAnother option is storing the contacts themselves in a dictionary rather than a list\n\n contact_dictionary = {}\n rob = Contact(name = \"Rob Miles\", address = \"18 Pussycat Mews\", telephone = \"+44(1234) 56789\")\n contact_dictionary[rob.name] = rob\n print(contact_dictionary)\n\n{'Rob Miles': &lt;__main__.Contact object at 0x7f75d49bc740&gt;}\n\n\nWe can then search for a contact by just querying the key\n\n  contact_dictionary[\"Rob Miles\"]\n\n&lt;__main__.Contact at 0x7f75d49bc740&gt;\n\n\nHowever the user would have to type the correct full name\n\nAlso case sensitive\nWe could fix the case sensitivity by rather than using the name directly using a normalised key\n\nsuch as by using strip().lower() to strip excess whitespace and convert to lowercase\n\n\nOur current implementation uses startswith to provide more flexible matching\nIn general though, dictionaries provide fast queries for finding objects when we can easily use the key as a unique identifier\n\n\n\n\n\n\nThe Tiny contacts program is a useful template for any kind of program that stores data and lets a user work with it. You can even add some of the sorting and data-processing features from the ice-cream sales program to make applications that not only store data but let you do interesting things with it.\nExpand on the Tiny Contacts Program to implement the following,\n\nThe Tiny Contacts program will print all contacts if the find_contacts search string is blank, document this for the user\nAdd the sorting features from the ice-cream sales program to print contacts in alphabetical order\nIdentify more common between functions in Tiny Contacts and see what further refactors you can make\n\nThe first step is straightforward. We update the program is two places. First we document the behaviour in the responsible function, find_contacts\ndef find_contacts(search_name):\n    \"\"\"\n    Finds the contacts with the matching name\n\n    If the empty string is given, all contacts\n    are matched\n\n    Parameters\n    ----------\n    search_name : str\n        Name to search for (uses prefix matching)\n\n    Returns\n    -------\n    list[Contact]\n        list of contacts matching `search_name`, if no\n        matches exist the list is empty\n    \"\"\"\n    search_name = search_name.strip().lower()\n    results = []\n    for contact in contacts:\n        name = contact.name.strip().lower()\n        if name.startswith(search_name):\n            results.append(contact)\n    return results\nThis helps anyone who in the future has to edit or maintain our code. However it doesn’t provide much help to the user of the program. So we also document this in the user facing code (display_contacts)\ndef display_contacts():\n    \"\"\"\n    Prompts the user for a contact name and\n    displays all matching contacts\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_contact : displays a single contact\n    \"\"\"\n    print(\"Find contact\")\n    contacts = find_contacts(\n        BTCInput.read_text(\"Enter the contact name (Press enter to display all): \")\n    )\n    if len(contacts) &gt; 0:\n        for contact in contacts:\n            display_contact(contact)\n    else:\n        print(\"This name was not found\")\nThe relevant line being,\n    BTCInput.read_text(\"Enter the contact name (Press enter to display all): \")\nTo add the sorting functionality we first need to put the sorting code in,\ndef sort_contacts():\n    \"\"\"\n    sorts the contacts list into alphabetical order\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"Sort contacts\")\n    for sort_pass in range(0, len(contacts)):\n        done_swap = False\n        for count in range(0, len(contacts) - 1 - sort_pass):\n            if contacts[count].name &gt; contacts[count + 1].name:\n                temp = contacts[count]\n                contacts[count] = contacts[count + 1]\n                contacts[count + 1] = temp\n                done_swap = True\n        if not done_swap:\n            break\nThis code is basically the same as the sorting code in the ice-cream stand example except there might be something that looks odd. namely the line\ncontacts[count].name &gt; contacts[count + 1].name\nThis is because we want to sort the Contact objects alphabetical on the name field. So we have to compare against this field. contacts[count] is a reference to the Contact object stored at the index count so we can access the attributes on the underlying object\nWe then need to include the sorting option in the display menu\nmenu = \"\"\"Tiny Contacts\n\n1. New Contact\n2. Find Contact\n3. Edit Contact\n4. Sort Contacts\n5. Exit Program\n\nEnter your command: \"\"\"\n\nfile_name = \"contacts.pickle\"\ntry:\n    load_contacts(file_name)\nexcept:  # noqa: E722\n    print(\"Contacts file not found\")\n    contacts = []\n\nwhile True:\n    command = BTCInput.read_int_ranged(prompt=menu, min_value=1, max_value=5)\n    if command == 1:\n        new_contact()\n    elif command == 2:\n        display_contacts()\n    elif command == 3:\n        edit_contacts()\n    elif command == 4:\n        sort_contacts()\n    elif command == 5:\n        try:\n            save_contacts(file_name)\n        except:  # noqa: E722\n            print(\"Contacts failed to save\")\n        break\n    else:\n        raise ValueError(\"Unexpected command id found: \" + str(command))\nTo answer the final question of what functionality we can pull out we can see that both display_contacts and edit_contacts contain code for displaying an individual Contact. We can pull this code out into a distinct display_contact function responsible for displaying a single Contact. We can then update display_contacts and edit_contacts to defer the display functionality to display_contact\ndef display_contact(contact):\n    \"\"\"\n    Displays the Contact details for the supplied contact\n\n    Parameters\n    ----------\n    contact : Contact\n        contact to display\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_contacts : Displays all contacts matching a search name\n    \"\"\"\n    print(\"Name:\", contact.name)\n    print(\"Address:\", contact.address)\n    print(\"Telephone:\", contact.telephone, \"\\n\")\nThe new display_contacts now looks like,\ndef display_contacts():\n    \"\"\"\n    Prompts the user for a contact name and\n    displays all matching contacts\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_contact : displays a single contact\n    \"\"\"\n    print(\"Find contact\")\n    contacts = find_contacts(\n        BTCInput.read_text(\"Enter the contact name (Press enter to display all): \")\n    )\n    if len(contacts) &gt; 0:\n        for contact in contacts:\n            display_contact(contact)\n    else:\n        print(\"This name was not found\")\nand edit_contacts looks similar\n\n\n\nThis Chapter also contains two further examples which demonstrate building data storage applications that handle more functionality than tiny contacts.\nDue to the size of the discussion required for each exercise they are linked on a seperate page\n\n\nFocuses on demonstrating adding additional functionality to a basic storage application for data interrogation\n\nDevelops an application that can store music tracks\nImplements searching and sorting based on length of the track\nSupports the ability to create and save playlists\nPlaylists can be interrogated for their total length\nThe program can suggest playlists that match the user’s target runtime\n\n\n\n\nDemonstrates working with larger more complicated objects in data storage\n\nDevelops and application for storing recipes\nUsers can search for recipes by their name or their ingredients\nSupports different mechanisms for viewing details about a recipe\n\nViewing the ingredients\nViewing the steps\nSteping through the recipe, step by step\n\n\nYou are encouraged to work through or examine these exercises",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 9: Use Classes to Store Data"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/09_UsingClasses/Chapter_09.html#summary",
    "href": "02_AdvancedProgramming/09_UsingClasses/Chapter_09.html#summary",
    "title": "Chapter 9: Use Classes to Store Data",
    "section": "Summary",
    "text": "Summary\n\nPython lets you define Classes\n\nClasses can have data attributes\ndata attributes can be defined at construction via a constructor\ndata attributes can be added dynamically at runtime\nclasses may define a constructor via __init__ to control how they are created\n\nPython variables are references to memory objects\n\nIf there are multiple references to one object then changing the object via one reference will be propagated to the other references\n\nSome fundamental python types int, str, float, are immutable\n\nAssigning a value to a variable holding an immutable type creates a new memory object with that value\n\nOther references to the original object are untouched\n\nThis allows them to be manipulated as simple values\n\npickle is a library for serialising python objects as binary data\nPython provides a dictionary data object that can be used to store a collection of key-value pairs",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 9: Use Classes to Store Data"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/09_UsingClasses/Chapter_09.html#questions-and-answers",
    "href": "02_AdvancedProgramming/09_UsingClasses/Chapter_09.html#questions-and-answers",
    "title": "Chapter 9: Use Classes to Store Data",
    "section": "Questions and Answers",
    "text": "Questions and Answers\n\nIf an object has name, address and telephone attributes can a program treat it as a Contact instance?\n\nYes, Python uses what is called duck-typing\n\n“If it walks like a duck, quacks like a duck, it is a duck”\nMeans that if it behaves like a Contact it can be used as a Contact\nIf the programmer makes a mistake however, a runtime exception is created\n\nThis means we could define a Customer with the same fields and treat it as a Contact\nPython does provide mechanisms for explicit type checking\n\nWe’ve seen one for example (type)\n\nOther languages have different rules\nJava, C# and C++ are “Strongly Typed”\n\nThe type of the variable is fixed and we can only work with objects, functions and operators that support that type\n\n“Strongly Typed” languages typically allow you catch mismatched type errors at compile-time before a program is run\n\nCan an object contain a reference to itself?\n\nYes, though this is usually not a good idea\nTypically objects are daisy-chained together\n\nObject A references Object B references Object C etc.\nThe most basic structure is called a linked list\nMore complex structures like trees have more complicated referential structures\n\n\nIs an object forced to have a constructor / initialiser?\n\nNo, we saw this with the first Contact which was a simple blank class\n__init__ provides greater ability to ensure that objects are created properly though\n\nCan you stop a program from adding new attributes to an object?\n\nNo\nThis has the impact of allowing us to create incompatible and distinct instances of the same class where for some reason one has been argumented with an additional attribute\n\nCan you remove attributes from an object?\n\nYes, you can use the del operator to delete an attribute\n\n  del(rob.name)\n  print(rob.address)\n  rob.name\n\n18 Pussycat Mews\n\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[34], line 3\n      1 del(rob.name)\n      2 print(rob.address)\n----&gt; 3 rob.name\n\nAttributeError: 'Contact' object has no attribute 'name'\n\n\n\n\nWhat is immutable again?\n\nimmutable means an unchangeable object\nWhen we try to change an immutable object python instead creates a copy with the new values\nimmutability improves data storage especially for primitive types\ne.g. We might have a story of one million words\n\nThe story string itself consists of words stored as strings which are immutable\nA list of words uses references to refer to each word\nCertain words are probably referred to multiple times (e.g. the)\nSince the words are immutable we can reference one instance of the string \"the\" rather than having a distinct memory object for each instance (which we would need if they were mutable)\n\n\nHow does the operating system know its storing a binary file?\n\nIt doesn’t\nReally all files are binary\nFile system simply responsible for locating and retrieving files\nPrograms are the ones that impose meaning on a file\n\nfile extensions are there to help an operating system or user associate different file formats with their respective programs\n\n\nCan two items in a dictionary have the same key?\n\nStrictly no, if you wish to store multiple objects with the same key you would have to use a dictionary where the value was some form of collection e.g. a list or tuple.\nYou would then access the list via the dictionary key\n\nThen have to search through the list to get the specific value you were interested in",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 9: Use Classes to Store Data"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/10_UseClassesToCreateActiveObjects/Chapter_10.html",
    "href": "02_AdvancedProgramming/10_UseClassesToCreateActiveObjects/Chapter_10.html",
    "title": "Chapter 10: Using Classes to Create Active Objects",
    "section": "",
    "text": "Program’s tend to evolve in scope over time\n\nSometimes due to scope underestimation\nAlso because customers tend to request new features\n\nConsider the Tiny Contacts\n\nClient now wants to functionality to track the time spent with a client\n\nAs usual start with the interface,\n\nTime Tracker\n\n1. New Contact\n2. Find Contact\n3. Edit Contact\n4. Add Session\n5. Exit Program\n\nEnter your command:\nWe want to now storyboard out the new Add Session option\nEnter your command: 4\nAdd Hours\nEnter the Contact Name: Rob\nName: Rob Miles\nPrevious Hours worked: 0\nSession Length: 3\nUpdated hours worked: 3.0\nWe also want to update the Find Contact option to include the hours,\nFind Contact\nEnter the Contact Name: Rob\nName: Rob Miles\nAddress: 18 Pussycat Mews, London, NE1 410S\nTelephone: 1234 56789\nHours worked: 3.0\n\n\n\nWe need to store the hours worked\nSimplest approach is to redefine the Contact class\n\nAdd an hours_worked field\n\n\n\nclass Contact:\n    \"\"\"\n    Contact with a name, address and telephone number.\n    Tracks the hours worked with a client\n\n    Attributes\n    ----------\n    name : str\n        Contact Name\n    address : str\n        Contact's postal or street address.\n    telephone : str\n        Contact phone number (stored as a string).\n    hours_worked : int | float\n        Hours worked with a Contact, initialised to 0\n\n    Examples\n    --------\n    &gt;&gt;&gt; Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"+44(1234) 56789\")\n    &lt;Contact ...&gt;\n    \"\"\"\n\n    def __init__(self, name, address, telephone):\n        \"\"\"\n        Create a new Contact instance\n\n        Parameters\n        ----------\n        name : str\n            Contact Name\n        address : str\n            Contact's postal or street address.\n        telephone : str\n            Contact phone number (stored as a string).\n        \"\"\"\n        self.name = name\n        self.address = address\n        self.telephone = telephone\n        self.hours_worked = 0\n\n\nDefaulted to 0 as part of the constructor\n\nWe might discuss this with the client, it’s possible a contact might have some initial consult hours\n\nFrom here we can add a new add_session function (see the complete updated code, in our version which supports duplicate names in the search)\n  def add_session():\n      \"\"\"\n      Prompts the user to add hours worked to contacts matching a search\n\n      Returns\n      -------\n      None\n\n      See Also\n      --------\n      find_contacts : returns contacts matching a search name\n      \"\"\"\n      print(\"add session\")\n      search_name = read_text(\"Enter the contact name: \")\n      contact = find_contact(search_name)\n      if contact != None:\n          #found a contact\n          print(\"Name: \", contact.name)\n          print(\"Previous hours worked:\", contact.hours_worked)\n          session_length = BTCInput.read_float_ranged(prompt=\"Session length: \", min_value=0.5, max_value=3.5)\n          contact.hours_worked = contact.hours_worked + session_length\n          print(\"Updated hours worked:\", contact.hours_worked)\n      else:\n          print(\"This name was not found\")\nDon’t forget we also have to update how we display contacts for the Find Contact functionality (or in our case the display_contact) function.\n\n  def display_contact(contact):\n      \"\"\"\n      Displays the Contact details for the supplied contact\n\n      Parameters\n      ----------\n      contact : Contact\n          contact to display\n\n      Returns\n      -------\n      None\n\n      See Also\n      --------\n      display_contacts : Displays all contacts matching a search name\n      \"\"\"\n      print(\"Name:\", contact.name)\n      print(\"Address:\", contact.address)\n      print(\"Telephone:\", contact.telephone)\n      print(\"Hours worked for this Contact:\", contact.hours_worked, \"\\n\")\n\nIf we create a new Contact object then we can see how this looks,\n\n  contact = Contact(name=\"Alice\", address=\"Bob St\", telephone=\"555\")\n  display_contact(contact)\n  contact.hours_worked = 5.0\n  display_contact(contact)\n\nName: Alice\nAddress: Bob St\nTelephone: 555\nHours worked for this Contact: 0 \n\nName: Alice\nAddress: Bob St\nTelephone: 555\nHours worked for this Contact: 5.0 \n\n\n\n\n\n\n\nWhen extending a program you should always look at its design\nCode rots as it gets older\n\nGets harder to maintain and understand\n\nWant to make the design as clear and simple as possible\nLike a builder we want to make houses out of walls, walls out of bricks and bricks out of clay\n\ni.e. clear progression in scale and responsibility\n\nA technique for this is called object-oriented design\n\nObjects are designed to be cohesive\nA cohesive object should contain all the attributes and methods to work with its domain\n\nFor the Contact object we want it to be responsible for all contact information\n\nCurrently not very cohesive\nTime Tracker works directly on Contact object attributes\n\nBusiness logic that applies to a Contact is outside the function\n\ne.g. in the add_session function, we have hardcoded a minimum session time of half an hour and a maximum session time of three and half hours\nThis is problematic\n\nBecause the numbers are just written there as opposed to being defined as constants with meaning (they are magic constants)\nThis data validation is external to the data storage object itself, the Contact\n\nWe also perform the act of updating the Contact’s hours worked, outside the Contact object\n\n  session_length = BTCInput.read_float_ranged(prompt=\"Session length: \", min_value=0.5, max_value=3.5)\n  contact.hours_worked = contact.hours_worked + session_length\nThe magic constant problem is one issue,\n\nIf we were to use the Contact as a libary object in another application, (like a graphical version) then we would have to maintain the validation code in two seperate places\n\n\n\n\n\n\n\n\nTip\n\n\n\nKeep Business Rules in Business Objects\nThe issue here is we have defined business rules (things our customer asks the system to do) outside of the business objects (things created to implement the customer’s system).\n\n\n\nA solution is to make the Contact object responsible for validating the session length\n\nAny application that uses the Contact object will naturally use its internal validation\nOnly one location to change now\n\n\n\n\n\n\n\nAny python code can access hours_worked in a Contact\n\nReally only need hours_worked to be accessed to,\n\nDisplay time spent with a contact\nAdd the length of a session to hours_worked\n\n\nPython objects can hold method attributes\n\nFunctions bound to the object\n\nLet us ask an object to do something\nE.g. the string object has the method upper (seen in Chapter 5)\nLet us define two method attributes for Contact\n\nRemoves the need to directly access the attribute\n\nStart by defining a method to access the hours worked\n\n\nclass Contact:\n    \"\"\"\n    Contact with a name, address and telephone number.\n    Tracks the hours worked with a client\n\n    Attributes\n    ----------\n    name : str\n        Contact Name\n    address : str\n        Contact's postal or street address.\n    telephone : str\n        Contact phone number (stored as a string).\n    hours_worked : int | float\n        Hours worked with a Contact, initialised to 0\n\n    Examples\n    --------\n    &gt;&gt;&gt; Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"+44(1234) 56789\")\n    &lt;Contact ...&gt;\n    \"\"\"\n\n    def __init__(self, name, address, telephone):\n        \"\"\"\n        Create a new Contact instance\n\n        Parameters\n        ----------\n        name : str\n            Contact Name\n        address : str\n            Contact's postal or street address.\n        telephone : str\n            Contact phone number (stored as a string).\n        \"\"\"\n        self.name = name\n        self.address = address\n        self.telephone = telephone\n        self.hours_worked = 0\n\n    def get_hours_worked(self):\n        \"\"\"\n        Get the hours worked for this contact\n        \"\"\"\n        return self.hours_worked\n\n\n\nConsider the following questions regarding the get_hours_worked function\n\nWhat is the parameter self used to accomplish?\n\nA method is part of an object\nself tells the method which object it is a part of\nThe code sample below shows how the method doesn’t need an additional reference to the Contact it refers to\n\n  # set up\n  rob = Contact(\"Rob\", \"A St\", \"1\")\n  rob.hours_worked = 1\n  jim = Contact(\"Jim\", \"B St\", \"555\")\n  jim.hours_worked = 2\n\n  # demonstration\n  rob_work = rob.get_hours_worked()\n  jim_work = jim.get_hours_worked()\n  if rob_work &gt; jim_work:\n      print(\"More work for rob\")\n  else:\n      print(\"More work for jim\")\n\nMore work for jim\n\n\n\nIs the get_hours_worked method stored when we save contact information in a file\n\nNo, if we use pickle to store a contact list, the method attributes are not stored. Pickle only stores the data attributes\n\nCan a program still access the hours_worked attribute of a Contact class\n\nYes, it can. Using method attributes to get data doesn’t stop a program accessing the data directly\nWe simply remove the desire to\nLater chapters look at techniques for enforcing this more robustly\n\n\n\nWe can create a second method to handle adding a session to a Contact\n\n  # existing class definition\n  class Contact:\n      def __init__(self, name, address, telephone):\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n          self.hours_worked = 0\n\n      def get_hours_worked(self):\n          \"\"\"\n          Gets the hours worked for this contact\n\n          Returns\n          -------\n          int | float\n              hours worked for this contact\n          \"\"\"\n          return self.hours_worked\n\n      # new method\n      def add_session(self, session_length):\n          \"\"\"\n          Adds a session (in hours) to the Contacts hours\n\n          Parameters\n          ----------\n          session_length : int | float\n              time spent on session in hours\n\n          Returns\n          -------\n          None\n          \"\"\"\n          self.hours_worked = self.hours_worked + session_length\n\nTakes two parameters\n\nself - the object the method is attached to\n\nHere the Contact being updated\n\nsession_length\n\nThe length of the session to be added\n\n\n\nYou can see the above implementation integrated into our TimeTracker implementation. Aside from defining these new functions we have to update the file scope add_session function (distinct from the class scope add_session method) and the display_contact functions to use the new methods\n\n\n\n\n\nCurrently add_session would allow function calls like,\n\n  rob = Contact(\"Rob\", \"A St\", \"555\")\n  rob.add_session(-10)\n  print(rob.get_hours_worked())\n\n-10\n\n\nLegal call\n\nMakes no logical sense\nCan’t work negative hours\n\nAt the moment the validation is performed in the global add_session function\n\nSuppose this was maintained by another team\nThey could change it, and break your code\n\n\n\n\n\n\n\n\nNote\n\n\n\nThink Carefully about Valid Input\nYou should think carefully about what is valid input for any function, especially when you restrict it. As observed here, a negative number of hours doesn’t make sense on the surface. However, it might make sense in the case of,\n\nCorrecting an overestimated number of hours\nThe Client wants to give a client a discounted number of hours\n\n\n\n\nWe want to move the validation inside the Contact object\n\nWant add_session to reject hours that are less than half-an-hour or greater than three and a half\n\nWe could add these as variables for each instance of a Contact\n\nBut they’re the same for every instance\nWould be nice to have a way to define it once for the class\n\n\n\n\n\nA class variable is data not attached to a specific object instance\nCan define the min and max hours as a class variable\n\nNo longer magic constants\nAccessible by all Contact instances\n\n\n  class Contact:\n      \"\"\"\n      Contact with a name, address and telephone number.\n      Tracks the hours worked with a client\n\n      Attributes\n      ----------\n      name : str\n          Contact Name\n      address : str\n          Contact's postal or street address.\n      telephone : str\n          Contact phone number (stored as a string).\n      hours_worked : int | float\n          Hours worked with a Contact, initialised to 0\n\n      Class Attributes\n      ----------------\n      min_session_length : Final[int | float]\n          minimum length of a billable session\n\n      max_session_length : Final[int | float]\n          maximum length of a billable session\n\n\n      Examples\n      --------\n      &gt;&gt;&gt; Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"+44(1234) 56789\")\n      &lt;Contact ...&gt;\n      \"\"\"\n\n      min_session_length = 0.5\n      max_session_length = 3.5\n\n      def __init__(self, name, address, telephone):\n          \"\"\"\n          Create a new Contact instance\n\n          Parameters\n          ----------\n          name : str\n              Contact Name\n          address : str\n              Contact's postal or street address.\n          telephone : str\n              Contact phone number (stored as a string).\n          \"\"\"\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n          self.hours_worked = 0\n\n          def get_hours_worked(self):\n              \"\"\"\n              Gets the hours worked for this contact\n\n              Returns\n              -------\n              int | float\n                  hours worked for this contact\n              \"\"\"\n              return self.hours_worked\n\n          # new method\n          def add_session(self, session_length):\n              \"\"\"\n              Adds a session (in hours) to the Contacts hours\n\n              Parameters\n              ----------\n              session_length : int | float\n                  time spent on session in hours\n\n              Returns\n              -------\n              None\n              \"\"\"\n              if session_length &lt; Contact.min_session_length or session_length &gt; Contact.max_session_length:\n                  return\n              self.hours_worked = self.hours_worked + session_length\n\nadd_session now silently rejects invalid session_length values\nThe idiom of first checking for invalid input and performing a return if encountered is called an early return and is a common technique\n\nReduces the need for indentation on the happy path - the error free path\n\nObserve we have to prefix the class variables with the class name as a namespace\nThe Final label in the docstring indicates that the session length variables are expected to be constant and should not be modified by a consuming program\n\n\n\nBuild your understanding of class variables by answering the following questions about their use-cases\n\nShould I use a class variable to hold the age of a contact?\n\nNo. Each contact will have an age, so the age must be a data attribute unique to each object instance\n\nShould I use a class variable to hold the maximum age of a contact?\n\nYes, we don’t need to store a copy of this value for every Contact instance, so it can be a class variable\n\nShould I use a class variable to hold the price per hour that the lawyer will charge?\n\nIt depends, if the lawyer charges the same for every client then it may be reasonable\nIf the lawyer wishes to charge different contacts different rates, then we would have to store it as a data attribute\n\nIn that case we might store the minimum and maximum hourly rate as class variables\n\n\n\n\n\n\n\n\nCohesion generally means objects shouldn’t expose attributes for external clients\nIdeally clients interact with a Contact via method calls\n\ne.g. get_hours_worked and add_session\nEliminates direct dependency on hours_worked data attribute\n\nIn the same vein, we don’t want users to directly interact with class variables\n\ne.g. max_session_length and min_session_length are used for internal validation\nExternal client should have no reason to directly modify them\n\nCould create a method, validate_session_length\n\nReceive a session_length argument\nReturn True if valid, else False\n\nValidation information (max_session_length and min_session_length) is held at the class level\n\nWould be nice to also have this validation method at the class level too\n\nWe can create class level methods through a Static Method\n\nStatic methods can be considered as methods defined on a class rather than an object instance\n\nWe can define one as below,\n\n  class Contact:\n      \"\"\"\n      Contact with a name, address and telephone number.\n      Tracks the hours worked with a client\n\n      Attributes\n      ----------\n      name : str\n          Contact Name\n      address : str\n          Contact's postal or street address.\n      telephone : str\n          Contact phone number (stored as a string).\n      hours_worked : int | float\n          Hours worked with a Contact, initialised to 0\n\n      Class Attributes\n      ----------------\n      min_session_length : Final[int | float]\n          minimum length of a billable session\n\n      max_session_length : Final[int | float]\n          maximum length of a billable session\n\n      Examples\n      --------\n      &gt;&gt;&gt; Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"+44(1234) 56789\")\n      &lt;Contact ...&gt;\n      \"\"\"\n\n      min_session_length = 0.5\n      max_session_length = 3.5\n\n      @staticmethod\n      def valid_session_length(session_length):\n          \"\"\"\n          Check a session length is valid\n\n          Parameters\n          ----------\n          session_length : int | float\n              length of a consult session in hours\n\n          Returns\n          -------\n          bool\n              `True` if the session length is valid else `False`\n          \"\"\"\n          if (\n              session_length &lt; Contact.min_session_length\n              or session_length &gt; Contact.max_session_length\n          ):\n              return False\n          return True\n\n      def __init__(self, name, address, telephone):\n          \"\"\"\n          Create a new Contact instance\n\n          Parameters\n          ----------\n          name : str\n              Contact Name\n          address : str\n              Contact's postal or street address.\n          telephone : str\n              Contact phone number (stored as a string).\n          \"\"\"\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n          self.hours_worked = 0\n\n      def get_hours_worked(self):\n          \"\"\"\n          Gets the hours worked for this contact\n\n          Returns\n          -------\n          int | float\n              hours worked for this contact\n          \"\"\"\n          return self.hours_worked\n\n      # new method\n      def add_session(self, session_length):\n          \"\"\"\n          Adds a session (in hours) to the Contacts hours\n\n          Parameters\n          ----------\n          session_length : int | float\n              time spent on session in hours\n\n          Returns\n          -------\n          None\n\n          See Also\n          --------\n          Contact.valid_session_length : checks a session length is valid\n          \"\"\"\n          if not Contact.valid_session_length(session_length):\n              return\n          self.hours_worked = self.hours_worked + session_length\n\nThe @staticmethod tag above the definition of valid_session_length is called a decorator\nA decorator wraps a function to modify how it works\nDecorators are added by writing @ followed by the decorator name above the function to be wrapped\n\nYou can wrap a function with multiple decorators\n\nThe @staticmethod decorator is a python language built-in\n\nConverts a method into a static method\nStatic methods can exist even without an instance of the given class\n\nStatic methods can be called directly from the class e.g.\n\n  print(Contact.valid_session_length(5))\n\nFalse\n\n\n\n\n\nInput validation is a very common use-case for static methods. Consider the following questions to understand static validation methods\n\nWhy does the valid_session_length method not have a self parameter?\n\nself refers to a particular object instance\nstatic methods are not associated with an instance\n\nAssociated with the class\nThus no self to refer to\n\n\nWhy does the valid_session_length method not print a message to the user communicating that the session length is invalid?\n\nvalid_session_length only has responsibility for checking if a session length is valid\nHow to handle an invalid session length is the responsibility of the caller\n\ne.g. a text-based vs graphical interface may want to handle this differently\n\ne.g. display text vs a window\n\n\nThis concept of making a function responsible for one thing is called either\n\nThe single responsibility principle,\nor more generally seperation of concerns\n\nHere a Contact object performs behaviours that modify or capture a the state of a clients interactions with a client\n\nHow the user responds to those states is not its responsibility\n\n\nWhat does a decorator do?\n\nA decorator is a function that wraps another function\nThey can do some work, call a function then do some clean-up\n\nCan I create my own decorators?\n\nYes\nThey are beyond the scope of this book though\n\nHow do I know when to create a static method in a class?\n\nYou want to create behaviour associated with a class, but\n\nIndependent of specific instance of a class\n\n\n\n\n\n\n\n\nadd_session prevents invalid session lengths being added to a Contact\nCurrently user has no way of knowing if a session was added\n\nMistakes might be missed\nRecords then lost\n\nNeed to indicate if add_session succeeded\nCan do so by returning a status flag from add_session rather than None\n\nTrue indicates session added\nFalse indicates session failed\n\n  def add_session(self, session_length):\n  \"\"\"\n  Adds a session (in hours) to the Contacts hours\n\n  Parameters\n  ----------\n  session_length : int | float\n      time spent on session in hours\n\n  Returns\n  -------\n  bool\n      `True` if session successfully added, else `False`\n\n  See Also\n  --------\n  Contact.valid_session_length : checks a session length is valid\n  \"\"\"\n  if not Contact.valid_session_length(session_length):\n      return False\n  self.hours_worked = self.hours_worked + session_length\n  return True\nThe calling program can then check the status\n\nBehave as appropriate on error\n\n  session_length = BTCInput.read_float(prompt=\"Session Length: \")\n  if contact.add_session(session_length):\n      print(\"Updated hours succeeded\", contact.get_hours_worked())\n  else:\n      print(\"Add hours failed\")\nThe above uses the status\n\nOn success the new hours are reported\nOn failure, the user is notified of the error\n\nThe full implementation is given in TimeTrackerWithStatusReporting.py\nThe problem with status messages is that the user can ignore them, e.g. the below variation of the previous example, ignores the return value\n\n   contact.add_session(BTCInput.read_float(prompt=\"Session Length: \"))\n   print(\"Updated hours:\", contact.get_hours_worked())\n\nThus no guarantee that failure will be handled\n\n\n\n\n\nExceptions force the caller to deal with them\n\nUnhandled exceptions crash the program\n\nExceptions are designed for when an error occurs where continuing makes no sense\n\ne.g. converting strings to numbers\nmeaningless to continue with an unconverted number\nUnless the caller specifies what to do in that case\nSo this causes an exception\n\n  x = int(\"Rob\")\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[11], line 1\n----&gt; 1 x = int(\"Rob\")\n\nValueError: invalid literal for int() with base 10: 'Rob'\n\n\n\n\nWe can make our on code throw exceptions\n\nWe use the raise keyword\n\n\n  def add_session(self, session_length):\n      \"\"\"\n      Adds a session (in hours) to the Contacts hours\n\n      Parameters\n      ----------\n      session_length : int | float\n          time spent on session in hours\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      Exception\n          Raised if invalid session length passed\n\n      See Also\n      --------\n      Contact.valid_session_length : checks a session length is valid\n      \"\"\"\n      if not Contact.valid_session_length(session_length):\n          raise Exception(\"Invalid Session Length\")\n      self.hours_worked = self.hours_worked + session_length\n\nContact’s add_session now raises an Exception if the session length is invalid\nException somewhat like a message\n\nTells the program what went wrong\n\nException class provides behaviours for exceptions\n\nTakes a string as an initialiser argument\nstring should describe the error\n\nOnce raised, the exception is either,\n\nhandled by an Except handler inside a try block\nStops the program with an error\n\nThe complete integration of the above is given byy TimeTrackerWithException.py\n\n\n\n\nInvestigate how exceptions are raised using the sample program Time Tracker with Exception\nStart a python interpreter and run the example program above, select option \\(1\\) on the menu, and enter the following,\n\n\n\nTime Tracker\n\n\n\n1. New Contact\n\n2. Find Contact\n\n3. Edit Contact\n\n4. Add Session\n\n5. Exit Program\n\n\n\nEnter your command: 1\n\nCreate new contact\n\nEnter the contact name:  Rob Miles\n\nEnter the contact address:  18 Pussycat Mews, London, NE1 410S\n\nEnter the contact phone:  1234 56789 \n\n\n\n\nNow add a session lasting 2 hours to the contact using option 4:\n\n\n\nEnter your command:  4\n\nadd session\n\nEnter the contact name:  Rob Miles\n\nName: Rob Miles\n\nPrevious hours worked: 0\n\nSession Length:  2\n\nUpdated hours worked: 2.0\n\n\n\n\nThis should work because \\(2\\) is a valid session length, now repeat but attempt to add a session length of \\(4\\), which should be invalid,\n\n\n\nEnter your command:  4\n\nadd session\n\nEnter the contact name:  Rob Miles\n\nName: Rob Miles\n\nPrevious hours worked: 2.0\n\nSession Length:  4\n\n\n\n\n\n\n\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\nCell In[16], line 3\n      1 rob = Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"1234 56789\")\n      2 add_session(rob, 2)\n----&gt; 3 add_session(rob, 4)\n\nCell In[12], line 24, in add_session(self, session_length)\n      2 \"\"\"\n      3 Adds a session (in hours) to the Contacts hours\n      4 \n   (...)     21 Contact.valid_session_length : checks a session length is valid\n     22 \"\"\"\n     23 if not Contact.valid_session_length(session_length):\n---&gt; 24     raise Exception(\"Invalid Session Length\")\n     25 self.hours_worked = self.hours_worked + session_length\n\nException: Invalid Session Length\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nOur implementation will look slightly different to the above (which is the book code) because it has additional logic for handling duplicates. But follow the steps and the prompts and you should get roughly the same process\n\n\n\n\n\n\nNow that we can raise exceptions, how do we handle them?\nWe’ve seen that we control jumps to an appropriate except but what if we want to access the message in the exception?\n\nWe can use the as keyword to assign the exception a variable label\nWe modify the user call to the Contact object, add_session as, (see the full implementation as TimeTrackerWithExceptionHandler.py)\n\n  hours_worked = BTCInput.read_float(prompt=\"Enter hours spent: \")\n  try:\n      contact.add_session(hours_worked)\n      print(\"Updated hours succeeded:\", contact.get_hours_worked())\n  except Exception as e:\n      print(\"Add failed:\", e)\nThe main change is rather than just going except Exception: we add a as e\n\nDefines a variable e that stores the exception\ne exists for the scope of the except block\n\nPassing an exception to print prints our the message associated with the exception\nA representative use might look like,\n\n\n\n\nEnter your command:  4\n\nadd session\n\nEnter the contact name:  Rob Miles\n\nName: Rob Miles\n\nPrevious hours worked: 2.0\n\nSession Length:  -1\n\nAdd failed: Invalid Session Length\n\n\n\n\n\n\n\nRepeat the steps in the previous example but this time use the new code in Time Tracker with Exceptionn Handler. You should find the program runs and the errors are captured without causing a crash\n\n\n\nConsider the following questions about dealing with exceptions\n\nWhy does this version of the program not check the result returned by add_session?\n\nThis implementation of add_session returns None\nInstead an exception is raised to indicate a failure state\nThere is therefore nothing to check\n\nIsn’t raising an exception and stopping the program when something goes wrong a bit harsh?\n\nDepends on your philosophy\nGenerally you want to avoid silent errors\ni.e. errors that are undetected by the user\nExceptions force the user to handle the error rather than silently ignore it\nIf the user wants to avoid exception handling, they can explicitly use validate_session_length\n\nCan a method be resumed once it has raised an exception?\n\nNo\nExceptions immediately terminate the normal control flow\nThe user can always call the function again\n\nWhy would you want to create your own types of exceptions?\n\nAllows any errors returned to be descriptive to your specific code\ne.g. if your program relies on a specific file being loaded you might want a more descriptive error message than the standard FileException provides\nError management and reporting should be decided early in a program\n\nShould I always use exceptions to indicate something has gone wrong?\n\nDepends\n\nYou may not care about handling all types of errors\n\nExceptions ensure errors are dealt with\n\nUser can customise the error handling in response to exception\ne.g. for a text-based vs GUI interface\n\n\nWhy have we made add_session work like this? The program worked before we made this change\n\nTechnically correct\n\nOld code used the error status to validate code\n\nArguably cleaner with the new error handling\n\nKnowledge about the Contact class has been centralised in the Contact class itself\nNo need to have external variables storing information about valid session length or doing the validation\n\nTypically a good idea to put all knowledge about a classes behaviour in the class itself\n\n\n\n\n\n\n\nClient no longer needs to directly interact with hours_worked\nHowever, client can still modify hours_worked\n\nProgrammer could accidently change the value\nCould also intentionally change it to break the code\n\nIdeally we want to prevent it being directly modified\n\n\n\n\n\n\n\nWarning\n\n\n\nPython protects against mistakes, not attacks\nPython provides features to help protect data attributes against accidental modifications. However, they don’t stop a programmer who intentionally (and perhaps maliciously) decides they want to modify the data attributes.\nThere is no mechanism in the python language to prevent another progrmmer adding code that changes hours_worked in the Contact object\n\n\n\nBy convention, python dictates that an attribute name starting with _ should not be used outside the class\n\nAlso referred to as being internal to the class\ne.g. _hours_worked means that the variable should not be touched\n  def get_hours_worked(self):\n      \"\"\"\n      Gets the hours worked for this contact\n\n      Returns\n      -------\n      int | float\n          hours worked for this contact\n      \"\"\"\n      return self._hours_worked\n\nAbove we provide a get_hours_worked method to get the value of _hours_worked\n\n_ indicates not to modify hours_worked itself\n\nNo actual protection for _hours_worked\n\nCould still be ignored by a programmer\n\nCan get greater security through, name-mangling\n\nstarting a varible name with double underscores __\n\nname-mangling makes it harder to access and modify the variable\n\n\n\nFollow the following steps to examine how to make a python class secure. Open a python interpreter and enter the statements below\n\n    class Secret:\n        def __init__(self):\n            self._secret = 99\n            self.__top_secret = 100\n\nThe above creates a class Secret which has two attributes, _secret and __top_secret\nCreate an instance of the Secret class\n\n    x = Secret()\n\nThe above creates a new instance of a Secret class and stores it with the variable x.\nTry to access the _secret attribute on x\n\n    x._secret\n\n99\n\n\nEven though we said that _ indicates we should not access the data attribute, we can see that nothing stops us from doing so\nNow try to access the __top_secret attribute\n\n    x.__top_secret\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[21], line 1\n----&gt; 1 x.__top_secret\n\nAttributeError: 'Secret' object has no attribute '__top_secret'\n\n\n\nThis time we get an AttributeError which suggests that there is no __top_secret attribute associated with the Secret class\nHowever, Python has performed some “name-mangling” to the name __top_secret. Inside the Secret class we can refer to __top_secret. Outside the class, the variable name is prepended with the class name (and an underscore). So we can still access it, as the below proves\n\n    x._Secret__top_secret\n\n100\n\n\nName-mangling thus secures us against accidental attribute use, however any one who knows the name mangling scheme and our attributes can still modify the data attribute if they want to\nThere are programs that check against this kind of bad code behaviour. One example is pylint\n\n\n\n\n\nOur current methods for the Contact class are all intended to be used by clients\n\nReferred to as public methods\n\nWe might also want to protect methods in a class\nCan use _ prefix to indicate that it should not be used\nOr __ prefix to name mangle\n\n\n\n\n\n\n\nTip\n\n\n\nWriting secure code is all about workflow\nMaking a secure program is all about establishing a workflow to generate quality code. For example, using prototypes to make sure that a customer agrees with the direction of a program early in the development\nThe next step is to sensible design and tools like pylint to make sure we’re writing good quality code.\n\n\n\n\n\n\n\nWe’ve talked about protecting hours_spent for our Contact\nWe should add more business logic to ensure that name, address and telephone items are sensible\n\nAs a purely toy example, lets say they must each be \\(4\\) characters long\n\nRealistically they would be discussed and confirmed with the customer\n\n\nclass Contact:\n\n    __min_text_length = 4\n\n    @staticmethod\n    def valid_text(text):\n        \"\"\"\n        Validates text to be stored in the contact storage\n\n        Parameters\n        ----------\n        text : str\n            text string to store\n\n        Returns\n        -------\n        bool\n            `True` if the text is valid, else `False`\n        \"\"\"\n\n        if len(text) &lt; Contact.__min_text_length:\n            return False\n        else:\n            return True\n\n\nAbove mirrors valid_session_length\nCalled to validate text to be stored in a Contact\nWe could then name mangle name, address, telephone\nSupply methods to get and set these attributes\n\ne.g. set_name and get_name for example\n\nPython has a built-in way for providing read and write access to protected data\nThis is called a Property\n\nProperties preserve simple access, while allowing us to implement validation\n\n\n\n\n\nclass Contact:\n    __min_text_length = 4\n\n    @staticmethod\n    def valid_text(text):\n        \"\"\"\n        Validates text to be stored in the contact storage\n\n        Valid input must be have a length greater than or\n        equal to Contact.__min_text_length\n\n        Parameters\n        ----------\n        text : str\n            text string to store\n\n        Returns\n        -------\n        bool\n            `True` if the text is valid, else `False`\n        \"\"\"\n        if len(text) &lt; Contact.__min_text_length:\n            return False\n        else:\n            return True\n\n    @property  # decorator makes name a property\n    def name(self):  # name of property function to get the name\n        \"\"\"\n        name : str\n            Contact Name\n\n        Raises\n        ------\n        Exception\n            raised if new name is invalid\n\n        See Also\n        --------\n        Contact.valid_text : validates text input\n        \"\"\"\n        return self.__name  # return private attribute containing the name\n\n    @name.setter  # decorator to identify the setter for name\n    def name(self, name):\n        if not Contact.validate_text(name):\n            raise Exception(\"Invalid name\")\n        self.__name = name\n\nThe code above shows how to implement a property for name in the Contact class. The property implements validation and rejects invalid names. Work through the following questions to understand properties\n\nHow does the value being set in the property get into the setter?\n\nsetter is called with two parameters\nself refers to the object on which the setter is being called\nThe second is the proposed value to set the property to\n\nHere it is setting the name attribute\n\n\nHow does the program know which setter method to call for a particular property?\n\nThe setter decorator has the format property.setter\n\nAssociates a setter to a property\n\n\nMust the setter method raise an exception if the value is being set is not valid?\n\nNo\nsetter could ignore invalid values, or assign a default\nExceptions allow us to inform the user that the set has failed\n\nAnd also forces the user to deal with the error\n\n\nDo we need to perform the same validation for all properties in a class?\n\nNo\nWe could test that telephone is purely numeric (for example)\n\nThis is not a good idea for real telephone numbers\n\nWe could ensure address matches a certain structure for a valid address\n\nMust a property have a setter?\n\nNo\nProperties without a setter are read-only\nThey cannot be modified\nWe could use this to remove the get_hours_worked method\n\nUse a property instead\n\n\n\n\n\n\nInvestigate how properties work. Open up the python interpreter and enter the statements below\n\nclass Prop:\n    @property\n    def x(self):\n        print(\"got property x\")\n        return self.__x\n    @x.setter\n    def x(self, x):\n        print(\"set property x:\", x)\n        self.__x = x\n\nThis creates a new class Prop with a property x that has a setter\nNow create an instance of this class as below\n\n    test = Prop()\n\nPut a value for x into the test instance\n\n    test.x = 99\n\nset property x: 99\n\n\nWhen python executes the above, it runs the setter method for the property. As we can see from the output above.\nNow try to read the property\n\n    print(test.x)\n\ngot property x\n99\n\n\nWhen reading the property, python runs the property method, as indicated above\nWe can combine getting and setting in complex expressions, execute the following\n\n    test.x = test.x + 1\n\ngot property x\nset property x: 100\n\n\nWe can see that first the getter is called to get the current value of x, then the setter is called to update it to the expression on the right\nTo convert the Contact class to use properties for name, telephone and address we have to add properties and then setters\n\nThe relevant changes to the Contact class are then,\n\n\nclass Contact:\n    \"\"\"\n    Contact with a name, address and telephone number.\n    Tracks the hours worked with a client\n\n    Attributes\n    ----------\n    name : str\n        Contact Name\n    address : str\n        Contact's postal or street address.\n    telephone : str\n        Contact phone number (stored as a string).\n\n\n    Examples\n    --------\n    &gt;&gt;&gt; Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"+44(1234) 56789\")\n    &lt;Contact ...&gt;\n    \"\"\"\n\n    __min_session_length = 0.5\n    __max_session_length = 3.5\n\n    @staticmethod\n    def valid_session_length(session_length):\n        \"\"\"\n        Check a session length is valid\n\n        Parameters\n        ----------\n        session_length : int | float\n            length of a consult session in hours\n\n        Returns\n        -------\n        bool\n            `True` if the session length is valid else `False`\n        \"\"\"\n        if (\n            session_length &lt; Contact.__min_session_length\n            or session_length &gt; Contact.__max_session_length\n        ):\n            return False\n        return True\n\n    __min_text_length = 4\n\n    @staticmethod\n    def valid_text(text):\n        \"\"\"\n        Validates text to be stored in the contact storage\n\n        Valid input must be have a length greater than or\n        equal to Contact.__min_text_length\n\n        Parameters\n        ----------\n        text : str\n            text string to store\n\n        Returns\n        -------\n        bool\n            `True` if the text is valid, else `False`\n        \"\"\"\n        if len(text) &lt; Contact.__min_text_length:\n            return False\n        else:\n            return True\n\n    @property\n    def name(self):\n        \"\"\"\n        name : str\n            Contact Name\n\n        Raises\n        ------\n        Exception\n            raised if new name is invalid\n\n        See Also\n        --------\n        Contact.valid_text : validates text input\n        \"\"\"\n        return self.__name\n\n    @name.setter\n    def name(self, name):\n        if not Contact.valid_text(name):\n            raise Exception(\"Invalid name\")\n        self.__name = name\n\n    @property\n    def address(self):\n        \"\"\"\n        address : str\n            Contact Address\n\n        Raises\n        ------\n        Exception\n            raised if new address is invalid\n\n        See Also\n        --------\n        Contact.valid_text : validates text input\n        \"\"\"\n        return self.__address\n\n    @address.setter\n    def address(self, address):\n        if not Contact.valid_text(address):\n            raise Exception(\"Invalid address\")\n        self.__address = address\n\n    @property\n    def telephone(self):\n        \"\"\"\n        telephone : str\n            Contact Telephone\n\n        Raises\n        ------\n        Exception\n            raised if new telephone is invalid\n\n        See Also\n        --------\n        Contact.valid_text : validates text input\n        \"\"\"\n        return self.__telephone\n\n    @telephone.setter\n    def telephone(self, telephone):\n        if not Contact.valid_text(telephone):\n            raise Exception(\"Invalid telephone\")\n        self.__telephone = telephone\n\n    def __init__(self, name, address, telephone):\n        \"\"\"\n        Create a new Contact instance\n\n        Parameters\n        ----------\n        name : str\n            Contact Name\n        address : str\n            Contact's postal or street address.\n        telephone : str\n            Contact phone number (stored as a string).\n        \"\"\"\n        self.name = name\n        self.address = address\n        self.telephone = telephone\n        self.__hours_worked = 0\n\n\nThe great thing about properties is they can be effectively drop in for traditional attributes\n\nWe make the attributes themselves name mangled\nDefine properties to mask the original names\n\nNo need to update the downstream calling code\n\nproperty syntax matches the traditional access pattern\n\nThe complete integration is seen in TimeTrackerWithPropertie.py\n\n\n\n\n\n\n\nCaution\n\n\n\nFailures in property code can be confusing\nThe example program implements the name, address and telephone number elements of a contact as properties. Setting a property to an invalid value will cause an exception. The initialiser looks like,\n    def __init__(self, name, address, telephone):\n        self.name = name\n        self.address = address\n        self.telephone = telephone\n        self.__hours_worked = 0\nThese statements look like normal variable assignments, nothing here indicates that these steps can fail. However, the following statement fails,\n\n    rob = Contact(name=\"Rob\", address=\"18 Pussycat Mews, London NE1 410S\", telephone=\"1234 56789\")\n\n\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\nCell In[31], line 1\n----&gt; 1 rob = Contact(name=\"Rob\", address=\"18 Pussycat Mews, London NE1 410S\", telephone=\"1234 56789\")\n\nCell In[30], line 154, in Contact.__init__(self, name, address, telephone)\n    141 def __init__(self, name, address, telephone):\n    142     \"\"\"\n    143     Create a new Contact instance\n    144 \n   (...)    152         Contact phone number (stored as a string).\n    153     \"\"\"\n--&gt; 154     self.name = name\n    155     self.address = address\n    156     self.telephone = telephone\n\nCell In[30], line 92, in Contact.name(self, name)\n     89 @name.setter\n     90 def name(self, name):\n     91     if not Contact.valid_text(name):\n---&gt; 92         raise Exception(\"Invalid name\")\n     93     self.__name = name\n\nException: Invalid name\n\n\n\nThe above raises an exception because the value Rob passed for the name property is too short. __init__ attempts to set name which calls the setter, and the property code raises an exception.\nProgrammers may expect methods or functions to cause exceptions but they typically do not expect statements that look like variable assignments. When implementing properties you need to be clear about how they work and how to handle failure.\nWe could extend our previous error handling code to add additional exception handlers to handle invalid assignments\n\n\n\n\n\n\n\nScenario\nThe lawyer likes your program but would now like to use it for billing. The program should track both the hours worked for a client and the the billing amount owed by each contact\nPrices are calculated as follows, for every session worked there is - A $30 flat case fee - A $50 hourly fee\nFor example a one hour session would cost $80\nThe client wants the billing amount to be automatically updated each time they add a session. Displaying a contact should then also display the billing amount\nName: Rob Miles\nAddress: 18 Pussycat Mews, London, NE1 410S\nTelephone: 1234 56789\nHours on the case: 2.0\nBilling amount: 130.0\n\n\n\nWork through the following questions to understand how we design managing the billing amount\n\nHow would we store the billing amount for a contact?\n\nStore as a data attribute on a Contact object\nManage like __hours_worked with validators\nLet’s call it __billing_amount\n\nWhy does __billing_amount have two leading underscores in the name?\n\nIndicates the variable is private to the class\nProvides name-mangling to reduce chance for accidental use\nProvide access via a read-only property\n  @property\n  def billing_amount(self):\n      return self.__billing_amount\nWe omit a setter, the property cannot be directly modified\nCan then access the property as we would expect\n  print(\"Rob owes:\", rob.billing_amount)\nSame output might look like,\n  #| echo: false\n  print(\"Rob owes:\", 130.0)\n\nWhat would the statement calculating the billable amount for a session look like?\n\nAt it’s most basic the statement might look like,\n  amount_to_bill = 30 + (50 * session_length)\nsession_length value is multipled by the hourly rate (\\(50\\))\nflat fee \\(30\\) is added to the total\nCan then add this to the billing amount\n  self.__billing_amount = self.billing_amount + amount_to_bill\nObserve that this approach means that each session incurs the same \\(30\\) case opening fee\nIt’s possible multiple sessions might be spent on the same case\n\nMight not incur the \\(30\\) fee each time\nThis would be something to confirm with the client\n\n\nIs it sensible to just use the values \\(30\\) and \\(50\\) in this code?\n\nNo\nThey are magic constants\nBetter to make them internal class variables of the Contact class\n  class Contact\n      __open_fee = 30\n      __hourly_fee = 50\nObserve that we flag them as private, they are internals for the class\nThe new amount to bill statement is then,\n  amount_to_bill = Contact.__open_fee + (Contact.__hourly_fee * session_length)\n\nWhere should the above statement go?\n\nAdjusting the billing is something that occurs when we add a session\nMakes sense to go in the add_session code of the Contact class\n  def add_session(self, session_length):\n      \"\"\"\n      Adds a session (in hours) to the Contacts hours\n\n      Updates the Contact's session hours and calculates\n      the billable amount owed\n\n      Parameters\n      ----------\n      session_length : int | float\n          time spent on session in hours\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      Exception\n          Raised if invalid session length passed\n\n      See Also\n      --------\n      Contact.valid_session_length : checks a session length is valid\n      \"\"\"\n      if not Contact.validate_session_length(session_length):\n          raise Exception(\"Invalid session length\")\n      self.__hours_worked = self.__hours_worked + session_length\n      amount_to_bill = Contact.__open_fee + (Contact.__hourly_fee * session_length)\n      self.__billing_amount = self.__billing_amount + amount_to_bill\n      return\nBilling amount is updated after we have validated and updated the hours worked\n\n\n\nWe change the display_contact method to add the billing amount\n\ndef display_contact(contact):\n    \"\"\"\n    Displays the Contact details for the supplied contact\n\n    Parameters\n    ----------\n    contact : Contact\n        contact to display\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_contacts : Displays all contacts matching a search name\n    \"\"\"\n    print(\"Name:\", contact.name)\n    print(\"Address:\", contact.address)\n    print(\"Telephone:\", contact.telephone)\n    print(\"Hours worked for this Contact:\", contact.get_hours_worked(), \"\\n\")\n    print(\"Amount to bill:\", contact.billing_amount)\n\nThe complete program can be found in Time Tracker with Billing Amount\n\n\n\n\n\nThe new program works, but it has a problem\nContacts saved under the old system, won’t work\n\nThey will load\nBut whe we try to display or add a session we’ll get an error, like\n\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[32], line 1\n----&gt; 1 raise AttributeError(\"'Contact' object has no attribute '_Contact__billing_amount'\")\n\nAttributeError: 'Contact' object has no attribute '_Contact__billing_amount'\n\n\n\n\nThis occurs because the program attempts to access the __billing_access attribute\nOld versions of the Contact class didn’t have this\n\nSo error occurs\n\nSame might occur if we make more modifications in the future\n\n\n\n\nWe can solve this by versioning a class\nAdd a version attribute to each class\n\nSimply a numeric attribute\n\n  def __init__(self, name, address, telephone):\n      \"\"\"\n      Create a new Contact instance\n\n      Parameters\n      ----------\n      name : str\n          Contact Name\n      address : str\n          Contact's postal or street address.\n      telephone : str\n          Contact phone number (stored as a string).\n      \"\"\"\n      self.name = name\n      self.address = address\n      self.telephone = telephone\n      self.__hours_worked = 0\n      self.__billing_amount = 0\n      self.__version = 1\nversion is set as a private variable\n\n\n\n\n\nThen create a method to check the version of a Contact\n\nLet’s us check that a Contact object matches the current version\n\n  def check_version(self):\n      \"\"\"\n      Check the version of a Contact instance\n\n      Upgrades the instance to the most recent version\n      if required\n      \"\"\"\n      pass\nLeave it as a stub for now\nWe want to use it when we load contacts to check versions\nUpdated load_contacts is below\n  def load_contacts(file_name):\n  \"\"\"\n  Loads the contacts from the given file\n\n  Contacts are stored in binary as a pickled file\n\n  Parameters\n  ----------\n  file_name : str\n      string giving the path to the file where the contacts data is stored\n\n  Returns\n  -------\n  None\n      Contact detail is loaded into the global contacts value\n\n  Raises\n  ------\n      Exceptions if contacts failed to load\n\n  See Also\n  --------\n  save_contacts : saves contacts to a pickled file\n  \"\"\"\n  global contacts\n  print(\"Load contacts\")\n  with open(file_name, \"rb\") as input_file:\n      contacts = pickle.load(input_file)\n  # Update version of loaded contacts if required\n  for contact in contacts:\n      contact.check_version()\n\n\n\n\n\nNow we want to write code to upgrade a Contact\nFor our version \\(1\\), we want to upgrade any class that does not have a __billing_amount attribute\nIn future we might define a version \\(2\\), then we would redefine the check_version method to upgrade any class that isn’t version \\(2\\)\n  def check_version(self):\n  \"\"\"\n  Check the version of a Contact instance\n\n  Upgrades the instance to the most recent version\n  if required\n  \"\"\"\n  try:\n      if not self.__version == 1:\n          self.__billing_amount = 0\n          self.__version = 1\n  except AttributeError:\n      self.__billing_amount = 0\n      self.__version = 1\nWe first attempt to check the version number\nIf it’s not the current version (\\(1\\)) we upgrade the class\n\nAdd a .__billing_amount attribute defaulted to zero\nUpgrade the version number\n\nUse a try...except block to catch the AttributeError if the version doesn’t exist (i.e. for old instances pre-versioning)\n\nPerform the upgrade\n\n\n\n\n\nTo get a better understanding of versioning, work through the following steps\nStart by running the program TimeTrackerWithPropertiesAndExceptionHandling.py. Create a new contact as below\n\n\n\nEnter your command: 1\n\nCreate new contact\n\nEnter the contact name: Rob Miles\n\nEnter the contact address: 18 Pussycat Mews, London, NE1 410S\n\nEnter the contact phone: 1234 56789\n\n\n\n\nThis creates a new contact, which looks like, (use Find Contact)\n\n\nName: Rob Miles\nAddress: 18 Pussycat Mews, London, NE1 410S\nTelephone: 1234 56789\nHours on the case: 0\n\n\nAs we can see this version is missing the billable hours information\nExit the program so the contact is saved. Now load this pickle file with TimeTrackerWithVersion.py\nThis should load the contact (which is unversioned), and upgrade it to the versioned variant with a billing amount\nAttempt to display this contact, you should see something like\n\n\nName: Rob Miles\nAddress: 18 Pussycat Mews, London, NE1 410S\nTelephone: 1234 56789\nHours on the case: 0\nAmount to bill: 0\n\n\nAs we can see, the amount to bill is now correctly displayed\n\n\n\n\n\n\nImportant\n\n\n\nAdd version management when you design data storage\nWhen starting a project you should consider which items are being stored and if they need version management. For example in the Time Tracker program we expect that the client will request changes to the features, so we should consider versioning it from the start\nEverytime a new version of a program is installed, we then have to go through the process of updating the underlying data to the new version\nWhen writing a program for a customer, you should consider how long it will take to write code that deal with data updates (or migrations). This can make trivial programs significantly more complex\n\n\n\n\n\n\n\nEach time we add a new attribute to the Contact class we have to modify display_contact\nWould be nice just to be able to print a Contact directly\nHowever, doing so, we find the output is pretty useless (using the mock below)\n\n  class Contact:\n      def __init__(self, name, address, telephone):\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n\n  contact = Contact(\"Rob Miles\", \"Pussycat Mews\", \"1234\")\n\n  def display_contact(contact):\n      print(contact)\n\n  display_contact(contact)\n\n&lt;__main__.Contact object at 0x7f59143ac5f0&gt;\n\n\ndefault for objects is the class name following by the memory address of the object\npython objects have a __str__ method\n\nUsed whenever the an object needs to be converted to a string\n\nTo change the default behaviour for our objects we need to redefine __str__\n  class Contact:\n      ...\n      def __str__(self):\n          return \"Name: \" + self.name + \"\\n\" + \\\n          \"Address: \" + self.address + \"\\n\" + \\\n          \"Telephone: \" + self.telephone + \"\\n\" + \\\n          \"Hours on the case: \" + str(self.hours_worked) + \"\\n\" + \\\n          \"Amount to bill: \" + str(self.billing_amount)\nThe \\ character above is used to continue the string onto a new line\nprinting now, we get what we expect\n\n  display_contact(contact)\n\nName: Rob Miles\nAddress: Pussycat Mews\nTelephone: 1234\nHours on the case: 0\nAmount to bill: 0\n\n\n\n\n\n\nWriting the string as a series of concatenations isn’t the cleanest\nDifficult to maintain and ensure correctness as we modify the class\nWe can use format to create a formatted string\n\nLets us write a shorter string\nformat is a string method\nformat takes in values as arguments and injects them into the string\n\n  class Contact:\n      ...\n      def __str__(self):\n          template = \"\"\"Name: {0}\nAddress: {1}\nTelephone: {2}\nHours on the case: {3}\nAmount to bill: {4}\"\"\"\n          return template.format(self.name, self.address, self.telephone, self.hours_worked, self.billing_amount)\nValues in format are inserted at marked points in the string\nMarked points are {n} where \\(n\\) is the index of the argument to substitue\n\nStarting from \\(0\\)\n\n\n\n\n\nOpen the python interpreter and work through the following steps to understand how string formatting works\nEnter the statements below\n\nname = \"Rob Miles\"\nage = 21\n\nThe above creates two variables name and age\nNow create the following template string\n\ntemplate = \"My name is {0} and my age is {1}\"\n\nThe just creates a string called template, {0} and {1} are two placeholder indicators for the format function\nNow call the format method on template\n\ntemplate.format(name, age)\n\n'My name is Rob Miles and my age is 21'\n\n\nAs we can see the placeholder values have been substituted with the values of the name and age value\nWe can add additional formatting information. Redefine and format the template as follows\n\ntemplate = \"My name is {0:20} and my age is {1:10}\"\ntemplate.format(name, age)\n\n'My name is Rob Miles            and my age is         21'\n\n\nWe write the placeholder as {n:w} where \\(n\\) is the index of the placeholder. \\(w\\) is the width value, as you can see from above, the value is still substituted but then spaces are added to pad out to the width. This is useful for defining columns. We use a : to seperate the format specifiers from the placeholder index\nFor floating point values you can also specify the number of decimal places to be printed\n\ntemplate = \"My name is {0:20} and my age is {1:10.2f}\"\ntemplate.format(name, age)\n\n'My name is Rob Miles            and my age is      21.00'\n\n\nThe above now prints the age with two decimal places. The full details of the string formatting mini language can be found at the python docs\nYou can find the full version of Time Tracker using the string method in\n\n\n\n\n\n\nOur client now gives us a new scenario\n\n\nThe client would like to record when each specific session for a contact took place. You and the client specify the following design,\n\nTime Tracker\n1. New Contact\n2. Find Contact\n3. Edit Contact\n4. Add Session\n5. Exit Program\n\nEnter you command: 2\nEnter  the contact name: Rob\nName: Rob Miles\nAddress: 18 Pussycat Mews, London, NE1 410S\nTelephone: 1234 56789\nHours on the case: 10.0\nAmount to bill: 470.0\nSessions\nDate: Mon Jul 10 11:30:00 2017 Length: 1.0\nDate: Tue Jul 12 11:30:00 2017 Length: 2.0\nDate: Wed Jul 19 11:30:00 2017 Length: 2.5\nDate: Wed Jul 26 10:30:00 2017 Length: 2.5\nDate: Mon Jul 31 16:51:45 2017 Length: 1.0\nDate: Mon Aug 14 16:51:45 2017 Length: 1.0\n\n\nFinding a contact now displays the sessions as a list\nNot immediately clear how we would add this to our class\n\n\n\nLet’s do some design work, for handling a session. Work through the following questions\n\nHow will we store information about a session?\n\nWe need to store a bunch of heterogenous related data\nGood idea to consider a class, say Session\nNeed to consider data to store\n\nlength of a session\ndate and time of the session\n\nWe should also move the Contact class attributes validating a session length to the Session class\n\n\n import time\n class Session:\n     \"\"\"\n     Session with a length and a date time it was conducted\n     \"\"\"\n\n     __min_session_length = 0.5\n     __max_session_length = 3.5\n\n     @staticmethod\n     def valid_session_length(session_length):\n         \"\"\"\n         Check a session length is valid\n\n         Parameters\n         ----------\n         session_length : int | float\n             length of a consult session in hours\n\n         Returns\n         -------\n         bool\n             `True` if the session length is valid else `False`\n         \"\"\"\n         if (\n             session_length &lt; Session.__min_session_length\n             or session_length &gt; Session.__max_session_length\n         ):\n             return False\n         return True\n\n     def __init__(self, session_length):\n         \"\"\"\n         Create a new Session instance\n\n         Parameters\n         ----------\n         session_length : int | float\n             length of a session\n\n         Raises\n         ------\n         Exception\n             Raised if `session_length` is invalid\n\n         See Also\n         --------\n         Session.valid_session_length : validates session lengths\n         \"\"\"\n         if not Session.valid_session_length(session_length):\n             raise Exception(\"Invalid session length\")\n         self.__session_length = session_length\n         self.__session_end_time = time.localtime()\n         self.__version = 1\n\n\nWe can now create Session objects\n\n  session_length = 2\n  session_record = Session(session_length)\n  print(session_record)\n\n&lt;__main__.Session object at 0x7f59143153d0&gt;\n\n\ncreates a Session with the passed session_length parameter\nvalidate_session_length moved to Session\n\nvalidates session lengths at object creation\nException raised if invalid session length is passed\n\n__init__ uses time library to get the local time\n\nStored in __session_end_time attribute\n\n\nAre we using version control for the Session class?\n\nYes\nHighly likely the Session object might change\nEspecially if we change our mind on what responsibility is in the Contact class vs the Session class\nThus also want to implement a check_version method\n  def check_version(self):\n      \"\"\"\n      Check the version of a Contact instance\n\n      Upgrades the instance to the most recent version\n      if required\n      \"\"\"\n      pass\nCurrently does nothing\n\nAll Session instances will be versioned\nOnly one version, so no need to edit\n\n\nHow will we allow users of the Session class to get the session length and session end time items from a Session object?\n\nWe add these as properties\nWant these to be read-only so no setter is provided\n\n @property\n def session_length(self):\n     \"\"\"\n     session_length : int | float\n         length (in hours) of this session\n     \"\"\"\n     return self.__session_length\n\n @property\n def session_end_time(self):\n     \"\"\"\n     session_end_time : time.struct_time\n         date and time of the session\n     \"\"\"\n     return self.__session_end_time\nWill the Session class have a __str__ method?\n\nYes\nReturn a string describing a Session instance\n\n def __str__(self):\n     template = \"Date: {0} Length: {1}\"\n     #convert time object string\n     date_string = time.asctime(self.__session_end_time)\n     return template.format(date_string, self.__session_length)\n\ntime library contains asctime\n\nTakes a localtime value and returns a string representation\n\nThen format the string\n\n\n\nGiven the Session object, we now need to incorporate this into the Contact object\nContact objects contain a list of sessions\n\nInitialised empty\n\nWe also need to bump the version number\n\nWhich means we also need to update the check_version method\nNow need to handle the conversion from no version to version 2 and version 1 to version 2\n\n  def check_version(self):\n      \"\"\"\n      Check the version of a Contact instance\n\n      Upgrades the instance to the most recent version\n      if required. This includes upgrading any Session\n      instances associated with this Contact instance\n\n      See Also\n      --------\n      Session.check_version : Checks and upgrades Session instances\n      \"\"\"\n      try:\n          if self.__version == 1:\n              # does not have session list\n              self.__sessions = []\n              self.__version = 2\n      except AttributeError:\n          self.__billing_amount = 0\n          self.__sessions = []\n          self.__version = 2\n\n      # now upgrade all sessions in a contact\n      for session in self.__sessions:\n          session.check_version()\nAny version \\(1\\) instance will be upgraded to version \\(2\\)\nFor old, unversioned instances, we still use the try...except to force an upgrade to the most recent\nWe also want to check that the sessions stored with a Contact are up to date\n\nSo after upgrading a Contact we check that the Session instances are up to date\n\nWe’ve written the code so that if the Session is upgraded, instances will still be upgraded even if the Contact object is the most recent version\nWe now need to modify adding a session to add a new Session instance, rather than just update the hours\n  def add_session(self, session_length):\n      \"\"\"\n      Adds a session (in hours) to the Contacts sessions\n\n      Parameters\n      ----------\n      session_length : int | float\n          time spent on session in hours\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      Exception\n          Raised if invalid session length passed\n\n      See Also\n      --------\n      Contact.valid_session_length : checks a session length is valid\n      \"\"\"\n      try:\n          self.__sessions.append(Session(session_length))\n          self.__hours_worked = self.__hours_worked + session_length\n          amount_to_bill = Contact.__open_fee + (\n              Contact.__hourly_fee * session_length\n          )\n          self.__billing_amount = self.__billing_amount + amount_to_bill\n      except Exception as e:\n          print(e)\nWe could validate the session length in add_session explicitly\n\nHowever, the Session constructor does this, via exceptions\n\nWe first try to create the Session\n\nIf it’s invalid we get an exception which we catch and handle\n\nIf created successfully we then update the hours worked and amount to bill\nLast step is to now work out how we want to display our Session instances when we report on a client\n\nOur client wants a line for each individual session\nWe need to convert the list of sessions to a string in this format\n\n  @property\n  def session_report(self):\n      \"\"\"\n      session_report : str\n          provides a string representation of a Contact's sessions\n      \"\"\"\n\n      # map converts each session to a string\n      report_strings = map(str, self.__sessions)\n      result = \"\\n\".join(report_strings)\n      return result\nUses map to convert a list of session objects to a list of their string representations\nUses join to then convert the list of strings to a single string with each element seperated by a newline\n\n\n\n\n\nOur aim is to convert a list of Session objects into a list of strings\nCould do this with a loop\nAlternative is to use map\nmap takes two arguments\n\nA function name\n\nThe function must accept a single argument and return a result\n\nList of items to apply the function to\n\nfunctions can be stored in variables and passed as arguments\nmap applies the function provided (first argument) to the list (second argument) and returns the result\n\n\n\nThese next few steps go on for a quite a while. So work through it at your own pace. However, this will give you a good understanding of not just map but also some fundamentals for python\nOpen up a python interpreter and work through the following steps. We’ll use map to indent a list of strings. Run the following steps\n\ncode = ['line1', 'line2', 'line3']\n\nThis creates a list containing three strings, we can easily view the contents\n\ncode\n\n['line1', 'line2', 'line3']\n\n\nNow we need to create our indentation function. We can do this by adding four spaces (or a tab etc.) at the beginning of a string. Define the following python funcion\n\ndef indent(x):\n    return \"    \" + x\n\nWe can test this function, on a sample string,\n\nprint(\"Rob\")\nindent(\"Rob\")\n\nRob\n\n\n'    Rob'\n\n\nWe would like to apply the indent function to every string in the code list. We could do this using a for loop, instead we use a map function\nNow run the following statements\n\nindented_code = map(indent, code)\nindented_code\n\n&lt;map at 0x7f5914314100&gt;\n\n\nNaively we expected a list of indented strings. Instead we have something called a map object. map returns something called an iterator. Iterators return items from a collection or sequence one at a time. We can work through iterators using a for loop. This is how we can work through lists. range also returns an iterator\nNow run the following for loop to get the indented_code values\n\nfor s in indented_code:\n    print(s)\n\n    line1\n    line2\n    line3\n\n\nNow we have the list of strings as we were expecting. Each time around the loop the next s value is retrieved from the iterator\nIterators allow us to save memory, rather than having to store the entire result in memory we can simply generate each one as needed. Each time we ask for a new result from the map object, map gets the next value from the original collection (code) and applies the function indent to it. Once the map iterator runs out of values to return, it raises StopIteration as an exception. This stops the loop.\nLets explore this in more detail\nRecreate the statement creating the map\n\nindented_code = map(indent, code)\n\nWe can then ask for the next item from an iterator using the __next__ method.\nCall this method on indented_code\n\nindented_code.__next__()\n\n'    line1'\n\n\nWe can see this produces the next value, though in this case, it’s the first item. We can keep repeating this\nRun the following\n\nprint(indented_code.__next__())\nprint(indented_code.__next__())\nprint(indented_code.__next__())\n\n    line2\n    line3\n\n\n\n---------------------------------------------------------------------------\nStopIteration                             Traceback (most recent call last)\nCell In[54], line 3\n      1 print(indented_code.__next__())\n      2 print(indented_code.__next__())\n----&gt; 3 print(indented_code.__next__())\n\nStopIteration: \n\n\n\nWe can see that we get the next two items from the iterator, and then finally after trying to get an non-existent value we see a StopIteration exception is raised\nYou can’t reuse a iterator once it has run out of items. You have to recreate it\n\nindent_iterator = map(indent, code)\n\nIf we want to convert this to normal collection, we can do something like call list to convert to a list\nCheck this out by running the following statements\n\nindented_code = list(indent_iterator)\nindented_code\n\n['    line1', '    line2', '    line3']\n\n\nWhat happens if we make the input of a map function an iterator\nEnter the following statements to explore\n\ni1 = map(indent, code)\ni2 = map(indent, i1)\n\nWe first create the iterator i1 to apply the indent function to the list code. We then create a second iterator i2 to apply the indent function to the items of the i1 iterator\nUse list to convert i2 to a list\n\nlist(i2)\n\n['        line1', '        line2', '        line3']\n\n\nWe can see that each item is indented twice. Once by i1 and again by i2. Observe that the nested iterator i1 was also applied as part of the conversion process. Python makes it very easy to chain iterators together\nLet us return to our original use of map\nreport_strings = map(str, self.__sessions)\nHere self.__sessions is a list of Session objects. map creates an iterator that applies str to each element of self.__sessions. str itself converts each Session to a string by calling the __str__ method. We then use the join method to work through this iterator to build the final output string\n\n\n\n\n\nWe can call string methods on string literals, e.g.\n\n  \"FRED\".lower()\n\n'fred'\n\n\nAnother string method is join\nTakes an iterator as an argument\njoin merges all strings in an iterator\n\nthe string on which join is called is inserted between each item\n\n\n  report_strings = [\"1\", \"2\", \"3\"]\n  report_results = \"\\n\".join(report_strings)\n\n\n\n\nWork through the following steps with the python interpreter to understand join\nEnter the statement below\n\nreport_strings = [\"report1\", \"report2\", \"report3\", \"report4\"]\n\nThe above creates a list of four strings, report_strings. Lists are iterators so we can pass this to join\nCall the join function as below\n\n\"**\".join(report_strings)\n\n'report1**report2**report3**report4'\n\n\nAs observed we iterate over the strings, merging them with ** inserted in between. Observe that ** is not placed at the start or end of the resulting string\nRerun the statement with the newline character below\n\nprint(\"\\n\".join(report_strings))\n\nreport1\nreport2\nreport3\nreport4\n\n\nThis does the same but instead each string is printed on its own line\nWe can use join to concatenate strings by using the empty string\nRun the following statement\n\n\"\".join(report_strings)\n\n'report1report2report3report4'\n\n\n\nAfter this discussion, we have completed this version of the Time Tracker\nAside from one final thing, updating the __str__ method in Contact to use the session_report property\n  def __str__(self):\n      template = \"\"\"Name: {0}\n  Address: {1}\n  Telephone: {2}\n  Hours on the case: {3}\n  Amount to bill: {4}\n  Sessions: \\n{5}\"\"\"\n      return template.format(\n          self.name,\n          self.address,\n          self.telephone,\n          self.hours_worked,\n          self.billing_amount,\n          self.session_report,\n      )\nYou can find the final implementation in Time Tracker with Session History\n\n\n\n\n\nThe time tracker application is a very good starting point for any program that you might like to write that stores and manages information. You could replace the sessions with albums and music tracks, salesman and sales artists and pictures - or anything else you want to track\nIn the previous chapter we created a Music Storage app that stored songs and could be used to manage a single playlist. Using the framework provided by Time Tracker extend the Music Storage app to be able to manage and store multiple playlists at a time\nThankfully this isn’t as in depth as building the application the first time around. We start by defining our Playlist class\nLet us first focus on the data attributes, we want a name and a list of songs. We also want the total runtime. Now for simplicity we’ll leave the name and tracks as public attributes, but we’ll define the runtime as a property, intefacing with a protected variable __runtime. We do this because the runtime is calculated from tracks so we don’t want the caller to modify it themselves.\nInspired by Time Tracker’s session_report we’ll also define a track_report property using that interfaces with map to provide a string representation of the tracks in a playlist where each track is on its own line\nclass Playlist:\n    \"\"\"\n    A class representing a music playlist with a name and list of tracks\n\n    Tracks and records the length of the playlist\n    \"\"\"\n\n    def __init__(self, name, tracks=[]):\n        \"\"\"\n        Create a new Playlist instance\n\n        Parameters\n        ----------\n        name : str\n            name to associate with the playlist\n        tracks : list, optional\n            list of songs in the playlist, by default []\n        \"\"\"\n        self.name = name\n        self.tracks = tracks\n        self.__runtime = 0\n        for song in self.tracks:\n            self.__runtime += song.length_in_seconds\n\n    def __str__(self):\n        template = \"\"\"Playlist: {0}\nTotal Length: {1} s\nSongs:\n{2}\"\"\"\n        return template.format(self.name, self.runtime, self.track_report)\n\n    @property\n    def runtime(self):\n        \"\"\"\n        runtime : int\n            total run time of the playlist in seconds\n        \"\"\"\n        return self.__runtime\n\n    @property\n    def track_report(self):\n        \"\"\"\n        track_report : str\n            string representation of tracks in the playlist, giving each track\n            on its own line\n        \"\"\"\n        song_strings = map(str, self.tracks)\n        return \"\\n\".join(song_strings)\nObserve that the constructor takes an optional list of tracks (by default its empty). This means that a user can create a Playlist by name only and then add songs to it (as used in create_playlist below) or we can create a playlist with a list of songs already (as used by suggest_playlist_of_given_length)\nNow we want to keep the internal track list and the runtime synchronised, so we add methods on the Playlist class to handle adding, removing and clearing tracks from the playlist\ndef add_track(self, track):\n    \"\"\"\n    Add a new track to the playlist\n\n    Updates the playlist length\n\n    Parameters\n    ----------\n    track : MusicTrack\n        track to add to the playlist\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    Playlist.remove_track : removes a track from a playlist\n    \"\"\"\n    # first update runtime so a non-track objects causes an error\n    self.__runtime += track.length_in_seconds\n    self.tracks.append(track)\n\ndef remove_track(self, track):\n    \"\"\"\n    Remove a track from the playlist\n\n    Parameters\n    ----------\n    track : MusicTrack\n        track to remove from the playlist\n\n    See Also\n    --------\n    Playlist.add_track : add a track to a playlist\n    Playlist.clear_tracks : remove all tracks from a playlist\n    \"\"\"\n    try:\n        self.tracks.remove(track)\n        self.__runtime -= track.length_in_seconds\n    except ValueError:\n        print(\"Could not find track:\", track.name, \"in the playlist\")\n\ndef clear_tracks(self):\n    \"\"\"\n    Remove all tracks from a playlist\n\n    Runtime is set to 0\n    \"\"\"\n    self.tracks.clear()\n    self.__runtime = 0\nThese are all relatively simple, the takeaway is that as we update the track list, we also ensure the runtime is kept synchronised\n\n\n\n\n\n\nWarning\n\n\n\nIt is important to keep data synchronised\nWe store the runtime as a seperate variable so that we don’t need to calculate it on the fly everytime a function requires it. However this introduces the difficulty that we have to keep runtime synched with the data it is representing (the sum of the length of the tracks in the tracks attribute). This is important in real world scenarios, as if these two data attributes diverge we might get nonsense results.\nThis is actually one of the big reasons why we like to make data attributes private, it ensures we can maintain the relationships between elements.\n\n\nAs written our code has the problem that data could become desynchronised because the user can directly modify the tracks list. We can’t get around this easily by making a read-only property, because it we return a reference to a list, than any changes on that reference would propagate to the original list\nOne option would be to provide a deep copy (a unique copy for each call), or another would be make tracks private and define methods on the class for all the nessecary interactions. I haven’t done this to minimise the disruption to the overall API, since this current API lets us reuse the adding and searching functionality we defined for the complete list of tracks. This could be something we change in the future\nLets now consider how we want to program to work. Previously we had one playlist. Now like the tracks, we want a list of them. However we still want to be able to work on and modify a playlist. To minimise the changes from the original design lets use the following approach\n\nThere will be a list of playlists\n\nThese will be loaded and saved to memory like the track list\n\nThere will be one active playlist at a time\n\nAt the start there is no active playlist\nThe user can create a new playlist\nThe user can select an existing playlist\nThe user can use the existing playlist generation feature\n\n\nBy keeping the one active global playlist we can minimise the disruption to our program. We can reuse existing functions making note that the current playlist has changed from a list of tracks to a Playlist object\nOur new Playlist menu now looks like,\ndef run_playlist_management_menu():\n    \"\"\"\n    Provides the user with a looping playlist menu\n\n    1. Create a new playlist\n    2. Select playlist\n    3. Get a suggested playlist of a target length\n    4. Add a track to the playlist\n    5. Remove a track from the playlist\n    6. Clear the playlist\n    7. Display the playlist\n    8. Show the runtime of the playlist\n    9. Export the current playlist\n    10. Return to the main menu\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    ValueError\n        An invalid number is encountered in menu selection, should not\n        occur in live code, please raise a bug report if encountered\n    \"\"\"\n    playlist_management_menu = \"\"\"Playlist Management\nCurrent playlist is {0}\n\n1. Create a new playlist\n2. Select playlist\n3. Get a suggested playlist of a target length\n4. Add a track to the playlist\n5. Remove a track from the playlist\n6. Clear the playlist\n7. Display the playlist\n8. Show the runtime of the playlist\n9. Export the current playlist\n10. Return to the main menu\n\nEnter your command: \"\"\"\n    while True:\n        command = BTCInput.read_int_ranged(\n            prompt=playlist_management_menu.format(current_playlist.name),\n            min_value=1,\n            max_value=10,\n        )\n        if command == 1:\n            create_playlist()\n        elif command == 2:\n            select_playlist()\n        elif command == 3:\n            suggest_playlist_of_given_length()\n        elif command == 10:\n            break\n        elif current_playlist.name == \"None\":\n            print(\"There is no active playlist. Please select or create one\")\n            continue\n        elif command == 4:\n            add_track_to_playlist()\n        elif command == 5:\n            remove_tracks_from_playlist()\n        elif command == 6:\n            clear_playlist()\n        elif command == 7:\n            display_playlist(current_playlist, name_only=False)\n        elif command == 8:\n            calculate_playlist_length()\n        elif command == 9:\n            export_playlist()\n        else:\n            raise ValueError(\n                \"Invalid command id \"\n                + str(command)\n                + \" found in playlist management sub-menu\"\n            )\nYou can see that we’ve defined new functions,\n\ncreate_playlist\nselect_playlist\ndisplay_playlist\n\nand that we’ve renamed the old save_playlist function to export_playlist. This last change is because we’ve introduced save_playlists and load_playlists as functions to pickle and unpickle the playlists binary data. Renaming save_playlist to export_playlist makes it clear that this function is not related to those two.\nYou also might notice that we’ve reordered the menu so that all the functions dealing with changing the current playlist (create_playlist, select_playlist, suggest_playlist_of_given_length) come first. This allows us to then check that we have an active playlist before running any of the other commands. We also check if user has decided to exit here to, since if we put it after the check for an active playlist the user can’t exit the playlist menu if the don’t have an active playlist\nAs mentioned, at the start there is no active playlist. Now the simplest way to implement this would be to initially set the current_playlist to None. However you can see this has a problem, we want the playlist menu to display the name of the current playlist, this doesn’t work if the current playlist is None. We could add some error checking, but we’ll instead use a technique called a None or Null object. This is an instance of an object that is designed to represent cases where the object does not actually exist. For us, we simply define a Playlist with the name None\n# null object\nno_playlist = Playlist(name=\"None\")\ncurrent_playlist = no_playlist\nLet us look now at the new functions we’ve defined, the first pair\ndef valid_playlist_name(name):\n    \"\"\"\n    Verifies that a playlist name is valid\n\n    Playlist names must be unique\n\n    Parameters\n    ----------\n    name : str\n        proposed name for a playlist\n\n    Returns\n    -------\n    bool\n        `True` if playlist name is valid else, `False`\n    \"\"\"\n    if name == \"None\":\n        return False\n    for playlist in playlists:\n        if name == playlist.name:\n            return False\n    return True\n\n\ndef create_playlist(tracks=[]):\n    \"\"\"\n    Create a new playlist and make it the active playlist\n\n    Prompts the user for a new name for the playlist, and ensures its valid\n    then constructs a playlist and sets it as the current active playlist\n\n    Parameters\n    ----------\n    tracks : list, optional\n        tracks to assign to the playlist, by default []\n\n    See Also\n    --------\n    valid_playlist_name : validates a playlist name\n    Playlist : class used to represent a playlist\n    \"\"\"\n    print(\"Create a new playlist\")\n    global current_playlist\n\n    new_playlist_name = BTCInput.read_text(\"Enter the playlist name: \")\n    while not valid_playlist_name(new_playlist_name):\n        print(\"That playlist name is already in use\")\n        new_playlist_name = BTCInput.read_text(\"Enter the playlist name: \")\n\n    new_playlist = Playlist(new_playlist_name, tracks)\n    current_playlist = new_playlist\n    playlists.append(new_playlist)\nPrompts the user for the name of a new playlist. We add code that means the user can’t override the NoneObject or use duplicate names which is given by the function valid_playlist_name. Unlike the validation code in the Time Tracker this is not in the class, because it is part of the business logic of the application layer, not the playlist itself\nWe then define the select_playlist function,\ndef select_playlist():\n    \"\"\"\n    Select an existing playlist to be the current playlist\n\n    Prompts the user for a search name then returns all playlists\n    that match that string. The user will be displayed each playlist\n    in turn and asked if they want to make that the current playlist\n\n    Notes\n    -----\n    Passing the empty string can be used to display all playlists\n    \"\"\"\n    print(\"Select a playlist\")\n    global current_playlist\n\n    search_name = BTCInput.read_text(\"Enter playlist name (enter to see ): \")\n\n    matched_playlists = []\n\n    for playlist in playlists:\n        if playlist.name.strip().lower().startswith(search_name.strip().lower()):\n            matched_playlists.append(playlist)\n\n    if len(matched_playlists) &gt; 0:\n        print(\"Found {0} matches\".format(len(matched_playlists)))\n        for playlist in matched_playlists:\n            display_playlist(playlist)\n            select = BTCInput.read_int_ranged(\n                \"Select this playlist? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n            )\n            if select:\n                current_playlist = playlist\n                return\n    else:\n        print(\"No playlists found matching that name\")\nSince no other method needs to search for playlist names, we forgo our usual pattern of defining a find and filter function and just combine it all in the one function. Additionally select is also used for letting the user see what playlists are stored in the program. A future version might add an explicit function called this (perhaps list_playlists)\nThis program works pretty simply. We use the standard name matching pattern, then for each match the user is shown the playlist name and runtime, and is given the option to select it. If they do then the current playlist is set to that playlist and the function ends, else it continues to the next.\nLastly we have our display_playlist function, to print a playlist\ndef display_playlist(playlist, name_only=True):\n    \"\"\"\n    Display a playlist\n\n    Can optionally list all the tracks or just the name and length\n\n    Parameters\n    ----------\n    playlist : Playlist\n        playlist to display\n    name_only : bool, optional\n        only display the playlists name and runtime, by default `True`\n\n    Returns\n    -------\n    None\n    \"\"\"\n    if name_only:\n        print(\"{0} ({1} s)\".format(playlist.name, playlist.runtime))\n    else:\n        print(playlist)\nThe optional name_only parameter is used indicate that we only want to print the playlist name and length, otherwise we defer to the Playlist __str__ method and print everything.\nThis captures the last of the high level changes. As mentioned, we have to make minor changes to the existing functions, such as to suggest_playlist_of_given_length shown below\ndef suggest_playlist_of_given_length():\n    \"\"\"\n    Suggests a playlist of length less than or equal to\n    a user prompted length\n\n    Asks the user for a maximum playlist length, and\n    then suggests a playlist by combining tracks randomly\n    such that the suggested playlist is no greater than\n    the length\n\n    The user has the option to review the proposed list\n    and either accept, reject or regenerate the list\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"Suggest playlist of given length\")\n    global current_playlist\n\n    target_length = read_min_valued_integer(\n        \"Enter maximum playlist length: \", min_value=1\n    )\n\n    while True:\n        suggested_tracks = []\n        suggested_tracks_total_length = 0\n        # find tracks that could fit in the playlist\n        candidate_songs = filter_tracks_shorter_than_length(target_length, tracks)\n\n        if len(candidate_songs) == 0:\n            print(\"Could not generate a playlist of that length. Try a longer playlist\")\n            return\n\n        while len(candidate_songs) &gt; 0:  # stop when no more eligable songs\n            # add a random song and update the playlist length\n            song_choice = random.choice(candidate_songs)\n            suggested_tracks.append(song_choice)\n            suggested_tracks_total_length = (\n                suggested_tracks_total_length + song_choice.length_in_seconds\n            )\n\n            # filter out songs that no longer fit\n            candidate_songs = filter_tracks_shorter_than_length(\n                target_length - suggested_tracks_total_length, candidate_songs\n            )\n        print(\"Generated a playlist...\")\n        # let the user review the playlist\n        display_tracks(suggested_tracks)\n        if BTCInput.read_int_ranged(\n            \"Accept this playlist? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        ):\n            create_playlist(suggested_tracks)\n            return\n        else:\n            if BTCInput.read_int_ranged(\n                \"Generate again? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n            ):\n                continue\n            return\nHere we still build up the suggested playlist as before (using a list) but once the user decides to keep this playlist, we then call create_playlist passing in the track list to create a proper named Playlist object\nYou are encouraged to work through the full program yourself (PlaylistStorage.py)\n\n\n\n\n\nLet’s build a simple music keyboard\nWe’ll add a simple music player\nExtend with some playback options\nThe snaps library code provides some music notes to use\n\nstored in MusicNotes\nplay_note lets us play a note\n\n\n\n\n\n\nWarning\n\n\n\nIf when running the program you get a file not found error, you may need to modify the path in play_note to either MusicNotes\\\\ or MusicNotes/\nThis path is relative to snaps and so the folder must in the same directory as snaps\n\n\n\nWe can start with a simple program that plays all the notes,\n  # Example 10.15.1 Play Notes\n  #\n  # Demonstrates using snaps to play notes\n\n  import time\n\n  import snaps\n\n  for note in range(0, 13):\n      snaps.play_note(note)\n      time.sleep(0.5)\n  input(\"Press enter to continue...\")\nWe use time.sleep(0.5) to stagger playing the notes\nWe could also play a tune,\n  # Example 10.15.2 Twinkle Twinkle\n  #\n  # Uses snaps to play a simple tune\n\n  import time\n\n  import snaps\n\n  snaps.play_note(0)\n  time.sleep(0.4)\n  snaps.play_note(0)\n  time.sleep(0.4)\n  snaps.play_note(7)\n  time.sleep(0.4)\n  snaps.play_note(7)\n  time.sleep(0.4)\n  snaps.play_note(9)\n  time.sleep(0.4)\n  snaps.play_note(9)\n  time.sleep(0.4)\n  snaps.play_note(7)\n  time.sleep(0.8)\n  snaps.play_note(5)\n  time.sleep(0.4)\n  snaps.play_note(5)\n  time.sleep(0.4)\n  snaps.play_note(4)\n  time.sleep(0.4)\n  snaps.play_note(4)\n  time.sleep(0.4)\n  snaps.play_note(2)\n  time.sleep(0.4)\n  snaps.play_note(2)\n  time.sleep(0.4)\n  snaps.play_note(0)\n  time.sleep(0.8)\nWe can see this is already becoming tedious\nWe repeatedly write the play_note followed by a sleep time\nHave to manuually modify the code\nWe could make this data-driven\nWe supply a list of tuples\n\nEach tuple contains the id for a note and the time to sleep after playing that note\n\nThen simply loop over the list to play the tune\nCan then play anything by just changing the embedded data\n  # Example 10.15.3 Twinkle Twinkle with Tuples\n  #\n  # Converts play notes to a data-driven program using tuples to specify notes\n  # and how long to pause after\n\n  import time\n\n  import snaps\n\n  tune = [\n      (0, 0.4),\n      (0, 0.4),\n      (7, 0.4),\n      (7, 0.4),\n      (9, 0.4),\n      (9, 0.4),\n      (7, 0.8),\n      (5, 0.4),\n      (5, 0.4),\n      (4, 0.4),\n      (4, 0.4),\n      (2, 0.4),\n      (2, 0.4),\n      (0, 0.8),\n  ]\n\n  for note in tune:\n      note_id, sleep_time = note\n      snaps.play_note(note_id)\n      time.sleep(sleep_time)\nEach tuple stores the note and the sleep time\nWe then loop over the tuples\nWe use unpacking to assign the elements of the tuple meaningful names (note_id and sleep_time)\nWhile playback is simple, constructing is not nessecarily\n\nThe tuples are undocumented and rely on the programmer knowing the indices\n\nWe could instead define a lightweight class\n  # Example 10.15.4 Twinkle Twinkle with Classes\n  #\n  # Modifies the data driven tuple implementation by definining a lightweight\n  # Note class\n\n  import time\n\n  import snaps\n\n\n  class Note:\n      \"\"\"\n      Musical note with a playback duration.\n      \"\"\"\n\n      def __init__(self, note, duration):\n          \"\"\"\n          Create a Note instance\n\n          Parameters\n          ----------\n          note : int\n              id of the note to play\n          duration : int | float\n              duration of the note\n          \"\"\"\n          self.__note = note\n          self.__duration = duration\n\n      def play(self):\n          \"\"\"\n          play the note\n\n          plays the note then pauses for the specified duration\n          \"\"\"\n          snaps.play_note(self.__note)\n          time.sleep(self.__duration)\n\n\n  tune = [\n      Note(note=0, duration=0.4),\n      Note(note=0, duration=0.4),\n      Note(note=7, duration=0.4),\n      Note(note=7, duration=0.4),\n      Note(note=9, duration=0.4),\n      Note(note=9, duration=0.4),\n      Note(note=7, duration=0.8),\n      Note(note=5, duration=0.4),\n      Note(note=5, duration=0.4),\n      Note(note=4, duration=0.4),\n      Note(note=4, duration=0.4),\n      Note(note=2, duration=0.4),\n      Note(note=2, duration=0.4),\n      Note(note=0, duration=0.8),\n  ]\n\n  for note in tune:\n      note.play()\nNote is a lightweight class holding the note’s id and the note duration\n\nKeep these private, since no need to access once set\n\nNote has a play method that captures playing a note\nProgram then defines a list of Note objects which are then played\n\n\n\nConsider the following questions about the design of the note class\n\nWhy does the Note class contain a Play method?\n\ncohesion\nNote contains all the information about a note\nSo should keep the behaviour with the information, i.e. in the Note class\nIf we want to change how a note is played we can change it in the Note class without impacting downstream callers\n\nSo long as we keep the same API\n\n\nCould the Note class have a __str__ method?\n\nIt’s probably a good idea\nA simple implementation is,\ndef __str__(self):\n  template = \"Note: {0} Duration: {1}\"\n  return template.format(self.__note, self.duration)\nWe can then print the tune super easily,\n  tune_strings = map(str, tune)\n  print(\"\\n\".join(tune_strings))\n\n\n\nAll the music playing examples can be found in the Music With Snaps example folder\n\n\n\n\nModify the sample programs to make your own tunes\nFor fun we’ll make two little tunes\n\nThe classic Macca’s jingle\n # Exercise 10.2.1 Maccas Jingle\n #\n # Uses the Note playback program to play the Maccas jingle\n\n import time\n\n import snaps\n\n\n class Note:\n     \"\"\"\n     Musical note with a playback duration.\n     \"\"\"\n\n     def __init__(self, note, duration):\n         \"\"\"\n         Create a Note instance\n\n         Parameters\n         ----------\n         note : int\n             id of the note to play\n         duration : int | float\n             duration of the note\n         \"\"\"\n         self.__note = note\n         self.__duration = duration\n\n     def __str__(self):\n         template = \"Note: {0} Duration: {1}\"\n         return template.format(self.__note, self.__duration)\n\n     def play(self):\n         \"\"\"\n         play the note\n\n         plays the note then pauses for the specified duration\n         \"\"\"\n         snaps.play_note(self.__note)\n         time.sleep(self.__duration)\n\n\n tune = [\n     Note(note=7, duration=0.3),\n     Note(note=11, duration=0.3),\n     Note(note=2, duration=0.3),\n     Note(note=5, duration=0.3),\n     Note(note=7, duration=0.5),\n ]\n\n for note in tune:\n     note.play()\n\n tune_strings = map(str, tune)\n print(\"\\n\".join(tune_strings))\n\nThis doesn’t sound exactly correct because we don’t have the correct octave progression in the provided wav files but we get a decent approximation\nYou might like to play around with the timings to see if you can make it better\n\nThree Blind Mice\n # Exercise 10.2.2 Three Blind Mice\n #\n # Uses the Note playback program to play three blind mice\n\n import time\n\n import snaps\n\n\n class Note:\n     \"\"\"\n     Musical note with a playback duration.\n     \"\"\"\n\n     def __init__(self, note, duration):\n         \"\"\"\n         Create a Note instance\n\n         Parameters\n         ----------\n         note : int\n             id of the note to play\n         duration : int | float\n             duration of the note\n         \"\"\"\n         self.__note = note\n         self.__duration = duration\n\n     def __str__(self):\n         template = \"Note: {0} Duration: {1}\"\n         return template.format(self.__note, self.__duration)\n\n     def play(self):\n         \"\"\"\n         play the note\n\n         plays the note then pauses for the specified duration\n         \"\"\"\n         snaps.play_note(self.__note)\n         time.sleep(self.__duration)\n\n\n tune = [\n     Note(note=4, duration=0.4),\n     Note(note=2, duration=0.4),\n     Note(note=0, duration=0.8),\n     Note(note=4, duration=0.4),\n     Note(note=2, duration=0.4),\n     Note(note=0, duration=0.8),\n     Note(note=7, duration=0.4),\n     Note(note=5, duration=0.4),\n     Note(note=5, duration=0.4),\n     Note(note=4, duration=0.8),\n     Note(note=7, duration=0.4),\n     Note(note=5, duration=0.4),\n     Note(note=5, duration=0.4),\n     Note(note=4, duration=0.8),\n     Note(note=7, duration=0.4),\n     Note(note=12, duration=0.4),\n     Note(note=12, duration=0.4),\n     Note(note=11, duration=0.4),\n     Note(note=9, duration=0.4),\n     Note(note=11, duration=0.4),\n     Note(note=12, duration=0.4),\n     Note(note=7, duration=0.4),\n     Note(note=7, duration=0.8),\n ]\n\n for note in tune:\n     note.play()\n\n tune_strings = map(str, tune)\n print(\"\\n\".join(tune_strings))\n\nThis one we get a much better sounding tune\n\n\n\n\n\nBy combining the structure and style of Time Tracker with the music playback provided by the Note class we could make a simple program that lets users create, edit and play their own tunes. Create this program. A user should be able to create a tune, edit a tune, delete a tune and play a selected tune. Tunes should be saved and persist between uses\nIf you can follow the Playlist Storage App and the Recipe Storage App then this program should fairly easy to follow\nLet’s first define our Note class\nclass Note:\n    \"\"\"\n    Musical note with a playback duration.\n\n    Class Attributes\n    ----------------\n    min_note_id : int\n        minimum valid note id\n    max_note_id : int\n        maximum valid note id\n    \"\"\"\n\n    min_note_id = 0\n    max_note_id = 12\n\n    @staticmethod\n    def valid_note(note):\n        \"\"\"\n        Checks if a note id is valid\n\n        Parameters\n        ----------\n        note : int\n            id of the note to validate\n\n        Returns\n        -------\n        bool\n            `True` if note is valid, else `False`\n        \"\"\"\n        if note &lt; 0 or note &gt; 12:\n            return False\n        return True\n\n    def __init__(self, note, duration):\n        \"\"\"\n        Create a Note instance\n\n        Parameters\n        ----------\n        note : int\n            id of the note to play\n        duration : int | float\n            duration of the note\n        \"\"\"\n        if not Note.valid_note(note):\n            raise ValueError(\n                \"invalid note {0} passed. note must be between {1} and {2}\".format(\n                    note, Note.min_note_id, Note.max_note_id\n                )\n            )\n        self.__note = note\n        self.__duration = duration\n\n    @property\n    def duration(self):\n        \"\"\"\n        duration : str\n            time in seconds the note is played for\n        \"\"\"\n        return self.__duration\n\n    def __str__(self):\n        template = \"Note: {0} Duration: {1}\"\n        return template.format(self.__note, self.__duration)\n\n    def play(self):\n        \"\"\"\n        play the note\n\n        plays the note then pauses for the specified duration\n        \"\"\"\n        snaps.play_note(self.__note)\n        time.sleep(self.__duration)\nThis is pretty much the same as the Note class in the Making Music Section. However we need the duration so that we can report how long the total tune is so we add a read only property for duration. Additionally since we’re now going to be taking user input to create notes we’ll want to validate that input. It makes sense for it to be in the Note class, so we define class variables min_note_id and max_note_id and a corresponding validation method, valid_note that can be used to check that a note (represented by an integer) is valid. We leave the class variables as public so we can use them in the prompts we display to the user\nNow when making our own music, we used a list of notes to create a tune. We want to use this structure but wrap it in a class that captures behaviour. We’ll call this class Tune\nclass Tune:\n    def __init__(self, name):\n        \"\"\"\n        Create a new Tune instance\n\n        Parameters\n        ----------\n        name : str\n            name of the tune\n        \"\"\"\n        self.name = name\n        self.__notes = []\n        self.__length = 0\n\n    def __str__(self):\n        notes_string = \"\"\n        for idx, note in enumerate(map(str, self.__notes)):\n            notes_string = notes_string + str(idx) + \": \" + note + \"\\n\"\n\n        template = \"\"\"name: {0}\nduration: {1}\nnotes:\n{2}\n\"\"\"\n        return template.format(self.name, self.__length, notes_string)\n\n    @property\n    def length(self):\n        \"\"\"\n        length : int | float\n            total length of the tune in seconds\n        \"\"\"\n        return self.__length\n\n    @property\n    def number_of_notes(self):\n        \"\"\"\n        number_of_notes : int\n            number of notes in the tune\n        \"\"\"\n        return len(self.__notes)\nThe class has a simple structure. The tune constructor only needs a name, we then create an empty list of notes, and a seperate variable that tracks the full length of the tune. Our string representation (__str__) follows the usual pattern, we print the name and duration of the Tune, the the list of Note objects in the tune. We use enumerate to make this a numbered list with each item on its own line. This is because most of our edits will require an index, so we want to user to be able to easily see the index of all the notes. Additionally we define two useful properties, one to get the length of the tune, and the second that returns the total number of notes in the tune. Both properties are read-only, while this last one is mostly used to help with validating user input\nAs you can see the list of notes is private, so we also want to provide some methods that allow us to modify the notes list\n    def add_note(self, note, index=None):\n        \"\"\"\n        Add a new note to the tune\n\n        Adds a new note to the tune, if the index is specified\n        the note is inserted at that index, else the note is appended\n\n        Parameters\n        ----------\n        note : Note\n            note to add to the tune\n        index : int | None, optional\n            index to insert the note at, if None, the Note is appended,\n            by default None\n\n        Returns\n        -------\n        None\n        \"\"\"\n        if index is not None:\n            self.__notes.insert(index, note)\n        else:\n            self.__notes.append(note)\n        self.__length += note.duration\n\n    def remove_note(self, index):\n        \"\"\"\n        Remove a note from the tune\n\n        Parameters\n        ----------\n        index : int\n            index of the note to remove\n\n        Returns\n        -------\n        Note\n            the removed Note\n        \"\"\"\n        try:\n            note = self.__notes.pop(index)\n            self.__length -= note.duration\n            return note\n        except IndexError:\n            print(\"Failed to remove the {0}-th note\".format(index + 1))\n\n    def clear_tune(self):\n        \"\"\"\n        Clear all notes from the tune\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.__notes.clear()\n        self.__length = 0\nThe first add_note takes a note, and an optional index. If the index is specified the note is inserted into the list (at the specified index), otherwise we append it. The second remove_note requires an index, and removes the note at that index. The removed note is returned as part of this process. We also provide some error handling in case the provided index does not actually exist. Last we provide a clear_tune method which simply removes all the notes\nThe arguably most important function for the Tune class however is play which simply plays the tune\n    def play(self):\n        \"\"\"\n        Plays the tune\n\n        Returns\n        -------\n        None\n        \"\"\"\n        for note in self.__notes:\n            note.play()\nWe define our main menu function as,\ndef run_main_menu():\n    first_option_id = 1\n    last_option_id = 7\n\n    main_menu_template = \"\"\"Tune Editor\nCurrent Tune: {0}\n\n1. New Tune\n2. List Tunes\n3. Select Tune\n4. Play Tune\n5. Edit Tune\n6. Delete Tune\n7. Exit program\n\nEnter your command: \"\"\"\n\n    while True:\n        command = BTCInput.read_int_ranged(\n            main_menu_template.format(current_tune.name),\n            min_value=first_option_id,\n            max_value=last_option_id,\n        )\n        if command == 1:\n            new_tune()\n        elif command == 2:\n            list_tunes()\n        elif command == 3:\n            select_tune()\n        elif command == 7:\n            try:\n                save_tunes(tune_file_name)\n            except:  # noqa: E722\n                print(\"Failed to save tunes\")\n            break\n        elif current_tune.name == \"None\":\n            print(\"No tune currently selected\")\n            continue\n        elif command == 4:\n            current_tune.play()\n        elif command == 5:\n            run_edit_menu()\n        elif command == 6:\n            delete_tune()\n        else:\n            raise ValueError(\n                \"Unexpected command id: {0} found in Main Menu\".format(command)\n            )\nWe use the same save and load paradigm as with all the previous examples so we won’t look at that code again. Of the functions here we have,\n\nnew_tune\n def valid_tune_name(name):\n     \"\"\"\n     Verifies that a tune name is available\n\n     Tune names must be unique\n\n     Parameters\n     ----------\n     name : str\n         proposed name for a tune\n\n     Returns\n     -------\n     bool\n         `True` if tune name is valid else, `False`\n     \"\"\"\n     if name == \"None\":\n         return False\n     for tune in tunes:\n         if name == tune.name:\n             return False\n     return True\n\n\n def prompt_valid_name(prompt):\n     \"\"\"\n     Prompts the user for a valid tune name\n\n     Loops until a valid name is provided\n\n     Parameters\n     ----------\n     prompt : str\n         prompt to display to the user\n\n     Returns\n     -------\n     str\n         string containing a valid tune name\n     \"\"\"\n     tune_name = BTCInput.read_text(prompt)\n     while not valid_tune_name(tune_name):\n         print(\"That tune name is already in use\")\n         tune_name = BTCInput.read_text(prompt)\n\n     return tune_name\n\n\n def new_tune():\n     \"\"\"\n     Create a new tune and make it the active tune\n\n     Prompts the user for a new name for the tune, and ensures its valid\n     then constructs a Tune and sets it as the current active tune\n\n     Returns\n     -------\n     None\n\n     See Also\n     --------\n     valid_tune_name : validates a tune name\n     Tune : class used to represent a tune\n     \"\"\"\n     print(\"New tune\")\n     global current_tune\n     new_tune_name = prompt_valid_name(\"Enter the tune name: \")\n     new_tune = Tune(new_tune_name)\n     current_tune = new_tune\n     tunes.append(new_tune)\n\nWe start by defining a function valid_tune_name\n\nboolean function that ensures a proposed name is unique\nreturns True if the name is valid, else False\n\nWe then wrap this in prompt_valid_name\n\nSince we want to reuse the code that gets a name from a user later\nPrompts the user for a valid name, looping until one is received\nReturns the valid name\n\nOur new_tune is now simple\n\ncall prompt_valid_name to get a new name\nCreate a new Tune object\nset the current tune to this new object\nAdd it to the tunes list\n\n\nlist_tunes\n def filter_tunes_by_name(search_name):\n     \"\"\"\n     Finds tunes matching a search name\n\n     Tunes are matched if their name is prefixed by the search name\n     after normalisation (striping whitespace and lowercasing)\n\n     Parameters\n     ----------\n     search_name : str\n         name to search for (search uses prefix matching)\n\n     Returns\n     -------\n     list[Tune]\n         list of tunes matching the name. If no matches\n         exist the list is empty\n\n     \"\"\"\n     search_name = search_name.strip().lower()\n     print(search_name)\n     matched_tunes = []\n     for tune in tunes:\n         tune_name = tune.name.strip().lower()\n         if tune_name.startswith(search_name):\n             matched_tunes.append(tune)\n     return matched_tunes\n\n\n def list_tunes():\n     \"\"\"\n     List all tunes matching a user-specified search string\n\n     Returns\n     -------\n     None\n\n     See Also\n     --------\n     filter_tunes_by_name : handles searching for tunes by name\n     \"\"\"\n     print(\"List tunes\")\n     search_name = BTCInput.read_text(\"Tune names to search (press enter for all): \")\n     matched_tunes = filter_tunes_by_name(search_name)\n     if len(matched_tunes) == 0:\n         print(\"No matches found\")\n         return\n     print(\"Found {0} matches\".format(len(matched_tunes)))\n     for tune in matched_tunes:\n         print(\"- {0} ({1:.2f} s)\".format(tune.name, tune.length))\n\nWe use the usual pattern of defining a filter_tunes_by_name function to perform the search\nWe then print out the matches as per usual\n\nselect_tune\n def select_tune():\n     \"\"\"\n     Select a tune from tunes matching a user-specified search string\n\n     Returns\n     -------\n     None\n\n     See Also\n     --------\n     filter_tunes_by_name : handles searching for tunes by name\n     \"\"\"\n     print(\"Select tune\")\n     search_name = BTCInput.read_text(\"Enter name of tune to select: \")\n     matched_tunes = filter_tunes_by_name(search_name)\n     if len(matched_tunes) == 0:\n         print(\"No matches found\")\n         return\n     print(\"Found {0} matches\".format(len(matched_tunes)))\n     for tune in matched_tunes:\n         select = BTCInput.read_int_ranged(\n             \"Tune: {0}, select this tune? (1 - Yes, 0 - No): \".format(tune.name),\n             min_value=0,\n             max_value=1,\n         )\n         if select:\n             global current_tune\n             current_tune = tune\n             break\n\nUses filter_tunes_by_name to get matching tunes\nUser is then prompted for each match if they want to make this the new current tune\nExecution stops once they’ve decided to select a new track\n\ndelete_tune\n def delete_tune():\n     \"\"\"\n     Optionally delete tunes matching a user-specified search string\n\n     Returns\n     -------\n     None\n\n     See Also\n     --------\n     filter_tunes_by_name : handles searching for tunes by name\n     \"\"\"\n     print(\"Delete tune\")\n     search_name = BTCInput.read_text(\"Enter name of tune to select: \")\n     matched_tunes = filter_tunes_by_name(search_name)\n     if len(matched_tunes) == 0:\n         print(\"No matches found\")\n         return\n     print(\"Found {0} matches\".format(len(matched_tunes)))\n     for tune in tunes:\n         select = BTCInput.read_int_ranged(\n             \"Tune: {0}, delete this tune? (1 - Yes, 0 - No): \".format(tune.name),\n             min_value=0,\n             max_value=1,\n         )\n         if select:\n             global current_tune\n             if tune == current_tune:\n                 current_tune = no_tune\n             tunes.remove(tune)\n\nAgain, use filter_tunes_by_name to match names\nThen prompt the user if they want to delete\nOnly caveat we have to be careful is that if we delete the currently selected tune we have to set the current tune to no_tune (a null object)\n\n\nNow, the last thing we have to look at is the edit menu. Our edit menu looks as follows,\ndef run_edit_menu():\n    first_option_id = 1\n    last_option_id = 8\n\n    edit_tune_menu_template = \"\"\"Editing Tune\nCurrent Tune: {0}\n1. Rename Tune\n2. Display Tune\n3. Play Tune\n4. New Note\n5. Edit Note\n6. Remove Note\n7. Clear Tune\n8. Finish Editing\n\nEnter your command: \"\"\"\n    while True:\n        command = BTCInput.read_int_ranged(\n            edit_tune_menu_template.format(current_tune.name),\n            min_value=first_option_id,\n            max_value=last_option_id,\n        )\n\n        if command == 1:\n            rename_tune()\n        elif command == 2:\n            print(current_tune)\n        elif command == 3:\n            print(\"Playing\", current_tune.name)\n            current_tune.play()\n        elif command == 4:\n            add_note_to_tune()\n        elif command == 5:\n            edit_note()\n        elif command == 6:\n            if current_tune.number_of_notes == 0:\n                print(\"No notes to remove\")\n            remove_note()\n        elif command == 7:\n            print(\"Cleared\", current_tune.name)\n            current_tune.clear_tune()\n        elif command == 8:\n            break\n        else:\n            raise ValueError(\n                \"Unexpected command id: {0} found in Edit Menu\".format(command)\n            )\nLets work through these functions\n\nrename_tune\n def rename_tune():\n     \"\"\"\n     Rename the current tune to a user prompted string\n\n     Returns\n     -------\n     None\n     \"\"\"\n     print(\"Rename current tune\")\n     new_name = prompt_valid_name(\"Enter new name (or . to leave unchanged): \")\n     if new_name != \".\":\n         current_tune.name = new_name\n\nReuses the prompt_valid_name function from new_tune to get a new name\n\nThis has the issue that we can’t write the same name as the current tune\nSo use . to indicate that we don’t actually want to change\n\n\nadd_note_to_tune\n def get_new_note_from_user():\n     \"\"\"\n     Prompts the user for a new Note\n\n     The user is prompted for the note and duration, and the input validated\n     to ensure that a valid Note object is created\n\n     Returns\n     -------\n     Note\n         Note object containing the user specified note id and duration\n     \"\"\"\n\n     note_prompt = \"Enter note ({0} - {1}): \".format(Note.min_note_id, Note.max_note_id)\n     note = BTCInput.read_int_ranged(\n         prompt=note_prompt, min_value=Note.min_note_id, max_value=Note.max_note_id\n     )\n\n     min_note_length = 0.1\n     max_note_length = 1\n     duration_prompt = \"Enter duration ({0} - {1}): \".format(\n         min_note_length, max_note_length\n     )\n     duration = BTCInput.read_float_ranged(\n         duration_prompt, min_value=min_note_length, max_value=max_note_length\n     )\n\n     return Note(note, duration)\n\n\n def add_note_to_tune():\n     \"\"\"\n     Adds a note to the current tune\n\n     Prompts the user to specify a new note as well as an index of\n     where to insert the note in the tune (-1 indicating append). The created\n     note is then added to the current tune at the indicated index (or appended)\n\n     Returns\n     -------\n     None\n     \"\"\"\n     print(\"Add note to current tune\")\n     new_note = get_new_note_from_user()\n     if current_tune.number_of_notes == 0:\n         current_tune.add_note(new_note)\n         print(\"Added note:\", new_note)\n         return\n\n     insert_prompt = \"Enter index to add note (0 - {0}) or -1 to append: \".format(\n         current_tune.number_of_notes - 1\n     )\n     insertion_idx = BTCInput.read_int_ranged(\n         insert_prompt, -1, current_tune.number_of_notes - 1\n     )\n     if insertion_idx == -1:\n         insertion_idx = None\n     current_tune.add_note(new_note, insertion_idx)\n     print(\"Added note:\", new_note)\n\nWe start by defining a function get_new_note_from_user\n\nGets a valid Note object from the user\nUses the class attributes on Note to limit the user’s input for the note id\nEnforces a program set limit on the duration\n\nThen define add_note_to_tune\n\nWe get a new note from the user\nIf there’s no notes on the Tune we can immediately add the note to the tune\nOtherwise we prompt the user for the index to add\n\n\\(-1\\) is used to indicate that the value should be appended\n\nCan then call the add_note method on the Tune object\n\n\nedit_note\n def edit_note():\n     \"\"\"\n     Modifies an existing note in the current tune\n\n     Prompts the user for the index of the existing note to overwrite and\n     then the details of the new note\n\n     Returns\n     -------\n     None\n     \"\"\"\n     print(\"Edit note in current tune\")\n     if current_tune.number_of_notes == 0:\n         print(\"There are no notes in the current tune to edit\")\n         return\n\n     edit_prompt = \"Enter index of note to edit (0 - {0}): \".format(\n         current_tune.number_of_notes - 1\n     )\n     insertion_idx = BTCInput.read_int_ranged(\n         edit_prompt, 0, current_tune.number_of_notes - 1\n     )\n     old_note = current_tune.remove_note(insertion_idx)\n\n     if insertion_idx == current_tune.number_of_notes:\n         insertion_idx = None  # we removed the last index, so now need to append\n\n     new_note = get_new_note_from_user()\n     current_tune.add_note(new_note, insertion_idx)\n     print(\"Note successfully edited\")\n     print(\"Note was:\", old_note)\n     print(\"Note now:\", new_note)\n\nWorks similar to add_note_to_tune\n\nThis time however we first prompt the user for which note they want to edit\n\nWe create a new Note\n“Editing” a note is achieved by removing the old note, and inserting the new note, where the old one was\n\nremove_note\n def remove_note():\n     \"\"\"\n     Remove the note at a user prompted index from the current tune\n\n     Returns\n     -------\n     None\n     \"\"\"\n     print(\"Remove note from current tune\")\n     remove_prompt = \"Enter index of note to remove (0 - {0}): \".format(\n         current_tune.number_of_notes - 1\n     )\n     remove_idx = BTCInput.read_int_ranged(\n         remove_prompt, 0, current_tune.number_of_notes - 1\n     )\n     current_tune.remove_note(remove_idx)\n\nCalling code responsible for ensuring that we don’t call this on an empty tune\nRemoves the note at the user prompted index\n\n\nWith those functions worked through that covers pretty much all the functionality of the program. You can see the full implementation in TuneCreator.py. The associated pickle file should load the example tunes we created earlier which you can play and edit to test the program",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 10: Using Classes to Create Active Objects"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/10_UseClassesToCreateActiveObjects/Chapter_10.html#notes",
    "href": "02_AdvancedProgramming/10_UseClassesToCreateActiveObjects/Chapter_10.html#notes",
    "title": "Chapter 10: Using Classes to Create Active Objects",
    "section": "",
    "text": "Program’s tend to evolve in scope over time\n\nSometimes due to scope underestimation\nAlso because customers tend to request new features\n\nConsider the Tiny Contacts\n\nClient now wants to functionality to track the time spent with a client\n\nAs usual start with the interface,\n\nTime Tracker\n\n1. New Contact\n2. Find Contact\n3. Edit Contact\n4. Add Session\n5. Exit Program\n\nEnter your command:\nWe want to now storyboard out the new Add Session option\nEnter your command: 4\nAdd Hours\nEnter the Contact Name: Rob\nName: Rob Miles\nPrevious Hours worked: 0\nSession Length: 3\nUpdated hours worked: 3.0\nWe also want to update the Find Contact option to include the hours,\nFind Contact\nEnter the Contact Name: Rob\nName: Rob Miles\nAddress: 18 Pussycat Mews, London, NE1 410S\nTelephone: 1234 56789\nHours worked: 3.0\n\n\n\nWe need to store the hours worked\nSimplest approach is to redefine the Contact class\n\nAdd an hours_worked field\n\n\n\nclass Contact:\n    \"\"\"\n    Contact with a name, address and telephone number.\n    Tracks the hours worked with a client\n\n    Attributes\n    ----------\n    name : str\n        Contact Name\n    address : str\n        Contact's postal or street address.\n    telephone : str\n        Contact phone number (stored as a string).\n    hours_worked : int | float\n        Hours worked with a Contact, initialised to 0\n\n    Examples\n    --------\n    &gt;&gt;&gt; Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"+44(1234) 56789\")\n    &lt;Contact ...&gt;\n    \"\"\"\n\n    def __init__(self, name, address, telephone):\n        \"\"\"\n        Create a new Contact instance\n\n        Parameters\n        ----------\n        name : str\n            Contact Name\n        address : str\n            Contact's postal or street address.\n        telephone : str\n            Contact phone number (stored as a string).\n        \"\"\"\n        self.name = name\n        self.address = address\n        self.telephone = telephone\n        self.hours_worked = 0\n\n\nDefaulted to 0 as part of the constructor\n\nWe might discuss this with the client, it’s possible a contact might have some initial consult hours\n\nFrom here we can add a new add_session function (see the complete updated code, in our version which supports duplicate names in the search)\n  def add_session():\n      \"\"\"\n      Prompts the user to add hours worked to contacts matching a search\n\n      Returns\n      -------\n      None\n\n      See Also\n      --------\n      find_contacts : returns contacts matching a search name\n      \"\"\"\n      print(\"add session\")\n      search_name = read_text(\"Enter the contact name: \")\n      contact = find_contact(search_name)\n      if contact != None:\n          #found a contact\n          print(\"Name: \", contact.name)\n          print(\"Previous hours worked:\", contact.hours_worked)\n          session_length = BTCInput.read_float_ranged(prompt=\"Session length: \", min_value=0.5, max_value=3.5)\n          contact.hours_worked = contact.hours_worked + session_length\n          print(\"Updated hours worked:\", contact.hours_worked)\n      else:\n          print(\"This name was not found\")\nDon’t forget we also have to update how we display contacts for the Find Contact functionality (or in our case the display_contact) function.\n\n  def display_contact(contact):\n      \"\"\"\n      Displays the Contact details for the supplied contact\n\n      Parameters\n      ----------\n      contact : Contact\n          contact to display\n\n      Returns\n      -------\n      None\n\n      See Also\n      --------\n      display_contacts : Displays all contacts matching a search name\n      \"\"\"\n      print(\"Name:\", contact.name)\n      print(\"Address:\", contact.address)\n      print(\"Telephone:\", contact.telephone)\n      print(\"Hours worked for this Contact:\", contact.hours_worked, \"\\n\")\n\nIf we create a new Contact object then we can see how this looks,\n\n  contact = Contact(name=\"Alice\", address=\"Bob St\", telephone=\"555\")\n  display_contact(contact)\n  contact.hours_worked = 5.0\n  display_contact(contact)\n\nName: Alice\nAddress: Bob St\nTelephone: 555\nHours worked for this Contact: 0 \n\nName: Alice\nAddress: Bob St\nTelephone: 555\nHours worked for this Contact: 5.0 \n\n\n\n\n\n\n\nWhen extending a program you should always look at its design\nCode rots as it gets older\n\nGets harder to maintain and understand\n\nWant to make the design as clear and simple as possible\nLike a builder we want to make houses out of walls, walls out of bricks and bricks out of clay\n\ni.e. clear progression in scale and responsibility\n\nA technique for this is called object-oriented design\n\nObjects are designed to be cohesive\nA cohesive object should contain all the attributes and methods to work with its domain\n\nFor the Contact object we want it to be responsible for all contact information\n\nCurrently not very cohesive\nTime Tracker works directly on Contact object attributes\n\nBusiness logic that applies to a Contact is outside the function\n\ne.g. in the add_session function, we have hardcoded a minimum session time of half an hour and a maximum session time of three and half hours\nThis is problematic\n\nBecause the numbers are just written there as opposed to being defined as constants with meaning (they are magic constants)\nThis data validation is external to the data storage object itself, the Contact\n\nWe also perform the act of updating the Contact’s hours worked, outside the Contact object\n\n  session_length = BTCInput.read_float_ranged(prompt=\"Session length: \", min_value=0.5, max_value=3.5)\n  contact.hours_worked = contact.hours_worked + session_length\nThe magic constant problem is one issue,\n\nIf we were to use the Contact as a libary object in another application, (like a graphical version) then we would have to maintain the validation code in two seperate places\n\n\n\n\n\n\n\n\nTip\n\n\n\nKeep Business Rules in Business Objects\nThe issue here is we have defined business rules (things our customer asks the system to do) outside of the business objects (things created to implement the customer’s system).\n\n\n\nA solution is to make the Contact object responsible for validating the session length\n\nAny application that uses the Contact object will naturally use its internal validation\nOnly one location to change now\n\n\n\n\n\n\n\nAny python code can access hours_worked in a Contact\n\nReally only need hours_worked to be accessed to,\n\nDisplay time spent with a contact\nAdd the length of a session to hours_worked\n\n\nPython objects can hold method attributes\n\nFunctions bound to the object\n\nLet us ask an object to do something\nE.g. the string object has the method upper (seen in Chapter 5)\nLet us define two method attributes for Contact\n\nRemoves the need to directly access the attribute\n\nStart by defining a method to access the hours worked\n\n\nclass Contact:\n    \"\"\"\n    Contact with a name, address and telephone number.\n    Tracks the hours worked with a client\n\n    Attributes\n    ----------\n    name : str\n        Contact Name\n    address : str\n        Contact's postal or street address.\n    telephone : str\n        Contact phone number (stored as a string).\n    hours_worked : int | float\n        Hours worked with a Contact, initialised to 0\n\n    Examples\n    --------\n    &gt;&gt;&gt; Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"+44(1234) 56789\")\n    &lt;Contact ...&gt;\n    \"\"\"\n\n    def __init__(self, name, address, telephone):\n        \"\"\"\n        Create a new Contact instance\n\n        Parameters\n        ----------\n        name : str\n            Contact Name\n        address : str\n            Contact's postal or street address.\n        telephone : str\n            Contact phone number (stored as a string).\n        \"\"\"\n        self.name = name\n        self.address = address\n        self.telephone = telephone\n        self.hours_worked = 0\n\n    def get_hours_worked(self):\n        \"\"\"\n        Get the hours worked for this contact\n        \"\"\"\n        return self.hours_worked\n\n\n\nConsider the following questions regarding the get_hours_worked function\n\nWhat is the parameter self used to accomplish?\n\nA method is part of an object\nself tells the method which object it is a part of\nThe code sample below shows how the method doesn’t need an additional reference to the Contact it refers to\n\n  # set up\n  rob = Contact(\"Rob\", \"A St\", \"1\")\n  rob.hours_worked = 1\n  jim = Contact(\"Jim\", \"B St\", \"555\")\n  jim.hours_worked = 2\n\n  # demonstration\n  rob_work = rob.get_hours_worked()\n  jim_work = jim.get_hours_worked()\n  if rob_work &gt; jim_work:\n      print(\"More work for rob\")\n  else:\n      print(\"More work for jim\")\n\nMore work for jim\n\n\n\nIs the get_hours_worked method stored when we save contact information in a file\n\nNo, if we use pickle to store a contact list, the method attributes are not stored. Pickle only stores the data attributes\n\nCan a program still access the hours_worked attribute of a Contact class\n\nYes, it can. Using method attributes to get data doesn’t stop a program accessing the data directly\nWe simply remove the desire to\nLater chapters look at techniques for enforcing this more robustly\n\n\n\nWe can create a second method to handle adding a session to a Contact\n\n  # existing class definition\n  class Contact:\n      def __init__(self, name, address, telephone):\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n          self.hours_worked = 0\n\n      def get_hours_worked(self):\n          \"\"\"\n          Gets the hours worked for this contact\n\n          Returns\n          -------\n          int | float\n              hours worked for this contact\n          \"\"\"\n          return self.hours_worked\n\n      # new method\n      def add_session(self, session_length):\n          \"\"\"\n          Adds a session (in hours) to the Contacts hours\n\n          Parameters\n          ----------\n          session_length : int | float\n              time spent on session in hours\n\n          Returns\n          -------\n          None\n          \"\"\"\n          self.hours_worked = self.hours_worked + session_length\n\nTakes two parameters\n\nself - the object the method is attached to\n\nHere the Contact being updated\n\nsession_length\n\nThe length of the session to be added\n\n\n\nYou can see the above implementation integrated into our TimeTracker implementation. Aside from defining these new functions we have to update the file scope add_session function (distinct from the class scope add_session method) and the display_contact functions to use the new methods\n\n\n\n\n\nCurrently add_session would allow function calls like,\n\n  rob = Contact(\"Rob\", \"A St\", \"555\")\n  rob.add_session(-10)\n  print(rob.get_hours_worked())\n\n-10\n\n\nLegal call\n\nMakes no logical sense\nCan’t work negative hours\n\nAt the moment the validation is performed in the global add_session function\n\nSuppose this was maintained by another team\nThey could change it, and break your code\n\n\n\n\n\n\n\n\nNote\n\n\n\nThink Carefully about Valid Input\nYou should think carefully about what is valid input for any function, especially when you restrict it. As observed here, a negative number of hours doesn’t make sense on the surface. However, it might make sense in the case of,\n\nCorrecting an overestimated number of hours\nThe Client wants to give a client a discounted number of hours\n\n\n\n\nWe want to move the validation inside the Contact object\n\nWant add_session to reject hours that are less than half-an-hour or greater than three and a half\n\nWe could add these as variables for each instance of a Contact\n\nBut they’re the same for every instance\nWould be nice to have a way to define it once for the class\n\n\n\n\n\nA class variable is data not attached to a specific object instance\nCan define the min and max hours as a class variable\n\nNo longer magic constants\nAccessible by all Contact instances\n\n\n  class Contact:\n      \"\"\"\n      Contact with a name, address and telephone number.\n      Tracks the hours worked with a client\n\n      Attributes\n      ----------\n      name : str\n          Contact Name\n      address : str\n          Contact's postal or street address.\n      telephone : str\n          Contact phone number (stored as a string).\n      hours_worked : int | float\n          Hours worked with a Contact, initialised to 0\n\n      Class Attributes\n      ----------------\n      min_session_length : Final[int | float]\n          minimum length of a billable session\n\n      max_session_length : Final[int | float]\n          maximum length of a billable session\n\n\n      Examples\n      --------\n      &gt;&gt;&gt; Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"+44(1234) 56789\")\n      &lt;Contact ...&gt;\n      \"\"\"\n\n      min_session_length = 0.5\n      max_session_length = 3.5\n\n      def __init__(self, name, address, telephone):\n          \"\"\"\n          Create a new Contact instance\n\n          Parameters\n          ----------\n          name : str\n              Contact Name\n          address : str\n              Contact's postal or street address.\n          telephone : str\n              Contact phone number (stored as a string).\n          \"\"\"\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n          self.hours_worked = 0\n\n          def get_hours_worked(self):\n              \"\"\"\n              Gets the hours worked for this contact\n\n              Returns\n              -------\n              int | float\n                  hours worked for this contact\n              \"\"\"\n              return self.hours_worked\n\n          # new method\n          def add_session(self, session_length):\n              \"\"\"\n              Adds a session (in hours) to the Contacts hours\n\n              Parameters\n              ----------\n              session_length : int | float\n                  time spent on session in hours\n\n              Returns\n              -------\n              None\n              \"\"\"\n              if session_length &lt; Contact.min_session_length or session_length &gt; Contact.max_session_length:\n                  return\n              self.hours_worked = self.hours_worked + session_length\n\nadd_session now silently rejects invalid session_length values\nThe idiom of first checking for invalid input and performing a return if encountered is called an early return and is a common technique\n\nReduces the need for indentation on the happy path - the error free path\n\nObserve we have to prefix the class variables with the class name as a namespace\nThe Final label in the docstring indicates that the session length variables are expected to be constant and should not be modified by a consuming program\n\n\n\nBuild your understanding of class variables by answering the following questions about their use-cases\n\nShould I use a class variable to hold the age of a contact?\n\nNo. Each contact will have an age, so the age must be a data attribute unique to each object instance\n\nShould I use a class variable to hold the maximum age of a contact?\n\nYes, we don’t need to store a copy of this value for every Contact instance, so it can be a class variable\n\nShould I use a class variable to hold the price per hour that the lawyer will charge?\n\nIt depends, if the lawyer charges the same for every client then it may be reasonable\nIf the lawyer wishes to charge different contacts different rates, then we would have to store it as a data attribute\n\nIn that case we might store the minimum and maximum hourly rate as class variables\n\n\n\n\n\n\n\n\nCohesion generally means objects shouldn’t expose attributes for external clients\nIdeally clients interact with a Contact via method calls\n\ne.g. get_hours_worked and add_session\nEliminates direct dependency on hours_worked data attribute\n\nIn the same vein, we don’t want users to directly interact with class variables\n\ne.g. max_session_length and min_session_length are used for internal validation\nExternal client should have no reason to directly modify them\n\nCould create a method, validate_session_length\n\nReceive a session_length argument\nReturn True if valid, else False\n\nValidation information (max_session_length and min_session_length) is held at the class level\n\nWould be nice to also have this validation method at the class level too\n\nWe can create class level methods through a Static Method\n\nStatic methods can be considered as methods defined on a class rather than an object instance\n\nWe can define one as below,\n\n  class Contact:\n      \"\"\"\n      Contact with a name, address and telephone number.\n      Tracks the hours worked with a client\n\n      Attributes\n      ----------\n      name : str\n          Contact Name\n      address : str\n          Contact's postal or street address.\n      telephone : str\n          Contact phone number (stored as a string).\n      hours_worked : int | float\n          Hours worked with a Contact, initialised to 0\n\n      Class Attributes\n      ----------------\n      min_session_length : Final[int | float]\n          minimum length of a billable session\n\n      max_session_length : Final[int | float]\n          maximum length of a billable session\n\n      Examples\n      --------\n      &gt;&gt;&gt; Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"+44(1234) 56789\")\n      &lt;Contact ...&gt;\n      \"\"\"\n\n      min_session_length = 0.5\n      max_session_length = 3.5\n\n      @staticmethod\n      def valid_session_length(session_length):\n          \"\"\"\n          Check a session length is valid\n\n          Parameters\n          ----------\n          session_length : int | float\n              length of a consult session in hours\n\n          Returns\n          -------\n          bool\n              `True` if the session length is valid else `False`\n          \"\"\"\n          if (\n              session_length &lt; Contact.min_session_length\n              or session_length &gt; Contact.max_session_length\n          ):\n              return False\n          return True\n\n      def __init__(self, name, address, telephone):\n          \"\"\"\n          Create a new Contact instance\n\n          Parameters\n          ----------\n          name : str\n              Contact Name\n          address : str\n              Contact's postal or street address.\n          telephone : str\n              Contact phone number (stored as a string).\n          \"\"\"\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n          self.hours_worked = 0\n\n      def get_hours_worked(self):\n          \"\"\"\n          Gets the hours worked for this contact\n\n          Returns\n          -------\n          int | float\n              hours worked for this contact\n          \"\"\"\n          return self.hours_worked\n\n      # new method\n      def add_session(self, session_length):\n          \"\"\"\n          Adds a session (in hours) to the Contacts hours\n\n          Parameters\n          ----------\n          session_length : int | float\n              time spent on session in hours\n\n          Returns\n          -------\n          None\n\n          See Also\n          --------\n          Contact.valid_session_length : checks a session length is valid\n          \"\"\"\n          if not Contact.valid_session_length(session_length):\n              return\n          self.hours_worked = self.hours_worked + session_length\n\nThe @staticmethod tag above the definition of valid_session_length is called a decorator\nA decorator wraps a function to modify how it works\nDecorators are added by writing @ followed by the decorator name above the function to be wrapped\n\nYou can wrap a function with multiple decorators\n\nThe @staticmethod decorator is a python language built-in\n\nConverts a method into a static method\nStatic methods can exist even without an instance of the given class\n\nStatic methods can be called directly from the class e.g.\n\n  print(Contact.valid_session_length(5))\n\nFalse\n\n\n\n\n\nInput validation is a very common use-case for static methods. Consider the following questions to understand static validation methods\n\nWhy does the valid_session_length method not have a self parameter?\n\nself refers to a particular object instance\nstatic methods are not associated with an instance\n\nAssociated with the class\nThus no self to refer to\n\n\nWhy does the valid_session_length method not print a message to the user communicating that the session length is invalid?\n\nvalid_session_length only has responsibility for checking if a session length is valid\nHow to handle an invalid session length is the responsibility of the caller\n\ne.g. a text-based vs graphical interface may want to handle this differently\n\ne.g. display text vs a window\n\n\nThis concept of making a function responsible for one thing is called either\n\nThe single responsibility principle,\nor more generally seperation of concerns\n\nHere a Contact object performs behaviours that modify or capture a the state of a clients interactions with a client\n\nHow the user responds to those states is not its responsibility\n\n\nWhat does a decorator do?\n\nA decorator is a function that wraps another function\nThey can do some work, call a function then do some clean-up\n\nCan I create my own decorators?\n\nYes\nThey are beyond the scope of this book though\n\nHow do I know when to create a static method in a class?\n\nYou want to create behaviour associated with a class, but\n\nIndependent of specific instance of a class\n\n\n\n\n\n\n\n\nadd_session prevents invalid session lengths being added to a Contact\nCurrently user has no way of knowing if a session was added\n\nMistakes might be missed\nRecords then lost\n\nNeed to indicate if add_session succeeded\nCan do so by returning a status flag from add_session rather than None\n\nTrue indicates session added\nFalse indicates session failed\n\n  def add_session(self, session_length):\n  \"\"\"\n  Adds a session (in hours) to the Contacts hours\n\n  Parameters\n  ----------\n  session_length : int | float\n      time spent on session in hours\n\n  Returns\n  -------\n  bool\n      `True` if session successfully added, else `False`\n\n  See Also\n  --------\n  Contact.valid_session_length : checks a session length is valid\n  \"\"\"\n  if not Contact.valid_session_length(session_length):\n      return False\n  self.hours_worked = self.hours_worked + session_length\n  return True\nThe calling program can then check the status\n\nBehave as appropriate on error\n\n  session_length = BTCInput.read_float(prompt=\"Session Length: \")\n  if contact.add_session(session_length):\n      print(\"Updated hours succeeded\", contact.get_hours_worked())\n  else:\n      print(\"Add hours failed\")\nThe above uses the status\n\nOn success the new hours are reported\nOn failure, the user is notified of the error\n\nThe full implementation is given in TimeTrackerWithStatusReporting.py\nThe problem with status messages is that the user can ignore them, e.g. the below variation of the previous example, ignores the return value\n\n   contact.add_session(BTCInput.read_float(prompt=\"Session Length: \"))\n   print(\"Updated hours:\", contact.get_hours_worked())\n\nThus no guarantee that failure will be handled\n\n\n\n\n\nExceptions force the caller to deal with them\n\nUnhandled exceptions crash the program\n\nExceptions are designed for when an error occurs where continuing makes no sense\n\ne.g. converting strings to numbers\nmeaningless to continue with an unconverted number\nUnless the caller specifies what to do in that case\nSo this causes an exception\n\n  x = int(\"Rob\")\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[11], line 1\n----&gt; 1 x = int(\"Rob\")\n\nValueError: invalid literal for int() with base 10: 'Rob'\n\n\n\n\nWe can make our on code throw exceptions\n\nWe use the raise keyword\n\n\n  def add_session(self, session_length):\n      \"\"\"\n      Adds a session (in hours) to the Contacts hours\n\n      Parameters\n      ----------\n      session_length : int | float\n          time spent on session in hours\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      Exception\n          Raised if invalid session length passed\n\n      See Also\n      --------\n      Contact.valid_session_length : checks a session length is valid\n      \"\"\"\n      if not Contact.valid_session_length(session_length):\n          raise Exception(\"Invalid Session Length\")\n      self.hours_worked = self.hours_worked + session_length\n\nContact’s add_session now raises an Exception if the session length is invalid\nException somewhat like a message\n\nTells the program what went wrong\n\nException class provides behaviours for exceptions\n\nTakes a string as an initialiser argument\nstring should describe the error\n\nOnce raised, the exception is either,\n\nhandled by an Except handler inside a try block\nStops the program with an error\n\nThe complete integration of the above is given byy TimeTrackerWithException.py\n\n\n\n\nInvestigate how exceptions are raised using the sample program Time Tracker with Exception\nStart a python interpreter and run the example program above, select option \\(1\\) on the menu, and enter the following,\n\n\n\nTime Tracker\n\n\n\n1. New Contact\n\n2. Find Contact\n\n3. Edit Contact\n\n4. Add Session\n\n5. Exit Program\n\n\n\nEnter your command: 1\n\nCreate new contact\n\nEnter the contact name:  Rob Miles\n\nEnter the contact address:  18 Pussycat Mews, London, NE1 410S\n\nEnter the contact phone:  1234 56789 \n\n\n\n\nNow add a session lasting 2 hours to the contact using option 4:\n\n\n\nEnter your command:  4\n\nadd session\n\nEnter the contact name:  Rob Miles\n\nName: Rob Miles\n\nPrevious hours worked: 0\n\nSession Length:  2\n\nUpdated hours worked: 2.0\n\n\n\n\nThis should work because \\(2\\) is a valid session length, now repeat but attempt to add a session length of \\(4\\), which should be invalid,\n\n\n\nEnter your command:  4\n\nadd session\n\nEnter the contact name:  Rob Miles\n\nName: Rob Miles\n\nPrevious hours worked: 2.0\n\nSession Length:  4\n\n\n\n\n\n\n\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\nCell In[16], line 3\n      1 rob = Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"1234 56789\")\n      2 add_session(rob, 2)\n----&gt; 3 add_session(rob, 4)\n\nCell In[12], line 24, in add_session(self, session_length)\n      2 \"\"\"\n      3 Adds a session (in hours) to the Contacts hours\n      4 \n   (...)     21 Contact.valid_session_length : checks a session length is valid\n     22 \"\"\"\n     23 if not Contact.valid_session_length(session_length):\n---&gt; 24     raise Exception(\"Invalid Session Length\")\n     25 self.hours_worked = self.hours_worked + session_length\n\nException: Invalid Session Length\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nOur implementation will look slightly different to the above (which is the book code) because it has additional logic for handling duplicates. But follow the steps and the prompts and you should get roughly the same process\n\n\n\n\n\n\nNow that we can raise exceptions, how do we handle them?\nWe’ve seen that we control jumps to an appropriate except but what if we want to access the message in the exception?\n\nWe can use the as keyword to assign the exception a variable label\nWe modify the user call to the Contact object, add_session as, (see the full implementation as TimeTrackerWithExceptionHandler.py)\n\n  hours_worked = BTCInput.read_float(prompt=\"Enter hours spent: \")\n  try:\n      contact.add_session(hours_worked)\n      print(\"Updated hours succeeded:\", contact.get_hours_worked())\n  except Exception as e:\n      print(\"Add failed:\", e)\nThe main change is rather than just going except Exception: we add a as e\n\nDefines a variable e that stores the exception\ne exists for the scope of the except block\n\nPassing an exception to print prints our the message associated with the exception\nA representative use might look like,\n\n\n\n\nEnter your command:  4\n\nadd session\n\nEnter the contact name:  Rob Miles\n\nName: Rob Miles\n\nPrevious hours worked: 2.0\n\nSession Length:  -1\n\nAdd failed: Invalid Session Length\n\n\n\n\n\n\n\nRepeat the steps in the previous example but this time use the new code in Time Tracker with Exceptionn Handler. You should find the program runs and the errors are captured without causing a crash\n\n\n\nConsider the following questions about dealing with exceptions\n\nWhy does this version of the program not check the result returned by add_session?\n\nThis implementation of add_session returns None\nInstead an exception is raised to indicate a failure state\nThere is therefore nothing to check\n\nIsn’t raising an exception and stopping the program when something goes wrong a bit harsh?\n\nDepends on your philosophy\nGenerally you want to avoid silent errors\ni.e. errors that are undetected by the user\nExceptions force the user to handle the error rather than silently ignore it\nIf the user wants to avoid exception handling, they can explicitly use validate_session_length\n\nCan a method be resumed once it has raised an exception?\n\nNo\nExceptions immediately terminate the normal control flow\nThe user can always call the function again\n\nWhy would you want to create your own types of exceptions?\n\nAllows any errors returned to be descriptive to your specific code\ne.g. if your program relies on a specific file being loaded you might want a more descriptive error message than the standard FileException provides\nError management and reporting should be decided early in a program\n\nShould I always use exceptions to indicate something has gone wrong?\n\nDepends\n\nYou may not care about handling all types of errors\n\nExceptions ensure errors are dealt with\n\nUser can customise the error handling in response to exception\ne.g. for a text-based vs GUI interface\n\n\nWhy have we made add_session work like this? The program worked before we made this change\n\nTechnically correct\n\nOld code used the error status to validate code\n\nArguably cleaner with the new error handling\n\nKnowledge about the Contact class has been centralised in the Contact class itself\nNo need to have external variables storing information about valid session length or doing the validation\n\nTypically a good idea to put all knowledge about a classes behaviour in the class itself\n\n\n\n\n\n\n\nClient no longer needs to directly interact with hours_worked\nHowever, client can still modify hours_worked\n\nProgrammer could accidently change the value\nCould also intentionally change it to break the code\n\nIdeally we want to prevent it being directly modified\n\n\n\n\n\n\n\nWarning\n\n\n\nPython protects against mistakes, not attacks\nPython provides features to help protect data attributes against accidental modifications. However, they don’t stop a programmer who intentionally (and perhaps maliciously) decides they want to modify the data attributes.\nThere is no mechanism in the python language to prevent another progrmmer adding code that changes hours_worked in the Contact object\n\n\n\nBy convention, python dictates that an attribute name starting with _ should not be used outside the class\n\nAlso referred to as being internal to the class\ne.g. _hours_worked means that the variable should not be touched\n  def get_hours_worked(self):\n      \"\"\"\n      Gets the hours worked for this contact\n\n      Returns\n      -------\n      int | float\n          hours worked for this contact\n      \"\"\"\n      return self._hours_worked\n\nAbove we provide a get_hours_worked method to get the value of _hours_worked\n\n_ indicates not to modify hours_worked itself\n\nNo actual protection for _hours_worked\n\nCould still be ignored by a programmer\n\nCan get greater security through, name-mangling\n\nstarting a varible name with double underscores __\n\nname-mangling makes it harder to access and modify the variable\n\n\n\nFollow the following steps to examine how to make a python class secure. Open a python interpreter and enter the statements below\n\n    class Secret:\n        def __init__(self):\n            self._secret = 99\n            self.__top_secret = 100\n\nThe above creates a class Secret which has two attributes, _secret and __top_secret\nCreate an instance of the Secret class\n\n    x = Secret()\n\nThe above creates a new instance of a Secret class and stores it with the variable x.\nTry to access the _secret attribute on x\n\n    x._secret\n\n99\n\n\nEven though we said that _ indicates we should not access the data attribute, we can see that nothing stops us from doing so\nNow try to access the __top_secret attribute\n\n    x.__top_secret\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[21], line 1\n----&gt; 1 x.__top_secret\n\nAttributeError: 'Secret' object has no attribute '__top_secret'\n\n\n\nThis time we get an AttributeError which suggests that there is no __top_secret attribute associated with the Secret class\nHowever, Python has performed some “name-mangling” to the name __top_secret. Inside the Secret class we can refer to __top_secret. Outside the class, the variable name is prepended with the class name (and an underscore). So we can still access it, as the below proves\n\n    x._Secret__top_secret\n\n100\n\n\nName-mangling thus secures us against accidental attribute use, however any one who knows the name mangling scheme and our attributes can still modify the data attribute if they want to\nThere are programs that check against this kind of bad code behaviour. One example is pylint\n\n\n\n\n\nOur current methods for the Contact class are all intended to be used by clients\n\nReferred to as public methods\n\nWe might also want to protect methods in a class\nCan use _ prefix to indicate that it should not be used\nOr __ prefix to name mangle\n\n\n\n\n\n\n\nTip\n\n\n\nWriting secure code is all about workflow\nMaking a secure program is all about establishing a workflow to generate quality code. For example, using prototypes to make sure that a customer agrees with the direction of a program early in the development\nThe next step is to sensible design and tools like pylint to make sure we’re writing good quality code.\n\n\n\n\n\n\n\nWe’ve talked about protecting hours_spent for our Contact\nWe should add more business logic to ensure that name, address and telephone items are sensible\n\nAs a purely toy example, lets say they must each be \\(4\\) characters long\n\nRealistically they would be discussed and confirmed with the customer\n\n\nclass Contact:\n\n    __min_text_length = 4\n\n    @staticmethod\n    def valid_text(text):\n        \"\"\"\n        Validates text to be stored in the contact storage\n\n        Parameters\n        ----------\n        text : str\n            text string to store\n\n        Returns\n        -------\n        bool\n            `True` if the text is valid, else `False`\n        \"\"\"\n\n        if len(text) &lt; Contact.__min_text_length:\n            return False\n        else:\n            return True\n\n\nAbove mirrors valid_session_length\nCalled to validate text to be stored in a Contact\nWe could then name mangle name, address, telephone\nSupply methods to get and set these attributes\n\ne.g. set_name and get_name for example\n\nPython has a built-in way for providing read and write access to protected data\nThis is called a Property\n\nProperties preserve simple access, while allowing us to implement validation\n\n\n\n\n\nclass Contact:\n    __min_text_length = 4\n\n    @staticmethod\n    def valid_text(text):\n        \"\"\"\n        Validates text to be stored in the contact storage\n\n        Valid input must be have a length greater than or\n        equal to Contact.__min_text_length\n\n        Parameters\n        ----------\n        text : str\n            text string to store\n\n        Returns\n        -------\n        bool\n            `True` if the text is valid, else `False`\n        \"\"\"\n        if len(text) &lt; Contact.__min_text_length:\n            return False\n        else:\n            return True\n\n    @property  # decorator makes name a property\n    def name(self):  # name of property function to get the name\n        \"\"\"\n        name : str\n            Contact Name\n\n        Raises\n        ------\n        Exception\n            raised if new name is invalid\n\n        See Also\n        --------\n        Contact.valid_text : validates text input\n        \"\"\"\n        return self.__name  # return private attribute containing the name\n\n    @name.setter  # decorator to identify the setter for name\n    def name(self, name):\n        if not Contact.validate_text(name):\n            raise Exception(\"Invalid name\")\n        self.__name = name\n\nThe code above shows how to implement a property for name in the Contact class. The property implements validation and rejects invalid names. Work through the following questions to understand properties\n\nHow does the value being set in the property get into the setter?\n\nsetter is called with two parameters\nself refers to the object on which the setter is being called\nThe second is the proposed value to set the property to\n\nHere it is setting the name attribute\n\n\nHow does the program know which setter method to call for a particular property?\n\nThe setter decorator has the format property.setter\n\nAssociates a setter to a property\n\n\nMust the setter method raise an exception if the value is being set is not valid?\n\nNo\nsetter could ignore invalid values, or assign a default\nExceptions allow us to inform the user that the set has failed\n\nAnd also forces the user to deal with the error\n\n\nDo we need to perform the same validation for all properties in a class?\n\nNo\nWe could test that telephone is purely numeric (for example)\n\nThis is not a good idea for real telephone numbers\n\nWe could ensure address matches a certain structure for a valid address\n\nMust a property have a setter?\n\nNo\nProperties without a setter are read-only\nThey cannot be modified\nWe could use this to remove the get_hours_worked method\n\nUse a property instead\n\n\n\n\n\n\nInvestigate how properties work. Open up the python interpreter and enter the statements below\n\nclass Prop:\n    @property\n    def x(self):\n        print(\"got property x\")\n        return self.__x\n    @x.setter\n    def x(self, x):\n        print(\"set property x:\", x)\n        self.__x = x\n\nThis creates a new class Prop with a property x that has a setter\nNow create an instance of this class as below\n\n    test = Prop()\n\nPut a value for x into the test instance\n\n    test.x = 99\n\nset property x: 99\n\n\nWhen python executes the above, it runs the setter method for the property. As we can see from the output above.\nNow try to read the property\n\n    print(test.x)\n\ngot property x\n99\n\n\nWhen reading the property, python runs the property method, as indicated above\nWe can combine getting and setting in complex expressions, execute the following\n\n    test.x = test.x + 1\n\ngot property x\nset property x: 100\n\n\nWe can see that first the getter is called to get the current value of x, then the setter is called to update it to the expression on the right\nTo convert the Contact class to use properties for name, telephone and address we have to add properties and then setters\n\nThe relevant changes to the Contact class are then,\n\n\nclass Contact:\n    \"\"\"\n    Contact with a name, address and telephone number.\n    Tracks the hours worked with a client\n\n    Attributes\n    ----------\n    name : str\n        Contact Name\n    address : str\n        Contact's postal or street address.\n    telephone : str\n        Contact phone number (stored as a string).\n\n\n    Examples\n    --------\n    &gt;&gt;&gt; Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"+44(1234) 56789\")\n    &lt;Contact ...&gt;\n    \"\"\"\n\n    __min_session_length = 0.5\n    __max_session_length = 3.5\n\n    @staticmethod\n    def valid_session_length(session_length):\n        \"\"\"\n        Check a session length is valid\n\n        Parameters\n        ----------\n        session_length : int | float\n            length of a consult session in hours\n\n        Returns\n        -------\n        bool\n            `True` if the session length is valid else `False`\n        \"\"\"\n        if (\n            session_length &lt; Contact.__min_session_length\n            or session_length &gt; Contact.__max_session_length\n        ):\n            return False\n        return True\n\n    __min_text_length = 4\n\n    @staticmethod\n    def valid_text(text):\n        \"\"\"\n        Validates text to be stored in the contact storage\n\n        Valid input must be have a length greater than or\n        equal to Contact.__min_text_length\n\n        Parameters\n        ----------\n        text : str\n            text string to store\n\n        Returns\n        -------\n        bool\n            `True` if the text is valid, else `False`\n        \"\"\"\n        if len(text) &lt; Contact.__min_text_length:\n            return False\n        else:\n            return True\n\n    @property\n    def name(self):\n        \"\"\"\n        name : str\n            Contact Name\n\n        Raises\n        ------\n        Exception\n            raised if new name is invalid\n\n        See Also\n        --------\n        Contact.valid_text : validates text input\n        \"\"\"\n        return self.__name\n\n    @name.setter\n    def name(self, name):\n        if not Contact.valid_text(name):\n            raise Exception(\"Invalid name\")\n        self.__name = name\n\n    @property\n    def address(self):\n        \"\"\"\n        address : str\n            Contact Address\n\n        Raises\n        ------\n        Exception\n            raised if new address is invalid\n\n        See Also\n        --------\n        Contact.valid_text : validates text input\n        \"\"\"\n        return self.__address\n\n    @address.setter\n    def address(self, address):\n        if not Contact.valid_text(address):\n            raise Exception(\"Invalid address\")\n        self.__address = address\n\n    @property\n    def telephone(self):\n        \"\"\"\n        telephone : str\n            Contact Telephone\n\n        Raises\n        ------\n        Exception\n            raised if new telephone is invalid\n\n        See Also\n        --------\n        Contact.valid_text : validates text input\n        \"\"\"\n        return self.__telephone\n\n    @telephone.setter\n    def telephone(self, telephone):\n        if not Contact.valid_text(telephone):\n            raise Exception(\"Invalid telephone\")\n        self.__telephone = telephone\n\n    def __init__(self, name, address, telephone):\n        \"\"\"\n        Create a new Contact instance\n\n        Parameters\n        ----------\n        name : str\n            Contact Name\n        address : str\n            Contact's postal or street address.\n        telephone : str\n            Contact phone number (stored as a string).\n        \"\"\"\n        self.name = name\n        self.address = address\n        self.telephone = telephone\n        self.__hours_worked = 0\n\n\nThe great thing about properties is they can be effectively drop in for traditional attributes\n\nWe make the attributes themselves name mangled\nDefine properties to mask the original names\n\nNo need to update the downstream calling code\n\nproperty syntax matches the traditional access pattern\n\nThe complete integration is seen in TimeTrackerWithPropertie.py\n\n\n\n\n\n\n\nCaution\n\n\n\nFailures in property code can be confusing\nThe example program implements the name, address and telephone number elements of a contact as properties. Setting a property to an invalid value will cause an exception. The initialiser looks like,\n    def __init__(self, name, address, telephone):\n        self.name = name\n        self.address = address\n        self.telephone = telephone\n        self.__hours_worked = 0\nThese statements look like normal variable assignments, nothing here indicates that these steps can fail. However, the following statement fails,\n\n    rob = Contact(name=\"Rob\", address=\"18 Pussycat Mews, London NE1 410S\", telephone=\"1234 56789\")\n\n\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\nCell In[31], line 1\n----&gt; 1 rob = Contact(name=\"Rob\", address=\"18 Pussycat Mews, London NE1 410S\", telephone=\"1234 56789\")\n\nCell In[30], line 154, in Contact.__init__(self, name, address, telephone)\n    141 def __init__(self, name, address, telephone):\n    142     \"\"\"\n    143     Create a new Contact instance\n    144 \n   (...)    152         Contact phone number (stored as a string).\n    153     \"\"\"\n--&gt; 154     self.name = name\n    155     self.address = address\n    156     self.telephone = telephone\n\nCell In[30], line 92, in Contact.name(self, name)\n     89 @name.setter\n     90 def name(self, name):\n     91     if not Contact.valid_text(name):\n---&gt; 92         raise Exception(\"Invalid name\")\n     93     self.__name = name\n\nException: Invalid name\n\n\n\nThe above raises an exception because the value Rob passed for the name property is too short. __init__ attempts to set name which calls the setter, and the property code raises an exception.\nProgrammers may expect methods or functions to cause exceptions but they typically do not expect statements that look like variable assignments. When implementing properties you need to be clear about how they work and how to handle failure.\nWe could extend our previous error handling code to add additional exception handlers to handle invalid assignments\n\n\n\n\n\n\n\nScenario\nThe lawyer likes your program but would now like to use it for billing. The program should track both the hours worked for a client and the the billing amount owed by each contact\nPrices are calculated as follows, for every session worked there is - A $30 flat case fee - A $50 hourly fee\nFor example a one hour session would cost $80\nThe client wants the billing amount to be automatically updated each time they add a session. Displaying a contact should then also display the billing amount\nName: Rob Miles\nAddress: 18 Pussycat Mews, London, NE1 410S\nTelephone: 1234 56789\nHours on the case: 2.0\nBilling amount: 130.0\n\n\n\nWork through the following questions to understand how we design managing the billing amount\n\nHow would we store the billing amount for a contact?\n\nStore as a data attribute on a Contact object\nManage like __hours_worked with validators\nLet’s call it __billing_amount\n\nWhy does __billing_amount have two leading underscores in the name?\n\nIndicates the variable is private to the class\nProvides name-mangling to reduce chance for accidental use\nProvide access via a read-only property\n  @property\n  def billing_amount(self):\n      return self.__billing_amount\nWe omit a setter, the property cannot be directly modified\nCan then access the property as we would expect\n  print(\"Rob owes:\", rob.billing_amount)\nSame output might look like,\n  #| echo: false\n  print(\"Rob owes:\", 130.0)\n\nWhat would the statement calculating the billable amount for a session look like?\n\nAt it’s most basic the statement might look like,\n  amount_to_bill = 30 + (50 * session_length)\nsession_length value is multipled by the hourly rate (\\(50\\))\nflat fee \\(30\\) is added to the total\nCan then add this to the billing amount\n  self.__billing_amount = self.billing_amount + amount_to_bill\nObserve that this approach means that each session incurs the same \\(30\\) case opening fee\nIt’s possible multiple sessions might be spent on the same case\n\nMight not incur the \\(30\\) fee each time\nThis would be something to confirm with the client\n\n\nIs it sensible to just use the values \\(30\\) and \\(50\\) in this code?\n\nNo\nThey are magic constants\nBetter to make them internal class variables of the Contact class\n  class Contact\n      __open_fee = 30\n      __hourly_fee = 50\nObserve that we flag them as private, they are internals for the class\nThe new amount to bill statement is then,\n  amount_to_bill = Contact.__open_fee + (Contact.__hourly_fee * session_length)\n\nWhere should the above statement go?\n\nAdjusting the billing is something that occurs when we add a session\nMakes sense to go in the add_session code of the Contact class\n  def add_session(self, session_length):\n      \"\"\"\n      Adds a session (in hours) to the Contacts hours\n\n      Updates the Contact's session hours and calculates\n      the billable amount owed\n\n      Parameters\n      ----------\n      session_length : int | float\n          time spent on session in hours\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      Exception\n          Raised if invalid session length passed\n\n      See Also\n      --------\n      Contact.valid_session_length : checks a session length is valid\n      \"\"\"\n      if not Contact.validate_session_length(session_length):\n          raise Exception(\"Invalid session length\")\n      self.__hours_worked = self.__hours_worked + session_length\n      amount_to_bill = Contact.__open_fee + (Contact.__hourly_fee * session_length)\n      self.__billing_amount = self.__billing_amount + amount_to_bill\n      return\nBilling amount is updated after we have validated and updated the hours worked\n\n\n\nWe change the display_contact method to add the billing amount\n\ndef display_contact(contact):\n    \"\"\"\n    Displays the Contact details for the supplied contact\n\n    Parameters\n    ----------\n    contact : Contact\n        contact to display\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_contacts : Displays all contacts matching a search name\n    \"\"\"\n    print(\"Name:\", contact.name)\n    print(\"Address:\", contact.address)\n    print(\"Telephone:\", contact.telephone)\n    print(\"Hours worked for this Contact:\", contact.get_hours_worked(), \"\\n\")\n    print(\"Amount to bill:\", contact.billing_amount)\n\nThe complete program can be found in Time Tracker with Billing Amount\n\n\n\n\n\nThe new program works, but it has a problem\nContacts saved under the old system, won’t work\n\nThey will load\nBut whe we try to display or add a session we’ll get an error, like\n\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[32], line 1\n----&gt; 1 raise AttributeError(\"'Contact' object has no attribute '_Contact__billing_amount'\")\n\nAttributeError: 'Contact' object has no attribute '_Contact__billing_amount'\n\n\n\n\nThis occurs because the program attempts to access the __billing_access attribute\nOld versions of the Contact class didn’t have this\n\nSo error occurs\n\nSame might occur if we make more modifications in the future\n\n\n\n\nWe can solve this by versioning a class\nAdd a version attribute to each class\n\nSimply a numeric attribute\n\n  def __init__(self, name, address, telephone):\n      \"\"\"\n      Create a new Contact instance\n\n      Parameters\n      ----------\n      name : str\n          Contact Name\n      address : str\n          Contact's postal or street address.\n      telephone : str\n          Contact phone number (stored as a string).\n      \"\"\"\n      self.name = name\n      self.address = address\n      self.telephone = telephone\n      self.__hours_worked = 0\n      self.__billing_amount = 0\n      self.__version = 1\nversion is set as a private variable\n\n\n\n\n\nThen create a method to check the version of a Contact\n\nLet’s us check that a Contact object matches the current version\n\n  def check_version(self):\n      \"\"\"\n      Check the version of a Contact instance\n\n      Upgrades the instance to the most recent version\n      if required\n      \"\"\"\n      pass\nLeave it as a stub for now\nWe want to use it when we load contacts to check versions\nUpdated load_contacts is below\n  def load_contacts(file_name):\n  \"\"\"\n  Loads the contacts from the given file\n\n  Contacts are stored in binary as a pickled file\n\n  Parameters\n  ----------\n  file_name : str\n      string giving the path to the file where the contacts data is stored\n\n  Returns\n  -------\n  None\n      Contact detail is loaded into the global contacts value\n\n  Raises\n  ------\n      Exceptions if contacts failed to load\n\n  See Also\n  --------\n  save_contacts : saves contacts to a pickled file\n  \"\"\"\n  global contacts\n  print(\"Load contacts\")\n  with open(file_name, \"rb\") as input_file:\n      contacts = pickle.load(input_file)\n  # Update version of loaded contacts if required\n  for contact in contacts:\n      contact.check_version()\n\n\n\n\n\nNow we want to write code to upgrade a Contact\nFor our version \\(1\\), we want to upgrade any class that does not have a __billing_amount attribute\nIn future we might define a version \\(2\\), then we would redefine the check_version method to upgrade any class that isn’t version \\(2\\)\n  def check_version(self):\n  \"\"\"\n  Check the version of a Contact instance\n\n  Upgrades the instance to the most recent version\n  if required\n  \"\"\"\n  try:\n      if not self.__version == 1:\n          self.__billing_amount = 0\n          self.__version = 1\n  except AttributeError:\n      self.__billing_amount = 0\n      self.__version = 1\nWe first attempt to check the version number\nIf it’s not the current version (\\(1\\)) we upgrade the class\n\nAdd a .__billing_amount attribute defaulted to zero\nUpgrade the version number\n\nUse a try...except block to catch the AttributeError if the version doesn’t exist (i.e. for old instances pre-versioning)\n\nPerform the upgrade\n\n\n\n\n\nTo get a better understanding of versioning, work through the following steps\nStart by running the program TimeTrackerWithPropertiesAndExceptionHandling.py. Create a new contact as below\n\n\n\nEnter your command: 1\n\nCreate new contact\n\nEnter the contact name: Rob Miles\n\nEnter the contact address: 18 Pussycat Mews, London, NE1 410S\n\nEnter the contact phone: 1234 56789\n\n\n\n\nThis creates a new contact, which looks like, (use Find Contact)\n\n\nName: Rob Miles\nAddress: 18 Pussycat Mews, London, NE1 410S\nTelephone: 1234 56789\nHours on the case: 0\n\n\nAs we can see this version is missing the billable hours information\nExit the program so the contact is saved. Now load this pickle file with TimeTrackerWithVersion.py\nThis should load the contact (which is unversioned), and upgrade it to the versioned variant with a billing amount\nAttempt to display this contact, you should see something like\n\n\nName: Rob Miles\nAddress: 18 Pussycat Mews, London, NE1 410S\nTelephone: 1234 56789\nHours on the case: 0\nAmount to bill: 0\n\n\nAs we can see, the amount to bill is now correctly displayed\n\n\n\n\n\n\nImportant\n\n\n\nAdd version management when you design data storage\nWhen starting a project you should consider which items are being stored and if they need version management. For example in the Time Tracker program we expect that the client will request changes to the features, so we should consider versioning it from the start\nEverytime a new version of a program is installed, we then have to go through the process of updating the underlying data to the new version\nWhen writing a program for a customer, you should consider how long it will take to write code that deal with data updates (or migrations). This can make trivial programs significantly more complex\n\n\n\n\n\n\n\nEach time we add a new attribute to the Contact class we have to modify display_contact\nWould be nice just to be able to print a Contact directly\nHowever, doing so, we find the output is pretty useless (using the mock below)\n\n  class Contact:\n      def __init__(self, name, address, telephone):\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n\n  contact = Contact(\"Rob Miles\", \"Pussycat Mews\", \"1234\")\n\n  def display_contact(contact):\n      print(contact)\n\n  display_contact(contact)\n\n&lt;__main__.Contact object at 0x7f59143ac5f0&gt;\n\n\ndefault for objects is the class name following by the memory address of the object\npython objects have a __str__ method\n\nUsed whenever the an object needs to be converted to a string\n\nTo change the default behaviour for our objects we need to redefine __str__\n  class Contact:\n      ...\n      def __str__(self):\n          return \"Name: \" + self.name + \"\\n\" + \\\n          \"Address: \" + self.address + \"\\n\" + \\\n          \"Telephone: \" + self.telephone + \"\\n\" + \\\n          \"Hours on the case: \" + str(self.hours_worked) + \"\\n\" + \\\n          \"Amount to bill: \" + str(self.billing_amount)\nThe \\ character above is used to continue the string onto a new line\nprinting now, we get what we expect\n\n  display_contact(contact)\n\nName: Rob Miles\nAddress: Pussycat Mews\nTelephone: 1234\nHours on the case: 0\nAmount to bill: 0\n\n\n\n\n\n\nWriting the string as a series of concatenations isn’t the cleanest\nDifficult to maintain and ensure correctness as we modify the class\nWe can use format to create a formatted string\n\nLets us write a shorter string\nformat is a string method\nformat takes in values as arguments and injects them into the string\n\n  class Contact:\n      ...\n      def __str__(self):\n          template = \"\"\"Name: {0}\nAddress: {1}\nTelephone: {2}\nHours on the case: {3}\nAmount to bill: {4}\"\"\"\n          return template.format(self.name, self.address, self.telephone, self.hours_worked, self.billing_amount)\nValues in format are inserted at marked points in the string\nMarked points are {n} where \\(n\\) is the index of the argument to substitue\n\nStarting from \\(0\\)\n\n\n\n\n\nOpen the python interpreter and work through the following steps to understand how string formatting works\nEnter the statements below\n\nname = \"Rob Miles\"\nage = 21\n\nThe above creates two variables name and age\nNow create the following template string\n\ntemplate = \"My name is {0} and my age is {1}\"\n\nThe just creates a string called template, {0} and {1} are two placeholder indicators for the format function\nNow call the format method on template\n\ntemplate.format(name, age)\n\n'My name is Rob Miles and my age is 21'\n\n\nAs we can see the placeholder values have been substituted with the values of the name and age value\nWe can add additional formatting information. Redefine and format the template as follows\n\ntemplate = \"My name is {0:20} and my age is {1:10}\"\ntemplate.format(name, age)\n\n'My name is Rob Miles            and my age is         21'\n\n\nWe write the placeholder as {n:w} where \\(n\\) is the index of the placeholder. \\(w\\) is the width value, as you can see from above, the value is still substituted but then spaces are added to pad out to the width. This is useful for defining columns. We use a : to seperate the format specifiers from the placeholder index\nFor floating point values you can also specify the number of decimal places to be printed\n\ntemplate = \"My name is {0:20} and my age is {1:10.2f}\"\ntemplate.format(name, age)\n\n'My name is Rob Miles            and my age is      21.00'\n\n\nThe above now prints the age with two decimal places. The full details of the string formatting mini language can be found at the python docs\nYou can find the full version of Time Tracker using the string method in\n\n\n\n\n\n\nOur client now gives us a new scenario\n\n\nThe client would like to record when each specific session for a contact took place. You and the client specify the following design,\n\nTime Tracker\n1. New Contact\n2. Find Contact\n3. Edit Contact\n4. Add Session\n5. Exit Program\n\nEnter you command: 2\nEnter  the contact name: Rob\nName: Rob Miles\nAddress: 18 Pussycat Mews, London, NE1 410S\nTelephone: 1234 56789\nHours on the case: 10.0\nAmount to bill: 470.0\nSessions\nDate: Mon Jul 10 11:30:00 2017 Length: 1.0\nDate: Tue Jul 12 11:30:00 2017 Length: 2.0\nDate: Wed Jul 19 11:30:00 2017 Length: 2.5\nDate: Wed Jul 26 10:30:00 2017 Length: 2.5\nDate: Mon Jul 31 16:51:45 2017 Length: 1.0\nDate: Mon Aug 14 16:51:45 2017 Length: 1.0\n\n\nFinding a contact now displays the sessions as a list\nNot immediately clear how we would add this to our class\n\n\n\nLet’s do some design work, for handling a session. Work through the following questions\n\nHow will we store information about a session?\n\nWe need to store a bunch of heterogenous related data\nGood idea to consider a class, say Session\nNeed to consider data to store\n\nlength of a session\ndate and time of the session\n\nWe should also move the Contact class attributes validating a session length to the Session class\n\n\n import time\n class Session:\n     \"\"\"\n     Session with a length and a date time it was conducted\n     \"\"\"\n\n     __min_session_length = 0.5\n     __max_session_length = 3.5\n\n     @staticmethod\n     def valid_session_length(session_length):\n         \"\"\"\n         Check a session length is valid\n\n         Parameters\n         ----------\n         session_length : int | float\n             length of a consult session in hours\n\n         Returns\n         -------\n         bool\n             `True` if the session length is valid else `False`\n         \"\"\"\n         if (\n             session_length &lt; Session.__min_session_length\n             or session_length &gt; Session.__max_session_length\n         ):\n             return False\n         return True\n\n     def __init__(self, session_length):\n         \"\"\"\n         Create a new Session instance\n\n         Parameters\n         ----------\n         session_length : int | float\n             length of a session\n\n         Raises\n         ------\n         Exception\n             Raised if `session_length` is invalid\n\n         See Also\n         --------\n         Session.valid_session_length : validates session lengths\n         \"\"\"\n         if not Session.valid_session_length(session_length):\n             raise Exception(\"Invalid session length\")\n         self.__session_length = session_length\n         self.__session_end_time = time.localtime()\n         self.__version = 1\n\n\nWe can now create Session objects\n\n  session_length = 2\n  session_record = Session(session_length)\n  print(session_record)\n\n&lt;__main__.Session object at 0x7f59143153d0&gt;\n\n\ncreates a Session with the passed session_length parameter\nvalidate_session_length moved to Session\n\nvalidates session lengths at object creation\nException raised if invalid session length is passed\n\n__init__ uses time library to get the local time\n\nStored in __session_end_time attribute\n\n\nAre we using version control for the Session class?\n\nYes\nHighly likely the Session object might change\nEspecially if we change our mind on what responsibility is in the Contact class vs the Session class\nThus also want to implement a check_version method\n  def check_version(self):\n      \"\"\"\n      Check the version of a Contact instance\n\n      Upgrades the instance to the most recent version\n      if required\n      \"\"\"\n      pass\nCurrently does nothing\n\nAll Session instances will be versioned\nOnly one version, so no need to edit\n\n\nHow will we allow users of the Session class to get the session length and session end time items from a Session object?\n\nWe add these as properties\nWant these to be read-only so no setter is provided\n\n @property\n def session_length(self):\n     \"\"\"\n     session_length : int | float\n         length (in hours) of this session\n     \"\"\"\n     return self.__session_length\n\n @property\n def session_end_time(self):\n     \"\"\"\n     session_end_time : time.struct_time\n         date and time of the session\n     \"\"\"\n     return self.__session_end_time\nWill the Session class have a __str__ method?\n\nYes\nReturn a string describing a Session instance\n\n def __str__(self):\n     template = \"Date: {0} Length: {1}\"\n     #convert time object string\n     date_string = time.asctime(self.__session_end_time)\n     return template.format(date_string, self.__session_length)\n\ntime library contains asctime\n\nTakes a localtime value and returns a string representation\n\nThen format the string\n\n\n\nGiven the Session object, we now need to incorporate this into the Contact object\nContact objects contain a list of sessions\n\nInitialised empty\n\nWe also need to bump the version number\n\nWhich means we also need to update the check_version method\nNow need to handle the conversion from no version to version 2 and version 1 to version 2\n\n  def check_version(self):\n      \"\"\"\n      Check the version of a Contact instance\n\n      Upgrades the instance to the most recent version\n      if required. This includes upgrading any Session\n      instances associated with this Contact instance\n\n      See Also\n      --------\n      Session.check_version : Checks and upgrades Session instances\n      \"\"\"\n      try:\n          if self.__version == 1:\n              # does not have session list\n              self.__sessions = []\n              self.__version = 2\n      except AttributeError:\n          self.__billing_amount = 0\n          self.__sessions = []\n          self.__version = 2\n\n      # now upgrade all sessions in a contact\n      for session in self.__sessions:\n          session.check_version()\nAny version \\(1\\) instance will be upgraded to version \\(2\\)\nFor old, unversioned instances, we still use the try...except to force an upgrade to the most recent\nWe also want to check that the sessions stored with a Contact are up to date\n\nSo after upgrading a Contact we check that the Session instances are up to date\n\nWe’ve written the code so that if the Session is upgraded, instances will still be upgraded even if the Contact object is the most recent version\nWe now need to modify adding a session to add a new Session instance, rather than just update the hours\n  def add_session(self, session_length):\n      \"\"\"\n      Adds a session (in hours) to the Contacts sessions\n\n      Parameters\n      ----------\n      session_length : int | float\n          time spent on session in hours\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      Exception\n          Raised if invalid session length passed\n\n      See Also\n      --------\n      Contact.valid_session_length : checks a session length is valid\n      \"\"\"\n      try:\n          self.__sessions.append(Session(session_length))\n          self.__hours_worked = self.__hours_worked + session_length\n          amount_to_bill = Contact.__open_fee + (\n              Contact.__hourly_fee * session_length\n          )\n          self.__billing_amount = self.__billing_amount + amount_to_bill\n      except Exception as e:\n          print(e)\nWe could validate the session length in add_session explicitly\n\nHowever, the Session constructor does this, via exceptions\n\nWe first try to create the Session\n\nIf it’s invalid we get an exception which we catch and handle\n\nIf created successfully we then update the hours worked and amount to bill\nLast step is to now work out how we want to display our Session instances when we report on a client\n\nOur client wants a line for each individual session\nWe need to convert the list of sessions to a string in this format\n\n  @property\n  def session_report(self):\n      \"\"\"\n      session_report : str\n          provides a string representation of a Contact's sessions\n      \"\"\"\n\n      # map converts each session to a string\n      report_strings = map(str, self.__sessions)\n      result = \"\\n\".join(report_strings)\n      return result\nUses map to convert a list of session objects to a list of their string representations\nUses join to then convert the list of strings to a single string with each element seperated by a newline\n\n\n\n\n\nOur aim is to convert a list of Session objects into a list of strings\nCould do this with a loop\nAlternative is to use map\nmap takes two arguments\n\nA function name\n\nThe function must accept a single argument and return a result\n\nList of items to apply the function to\n\nfunctions can be stored in variables and passed as arguments\nmap applies the function provided (first argument) to the list (second argument) and returns the result\n\n\n\nThese next few steps go on for a quite a while. So work through it at your own pace. However, this will give you a good understanding of not just map but also some fundamentals for python\nOpen up a python interpreter and work through the following steps. We’ll use map to indent a list of strings. Run the following steps\n\ncode = ['line1', 'line2', 'line3']\n\nThis creates a list containing three strings, we can easily view the contents\n\ncode\n\n['line1', 'line2', 'line3']\n\n\nNow we need to create our indentation function. We can do this by adding four spaces (or a tab etc.) at the beginning of a string. Define the following python funcion\n\ndef indent(x):\n    return \"    \" + x\n\nWe can test this function, on a sample string,\n\nprint(\"Rob\")\nindent(\"Rob\")\n\nRob\n\n\n'    Rob'\n\n\nWe would like to apply the indent function to every string in the code list. We could do this using a for loop, instead we use a map function\nNow run the following statements\n\nindented_code = map(indent, code)\nindented_code\n\n&lt;map at 0x7f5914314100&gt;\n\n\nNaively we expected a list of indented strings. Instead we have something called a map object. map returns something called an iterator. Iterators return items from a collection or sequence one at a time. We can work through iterators using a for loop. This is how we can work through lists. range also returns an iterator\nNow run the following for loop to get the indented_code values\n\nfor s in indented_code:\n    print(s)\n\n    line1\n    line2\n    line3\n\n\nNow we have the list of strings as we were expecting. Each time around the loop the next s value is retrieved from the iterator\nIterators allow us to save memory, rather than having to store the entire result in memory we can simply generate each one as needed. Each time we ask for a new result from the map object, map gets the next value from the original collection (code) and applies the function indent to it. Once the map iterator runs out of values to return, it raises StopIteration as an exception. This stops the loop.\nLets explore this in more detail\nRecreate the statement creating the map\n\nindented_code = map(indent, code)\n\nWe can then ask for the next item from an iterator using the __next__ method.\nCall this method on indented_code\n\nindented_code.__next__()\n\n'    line1'\n\n\nWe can see this produces the next value, though in this case, it’s the first item. We can keep repeating this\nRun the following\n\nprint(indented_code.__next__())\nprint(indented_code.__next__())\nprint(indented_code.__next__())\n\n    line2\n    line3\n\n\n\n---------------------------------------------------------------------------\nStopIteration                             Traceback (most recent call last)\nCell In[54], line 3\n      1 print(indented_code.__next__())\n      2 print(indented_code.__next__())\n----&gt; 3 print(indented_code.__next__())\n\nStopIteration: \n\n\n\nWe can see that we get the next two items from the iterator, and then finally after trying to get an non-existent value we see a StopIteration exception is raised\nYou can’t reuse a iterator once it has run out of items. You have to recreate it\n\nindent_iterator = map(indent, code)\n\nIf we want to convert this to normal collection, we can do something like call list to convert to a list\nCheck this out by running the following statements\n\nindented_code = list(indent_iterator)\nindented_code\n\n['    line1', '    line2', '    line3']\n\n\nWhat happens if we make the input of a map function an iterator\nEnter the following statements to explore\n\ni1 = map(indent, code)\ni2 = map(indent, i1)\n\nWe first create the iterator i1 to apply the indent function to the list code. We then create a second iterator i2 to apply the indent function to the items of the i1 iterator\nUse list to convert i2 to a list\n\nlist(i2)\n\n['        line1', '        line2', '        line3']\n\n\nWe can see that each item is indented twice. Once by i1 and again by i2. Observe that the nested iterator i1 was also applied as part of the conversion process. Python makes it very easy to chain iterators together\nLet us return to our original use of map\nreport_strings = map(str, self.__sessions)\nHere self.__sessions is a list of Session objects. map creates an iterator that applies str to each element of self.__sessions. str itself converts each Session to a string by calling the __str__ method. We then use the join method to work through this iterator to build the final output string\n\n\n\n\n\nWe can call string methods on string literals, e.g.\n\n  \"FRED\".lower()\n\n'fred'\n\n\nAnother string method is join\nTakes an iterator as an argument\njoin merges all strings in an iterator\n\nthe string on which join is called is inserted between each item\n\n\n  report_strings = [\"1\", \"2\", \"3\"]\n  report_results = \"\\n\".join(report_strings)\n\n\n\n\nWork through the following steps with the python interpreter to understand join\nEnter the statement below\n\nreport_strings = [\"report1\", \"report2\", \"report3\", \"report4\"]\n\nThe above creates a list of four strings, report_strings. Lists are iterators so we can pass this to join\nCall the join function as below\n\n\"**\".join(report_strings)\n\n'report1**report2**report3**report4'\n\n\nAs observed we iterate over the strings, merging them with ** inserted in between. Observe that ** is not placed at the start or end of the resulting string\nRerun the statement with the newline character below\n\nprint(\"\\n\".join(report_strings))\n\nreport1\nreport2\nreport3\nreport4\n\n\nThis does the same but instead each string is printed on its own line\nWe can use join to concatenate strings by using the empty string\nRun the following statement\n\n\"\".join(report_strings)\n\n'report1report2report3report4'\n\n\n\nAfter this discussion, we have completed this version of the Time Tracker\nAside from one final thing, updating the __str__ method in Contact to use the session_report property\n  def __str__(self):\n      template = \"\"\"Name: {0}\n  Address: {1}\n  Telephone: {2}\n  Hours on the case: {3}\n  Amount to bill: {4}\n  Sessions: \\n{5}\"\"\"\n      return template.format(\n          self.name,\n          self.address,\n          self.telephone,\n          self.hours_worked,\n          self.billing_amount,\n          self.session_report,\n      )\nYou can find the final implementation in Time Tracker with Session History\n\n\n\n\n\nThe time tracker application is a very good starting point for any program that you might like to write that stores and manages information. You could replace the sessions with albums and music tracks, salesman and sales artists and pictures - or anything else you want to track\nIn the previous chapter we created a Music Storage app that stored songs and could be used to manage a single playlist. Using the framework provided by Time Tracker extend the Music Storage app to be able to manage and store multiple playlists at a time\nThankfully this isn’t as in depth as building the application the first time around. We start by defining our Playlist class\nLet us first focus on the data attributes, we want a name and a list of songs. We also want the total runtime. Now for simplicity we’ll leave the name and tracks as public attributes, but we’ll define the runtime as a property, intefacing with a protected variable __runtime. We do this because the runtime is calculated from tracks so we don’t want the caller to modify it themselves.\nInspired by Time Tracker’s session_report we’ll also define a track_report property using that interfaces with map to provide a string representation of the tracks in a playlist where each track is on its own line\nclass Playlist:\n    \"\"\"\n    A class representing a music playlist with a name and list of tracks\n\n    Tracks and records the length of the playlist\n    \"\"\"\n\n    def __init__(self, name, tracks=[]):\n        \"\"\"\n        Create a new Playlist instance\n\n        Parameters\n        ----------\n        name : str\n            name to associate with the playlist\n        tracks : list, optional\n            list of songs in the playlist, by default []\n        \"\"\"\n        self.name = name\n        self.tracks = tracks\n        self.__runtime = 0\n        for song in self.tracks:\n            self.__runtime += song.length_in_seconds\n\n    def __str__(self):\n        template = \"\"\"Playlist: {0}\nTotal Length: {1} s\nSongs:\n{2}\"\"\"\n        return template.format(self.name, self.runtime, self.track_report)\n\n    @property\n    def runtime(self):\n        \"\"\"\n        runtime : int\n            total run time of the playlist in seconds\n        \"\"\"\n        return self.__runtime\n\n    @property\n    def track_report(self):\n        \"\"\"\n        track_report : str\n            string representation of tracks in the playlist, giving each track\n            on its own line\n        \"\"\"\n        song_strings = map(str, self.tracks)\n        return \"\\n\".join(song_strings)\nObserve that the constructor takes an optional list of tracks (by default its empty). This means that a user can create a Playlist by name only and then add songs to it (as used in create_playlist below) or we can create a playlist with a list of songs already (as used by suggest_playlist_of_given_length)\nNow we want to keep the internal track list and the runtime synchronised, so we add methods on the Playlist class to handle adding, removing and clearing tracks from the playlist\ndef add_track(self, track):\n    \"\"\"\n    Add a new track to the playlist\n\n    Updates the playlist length\n\n    Parameters\n    ----------\n    track : MusicTrack\n        track to add to the playlist\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    Playlist.remove_track : removes a track from a playlist\n    \"\"\"\n    # first update runtime so a non-track objects causes an error\n    self.__runtime += track.length_in_seconds\n    self.tracks.append(track)\n\ndef remove_track(self, track):\n    \"\"\"\n    Remove a track from the playlist\n\n    Parameters\n    ----------\n    track : MusicTrack\n        track to remove from the playlist\n\n    See Also\n    --------\n    Playlist.add_track : add a track to a playlist\n    Playlist.clear_tracks : remove all tracks from a playlist\n    \"\"\"\n    try:\n        self.tracks.remove(track)\n        self.__runtime -= track.length_in_seconds\n    except ValueError:\n        print(\"Could not find track:\", track.name, \"in the playlist\")\n\ndef clear_tracks(self):\n    \"\"\"\n    Remove all tracks from a playlist\n\n    Runtime is set to 0\n    \"\"\"\n    self.tracks.clear()\n    self.__runtime = 0\nThese are all relatively simple, the takeaway is that as we update the track list, we also ensure the runtime is kept synchronised\n\n\n\n\n\n\nWarning\n\n\n\nIt is important to keep data synchronised\nWe store the runtime as a seperate variable so that we don’t need to calculate it on the fly everytime a function requires it. However this introduces the difficulty that we have to keep runtime synched with the data it is representing (the sum of the length of the tracks in the tracks attribute). This is important in real world scenarios, as if these two data attributes diverge we might get nonsense results.\nThis is actually one of the big reasons why we like to make data attributes private, it ensures we can maintain the relationships between elements.\n\n\nAs written our code has the problem that data could become desynchronised because the user can directly modify the tracks list. We can’t get around this easily by making a read-only property, because it we return a reference to a list, than any changes on that reference would propagate to the original list\nOne option would be to provide a deep copy (a unique copy for each call), or another would be make tracks private and define methods on the class for all the nessecary interactions. I haven’t done this to minimise the disruption to the overall API, since this current API lets us reuse the adding and searching functionality we defined for the complete list of tracks. This could be something we change in the future\nLets now consider how we want to program to work. Previously we had one playlist. Now like the tracks, we want a list of them. However we still want to be able to work on and modify a playlist. To minimise the changes from the original design lets use the following approach\n\nThere will be a list of playlists\n\nThese will be loaded and saved to memory like the track list\n\nThere will be one active playlist at a time\n\nAt the start there is no active playlist\nThe user can create a new playlist\nThe user can select an existing playlist\nThe user can use the existing playlist generation feature\n\n\nBy keeping the one active global playlist we can minimise the disruption to our program. We can reuse existing functions making note that the current playlist has changed from a list of tracks to a Playlist object\nOur new Playlist menu now looks like,\ndef run_playlist_management_menu():\n    \"\"\"\n    Provides the user with a looping playlist menu\n\n    1. Create a new playlist\n    2. Select playlist\n    3. Get a suggested playlist of a target length\n    4. Add a track to the playlist\n    5. Remove a track from the playlist\n    6. Clear the playlist\n    7. Display the playlist\n    8. Show the runtime of the playlist\n    9. Export the current playlist\n    10. Return to the main menu\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    ValueError\n        An invalid number is encountered in menu selection, should not\n        occur in live code, please raise a bug report if encountered\n    \"\"\"\n    playlist_management_menu = \"\"\"Playlist Management\nCurrent playlist is {0}\n\n1. Create a new playlist\n2. Select playlist\n3. Get a suggested playlist of a target length\n4. Add a track to the playlist\n5. Remove a track from the playlist\n6. Clear the playlist\n7. Display the playlist\n8. Show the runtime of the playlist\n9. Export the current playlist\n10. Return to the main menu\n\nEnter your command: \"\"\"\n    while True:\n        command = BTCInput.read_int_ranged(\n            prompt=playlist_management_menu.format(current_playlist.name),\n            min_value=1,\n            max_value=10,\n        )\n        if command == 1:\n            create_playlist()\n        elif command == 2:\n            select_playlist()\n        elif command == 3:\n            suggest_playlist_of_given_length()\n        elif command == 10:\n            break\n        elif current_playlist.name == \"None\":\n            print(\"There is no active playlist. Please select or create one\")\n            continue\n        elif command == 4:\n            add_track_to_playlist()\n        elif command == 5:\n            remove_tracks_from_playlist()\n        elif command == 6:\n            clear_playlist()\n        elif command == 7:\n            display_playlist(current_playlist, name_only=False)\n        elif command == 8:\n            calculate_playlist_length()\n        elif command == 9:\n            export_playlist()\n        else:\n            raise ValueError(\n                \"Invalid command id \"\n                + str(command)\n                + \" found in playlist management sub-menu\"\n            )\nYou can see that we’ve defined new functions,\n\ncreate_playlist\nselect_playlist\ndisplay_playlist\n\nand that we’ve renamed the old save_playlist function to export_playlist. This last change is because we’ve introduced save_playlists and load_playlists as functions to pickle and unpickle the playlists binary data. Renaming save_playlist to export_playlist makes it clear that this function is not related to those two.\nYou also might notice that we’ve reordered the menu so that all the functions dealing with changing the current playlist (create_playlist, select_playlist, suggest_playlist_of_given_length) come first. This allows us to then check that we have an active playlist before running any of the other commands. We also check if user has decided to exit here to, since if we put it after the check for an active playlist the user can’t exit the playlist menu if the don’t have an active playlist\nAs mentioned, at the start there is no active playlist. Now the simplest way to implement this would be to initially set the current_playlist to None. However you can see this has a problem, we want the playlist menu to display the name of the current playlist, this doesn’t work if the current playlist is None. We could add some error checking, but we’ll instead use a technique called a None or Null object. This is an instance of an object that is designed to represent cases where the object does not actually exist. For us, we simply define a Playlist with the name None\n# null object\nno_playlist = Playlist(name=\"None\")\ncurrent_playlist = no_playlist\nLet us look now at the new functions we’ve defined, the first pair\ndef valid_playlist_name(name):\n    \"\"\"\n    Verifies that a playlist name is valid\n\n    Playlist names must be unique\n\n    Parameters\n    ----------\n    name : str\n        proposed name for a playlist\n\n    Returns\n    -------\n    bool\n        `True` if playlist name is valid else, `False`\n    \"\"\"\n    if name == \"None\":\n        return False\n    for playlist in playlists:\n        if name == playlist.name:\n            return False\n    return True\n\n\ndef create_playlist(tracks=[]):\n    \"\"\"\n    Create a new playlist and make it the active playlist\n\n    Prompts the user for a new name for the playlist, and ensures its valid\n    then constructs a playlist and sets it as the current active playlist\n\n    Parameters\n    ----------\n    tracks : list, optional\n        tracks to assign to the playlist, by default []\n\n    See Also\n    --------\n    valid_playlist_name : validates a playlist name\n    Playlist : class used to represent a playlist\n    \"\"\"\n    print(\"Create a new playlist\")\n    global current_playlist\n\n    new_playlist_name = BTCInput.read_text(\"Enter the playlist name: \")\n    while not valid_playlist_name(new_playlist_name):\n        print(\"That playlist name is already in use\")\n        new_playlist_name = BTCInput.read_text(\"Enter the playlist name: \")\n\n    new_playlist = Playlist(new_playlist_name, tracks)\n    current_playlist = new_playlist\n    playlists.append(new_playlist)\nPrompts the user for the name of a new playlist. We add code that means the user can’t override the NoneObject or use duplicate names which is given by the function valid_playlist_name. Unlike the validation code in the Time Tracker this is not in the class, because it is part of the business logic of the application layer, not the playlist itself\nWe then define the select_playlist function,\ndef select_playlist():\n    \"\"\"\n    Select an existing playlist to be the current playlist\n\n    Prompts the user for a search name then returns all playlists\n    that match that string. The user will be displayed each playlist\n    in turn and asked if they want to make that the current playlist\n\n    Notes\n    -----\n    Passing the empty string can be used to display all playlists\n    \"\"\"\n    print(\"Select a playlist\")\n    global current_playlist\n\n    search_name = BTCInput.read_text(\"Enter playlist name (enter to see ): \")\n\n    matched_playlists = []\n\n    for playlist in playlists:\n        if playlist.name.strip().lower().startswith(search_name.strip().lower()):\n            matched_playlists.append(playlist)\n\n    if len(matched_playlists) &gt; 0:\n        print(\"Found {0} matches\".format(len(matched_playlists)))\n        for playlist in matched_playlists:\n            display_playlist(playlist)\n            select = BTCInput.read_int_ranged(\n                \"Select this playlist? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n            )\n            if select:\n                current_playlist = playlist\n                return\n    else:\n        print(\"No playlists found matching that name\")\nSince no other method needs to search for playlist names, we forgo our usual pattern of defining a find and filter function and just combine it all in the one function. Additionally select is also used for letting the user see what playlists are stored in the program. A future version might add an explicit function called this (perhaps list_playlists)\nThis program works pretty simply. We use the standard name matching pattern, then for each match the user is shown the playlist name and runtime, and is given the option to select it. If they do then the current playlist is set to that playlist and the function ends, else it continues to the next.\nLastly we have our display_playlist function, to print a playlist\ndef display_playlist(playlist, name_only=True):\n    \"\"\"\n    Display a playlist\n\n    Can optionally list all the tracks or just the name and length\n\n    Parameters\n    ----------\n    playlist : Playlist\n        playlist to display\n    name_only : bool, optional\n        only display the playlists name and runtime, by default `True`\n\n    Returns\n    -------\n    None\n    \"\"\"\n    if name_only:\n        print(\"{0} ({1} s)\".format(playlist.name, playlist.runtime))\n    else:\n        print(playlist)\nThe optional name_only parameter is used indicate that we only want to print the playlist name and length, otherwise we defer to the Playlist __str__ method and print everything.\nThis captures the last of the high level changes. As mentioned, we have to make minor changes to the existing functions, such as to suggest_playlist_of_given_length shown below\ndef suggest_playlist_of_given_length():\n    \"\"\"\n    Suggests a playlist of length less than or equal to\n    a user prompted length\n\n    Asks the user for a maximum playlist length, and\n    then suggests a playlist by combining tracks randomly\n    such that the suggested playlist is no greater than\n    the length\n\n    The user has the option to review the proposed list\n    and either accept, reject or regenerate the list\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"Suggest playlist of given length\")\n    global current_playlist\n\n    target_length = read_min_valued_integer(\n        \"Enter maximum playlist length: \", min_value=1\n    )\n\n    while True:\n        suggested_tracks = []\n        suggested_tracks_total_length = 0\n        # find tracks that could fit in the playlist\n        candidate_songs = filter_tracks_shorter_than_length(target_length, tracks)\n\n        if len(candidate_songs) == 0:\n            print(\"Could not generate a playlist of that length. Try a longer playlist\")\n            return\n\n        while len(candidate_songs) &gt; 0:  # stop when no more eligable songs\n            # add a random song and update the playlist length\n            song_choice = random.choice(candidate_songs)\n            suggested_tracks.append(song_choice)\n            suggested_tracks_total_length = (\n                suggested_tracks_total_length + song_choice.length_in_seconds\n            )\n\n            # filter out songs that no longer fit\n            candidate_songs = filter_tracks_shorter_than_length(\n                target_length - suggested_tracks_total_length, candidate_songs\n            )\n        print(\"Generated a playlist...\")\n        # let the user review the playlist\n        display_tracks(suggested_tracks)\n        if BTCInput.read_int_ranged(\n            \"Accept this playlist? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        ):\n            create_playlist(suggested_tracks)\n            return\n        else:\n            if BTCInput.read_int_ranged(\n                \"Generate again? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n            ):\n                continue\n            return\nHere we still build up the suggested playlist as before (using a list) but once the user decides to keep this playlist, we then call create_playlist passing in the track list to create a proper named Playlist object\nYou are encouraged to work through the full program yourself (PlaylistStorage.py)\n\n\n\n\n\nLet’s build a simple music keyboard\nWe’ll add a simple music player\nExtend with some playback options\nThe snaps library code provides some music notes to use\n\nstored in MusicNotes\nplay_note lets us play a note\n\n\n\n\n\n\nWarning\n\n\n\nIf when running the program you get a file not found error, you may need to modify the path in play_note to either MusicNotes\\\\ or MusicNotes/\nThis path is relative to snaps and so the folder must in the same directory as snaps\n\n\n\nWe can start with a simple program that plays all the notes,\n  # Example 10.15.1 Play Notes\n  #\n  # Demonstrates using snaps to play notes\n\n  import time\n\n  import snaps\n\n  for note in range(0, 13):\n      snaps.play_note(note)\n      time.sleep(0.5)\n  input(\"Press enter to continue...\")\nWe use time.sleep(0.5) to stagger playing the notes\nWe could also play a tune,\n  # Example 10.15.2 Twinkle Twinkle\n  #\n  # Uses snaps to play a simple tune\n\n  import time\n\n  import snaps\n\n  snaps.play_note(0)\n  time.sleep(0.4)\n  snaps.play_note(0)\n  time.sleep(0.4)\n  snaps.play_note(7)\n  time.sleep(0.4)\n  snaps.play_note(7)\n  time.sleep(0.4)\n  snaps.play_note(9)\n  time.sleep(0.4)\n  snaps.play_note(9)\n  time.sleep(0.4)\n  snaps.play_note(7)\n  time.sleep(0.8)\n  snaps.play_note(5)\n  time.sleep(0.4)\n  snaps.play_note(5)\n  time.sleep(0.4)\n  snaps.play_note(4)\n  time.sleep(0.4)\n  snaps.play_note(4)\n  time.sleep(0.4)\n  snaps.play_note(2)\n  time.sleep(0.4)\n  snaps.play_note(2)\n  time.sleep(0.4)\n  snaps.play_note(0)\n  time.sleep(0.8)\nWe can see this is already becoming tedious\nWe repeatedly write the play_note followed by a sleep time\nHave to manuually modify the code\nWe could make this data-driven\nWe supply a list of tuples\n\nEach tuple contains the id for a note and the time to sleep after playing that note\n\nThen simply loop over the list to play the tune\nCan then play anything by just changing the embedded data\n  # Example 10.15.3 Twinkle Twinkle with Tuples\n  #\n  # Converts play notes to a data-driven program using tuples to specify notes\n  # and how long to pause after\n\n  import time\n\n  import snaps\n\n  tune = [\n      (0, 0.4),\n      (0, 0.4),\n      (7, 0.4),\n      (7, 0.4),\n      (9, 0.4),\n      (9, 0.4),\n      (7, 0.8),\n      (5, 0.4),\n      (5, 0.4),\n      (4, 0.4),\n      (4, 0.4),\n      (2, 0.4),\n      (2, 0.4),\n      (0, 0.8),\n  ]\n\n  for note in tune:\n      note_id, sleep_time = note\n      snaps.play_note(note_id)\n      time.sleep(sleep_time)\nEach tuple stores the note and the sleep time\nWe then loop over the tuples\nWe use unpacking to assign the elements of the tuple meaningful names (note_id and sleep_time)\nWhile playback is simple, constructing is not nessecarily\n\nThe tuples are undocumented and rely on the programmer knowing the indices\n\nWe could instead define a lightweight class\n  # Example 10.15.4 Twinkle Twinkle with Classes\n  #\n  # Modifies the data driven tuple implementation by definining a lightweight\n  # Note class\n\n  import time\n\n  import snaps\n\n\n  class Note:\n      \"\"\"\n      Musical note with a playback duration.\n      \"\"\"\n\n      def __init__(self, note, duration):\n          \"\"\"\n          Create a Note instance\n\n          Parameters\n          ----------\n          note : int\n              id of the note to play\n          duration : int | float\n              duration of the note\n          \"\"\"\n          self.__note = note\n          self.__duration = duration\n\n      def play(self):\n          \"\"\"\n          play the note\n\n          plays the note then pauses for the specified duration\n          \"\"\"\n          snaps.play_note(self.__note)\n          time.sleep(self.__duration)\n\n\n  tune = [\n      Note(note=0, duration=0.4),\n      Note(note=0, duration=0.4),\n      Note(note=7, duration=0.4),\n      Note(note=7, duration=0.4),\n      Note(note=9, duration=0.4),\n      Note(note=9, duration=0.4),\n      Note(note=7, duration=0.8),\n      Note(note=5, duration=0.4),\n      Note(note=5, duration=0.4),\n      Note(note=4, duration=0.4),\n      Note(note=4, duration=0.4),\n      Note(note=2, duration=0.4),\n      Note(note=2, duration=0.4),\n      Note(note=0, duration=0.8),\n  ]\n\n  for note in tune:\n      note.play()\nNote is a lightweight class holding the note’s id and the note duration\n\nKeep these private, since no need to access once set\n\nNote has a play method that captures playing a note\nProgram then defines a list of Note objects which are then played\n\n\n\nConsider the following questions about the design of the note class\n\nWhy does the Note class contain a Play method?\n\ncohesion\nNote contains all the information about a note\nSo should keep the behaviour with the information, i.e. in the Note class\nIf we want to change how a note is played we can change it in the Note class without impacting downstream callers\n\nSo long as we keep the same API\n\n\nCould the Note class have a __str__ method?\n\nIt’s probably a good idea\nA simple implementation is,\ndef __str__(self):\n  template = \"Note: {0} Duration: {1}\"\n  return template.format(self.__note, self.duration)\nWe can then print the tune super easily,\n  tune_strings = map(str, tune)\n  print(\"\\n\".join(tune_strings))\n\n\n\nAll the music playing examples can be found in the Music With Snaps example folder\n\n\n\n\nModify the sample programs to make your own tunes\nFor fun we’ll make two little tunes\n\nThe classic Macca’s jingle\n # Exercise 10.2.1 Maccas Jingle\n #\n # Uses the Note playback program to play the Maccas jingle\n\n import time\n\n import snaps\n\n\n class Note:\n     \"\"\"\n     Musical note with a playback duration.\n     \"\"\"\n\n     def __init__(self, note, duration):\n         \"\"\"\n         Create a Note instance\n\n         Parameters\n         ----------\n         note : int\n             id of the note to play\n         duration : int | float\n             duration of the note\n         \"\"\"\n         self.__note = note\n         self.__duration = duration\n\n     def __str__(self):\n         template = \"Note: {0} Duration: {1}\"\n         return template.format(self.__note, self.__duration)\n\n     def play(self):\n         \"\"\"\n         play the note\n\n         plays the note then pauses for the specified duration\n         \"\"\"\n         snaps.play_note(self.__note)\n         time.sleep(self.__duration)\n\n\n tune = [\n     Note(note=7, duration=0.3),\n     Note(note=11, duration=0.3),\n     Note(note=2, duration=0.3),\n     Note(note=5, duration=0.3),\n     Note(note=7, duration=0.5),\n ]\n\n for note in tune:\n     note.play()\n\n tune_strings = map(str, tune)\n print(\"\\n\".join(tune_strings))\n\nThis doesn’t sound exactly correct because we don’t have the correct octave progression in the provided wav files but we get a decent approximation\nYou might like to play around with the timings to see if you can make it better\n\nThree Blind Mice\n # Exercise 10.2.2 Three Blind Mice\n #\n # Uses the Note playback program to play three blind mice\n\n import time\n\n import snaps\n\n\n class Note:\n     \"\"\"\n     Musical note with a playback duration.\n     \"\"\"\n\n     def __init__(self, note, duration):\n         \"\"\"\n         Create a Note instance\n\n         Parameters\n         ----------\n         note : int\n             id of the note to play\n         duration : int | float\n             duration of the note\n         \"\"\"\n         self.__note = note\n         self.__duration = duration\n\n     def __str__(self):\n         template = \"Note: {0} Duration: {1}\"\n         return template.format(self.__note, self.__duration)\n\n     def play(self):\n         \"\"\"\n         play the note\n\n         plays the note then pauses for the specified duration\n         \"\"\"\n         snaps.play_note(self.__note)\n         time.sleep(self.__duration)\n\n\n tune = [\n     Note(note=4, duration=0.4),\n     Note(note=2, duration=0.4),\n     Note(note=0, duration=0.8),\n     Note(note=4, duration=0.4),\n     Note(note=2, duration=0.4),\n     Note(note=0, duration=0.8),\n     Note(note=7, duration=0.4),\n     Note(note=5, duration=0.4),\n     Note(note=5, duration=0.4),\n     Note(note=4, duration=0.8),\n     Note(note=7, duration=0.4),\n     Note(note=5, duration=0.4),\n     Note(note=5, duration=0.4),\n     Note(note=4, duration=0.8),\n     Note(note=7, duration=0.4),\n     Note(note=12, duration=0.4),\n     Note(note=12, duration=0.4),\n     Note(note=11, duration=0.4),\n     Note(note=9, duration=0.4),\n     Note(note=11, duration=0.4),\n     Note(note=12, duration=0.4),\n     Note(note=7, duration=0.4),\n     Note(note=7, duration=0.8),\n ]\n\n for note in tune:\n     note.play()\n\n tune_strings = map(str, tune)\n print(\"\\n\".join(tune_strings))\n\nThis one we get a much better sounding tune\n\n\n\n\n\nBy combining the structure and style of Time Tracker with the music playback provided by the Note class we could make a simple program that lets users create, edit and play their own tunes. Create this program. A user should be able to create a tune, edit a tune, delete a tune and play a selected tune. Tunes should be saved and persist between uses\nIf you can follow the Playlist Storage App and the Recipe Storage App then this program should fairly easy to follow\nLet’s first define our Note class\nclass Note:\n    \"\"\"\n    Musical note with a playback duration.\n\n    Class Attributes\n    ----------------\n    min_note_id : int\n        minimum valid note id\n    max_note_id : int\n        maximum valid note id\n    \"\"\"\n\n    min_note_id = 0\n    max_note_id = 12\n\n    @staticmethod\n    def valid_note(note):\n        \"\"\"\n        Checks if a note id is valid\n\n        Parameters\n        ----------\n        note : int\n            id of the note to validate\n\n        Returns\n        -------\n        bool\n            `True` if note is valid, else `False`\n        \"\"\"\n        if note &lt; 0 or note &gt; 12:\n            return False\n        return True\n\n    def __init__(self, note, duration):\n        \"\"\"\n        Create a Note instance\n\n        Parameters\n        ----------\n        note : int\n            id of the note to play\n        duration : int | float\n            duration of the note\n        \"\"\"\n        if not Note.valid_note(note):\n            raise ValueError(\n                \"invalid note {0} passed. note must be between {1} and {2}\".format(\n                    note, Note.min_note_id, Note.max_note_id\n                )\n            )\n        self.__note = note\n        self.__duration = duration\n\n    @property\n    def duration(self):\n        \"\"\"\n        duration : str\n            time in seconds the note is played for\n        \"\"\"\n        return self.__duration\n\n    def __str__(self):\n        template = \"Note: {0} Duration: {1}\"\n        return template.format(self.__note, self.__duration)\n\n    def play(self):\n        \"\"\"\n        play the note\n\n        plays the note then pauses for the specified duration\n        \"\"\"\n        snaps.play_note(self.__note)\n        time.sleep(self.__duration)\nThis is pretty much the same as the Note class in the Making Music Section. However we need the duration so that we can report how long the total tune is so we add a read only property for duration. Additionally since we’re now going to be taking user input to create notes we’ll want to validate that input. It makes sense for it to be in the Note class, so we define class variables min_note_id and max_note_id and a corresponding validation method, valid_note that can be used to check that a note (represented by an integer) is valid. We leave the class variables as public so we can use them in the prompts we display to the user\nNow when making our own music, we used a list of notes to create a tune. We want to use this structure but wrap it in a class that captures behaviour. We’ll call this class Tune\nclass Tune:\n    def __init__(self, name):\n        \"\"\"\n        Create a new Tune instance\n\n        Parameters\n        ----------\n        name : str\n            name of the tune\n        \"\"\"\n        self.name = name\n        self.__notes = []\n        self.__length = 0\n\n    def __str__(self):\n        notes_string = \"\"\n        for idx, note in enumerate(map(str, self.__notes)):\n            notes_string = notes_string + str(idx) + \": \" + note + \"\\n\"\n\n        template = \"\"\"name: {0}\nduration: {1}\nnotes:\n{2}\n\"\"\"\n        return template.format(self.name, self.__length, notes_string)\n\n    @property\n    def length(self):\n        \"\"\"\n        length : int | float\n            total length of the tune in seconds\n        \"\"\"\n        return self.__length\n\n    @property\n    def number_of_notes(self):\n        \"\"\"\n        number_of_notes : int\n            number of notes in the tune\n        \"\"\"\n        return len(self.__notes)\nThe class has a simple structure. The tune constructor only needs a name, we then create an empty list of notes, and a seperate variable that tracks the full length of the tune. Our string representation (__str__) follows the usual pattern, we print the name and duration of the Tune, the the list of Note objects in the tune. We use enumerate to make this a numbered list with each item on its own line. This is because most of our edits will require an index, so we want to user to be able to easily see the index of all the notes. Additionally we define two useful properties, one to get the length of the tune, and the second that returns the total number of notes in the tune. Both properties are read-only, while this last one is mostly used to help with validating user input\nAs you can see the list of notes is private, so we also want to provide some methods that allow us to modify the notes list\n    def add_note(self, note, index=None):\n        \"\"\"\n        Add a new note to the tune\n\n        Adds a new note to the tune, if the index is specified\n        the note is inserted at that index, else the note is appended\n\n        Parameters\n        ----------\n        note : Note\n            note to add to the tune\n        index : int | None, optional\n            index to insert the note at, if None, the Note is appended,\n            by default None\n\n        Returns\n        -------\n        None\n        \"\"\"\n        if index is not None:\n            self.__notes.insert(index, note)\n        else:\n            self.__notes.append(note)\n        self.__length += note.duration\n\n    def remove_note(self, index):\n        \"\"\"\n        Remove a note from the tune\n\n        Parameters\n        ----------\n        index : int\n            index of the note to remove\n\n        Returns\n        -------\n        Note\n            the removed Note\n        \"\"\"\n        try:\n            note = self.__notes.pop(index)\n            self.__length -= note.duration\n            return note\n        except IndexError:\n            print(\"Failed to remove the {0}-th note\".format(index + 1))\n\n    def clear_tune(self):\n        \"\"\"\n        Clear all notes from the tune\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.__notes.clear()\n        self.__length = 0\nThe first add_note takes a note, and an optional index. If the index is specified the note is inserted into the list (at the specified index), otherwise we append it. The second remove_note requires an index, and removes the note at that index. The removed note is returned as part of this process. We also provide some error handling in case the provided index does not actually exist. Last we provide a clear_tune method which simply removes all the notes\nThe arguably most important function for the Tune class however is play which simply plays the tune\n    def play(self):\n        \"\"\"\n        Plays the tune\n\n        Returns\n        -------\n        None\n        \"\"\"\n        for note in self.__notes:\n            note.play()\nWe define our main menu function as,\ndef run_main_menu():\n    first_option_id = 1\n    last_option_id = 7\n\n    main_menu_template = \"\"\"Tune Editor\nCurrent Tune: {0}\n\n1. New Tune\n2. List Tunes\n3. Select Tune\n4. Play Tune\n5. Edit Tune\n6. Delete Tune\n7. Exit program\n\nEnter your command: \"\"\"\n\n    while True:\n        command = BTCInput.read_int_ranged(\n            main_menu_template.format(current_tune.name),\n            min_value=first_option_id,\n            max_value=last_option_id,\n        )\n        if command == 1:\n            new_tune()\n        elif command == 2:\n            list_tunes()\n        elif command == 3:\n            select_tune()\n        elif command == 7:\n            try:\n                save_tunes(tune_file_name)\n            except:  # noqa: E722\n                print(\"Failed to save tunes\")\n            break\n        elif current_tune.name == \"None\":\n            print(\"No tune currently selected\")\n            continue\n        elif command == 4:\n            current_tune.play()\n        elif command == 5:\n            run_edit_menu()\n        elif command == 6:\n            delete_tune()\n        else:\n            raise ValueError(\n                \"Unexpected command id: {0} found in Main Menu\".format(command)\n            )\nWe use the same save and load paradigm as with all the previous examples so we won’t look at that code again. Of the functions here we have,\n\nnew_tune\n def valid_tune_name(name):\n     \"\"\"\n     Verifies that a tune name is available\n\n     Tune names must be unique\n\n     Parameters\n     ----------\n     name : str\n         proposed name for a tune\n\n     Returns\n     -------\n     bool\n         `True` if tune name is valid else, `False`\n     \"\"\"\n     if name == \"None\":\n         return False\n     for tune in tunes:\n         if name == tune.name:\n             return False\n     return True\n\n\n def prompt_valid_name(prompt):\n     \"\"\"\n     Prompts the user for a valid tune name\n\n     Loops until a valid name is provided\n\n     Parameters\n     ----------\n     prompt : str\n         prompt to display to the user\n\n     Returns\n     -------\n     str\n         string containing a valid tune name\n     \"\"\"\n     tune_name = BTCInput.read_text(prompt)\n     while not valid_tune_name(tune_name):\n         print(\"That tune name is already in use\")\n         tune_name = BTCInput.read_text(prompt)\n\n     return tune_name\n\n\n def new_tune():\n     \"\"\"\n     Create a new tune and make it the active tune\n\n     Prompts the user for a new name for the tune, and ensures its valid\n     then constructs a Tune and sets it as the current active tune\n\n     Returns\n     -------\n     None\n\n     See Also\n     --------\n     valid_tune_name : validates a tune name\n     Tune : class used to represent a tune\n     \"\"\"\n     print(\"New tune\")\n     global current_tune\n     new_tune_name = prompt_valid_name(\"Enter the tune name: \")\n     new_tune = Tune(new_tune_name)\n     current_tune = new_tune\n     tunes.append(new_tune)\n\nWe start by defining a function valid_tune_name\n\nboolean function that ensures a proposed name is unique\nreturns True if the name is valid, else False\n\nWe then wrap this in prompt_valid_name\n\nSince we want to reuse the code that gets a name from a user later\nPrompts the user for a valid name, looping until one is received\nReturns the valid name\n\nOur new_tune is now simple\n\ncall prompt_valid_name to get a new name\nCreate a new Tune object\nset the current tune to this new object\nAdd it to the tunes list\n\n\nlist_tunes\n def filter_tunes_by_name(search_name):\n     \"\"\"\n     Finds tunes matching a search name\n\n     Tunes are matched if their name is prefixed by the search name\n     after normalisation (striping whitespace and lowercasing)\n\n     Parameters\n     ----------\n     search_name : str\n         name to search for (search uses prefix matching)\n\n     Returns\n     -------\n     list[Tune]\n         list of tunes matching the name. If no matches\n         exist the list is empty\n\n     \"\"\"\n     search_name = search_name.strip().lower()\n     print(search_name)\n     matched_tunes = []\n     for tune in tunes:\n         tune_name = tune.name.strip().lower()\n         if tune_name.startswith(search_name):\n             matched_tunes.append(tune)\n     return matched_tunes\n\n\n def list_tunes():\n     \"\"\"\n     List all tunes matching a user-specified search string\n\n     Returns\n     -------\n     None\n\n     See Also\n     --------\n     filter_tunes_by_name : handles searching for tunes by name\n     \"\"\"\n     print(\"List tunes\")\n     search_name = BTCInput.read_text(\"Tune names to search (press enter for all): \")\n     matched_tunes = filter_tunes_by_name(search_name)\n     if len(matched_tunes) == 0:\n         print(\"No matches found\")\n         return\n     print(\"Found {0} matches\".format(len(matched_tunes)))\n     for tune in matched_tunes:\n         print(\"- {0} ({1:.2f} s)\".format(tune.name, tune.length))\n\nWe use the usual pattern of defining a filter_tunes_by_name function to perform the search\nWe then print out the matches as per usual\n\nselect_tune\n def select_tune():\n     \"\"\"\n     Select a tune from tunes matching a user-specified search string\n\n     Returns\n     -------\n     None\n\n     See Also\n     --------\n     filter_tunes_by_name : handles searching for tunes by name\n     \"\"\"\n     print(\"Select tune\")\n     search_name = BTCInput.read_text(\"Enter name of tune to select: \")\n     matched_tunes = filter_tunes_by_name(search_name)\n     if len(matched_tunes) == 0:\n         print(\"No matches found\")\n         return\n     print(\"Found {0} matches\".format(len(matched_tunes)))\n     for tune in matched_tunes:\n         select = BTCInput.read_int_ranged(\n             \"Tune: {0}, select this tune? (1 - Yes, 0 - No): \".format(tune.name),\n             min_value=0,\n             max_value=1,\n         )\n         if select:\n             global current_tune\n             current_tune = tune\n             break\n\nUses filter_tunes_by_name to get matching tunes\nUser is then prompted for each match if they want to make this the new current tune\nExecution stops once they’ve decided to select a new track\n\ndelete_tune\n def delete_tune():\n     \"\"\"\n     Optionally delete tunes matching a user-specified search string\n\n     Returns\n     -------\n     None\n\n     See Also\n     --------\n     filter_tunes_by_name : handles searching for tunes by name\n     \"\"\"\n     print(\"Delete tune\")\n     search_name = BTCInput.read_text(\"Enter name of tune to select: \")\n     matched_tunes = filter_tunes_by_name(search_name)\n     if len(matched_tunes) == 0:\n         print(\"No matches found\")\n         return\n     print(\"Found {0} matches\".format(len(matched_tunes)))\n     for tune in tunes:\n         select = BTCInput.read_int_ranged(\n             \"Tune: {0}, delete this tune? (1 - Yes, 0 - No): \".format(tune.name),\n             min_value=0,\n             max_value=1,\n         )\n         if select:\n             global current_tune\n             if tune == current_tune:\n                 current_tune = no_tune\n             tunes.remove(tune)\n\nAgain, use filter_tunes_by_name to match names\nThen prompt the user if they want to delete\nOnly caveat we have to be careful is that if we delete the currently selected tune we have to set the current tune to no_tune (a null object)\n\n\nNow, the last thing we have to look at is the edit menu. Our edit menu looks as follows,\ndef run_edit_menu():\n    first_option_id = 1\n    last_option_id = 8\n\n    edit_tune_menu_template = \"\"\"Editing Tune\nCurrent Tune: {0}\n1. Rename Tune\n2. Display Tune\n3. Play Tune\n4. New Note\n5. Edit Note\n6. Remove Note\n7. Clear Tune\n8. Finish Editing\n\nEnter your command: \"\"\"\n    while True:\n        command = BTCInput.read_int_ranged(\n            edit_tune_menu_template.format(current_tune.name),\n            min_value=first_option_id,\n            max_value=last_option_id,\n        )\n\n        if command == 1:\n            rename_tune()\n        elif command == 2:\n            print(current_tune)\n        elif command == 3:\n            print(\"Playing\", current_tune.name)\n            current_tune.play()\n        elif command == 4:\n            add_note_to_tune()\n        elif command == 5:\n            edit_note()\n        elif command == 6:\n            if current_tune.number_of_notes == 0:\n                print(\"No notes to remove\")\n            remove_note()\n        elif command == 7:\n            print(\"Cleared\", current_tune.name)\n            current_tune.clear_tune()\n        elif command == 8:\n            break\n        else:\n            raise ValueError(\n                \"Unexpected command id: {0} found in Edit Menu\".format(command)\n            )\nLets work through these functions\n\nrename_tune\n def rename_tune():\n     \"\"\"\n     Rename the current tune to a user prompted string\n\n     Returns\n     -------\n     None\n     \"\"\"\n     print(\"Rename current tune\")\n     new_name = prompt_valid_name(\"Enter new name (or . to leave unchanged): \")\n     if new_name != \".\":\n         current_tune.name = new_name\n\nReuses the prompt_valid_name function from new_tune to get a new name\n\nThis has the issue that we can’t write the same name as the current tune\nSo use . to indicate that we don’t actually want to change\n\n\nadd_note_to_tune\n def get_new_note_from_user():\n     \"\"\"\n     Prompts the user for a new Note\n\n     The user is prompted for the note and duration, and the input validated\n     to ensure that a valid Note object is created\n\n     Returns\n     -------\n     Note\n         Note object containing the user specified note id and duration\n     \"\"\"\n\n     note_prompt = \"Enter note ({0} - {1}): \".format(Note.min_note_id, Note.max_note_id)\n     note = BTCInput.read_int_ranged(\n         prompt=note_prompt, min_value=Note.min_note_id, max_value=Note.max_note_id\n     )\n\n     min_note_length = 0.1\n     max_note_length = 1\n     duration_prompt = \"Enter duration ({0} - {1}): \".format(\n         min_note_length, max_note_length\n     )\n     duration = BTCInput.read_float_ranged(\n         duration_prompt, min_value=min_note_length, max_value=max_note_length\n     )\n\n     return Note(note, duration)\n\n\n def add_note_to_tune():\n     \"\"\"\n     Adds a note to the current tune\n\n     Prompts the user to specify a new note as well as an index of\n     where to insert the note in the tune (-1 indicating append). The created\n     note is then added to the current tune at the indicated index (or appended)\n\n     Returns\n     -------\n     None\n     \"\"\"\n     print(\"Add note to current tune\")\n     new_note = get_new_note_from_user()\n     if current_tune.number_of_notes == 0:\n         current_tune.add_note(new_note)\n         print(\"Added note:\", new_note)\n         return\n\n     insert_prompt = \"Enter index to add note (0 - {0}) or -1 to append: \".format(\n         current_tune.number_of_notes - 1\n     )\n     insertion_idx = BTCInput.read_int_ranged(\n         insert_prompt, -1, current_tune.number_of_notes - 1\n     )\n     if insertion_idx == -1:\n         insertion_idx = None\n     current_tune.add_note(new_note, insertion_idx)\n     print(\"Added note:\", new_note)\n\nWe start by defining a function get_new_note_from_user\n\nGets a valid Note object from the user\nUses the class attributes on Note to limit the user’s input for the note id\nEnforces a program set limit on the duration\n\nThen define add_note_to_tune\n\nWe get a new note from the user\nIf there’s no notes on the Tune we can immediately add the note to the tune\nOtherwise we prompt the user for the index to add\n\n\\(-1\\) is used to indicate that the value should be appended\n\nCan then call the add_note method on the Tune object\n\n\nedit_note\n def edit_note():\n     \"\"\"\n     Modifies an existing note in the current tune\n\n     Prompts the user for the index of the existing note to overwrite and\n     then the details of the new note\n\n     Returns\n     -------\n     None\n     \"\"\"\n     print(\"Edit note in current tune\")\n     if current_tune.number_of_notes == 0:\n         print(\"There are no notes in the current tune to edit\")\n         return\n\n     edit_prompt = \"Enter index of note to edit (0 - {0}): \".format(\n         current_tune.number_of_notes - 1\n     )\n     insertion_idx = BTCInput.read_int_ranged(\n         edit_prompt, 0, current_tune.number_of_notes - 1\n     )\n     old_note = current_tune.remove_note(insertion_idx)\n\n     if insertion_idx == current_tune.number_of_notes:\n         insertion_idx = None  # we removed the last index, so now need to append\n\n     new_note = get_new_note_from_user()\n     current_tune.add_note(new_note, insertion_idx)\n     print(\"Note successfully edited\")\n     print(\"Note was:\", old_note)\n     print(\"Note now:\", new_note)\n\nWorks similar to add_note_to_tune\n\nThis time however we first prompt the user for which note they want to edit\n\nWe create a new Note\n“Editing” a note is achieved by removing the old note, and inserting the new note, where the old one was\n\nremove_note\n def remove_note():\n     \"\"\"\n     Remove the note at a user prompted index from the current tune\n\n     Returns\n     -------\n     None\n     \"\"\"\n     print(\"Remove note from current tune\")\n     remove_prompt = \"Enter index of note to remove (0 - {0}): \".format(\n         current_tune.number_of_notes - 1\n     )\n     remove_idx = BTCInput.read_int_ranged(\n         remove_prompt, 0, current_tune.number_of_notes - 1\n     )\n     current_tune.remove_note(remove_idx)\n\nCalling code responsible for ensuring that we don’t call this on an empty tune\nRemoves the note at the user prompted index\n\n\nWith those functions worked through that covers pretty much all the functionality of the program. You can see the full implementation in TuneCreator.py. The associated pickle file should load the example tunes we created earlier which you can play and edit to test the program",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 10: Using Classes to Create Active Objects"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/10_UseClassesToCreateActiveObjects/Chapter_10.html#summary",
    "href": "02_AdvancedProgramming/10_UseClassesToCreateActiveObjects/Chapter_10.html#summary",
    "title": "Chapter 10: Using Classes to Create Active Objects",
    "section": "Summary",
    "text": "Summary\n\nClasses can be used to store data attributes\n\nWhen a class instance is created, the data is stored in the object\nThe __init__ or constructor is a function that can be used to set instance attributes at creation\n\nClasses can contain method attributes\n\nan object can asked to perform a function by calling the method\nmethods are effectively functions that contain a reference to the object itself as a first argument\n\nTraditionally called self\n\n\nClasses should strive to be cohesive\n\nMethods let us create cohesive classes\nCohesive classes are less reliant on the internals of other classes\nself contained objects can validate method calls or data assignments\n\nInvalid data or failed methods can be handled in two ways\n\nreturn a status message\n\nUser has the option of ignoring it\n\nraise an exception\n\nUser is forced to handle it or the program crashes\n\n\nPython provides mechanisms for protecting data\n\nNo absolute runtime guarantees\n_ indicates an attribute is supposed to be private to a class\n__ name mangles a variable making it harder to access outside the class\n\nStatic methods can be defined on a class and called without a specific instance\nUseful for creating validation methods, that do not rely on specific instance values\nProperties let us write methods that behave like attributes\n\nCan be used to return values that can be calculated on the fly\nReturn read-only versions of data attributes\nperform data validation on data attribute assignment while still keeping the same syntax i.e. obj.param = new_value\n\nVersion management is important whenever you want to store classes that might change long-term\n\nYou should incorporate methods for upgrading older versions of a class to a new version\n\nThe __str__ method is used to define how a class is represented as a string\nPython string formatting provides a simple way for creating strings containing formatted variable values\nIterators are objects that can produce elements of a sequence for iteration\n\nIterators can come from a list or a different iterator\n\nmap can be used to create an iterator that applies a function to an existing iteration\njoin can be used to merge a list of strings into a larger string",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 10: Using Classes to Create Active Objects"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/10_UseClassesToCreateActiveObjects/Chapter_10.html#questions-and-answers",
    "href": "02_AdvancedProgramming/10_UseClassesToCreateActiveObjects/Chapter_10.html#questions-and-answers",
    "title": "Chapter 10: Using Classes to Create Active Objects",
    "section": "Questions and Answers",
    "text": "Questions and Answers\n\nWhy doesn’t python provide a way for a programmer to completely protect data attributes in an object?\n\nThe creator of python didn’t believe in the traditional object-oriented concepts of public, protected and private variables\nEven these techniques can’t protect against a malicious actor with access to your source code\n\nThey could modify a public function to reveal a private variable\nOr they could just add one\n\nIt is important to still be able to review code to ensure it is secure\n\nWhen would we use a property in a program?\n\nProperties let us control how data attributes are accessed\nProperties let us write traditional get and set methods that still behave like simple data attributes\nWe can also define read-only properties that have no set methods\nProperties are good when you want to manage access to data (or validate it) but without the user having to call methods\n\nWhen would we create static class attributes?\n\nStatic class data attributes are useful to store information about a class\n\ni.e. independent on any specific object instance\n\nA good example is data validation values\n\nThese will typically be common across all instances\n\nSimilarly static method attributes are good for performing this validation\n\nMust all objects be highly cohesive?\n\nNot strictly\nIt’s about scale\n\nFor a small program, that does one thing, that will be used once (or a few times by one person)\nLittle harm in being uncohesive\nThe time spent making it cohesive as opposed to making it is probably wasted\n\nAn overriding rule is to keep it simple\nIf a program is likely to be maintained, or developed by multiple people\n\nProbably beneficial\nShort-term costs of good design are better than the long-term of maintaining a poor design\n\nTime Tracker is pretty close to final product quality\n\nWhat is an iterator again?\n\nAn iterator is an object that provides the __next__ method\n\nProvides the next value in a sequence\n\nSome objects, e.g. list behave as iterators\nSome methods, e.g. map and range return objects that behave as iterators\nPython constructs like for that use iterators can work on any type of iterator\n\nSo long as it fulfills the protocol (__next__ method and raises StopIteration)\nconstruction doesn’t know what its dealing with, just sees the __next__ method\nStopIteration raised once there are no more elements left",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 10: Using Classes to Create Active Objects"
    ]
  }
]