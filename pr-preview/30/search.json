[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Beginning to Code with Python: Notes, Examples and Exercises",
    "section": "",
    "text": "This repository contains code fragments, notes and exercises from the book Begin to Code With Python by Rob Miles. The book is available at the official Microsoft Press Store.\nI started this repository to work through an easy and basic book before working on some more intermediate level python projects and books."
  },
  {
    "objectID": "index.html#contents",
    "href": "index.html#contents",
    "title": "Beginning to Code with Python: Notes, Examples and Exercises",
    "section": "Contents",
    "text": "Contents\n\nPart 1. Programming Fundamentals\n\nChapter 2: Python and Programming\nChapter 3: Python Program Structure\nChapter 4: Working with Variables\nChapter 5: Making Decisions\nChapter 6: Repeating Actions with Loops\nChapter 7: Using Functions to Simplify Programs\nChapter 8: Storing Collections of Data\n\n\n\nPart 2. Advanced Programming\n\nChapter 9: Using Classes to Store Data\n\nExtension Exercises for Chapter 9\n\nChapter 10: Use Classes to Create Active Objects\nChapter 11: Object-Based Solution Design\nChapter 12: Python Applications\n\n\n\nPart 3. Useful Python\n\nChapter 13: Python and Graphical User Interfaces\n\n\n\nUseful Python\n\n\n\n\n\n\nImportant\n\n\n\nChapter 1 only provides basic information on installing python and assumes a Windows environment so is not covered in these notes"
  },
  {
    "objectID": "index.html#python-version-and-writing-style",
    "href": "index.html#python-version-and-writing-style",
    "title": "Beginning to Code with Python: Notes, Examples and Exercises",
    "section": "Python Version and Writing Style",
    "text": "Python Version and Writing Style\n\nThe original book was written with python 2.X and python 3.6 in mind.\nCurrently we’ve written the code using python 3.12.\nSmall changes have been made to the supplied code to resolve the following issues:\n\nsnaps get_string function not allowing the user to actually supply input\nsnaps display_image modified to deal with issues where .png files might not display\n\nIn general the code style of the solutions is restricted to elements of the python language introduced up until that point\n\nFor some of the extension exercises we have gone beyond that by still restricting ourselves to concepts that have been introduced, e.g\n\nWe use random.choice to select random items from a list, after having been exposed to both the random and list libraries\nWe use the string method find after having been introduced to the concept of string methods and substrings searching with startswith"
  },
  {
    "objectID": "02_AdvancedProgramming/12_PythonApplications/Chapter_12.html",
    "href": "02_AdvancedProgramming/12_PythonApplications/Chapter_12.html",
    "title": "Chapter 12: Python Applications",
    "section": "",
    "text": "Python functions are powerful and can be used in some interesting ways\n\n\n\n\nWe’ve seen that we can use references to functions much like variables\ne.g. map in Chapter 10 took a reference to a function and applied it element-wise to a list\n\nAnother example was filter\n\nLet’s explore this in more detail, consider the following code snippet (see SimpleFunctionReferences.py)\n\n  # Example 12.1 Simple Function References\n\n  def func_1():\n      print(\"Hello from function 1\")\n\n  def func_2():\n      print(\"Hello from function 2\")\n\n  x = func_1\n  x()\n  x = func_2\n  x()\n\nHello from function 1\nHello from function 2\n\n\nWe have two functions func_1 and func_2\nWe can assign the variable x to refer to and call each of these in turn\n\nThe dereference operator () called on x resolves to the function it references\n\nThe variable is effectively another name for the function\nWe still have to call it properly, e.g. (see InvalidFunctionReferences.py)\n\n  # Example 12.2 Invalid Function References\n\n  def func_1():\n      print(\"Hello from func_1\")\n\n  x = func_1\n  x(99)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[2], line 7\n      4     print(\"Hello from func_1\")\n      6 x = func_1\n----&gt; 7 x(99)\n\nTypeError: func_1() takes 0 positional arguments but 1 was given\n\n\n\nThe above generates an error as expected, because x is given an argument 99\nfunc_1 takes no arguments\nThe error resolves to the original function name (here func_1)\n\n\n\n\nRecall back in Chapter 7 we created a module for getting validated user input, BTCInput\nWe wrote code for reading integers and floating points with an additional ranged API\nBoth functions pretty much looked the same except one used int() to convert user input, the other used float()\nAs a refresher here is read_int\n  def read_int(prompt):\n      while True:\n          try:\n              # read in the number\n              number_text = read_text(prompt)\n              # perform conversion to int\n              result = int(number_text)\n              break\n          except ValueError:\n              print(\"Please enter an integer\")\n      return result\nWe could combine these two functions into one by using a function-valued variable\ni.e. the function now accepts as a argument a function that takes in a string and converts the result to the appropriate type of number\n  def read_number(prompt, number_converter):\n      \"\"\"\n      Read and convert a user-provided number\n\n      User is prompted for a number, and the resulting\n      string is converted by the supplied `number_converter`\n      function\n\n      Parameters\n      ----------\n      prompt : str\n          string to display to the user when asking for input\n      number_converter : Callable[[[str], int | float]\n          function that converts a string to a number. Must\n          raise a `ValueError` on invalid input\n\n      Returns\n      -------\n      int | float\n          User input converted to a number\n      \"\"\"\n      while True:\n          try:\n              number_text = read_text(prompt)\n              result = number_converter(number_text)\n              break\n          except ValueError:\n              print(\"Please enter a number\")\n      return result\nNow the call to int or float is instead replaced with a call to number_converter\nAs part of the documentation we have to specify the required behaviour of the number_converter function\n\nHere we need it to be a one parameter function that accepts a string\nThe returned result should be an int or float\nAdditionally a key requirement is that any failed conversion raises a ValueError so that the error-handling code in read_number catches it\n\nread_number is a great function from our programmer perspective\n\nBut not necessarily the cleanest implementation for a downstream user\nThey would still likely just want to call read_int or read_float\nWe’ll provide wrapper functions read_int and read_float that pass the appropriate parameters through to read_number\n\nWe’ll make them match the old API for input so a downstream user sees no change\n\n\n  def read_float(prompt):\n      return read_number(prompt=prompt, number_converter=float)\nObserve when we pass a function we just pass the name, don’t use ()\n\n\n\n\nFunction references are complicated, work through the following questions to help your understanding\n\nWhat is a function reference?\n\nOne piece of a program telling another what to do\nread_number is given a prompt, and a function\n\nThe function tells read_number how to convert to a number\n\n\nWhy is using function references like this a good idea?\n\nMakes code more maintainable\nRather than having basically the same code in two places read_int and read_float we have it in one place\nIf we later need to modify the code, we can now do it in one place read_number rather than making sure both functions remain consistent\n\nIf I wrote a function that converted Roman numerals into a numeric result, could I use read_number to read Roman Numbers?\n\nYes, as long as that function matches the requirements for number_converter\ni.e. Only takes in a string\n\nEasy enough, this should be the roman numerals\n\nReturns either an int or float\n\nEasy again Roman numerals convert to integers\n\nRaises a ValueError if an invalid Roman numeral is encountered\nIf we meet this API we could then use read_number e.g.\n  number = read_number(\"Enter your age in roman numerals: \", number_converter=roman_converter)\nThere is in fact nothing (other than the name read_number) that prevents us from using this function more generally\nWe could let number_converter be any function that takes a string argument, and returns a value, raising a ValueError on invalid input\n\ne.g. we could write date_converter that asks the user for a valid date string (e.g. 12/10/2017)\nCould convert this into a date object\n\nFunction parameters are thus a form of abstraction\n\nWe step away from a more concrete implementation (read_int, read_float etc)\nUse a more general solution read_number\nWe may then find that our solution is more general then we thought\n\ne.g. read_number actually provides a structure to parse a lot of input depending on the provided parsing function (number_converter)\ni.e. we might instead call read_number as parse_input\n\n\n\n\n\n\n\nWrite a function that takes a string representing roman numerals and converts it to an integer. Make this function work with the read_number API\nFirst lets set out some ground rules. The valid roman numerals are:\n\n\n\nSymbol\nI\nV\nX\nL\nC\nD\nM\n\n\n\n\nValue\n1\n5\n10\n50\n100\n500\n1000\n\n\n\nThe standard form for the roman numerals is given by,\n\n\n\n\nThousands\nHundreds\nTens\nOnes\n\n\n\n\n1\nM\nC\nX\nI\n\n\n2\nMM\nCC\nXX\nII\n\n\n3\nMMM\nCCC\nXXX\nIII\n\n\n4\n\nCD\nXL\nIV\n\n\n5\n\nD\nL\nV\n\n\n6\n\nDC\nLX\nVI\n\n\n7\n\nDCC\nLXX\nVII\n\n\n8\n\nDCCC\nLXXX\nVIII\n\n\n9\n\nCM\nXC\nIX\n\n\n\nTo create a value we append the appropriate thousands, hundreds, tens, and ones.\ne.g. \\(3698 = MMM + DC + XC + VIII = MMMDCXCVIII\\)\nThe basic conversion rules are as follows,\n\nRead from left to right\nConsider a “digit”.\n\nIf the next digit is the same value or less, then it is added to the total\n\ne.g. in \\(II\\) and \\(XI\\), we read these as \\(1 = 1\\), and \\(10 &gt; 1\\), so the running total is \\(1\\) and \\(10\\) respectively\n\nIf the next digit is a greater value, then we subtract from the total\n\ne.g. in \\(IV\\) we read this as \\(1 &lt; 4\\), so the running total is \\(-1\\)\n\nIf there is no next digit, then the value is added\n\n\nThis is the basic ruleset, we could write a function to convert using these rules and be perfectly happy with it. However, in many modern use cases there are stricter syntax rules which for fun we’ll also implement, namely\n\n\\(M\\), \\(C\\), \\(X\\), \\(I\\) can be repeated no more than three times sequentially, e.g. \\(IIII\\) is invalid\n\\(V\\), \\(L\\), \\(D\\) can’t be sequentially repeated, e.g. \\(VV\\) is invalid\nThere can be no repeated sequence of the same value before a subtraction, i.e. \\(IIV\\) is invalid because this should translate to \\(5 - 2\\).\nThere are precedence rules\n\n“Tens”-like values can only precede smaller or the next two largest valued characters\n\ne.g. \\(IV\\) or \\(IX\\) are valid, but not \\(IM\\)\ne.g. \\(XL\\) or \\(XC\\) are valid, but not \\(XD\\)\n\n“Fives”-like can values can only precede smaller\n\ne.g. \\(VI\\) is valid, but not \\(VX\\)\ne.g. \\(LI\\) and \\(LX\\) are valid, but not \\(LD\\)\n\n\n\nLet’s now plan out our algorithm, before considering valid syntax the basic structure will be as follows,\n\nset a running total to \\(0\\)\nIterate over each character\n\nConvert the character to their integer value\nIf the next character exists and it’s value is larger subtract the current value from the total\nElse, add the current value\n\nOnce all the characters have been processed return the total\n\nThe easiest way to do this would be to use a dictionary lookup. We can directly convert the symbol to a value. Now let’s go one step further. We’ll define a lightweight class RomanNumeral this holds the symbol, the value and importantly also a set bookkeeping what other roman numerals this one is allowed to precede\n\nclass RomanNumeral:\n    \"\"\"\n    Lightweight class representing a roman numeral\n\n    Attributes\n    ----------\n    symbol : str\n        latin character symbolising the roman numeral\n    value : int\n        numeric value of a roman numeral\n    precedes : set[str]\n        set of strings representing other roman numerals this numeral may precede\n    \"\"\"\n\n    def __init__(self, symbol, value, precedes):\n        \"\"\"\n        Create a new `RomanNumeral` Instance\n\n        Parameters\n        ----------\n        symbol : str\n            latin character symbolising the roman numeral\n        value : int\n            numeric value of a roman numeral\n        repetition_limit : int\n            maximum number of times the same numeral can be repeated\n        precedes : set[str]\n            set of strings representing other roman numerals this numeral may precede\n        \"\"\"\n        self.symbol = symbol\n        self.value = value\n        self.precedes = precedes\n\n    def may_precede(self, roman_numeral):\n        \"\"\"\n        Checks if this numeral may precede another\n\n        Parameters\n        ----------\n        roman_numeral : str\n            character representing roman numeral to check if we can precede\n\n        Returns\n        -------\n        `True` if `self` may precede `roman_numeral` else, `False`\n        \"\"\"\n        return roman_numeral in self.precedes\n\n\nWe define one helper function may_precede which is used to check if one symbol may precede another\nWe then define at the start of our function a dictionary containing the valid roman numerals\n\ndef roman_numeral_converter(number_string):\n    \"\"\"\n    Convert a number written in roman numerals to an int\n\n    The string must be a valid roman numeral in `standard format`__\n\n    Parameters\n    ----------\n    number_string : str\n        A valid roman numeral expression\n\n    Returns\n    -------\n    int\n        Result of converting the roman numeral to an int\n\n    Raises\n    ------\n    ValueError\n        Raised if `number_string` is not a valid roman numeral\n\n    .. _standard format: https://en.wikipedia.org/wiki/Roman_numerals#Standard_form\n    \"\"\"\n    roman_numerals = {\n        \"I\": RomanNumeral(\"I\", 1, {\"I\", \"V\", \"X\"}),\n        \"V\": RomanNumeral(\"V\", 5, {\"I\"}),\n        \"X\": RomanNumeral(\"X\", 10, {\"I\", \"X\", \"L\", \"C\"}),\n        \"L\": RomanNumeral(\"L\", 50, {\"I\", \"V\", \"X\"}),\n        \"C\": RomanNumeral(\"C\", 100, {\"I\", \"V\", \"X\", \"L\", \"C\", \"M\"}),\n        \"D\": RomanNumeral(\"D\", 500, {\"C\", \"L\", \"X\", \"V\", \"I\"}),\n        \"M\": RomanNumeral(\"M\", 1000, {\"I\", \"V\", \"X\", \"L\", \"C\", \"D\", \"M\"}),\n    }\n\n    def get_roman_numeral(numeral):\n        \"\"\"\n        Returns the `RomanNumeral` corresponding to the provided string\n\n        Parameters\n        ----------\n        numeral : str\n            character representing a roman numeral digit\n\n        Returns\n        -------\n        RomanNumeral\n            object describing the corresponding roman numeral\n\n        Raises\n        ------\n        ValueError\n            The provided character is not a valid roman numeral digit\n\n        \"\"\"\n        try:\n            return roman_numerals[numeral]\n        except KeyError:\n            raise ValueError(numeral, \"is not a valid character for a roman numeral\")\n\nThe function get_roman_numeral is a helper function defined inside our converter\n\nIt wraps the error handling of getting the roman numeral from the dictionary\nIt’s main purpose is to convert a KeyError for an invalid character into a ValueError as required by the read_number interface\n\nNow lets work through our previous algorithm and add in the syntax checking at the appropriate steps\n\n\nset a running total to \\(0\\), and previous to None\nIterate over each character\n\nIf the character doesn’t exist, a ValueError is raised\nIf this character is the same as the previous increment the number of repetitions\n\nIf it’s more than three, raise a ValueError for violation of the repetition rule\nElse reset the number of repetitions\n\nCheck if we’re at the end of the string\n\nIf so, add the current character’s value to the total and return\nElse, attempt to get the next character’s roman numeral data\n\nAgain raise a ValueError if it doesn’t exist\n\n\nCheck that the current character is allowed to precede the next character\n\nRaise a ValueError if it can’t\n\nCheck the next character’s value is larger\n\nIf it is\n\nCheck if the number of repetitions is greater than \\(1\\)\n\nIf it is, raise a ValueError since there can be no repetitions before a subtraction\nElse subtract the value of the current character from the total\n\n\nElse\n\nAdd the value to the current total\n\n\nSet the previous to the current character\n\n\nThe complete implementation is given by,\n\ndef roman_numeral_converter(number_string):\n    \"\"\"\n    Convert a number written in roman numerals to an int\n\n    The string must be a valid roman numeral in `standard format`__\n\n    Parameters\n    ----------\n    number_string : str\n        A valid roman numeral expression\n\n    Returns\n    -------\n    int\n        Result of converting the roman numeral to an int\n\n    Raises\n    ------\n    ValueError\n        Raised if `number_string` is not a valid roman numeral\n\n    .. _standard format: https://en.wikipedia.org/wiki/Roman_numerals#Standard_form\n    \"\"\"\n    roman_numerals = {\n        \"I\": RomanNumeral(\"I\", 1, {\"I\", \"V\", \"X\"}),\n        \"V\": RomanNumeral(\"V\", 5, {\"I\"}),\n        \"X\": RomanNumeral(\"X\", 10, {\"I\", \"X\", \"L\", \"C\"}),\n        \"L\": RomanNumeral(\"L\", 50, {\"I\", \"V\", \"X\"}),\n        \"C\": RomanNumeral(\"C\", 100, {\"I\", \"V\", \"X\", \"L\", \"C\", \"M\"}),\n        \"D\": RomanNumeral(\"D\", 500, {\"C\", \"L\", \"X\", \"V\", \"I\"}),\n        \"M\": RomanNumeral(\"M\", 1000, {\"I\", \"V\", \"X\", \"L\", \"C\", \"D\", \"M\"}),\n    }\n\n    def get_roman_numeral(numeral):\n        \"\"\"\n        Returns the `RomanNumeral` corresponding to the provided string\n\n        Parameters\n        ----------\n        numeral : str\n            character representing a roman numeral digit\n\n        Returns\n        -------\n        RomanNumeral\n            object describing the corresponding roman numeral\n\n        Raises\n        ------\n        ValueError\n            The provided character is not a valid roman numeral digit\n\n        \"\"\"\n        try:\n            return roman_numerals[numeral]\n        except KeyError:\n            raise ValueError(numeral, \"is not a valid character for a roman numeral\")\n\n    total = 0\n    previous = None\n    n_reps = 0\n    number_string = number_string.upper().strip()\n    max_repeats = 3\n\n    for i, ch in enumerate(number_string):\n        # get the roman numeral associated with the next character\n        numeral = get_roman_numeral(ch)\n        if numeral.value == previous:\n            # check that we haven't repeated this numeral too many times\n            n_reps += 1\n            if n_reps &gt; max_repeats:\n                raise ValueError(\n                    ch,\n                    \"repeated {0} times, maximum is {1}\".format(n_reps, max_repeats),\n                )\n        else:\n            n_reps = 1\n        if i + 1 == len(number_string):  # reached the end and stop\n            return total + numeral.value\n        else:\n            next_numeral = get_roman_numeral(number_string[i + 1])\n\n            if not numeral.may_precede(next_numeral.symbol):\n                raise ValueError(\n                    \"Invalid roman numeral: {0} may not precede {1}\".format(\n                        numeral.symbol, next_numeral.symbol\n                    )\n                )\n            # if next is larger perform subtraction if valid\n            if next_numeral.value &gt; numeral.value:\n                if n_reps &gt; 1:\n                    raise ValueError(\n                        \"Invalid roman numeral: cannot repeat digits for subtraction\"\n                    )\n                else:\n                    total -= numeral.value\n            else:\n                total += numeral.value\n        previous = numeral.value\n    return total\n\nWhich we can see on some sample valid inputs,\n\nprint(\"I: Expected: 1, Received: {0}\".format(roman_numeral_converter(\"I\")))\nprint(\"V: Expected: 5, Received: {0}\".format(roman_numeral_converter(\"V\")))\nprint(\"X: Expected: 10, Received: {0}\".format(roman_numeral_converter(\"X\")))\nprint(\"II: Expected: 2, Received: {0}\".format(roman_numeral_converter(\"II\")))\nprint(\"III: Expected: 3, Received: {0}\".format(roman_numeral_converter(\"III\")))\nprint(\n    \"MMMDCXCVIII: Expected: 3698, Result: {0}\".format(\n        roman_numeral_converter(\"MMMDCXCVIII\")\n    )\n)\n\nI: Expected: 1, Received: 1\nV: Expected: 5, Received: 5\nX: Expected: 10, Received: 10\nII: Expected: 2, Received: 2\nIII: Expected: 3, Received: 3\nMMMDCXCVIII: Expected: 3698, Result: 3698\n\n\nAnd on a sample invalid input,\n\n    print(\n        \"VV: Expected: Invalid Number, Received: {0}\".format(\n            roman_numeral_converter(\"VV\")\n        )\n    )\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[6], line 3\n      1 print(\n      2     \"VV: Expected: Invalid Number, Received: {0}\".format(\n----&gt; 3         roman_numeral_converter(\"VV\")\n      4     )\n      5 )\n\nCell In[4], line 84, in roman_numeral_converter(number_string)\n     81 next_numeral = get_roman_numeral(number_string[i + 1])\n     83 if not numeral.may_precede(next_numeral.symbol):\n---&gt; 84     raise ValueError(\n     85         \"Invalid roman numeral: {0} may not precede {1}\".format(\n     86             numeral.symbol, next_numeral.symbol\n     87         )\n     88     )\n     89 # if next is larger perform subtraction if valid\n     90 if next_numeral.value &gt; numeral.value:\n\nValueError: Invalid roman numeral: V may not precede V\n\n\n\nA more comprehensive set of tests can be found in the complete program\n\n\n\n\n\n\nNote\n\n\n\nTrusting vs Checking the Input\nYou can see that compared to the simple algorithm outlined for the case were we assumed the input was valid, the final algorithm is a lot longer. This is most due to it performing syntax validation at the same time as it calculates the result.\nThis is a common philosophical argument. Should roman_numeral_converter validate it’s input. In principle we could write a function validate_roman_numeral which would check that the string is valid. Doing it this way means we could make roman_numeral_converter itself quite lean. This has the downside that we would need to make two passes through the string now. The first to validate and the second to convert it.\nThere are two sides here, the safer version of roman_numeral_converter can be used anywhere and always ensures it’s input is valid. This comes at the cost that for valid input we are doing extra work checking it. Thus it’s a tradeoff, if we expect to receive valid input then we can use the fast version (and if there is perhaps a separate path that can supply invalid input we might use validate_roman_numeral), but if not we should use a protected version.\nSince our implementation is designed to be for parsing user input, I’ve combined the code into one function. In the future if the design requirements changed I might revisit this choice\n\n\nThere’s another more simple implementation of this. If we restrict ourselves as above to the standard form then we can only represent \\(1\\) to \\(3999\\), and each has a unique representation. Thus we could create an explicit conversion dictionary that makes the string representation to the integer representation. This is a form of lookup table. We set the lookup table to be generated when the roman numeral conversion code is loaded.\n# Exercise 12.1b Roman Numeral Converter\n#\n# Write a function that converts strings of roman numerals to an integer\n#\n# This implementation uses a lookup table\n\nimport itertools\n\nimport BTCInput\n\nthousands = {\"\": 0, \"M\": 1000, \"MM\": 2000, \"MMM\": 3000}\nhundreds = {\n    \"\": 0,\n    \"C\": 100,\n    \"CC\": 200,\n    \"CCC\": 300,\n    \"CD\": 400,\n    \"D\": 500,\n    \"DC\": 600,\n    \"DCC\": 700,\n    \"DCCC\": 800,\n    \"CM\": 900,\n}\ntens = {\n    \"\": 0,\n    \"X\": 10,\n    \"XX\": 20,\n    \"XXX\": 30,\n    \"XL\": 40,\n    \"L\": 50,\n    \"LX\": 60,\n    \"LXX\": 70,\n    \"VXXX\": 80,\n    \"XC\": 90,\n}\nones = {\n    \"\": 0,\n    \"I\": 1,\n    \"II\": 2,\n    \"III\": 3,\n    \"IV\": 4,\n    \"V\": 5,\n    \"VI\": 6,\n    \"VII\": 7,\n    \"VIII\": 8,\n    \"IX\": 9,\n}\n\n\nroman_numeral_dictionary = {}\n\nfor p in itertools.product(\n    thousands.items(), hundreds.items(), tens.items(), ones.items()\n):\n    key = \"\"\n    value = 0\n    for symbol_value_pair in p:\n        key += symbol_value_pair[0]\n        value += symbol_value_pair[1]\n    roman_numeral_dictionary[key] = value\n\nroman_numeral_dictionary.pop(\"\")\nWe define component dictionaries for each valid roman numeral that is purely a thousands, hundreds, tens or singles expression. Any valid expression is then given by the concatenation of the strings and addition of the values. The valid expressions are thus all possible pairings which is given by the cartesian product of all the dictionaries. (We add the empty string as a key to give a \\(0\\) value to represent not choosing from a given set)\nOnce we generated all the possible pairings we then build the dictionary by iterating over the pairings and concatenating the string components to create the string. The value is similarly created by adding all the value components.\nOur actual implementation of the roman numeral lookup parser is simple, we normalise the input (convert to upper case and strip whitespace), and then simply try to get the value from the dictionary. As before we convert KeyError for missing values to ValueError to comply with the read_number interface\ndef roman_numeral_converter(number_string):\n    \"\"\"\n    Convert a number written in roman numerals to an int\n\n    The string must be a valid roman numeral in `standard format`__\n\n    Parameters\n    ----------\n    number_string : str\n        A valid roman numeral expression\n\n    Returns\n    -------\n    int\n        Result of converting the roman numeral to an int\n\n    Raises\n    ------\n    ValueError\n        Raised if `number_string` is not a valid roman numeral\n\n    .. _standard format: https://en.wikipedia.org/wiki/Roman_numerals#Standard_form\n    \"\"\"\n    try:\n        return roman_numeral_dictionary[number_string.upper().strip()]\n    except KeyError:\n        raise ValueError(\"{0} is not a valid roman numeral\".format(number_string))\nIf we wanted to make this even faster, we could have used a python program to generate the dictionary, print that out and copy the lookup table into the file. However for demonstration purposes seeing how it’s generated is useful\nThis implementation is found in RomanNumeralLookupTable.py and passes all the same tests as the previous one\n\n\n\n\n\nFunction references can be used as any other references\nFor example, we can create collections\n\n# Example 12.3 Robot Dancer\n#\n# Demonstrates creating collections of function references\n\nimport time\n\n\ndef forward():\n    print(\"Robot moving forward\")\n    time.sleep(1)\n\n\ndef back():\n    print(\"Robot moving backwards\")\n    time.sleep(1)\n\n\ndef left():\n    print(\"Robot moving left\")\n    time.sleep(1)\n\n\ndef right():\n    print(\"robot moving right\")\n    time.sleep(1)\n\n\ndance_moves = [forward, back, left, right]\n\nprint(\"Dance starting\")\nfor move in dance_moves:\n    move()\nprint(\"Dance over\")\n\n\nDance starting\nRobot moving forward\nRobot moving backwards\nRobot moving left\nrobot moving right\nDance over\n\n\n\nWe define a set of functions\nThen create a collection referencing them\nHere they represent a robot performing a sequence of dance moves\nA longer program can then be created by increasing the length of the function\n\n\n\n\n\nA lambda function is like a tiny one line function\nHas the following structure\n\n\n\n\n\n\nblock-beta\n    columns 4\n    space\n    title[\"Breakdown of an Lambda Expression\"]:2\n    space\n\n    block:LambdaStatement\n    columns 1\n        lambda[\"lambda\"]\n        lambdaDescr[\"(start of the lambda)\"]\n    end\n\n    block:Arguments\n    columns 1\n        argument[\"arguments\"]\n        argumentDescr[\"(comma-separated list of arguments values)\"]\n    end\n\n    block:Colon\n    columns 1\n        colon[\":\"]\n        colonDescr[\"colon\"]\n    end\n\n    block:Expression\n    columns 1\n        expression[\"expression\"]\n        expressionDescr[\"(expression to be evaluated)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass argument BG\nclass argumentDescr BG\nclass colon BG\nclass colonDescr BG\nclass lambda BG\nclass lambdaDescr BG\nclass expression BG\nclass expressionDescr BG\n\n\n\n\n\n\n\nColon separates arguments (supplied values) from expression (results coming out), e.g.\n\ndef increment(x):\n    return x + 1\n\nIs equivalent to,\n\n\nincrement = lambda x : x + 1\nprint(increment(1))\n\n2\n\n\n\nWe can see this is called like a function, and returns the increment of the provided value\n\n\n\nWork through the following steps to understand lambda expressions\n\nEnter the following statement\n\n numbers = [1, 2, 3, 4, 5, 6, 7, 8]\n\n\nThis creates some sample data to work with\nLet’s say we want to increment very value of numbers by \\(1\\)\nWe could do this normally by defining a function and using map\n\nDefine a function increment as below, and run the following code\n\n def increment(x):\n     return x + 1\n\n new_numbers = map(increment, numbers)\n print(list(new_numbers))\n\n[2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nThis works, but has two downsides\nOne have to name and define a function increment\nThe function then exists for the remaining lifetime of the scope\nThis is a natural use for a lambda\n\nNo need to associate a name\nexistence is restricted to the use of map\n\n\nRepeat the previous steps, but use a lambda as below instead of an explicit function\n\n new_numbers = map(lambda x : x + 1, numbers)\n print(list(new_numbers))\n\n[2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nThe same behaviour is observed\nBut the code is more compact, and the behaviour is localised to the map\n\nCreate the following lambda\n\n adder = lambda x, y : x + y\n\n\naddr is a lambda expression that takes two arguments and adds them\nWe can now use the lambda as we want\n\nRun the following expressions to demonstrate using the lambda\n\n adder(1, 2)\n\n3\n\n\n\nWe can see this evaluates like any other function call\n\n\n\n\n\nConsider the following questions about lambda expressions\n\nWhat are lambda expressions?\n\nCan think of them as data representing an operation to perform\nRather than passing a function reference we create a value containing that behaviour\nlambda expressions are sometimes called anonymous functions\n\nThey are functional behaviour without a named handle\n\n\nMust I use lambda expressions in my programs?\n\nNo\nLambdas don’t add any new behaviour over defining functions\nHowever, they can make code cleaner or more compact\nThey are especially useful for defining small temporary functions that are passed to things like map and filter\n\nCan a lambda function contain more than one action?\n\nNo\nThe active part of a lambda function is a single expression that calculates a return value\n\nCan a lambda expression accept multiple arguments?\n\nYes, we saw this with the addr lambda which took two arguments\nLambda’s can also technically take no arguments\n\nCan a lambda expression make decisions?\n\nA lambda could return True or False\nCan then use as a condition in programs\nWe can define conditional expressions to choose a value to return\n\n  hour = 8\n  print(\"morning\" if hour &lt; 12 else \"afternoon\")\n\nmorning\n\n\nFunctions as an in line if statement\n\nFirst value returned if condition evaluates true, else false\n\n\n\n\n\n\n\n\n        block-beta\n            columns 5\n            space\n            title[\"Breakdown of a Conditional Expression\"]:3\n            space\n\n            block:ValueStatement\n            columns 1\n                value[\"value\"]\n                valueDescr[\"(value of expression if true)\"]\n            end\n\n            block:If\n            columns 1\n                if[\"if\"]\n            end\n\n            block:Condition\n            columns 1\n                condition[\"condition\"]\n                conditionDescr[\"(True or False condition)\"]\n            end\n\n            block:Else\n            columns 1\n                else[\"else\"]\n            end\n\n            block:Value2\n            columns 1\n                value2[\"value\"]\n                value2Descr[\"(value of expression if true)\"]\n            end\n\n        classDef BG stroke:transparent, fill:transparent\n        class title BG\n        class value BG\n        class valueDescr BG\n        class if BG\n        class else BG\n        class colon BG\n        class colonDescr BG\n        class condition BG\n        class conditionDescr BG\n        class value2 BG\n        class value2Descr BG\n\n\n\n\n\n\n- Conditional expressions can be used anywhere an expression can be\n- A lambda can thus return a conditional expression\n\n    day_prompt = lambda hour : \"morning\" if hour &lt; 12 else \"afternoon\"\n    print(\"{0} is during the day: {1}\".format(8, day_prompt(8)))\n    print(\"{0} is during the day: {1}\".format(13, day_prompt(13)))\n\n8 is during the day: morning\n13 is during the day: afternoon\n\n\n\n\n\n\n\n\nNote\n\n\n\nDon’t worry if you don’t get lambda expressions the first time you see them\nLambda expressions can be difficult to understand at first. They blur the lines between data and program code. Our previous programs seperate the data (as values) from the code (as functions). A lambda expression is code as data. Sometimes it’s useful to be able to pass behaviours around as data and lambdas provide a way to do that\n\n\n\n\n\n\n\nRecall python has a concept of an iterator\nGenerally when we encounter iterators we work through the values they generate\nrange is an example, e.g. creating a sequence of numbers\n\n  for i in range(1, 5):\n      print(i)\n\n1\n2\n3\n4\n\n\nrange returns a result that is an iterator producing the values \\(1\\) to \\(4\\).\nWhen then consume the values to print them in order\n\nRemember range does not include the end point\n\nIterators can be made by using the yield keyword\n\nA yield is like a function return but the function remembers its state\nfunctions that yield can be used to create a sequence of values\n\n\n\n\nUse an interpreter to work through the following steps to learn about the yield keyword\n\nEnter the following into the interpreter\n\n def my_yield():\n     yield 1\n     yield 2\n     yield 3\n     yield 4\n\n\nThe function my_yield contains four yield statements\nEach returns a value\nLet’s see what happens when we now loop over the function\n\nDefine and run the following loop\n\n for i in my_yield():\n     print(i)\n\n1\n2\n3\n4\n\n\n\nWe can see that the value returned by each yield is printed out in turn\nWe could also convert this to a list\n\nDefine and run the following\n\n list(my_yield())\n\n[1, 2, 3, 4]\n\n\n\nlist accepts an iterator and converts it to list\n\n\n\n\n\n\nyield can be used to make a flexible test data generator\n\ne.g. for Time Tracker\ne.g. If we want to do load testing for when we have hundreds of contacts rather than say tens\n\n\n\n\n\n\n\n\nTip\n\n\n\nUsing a program to create test data is a great idea\nIf you find yourself entering lots of test data into your programs, you should write a program to do the work for you. Remember that computers were created to spare us from drudgery, not create more of it\n\n\n\n# Example 12.5 Test Contact Generator\n#\n# Demonstrates using yield to generate test Contacts for the\n# time tracker application\n\n\nclass Contact:\n    def __init__(self, name, address, telephone):\n        self.name = name\n        self.address = address\n        self.telephone = telephone\n        self.hours_worked = 0\n\n    @staticmethod\n    def create_test_contacts():\n        phone_number = 1000000\n        hours_worked = 0\n        for first_name in (\"Rob\", \"Mary\", \"Jenny\", \"Davis\", \"Chris\", \"Imogen\"):\n            for second_name in (\"Miles\", \"Brown\"):\n                full_name = first_name + \" \" + second_name\n                address = full_name + \"'s house\"\n                telephone = str(phone_number)\n                telephone = telephone + str(1)\n                contact = Contact(full_name, address, telephone)\n                contact.hours_worked = hours_worked\n                hours_worked = hours_worked + 1\n                yield contact\n\n\nThe test data generation is implemented as a static method\n\nLet’s us access and set hidden attributes on the Contact class\n\nImplementation (make_test_contacts) cycles through a set of first and last names\n\nContacts are then generated with a generated name, a simplified address (we simply append 's house' to the end of the name), a telephone number and hours_worked\nEach iteration increases the telephone number and hours worked by one\n\nWe can the use the method as a iterator, see\n\n\nfor contact in Contact.create_test_contacts():\n    print(contact.name)\n\ncontacts = list(Contact.create_test_contacts())\n\nfor contact in contacts:\n    print(\n        \"\"\"{0}\nAddress: {1}\nTelephone: {2}\nHours worked: {3}\n\"\"\".format(contact.name, contact.address, contact.telephone, contact.hours_worked)\n    )\n\nRob Miles\nRob Brown\nMary Miles\nMary Brown\nJenny Miles\nJenny Brown\nDavis Miles\nDavis Brown\nChris Miles\nChris Brown\nImogen Miles\nImogen Brown\nRob Miles\nAddress: Rob Miles's house\nTelephone: 10000001\nHours worked: 0\n\nRob Brown\nAddress: Rob Brown's house\nTelephone: 10000001\nHours worked: 1\n\nMary Miles\nAddress: Mary Miles's house\nTelephone: 10000001\nHours worked: 2\n\nMary Brown\nAddress: Mary Brown's house\nTelephone: 10000001\nHours worked: 3\n\nJenny Miles\nAddress: Jenny Miles's house\nTelephone: 10000001\nHours worked: 4\n\nJenny Brown\nAddress: Jenny Brown's house\nTelephone: 10000001\nHours worked: 5\n\nDavis Miles\nAddress: Davis Miles's house\nTelephone: 10000001\nHours worked: 6\n\nDavis Brown\nAddress: Davis Brown's house\nTelephone: 10000001\nHours worked: 7\n\nChris Miles\nAddress: Chris Miles's house\nTelephone: 10000001\nHours worked: 8\n\nChris Brown\nAddress: Chris Brown's house\nTelephone: 10000001\nHours worked: 9\n\nImogen Miles\nAddress: Imogen Miles's house\nTelephone: 10000001\nHours worked: 10\n\nImogen Brown\nAddress: Imogen Brown's house\nTelephone: 10000001\nHours worked: 11\n\n\n\n\n\n\nAnswer the following questions about the previous bits of code\n\nWhy is create_test_contacts a static method?\n\nWe don’t want to ask a specific Contact for test information\nWe want to generate a new Contact as test data\nBelongs with the Contact class itself\n\nWhat is the difference between yield and return?\n\nyield pauses function execution and bookmarks where it is, returning the yield\n\nSubsequent call follows on from this position\n\nreturn returns the value and ends function execution\n\nAll subsequent executions will begin from the start of the function\n\nreturn does not support iteration\nConsider the following,\n\n  def yield_return():\n      yield 1\n      yield 2\n      return 3\n      yield 4\n\n  for i in yield_return():\n      print(i)\n\n1\n2\n\n\nThe iteration only prints 1 and 2 since the third iteration encounters a return which ends the iteration (and is not included)\n\nWe never reach the yield 4 statement\n\n\nDoes a function using yield have to return?\n\nNo\nAn iterator using yield could in theory run forever, e.g.\n\n  def forever_tens():\n      result = 0\n      while True:\n          yield result\n          result = result + 10\n\nThis creates an infinitely long iteration\nEach value is ten times larger than before\n\n  for result in forever_tens():\n      print(result)\n      if result &gt; 100:\n          break\n\n0\n10\n20\n30\n40\n50\n60\n70\n80\n90\n100\n110\n\n\nLoop continues until the result returned by the iterator is too large\n\nWhat happens to local variables in a yielded function?\n\nLocal variables are retained when the function yields a result\ne.g. forever_tens() relies on the value of result being preserved between calls to generate the continuing sequence\n\n\n\n\n\n\n\nWe’ve seen functions like print which seem to accept a variety of arguments, e.g.\n\n  print(\"a\")\n  print(\"a\", \"b\")\n\na\na b\n\n\nWhen we’ve written functions, we’ve been able to define optional or default-valued parameters\nHowever, we’ve always had to specify the number of variables\nprint accepts an arbitrary number of arguments\n\n\n\nLet’s learn about arbitrary-argument functions by working through the following steps in the interpreter\n\nDefine the following function\n\n def add_function(x, y):\n     return x + y\n\n\nThis is a function that adds two numbers\n\n  add_function(1, 2)\n\n3\n\n\nHowever if we tried to add three numbers,\n\n  add_function(1, 2, 3)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[28], line 1\n----&gt; 1 add_function(1, 2, 3)\n\nTypeError: add_function() takes 2 positional arguments but 3 were given\n\n\n\nWe see that we get an error because there’s a mismatch between the number of arguments required and supplied\n\n\n\nIt might make sense to have a function like add_function that accepts an arbitrary number of numbers and adds them all together\nWe can specify to a python function that an arbitrary number of arguments are accepted with the * identifier, e.g.\n\n  def add_function(*values):\n      total = 0\n      for value in values:\n          total = total + value\n      return total\n\nThe above could accept any number of arguments, including zero\n\n  print(add_function())\n  print(add_function(1))\n  print(add_function(1,2))\n  print(add_function(1,2,3))\n\n0\n1\n3\n6\n\n\nA parameter indicating an arbitrary number of parameters may be preceded by normal parameters\nFor example, if we wanted to force the add_function to receive at least one value\n\n  def add_function(start, *values):\n      total = start\n      for value in values:\n          total = total + value\n      return total\n\n  print(add_function(1))\n  print(add_function(1,2))\n\n1\n3\n\n\nIf we try and pass nothing to the above, we get an error\n\n      add_function()\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[32], line 1\n----&gt; 1 add_function()\n\nTypeError: add_function() missing 1 required positional argument: 'start'\n\n\n\nWhat happens if the user already has an arbitrary number of values stored in a collection?\nHow do they translate a tuple say x = (1,2,3, 4) into the correct call structure?\n\nCan’t just write add_function(x) since that will treat x as one variable\n\nNeed a way to unpack the contents\nThis is provided by the * operator\n\nUnpacks a collection\n\nFor example,\n\n  numbers = (1, 2, 3, 4)\n  add_function(0, *numbers)\n\n10\n\n\nEach element in numbers is unpacked out into their own argument\n\n\n\n\n\n\n\nWarning\n\n\n\nThe * Character in function arguments can cause confusion with C and C++ syntax\nAs discussed in python * is used to represent unpacking a collection into it’s constituent values. Other languages may use * for different meanings. An example is C and C++ where * is used to handle and manipulate pointers (memory addresses). Something to learn as you work with multiple languages - be careful not to get your syntax’s confused.\n\n\n\nPython provides an inbuilt function that performs the functionality of the add_function called sum\n\nsum expects its arguments to passed as an iterable though\n\n\n  sum(numbers)\n\n10\n\n\nSome sample code for arbitrary argument functions is provided in ArbitaryArgumentFunctions.py\n\n\n\n\n\n\nWe’ve already seen that we can build python programs out of multiple source files. In this section we’ll look more closely at ways of structuring large python projects split across multiple files through the concepts of modules and packages\n\n\n\nA python module is essentially a python file\nFor example the file BTCInput.py is a file that contains function definitions for reading valid input\n\nWe also call it a module\n\nTypically the difference between a module and a script is that a module is designed to be imported by another program\n\nA script typically runs standalone\nThis is just a heuristic though\n\nWe’ve seen that we can include a module using the import statement\nSo if we wanted to use BTCInput to read an integer restricted to a range, we write\n  import BTCInput\n\n  age = BTCInput.read_int_ranged(prompt=\"Enter age: \", min_value=5, max_value=95)\n  print(\"Your age is: \", age)\nA sample interaction might then be,\n\n\n\nEnter age:  31\n\nYour age is: 31\n\n\n\n\nPython will execute and obey all statements in a module when a module is imported\nFor BTCInput these are function definitions\nA module could also define variables or other code that should be executed on load-\n\n\n\n\nWe could add a readme function to BTCInput that describes the modules contents\n\n  VERSION = \"1.0.0\"\n\n\n  def readme():\n      print(\n          \"\"\"Welcome to the BTCInput functions module version {0}\n\n  BTCInput provides functions for reading numbers and strings and validating the\n  user input.\n\n  The functions are used as follows:\n  text = read_text(prompt)\n  int_value = read_int(prompt)\n  int_float = read_float(prompt)\n  int_value = read_int_ranged(prompt, min_value, max_value)\n  float_value = read_float_ranged(prompt, min_value, max_value)\n\n  BTCInput also provides read_number and read_number_ranged which can be\n  used in conjunction with a user-defined function to provide custom\n  number parsing behaviour\n\n  Have fun with them.\n  Rob Miles\"\"\".format(VERSION)\n      )\n\nreadme displays a string which provides the user with some basic usage information\nWe’ve added a little variable that tracks the version of the file - automatically updated in the documentation\nThe user has to manually call the readme though\nLater we’ll see how to generate the description text directly from the code docstring (View Program Documentation)\n\n\n\n\n\nPython modules are files like any other\nThey can be run by the python interpreter\nFor example, we might add a call to readme\n\nSo someone running BTCInput automatically sees the documentation\n\n\n  # all the BTCInput functions go here\n  # end of the file\n  readme()\n\nWelcome to the BTCInput functions module version 1.0.0\n\nBTCInput provides functions for reading numbers and strings and validating the\nuser input.\n\nThe functions are used as follows:\ntext = read_text(prompt)\nint_value = read_int(prompt)\nint_float = read_float(prompt)\nint_value = read_int_ranged(prompt, min_value, max_value)\nfloat_value = read_float_ranged(prompt, min_value, max_value)\n\nBTCInput also provides read_number and read_number_ranged which can be\nused in conjunction with a user-defined function to provide custom\nnumber parsing behaviour\n\nHave fun with them.\nRob Miles\n\n\nRecall: on importing python executes all the statements in a file\nThis means the readme is displayed even when the user imports the module\n\nProbably not the desired behaviour\n\n\n\n\n\n\nPrinting the readme is useful when the actual module is executed\nHowever, would like a way to turn this off when the module is imported\nPython provides the __name__ variable\n\nHelps define the context in which the program is running\n\nIf a module is imported, __name__ is set to the name of the module\nIf a module is running as the original code that started the program, then __name__ is set to __main__\nCan thus be used to restrict code that we don’t want to run outside of the __main__ context (or alternatively on import)\n  if __name__ == \"__main__\":\n      readme()\n\n\n\nClick here to access the updated version of BTCInput\nRun the file through the interpreter, you should see the readme be displayed. Then replace the implementation of BTCInput in one of the previous examples with this new implementation and run that program. You should see that the the readme will not be displayed even though the file is imported\n\nOften useful to write modules also provide functionality as a program\nFor example, you may provide documentation as above, demonstrate examples alternatively a module may be designed to perform some basic functionality on user input (e.g. a mathematical program might read numbers and perform a calculation) and be imported by more complex programs\n\n\n\n\n\n\n\nLarge programs may contain many different program files\nAt that point we might want to start thinking about how we organise files, rather than have everything in one folder\nThis is the point at which packages can help\nA common organisation pattern (that we’ve previously utilised) is to put every major component in it’s own file\nFor example in our Fashion Shop we created two types of classes\n\nThose that handled the data (StockItem, FashionShop)\nThose that handled the UI (FashionShopApplication)\n\nEach of these components was written as it’s own file, and we wrapped the entry point in our FashionShopApplication.py\n\nFashionShopApplication.py imported StockItem.py and FashionShop.py to get the associated class components\n\nAn alternative arrangement might be to formulate the data components as one package and the UI components as another\nA (local) python package is a directory containing a set of python source files\n\nAn __init__.py file is used to mark a package\n\nBelow show’s how we could restructure the fashion shop application to use a package structure\n\n.\n├── Data\n│   ├── FashionShop.py\n│   ├── StockItem.py\n│   └── __init__.py\n├── FashionShopShellUI.py\n└── UI\n    ├── BTCInput.py\n    ├── FashionShopApplication.py\n    └── __init__.py\n\nUI contains the classes responsible for handling the user\n\nCurrently these are all shell-based\nIf in the future we introduce a GUI option we might create subpackages for UI\n\nShellUI for shell-based interactivity\nGUI for graphical-based interactivity\n\nAlso contains an __init__.py file\n\nData contains the classes responsible for handling the fashion shop data\n\nThis is the StockItem class, and the FashionShop container class\nAgain, we need the __init__.py\n\nOutside the class structure we define a FashionShopShellUI.py which is the entry point file\n\nConsumes the classes in the subpackages\nThis is not a package itself, so no need for an __init__.py\n\n\n\n\nConsider the following questions about modules\n\nHow do I decide which module goes in which package?\n\nRelated classes and functions should be in the same package\nFor the fashion shop as we’ve identified the types of modules are\n\nThose that handle the user interaction (FashionShopApplication.py and BTCInput.py)\nThose that handle the data representation of the fashion shop (FashionShop and StockItem)\n\n\nWhat does the __init__.py file in a package do?\n\n__init__.py controls how a package is loaded\n__init__.py is ran when a package is first opened\n\nLike the constructor for a package\nCan set up resources, e.g. a help string, global constants etc.\n\n\n\n\n\n\n\n\nModules can be imported from packages\n\nSyntax is like that for importing a single class, function or variable from a module\n\n  from Data import FashionShop\nContents of the FashionShop module now available\nCan be used as we’ve seen before\n  shop = FashionShop.FashionShop()\nAs we’ve talked before the FashionShop class is namespaced by the module FashionShop.py (minus the .py extension)\nIf there was another FashionShop defined in another package (say DataStorage.py) we can differentiate them, e.g.\n  shop2 = DataStorage.FashionShop()\nWe could also just import the higher level package (Data) like a module, i.e.\n  import Data\nContents of the Data package now available\n\nAdds another level of namespacing, e.g. setting accessing the FashionShop class is now\n  shop = Data.FashionShop.FashionShop()\n\n\n\n\nClasses can be used as values just as we’ve seen with functions. Work through the following steps in the python interpreter to understand how this works\n\nEnter the statements below into the python interpreter\n\n class VarTest:\n     def __init__(self):\n         print(\"making a VarTest\")\n\n\nThis creates a class VarTest with a constructor\nConstructor simply prints a message\nWe can create a VarTest instance easily enough\n\n  x = VarTest()\n\nmaking a VarTest\n\n\nWe can see the __init__ method is called and we create a new VarTest instance, referenced by x\n\nNow assign the class definition itself to a variable, as in the statement below\n\n y = VarTest\n\n\nObserve no parentheses around VarTest\nMirrors the case where we want a reference to a function\ny has the value of VarTest which is the class definition itself\ny is effectively an alias for VarTest and can be used the same way, e.g.\n\n  z = y()\n\nmaking a VarTest\n\n\nWe can see that this creates a new VarTest instance and assigns it to z\n\nAs if we had written z = Vartest() directly\n\n\n\n\nClass references can be treated as any other data, including\n\nBeing used in collections (e.g. lists, dictionaries)\nPassed as arguments to function calls\n\nThe statement below sets the variable shop to the class definition of the FashionShop\n  shop = FashionShop.FashionShop\nOur UI shouldn’t need to know about the underlying data representation directly\n\nShould just now the interface it needs to work with\nThen we can have it accept any implementation that obeys this interface\nWe could say then pass shop as an argument\n\n\n\n\n\nWork through the following questions to understand how class references work\n\nWhat are the benefits of using class references?\n\nClass references allow to define common implementations and then change the underlying implementation\n\nWe might replace the shell interface with a GUI\nWe might replace the FashionShop in-memory data storage with a database\n\nIf we can make the new implementations conform to the interface then all we need to do is change the class reference\n\nReduces the coupling between components\nMakes the implementation easier to manage\n\n\n\n\nHow do we introduce class references in a program?\nWe’ll write a program FashionShopShellUI.py that handles connecting the components together\n\nCreates the UI and displays it\nStart by importing our modules\n\n  # Example 12.8a Modular Fashion Shop\n  #\n  # Provides the entry point and coordinating behaviour for a modularised\n  # implementation of the Fashion Shop Application\n\n\n  from Data import FashionShop\n  from UI import FashionShopApplication\n\n  # load the UI implementation\n  ui = FashionShopApplication.FashionShopApplication\n\n  # load the data management implementation\n  shop = FashionShop.FashionShop\n\n  app = ui(filename=\"fashionshop.pickle\", storage_class=shop)\nWe start by defining on ui and shop classes which take the UI implementation in FashionShopApplication and FashionShop respectively\nWe then have to create our application\n\nWe create an instance of the application (using the reference ui)\n\nWe pass shop to define how the data is managed\nObserve that this is a new change to the API of FashionShopApplication we’ll have to implement\n\n\nLet’s update the FashionShopApplication API\n\nWe want to accept a class reference now when we construct the object\nSo we have to add one to the __init__ method\nWe then want to replace explicit calls to FashionShop with calls to this class reference\n\n  class FashionShopApplication:\n      \"\"\"\n      Provides a text-based interface for Fashion Shop inventory management\n      \"\"\"\n      def __init__(self, filename, storage_class):\n          \"\"\"\n          Creates a new `FashionShopApplication`\n\n          Attempts to load a `FashionShop` from the provided file. Otherwise\n          an empty instance is created\n\n          Parameters\n          ----------\n          filename : str\n              path to a file containing pickled `FashionShop` data\n          storage_class : Data Manager\n              class that supports the Fashion Shop Data Management API\n\n          See Also\n          --------\n          FashionShop : Main class for handling inventory management\n          \"\"\"\n          FashionShopApplication.__filename = filename\n          try:\n              self.__shop = storage_class.load(filename)\n          except:  # noqa: E722\n              print(\"Failed to load Fashion Shop\")\n              print(\"Creating an empty Fashion Shop\")\n              self.__shop = storage_class()\n\nWe’ve changed the API on the __init__ so we have to make sure we update the docstring appropriately\n\nNow we want to start running the program as before\n  app.main_menu()\nThere is one small step as well which is to update the import statements in FashionShopApplication.py\n\nNo longer explicitly requires FashionShop\nNeeds to import StockItem from the Data package\nNeeds to import BTCInput from the UI package\n  - import BTCInput\n  + from UI import BTCInput\n  - import StockItem\n  + from Data import StockItem\n  - import FashionShop\n\n\n\n\n\n\n\n\nWarning\n\n\n\nPython imports can be Confusing\nAn annoying feature of python import statements is that they are resolved relative to the directory where the entry point is. This means that even though BTCInput is in the same package as FashionShopApplication we can’t write\n    import BTCInput\nbut instead have to write\n    from UI import BTCInput\nThis is rather annoying because in theory FashionShopApplication shouldn’t need to care what folder it’s located in, let alone where the starting point is. If we wanted to write another higher level program that contained our entire fashion shop application as a package this would break the imports. The way to resolve this is to install the packages, but that’s beyond the scope for now\n\n\n\nYou can find the modularised implementation in 08_FashionShopApp\nAs an aside in the future as we add implementations we would likely rename FashionShopApplication to something more descriptive like FashionShopShell\n\n\n\n\n\n\n\nImportant\n\n\n\nUsing classes as values is an extremely powerful programming technique\nThe technique of passing functions or classes as arguments to higher-level classes or functions is called dependency injection. The idea is that if a class or function uses the interface of another class or function rather than hardcoding what the implementation of that interface is, we allow the implementation to be passed in as an argument (i.e. we inject the behaviour we want to implement)\nThe idea is to let us change how the behaviours specified by an API are implemented, for example we can use this to switch between a basic shell ui, a terminal-based ui or a full graphical ui. We might also want to switch our data storage layer from an in-memory approach to one that uses a database. If we hardcode the higher level implementation (i.e. a class that uses an in-memory loader and a shell ui) then we have to create many new implementations to support the desired behaviour. For example if we implement all the above options as hard coded classes we would have,\n\nin-memory loader + shell UI\nin-memory loader + terminal UI\nin-memory loader + graphical UI\ndatabase loader + shell UI\ndatabase loader + terminal UI\ndatabase loader + graphical UI\n\n\n\nIn other words, we created three new classes (2 new UI classes and one data storage class) but then had to define five additional classes to handle creating our application. With dependency injection there is no need to define new classes, we just swap out what class references we are using and pass them through to the high level application constructor.\nThis design also makes it much easier to test large components because we can inject a test implementation.\n\n\n\n\n\n\nTesting is part of the process of validating that a program meets requirements\nTests should be\n\nRepeatable (we can conduct the same test multiple times)\nDocumented (they clearly indicate what they test and the results)\nAutomatic (tests should be an integrated part of development)\n\nLet’s consider implementing tests for the StockItem from the Fashion Shop Application\nWe need to start by defining what features we want to test\n\nValidate that newly constructed StockItem instances have correctly set values for their attributes\nAttempts to create an invalid StockItem are rejected\nStockItem methods behave as expected\n\nWe could start with manual testing\n\ni.e. create a StockItem using the interpreter and check the behaviours\n\nHowever this is clearly not automatic\nIt is difficult to repeat since we have to follow the steps clearly\nHard to document\n\nIdeally the documentation should be colocated with the test\nThe same way we colocate documentation with a function (docstrings)\nClearly not the case if we’re manually entering values\n\nBetter is to write code that automatically tests the class\n\nWe’ve seen similar before where we’ve written print statements that output an expected versus actual value\nSee Roman Numeral Converter for an example\nThis still has the downside that we need to manually parse the output to check the tests passed\nWould be good to automate this part of the process as well!\n\nAn improvement might be to use exceptions, e.g.\n  item = StockItem(stock_ref=\"Test\", price=10, tag=\"test:tag\")\n  if item.stock_level != 0:\n      raise Exception(\"Initial Stock level not 0\")\nThis means that any failed test will stop the program and alert the user\nHow could we test code that is supposed to throw an exception?\nWe could write a wrapper, e.g.\n  excepted = False\n  try:\n      \"\"\"\n      Test behaviour that\n      should raise an exception\n      goes here\n      \"\"\"\n  except: # ideally specify the exact exception we expect\n      excepted = True\n\n  if not excepted:\n      raise Exception(\"Test Failed: No Exception raised\")\nIdeally define lots of small tests\nRepeat the relevant tests each time part of a program is updated\nOn large programs tests might be run automatically every day, night etc.\nPython provides some tools for making testing easier to implement\n\n\n\n\nPython defines the assert keyword\nLet’s programs test as they run\nAssert means “ensure this is true”\nWe can rewrite the previous test using assert\n  item = StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n  assert item.stock_level == 0\nLet’s see what happens if the assert fails\n\nWe’ll define a dummy StockItem class with a non-zero starting stock level\n\n\n  class StockItem:\n      def __init__(self, stock_ref, price, tags):\n          self.stock_level = 1\n\n  item = StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n  assert item.stock_level == 0\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[42], line 6\n      3         self.stock_level = 1\n      5 item = StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n----&gt; 6 assert item.stock_level == 0\n\nAssertionError: \n\n\n\nAs we can see an AssertionError is raised\n\nJust like any other form of exception\n\n\n\n\nWork through the following questions about assert statements\n\nHow many assert statements can a program contain?\n\nThere is no limit\n\nDoes the program continue after an assertion has failed?\n\nDepends on how the program handles it\nIf there’s no exception handling then the program will be stopped\nA try...catch block may allow the program to recover\n\n\n\n\n\n\n\nassert lets us write checks that execute in code\n\nCan be used to halt a program if an invalid state in encountered during execution\nDoesn’t intrinsically help us write many, small, independent tests\n\nPython provides a framework for automating the construction and execution of unit tests\nUnit tests are small, self-contained test designed to verify one behaviour (a unit)\nUnit tests for a component should be created alongside the component itself\n\nIn test-driven development the tests are written before the components themselves\n\nOr at least defined until we stabilise the API\nCode is written such that by implementing the behaviour to pass every more sophisticated tests we create a working component\n\n\nunittest is provided as part of the python standard installation\n\nImported the usual way\n\n  import unittest\n\n\nRecall our complete (tag-based) StockItem implementation\n\n\nclass StockItem:\n    \"\"\"\n    Represents a single inventory item\n\n    Attributes\n    ----------\n    stock_ref : str\n        reference id of the stock item\n    tags : set[str]\n        set of tags describing the stock item\n\n    Class Attributes\n    ----------------\n    show_instrumentation : bool\n        Indicates if instrumentation should be printed\n    max_stock_add : int\n        maximum amount of stock that can be added to an item's stock level at a time\n    min_price : int | float\n        minimum price of any stock item\n    max_price : int | float\n        maximum price of any stock item\n    \"\"\"\n\n    show_instrumentation = True\n\n    max_stock_add = 10\n\n    min_price = 0.5\n    max_price = 500\n\n    def __init__(self, stock_ref, price, tags):\n        \"\"\"\n        Creates a `StockItem` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            stock reference id\n        price : int | float\n            stock price\n        tags : set[str]\n            set of tags describing the stock item\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem __init__ called\")\n        self.stock_ref = stock_ref\n        self.__price = price\n        self.tags = tags\n        self.__stock_level = 0\n        self.__StockItem_version = 4\n\n    def __str__(self):\n        if StockItem.show_instrumentation:\n            print(\"**StockItem __str__ called\")\n        template = \"\"\"Stock Reference: {0}\nPrice: {1}\nStock level: {2}\nTags: {3}\"\"\"\n        return template.format(self.stock_ref, self.price, self.stock_level, self.tags)\n\n    @property\n    def price(self):\n        \"\"\"\n        price : int | float\n            dress price\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem get price called\")\n        return self.__price\n\n    @property\n    def stock_level(self):\n        \"\"\"\n        stock_level : int\n            amount of stock in inventory\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem get stock_level called\")\n        return self.__stock_level\n\n    def check_version(self):\n        \"\"\"\n        Checks the version of a `StockItem` instance and upgrades it if required\n\n        Returns\n        -------\n        None\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem check_version called\")\n        if self.__StockItem_version != 4:\n            print(\"Stock item uses old data model, please recreate this item\")\n\n    def add_stock(self, count):\n        \"\"\"\n        Add stock to an item\n\n        Parameters\n        ----------\n        count : int\n            amount of stock to add to an item\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        Exception\n            raised if `count` &lt; 0 or `count` &gt; `StockItem.max_stock_add`\n\n        See Also\n        --------\n        StockItem.max_stock_add : maximum amount of stock that can be added to a `StockItem`\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem add_stock called\")\n        if count &lt; 0 or count &gt; StockItem.max_stock_add:\n            raise Exception(\"Invalid add amount\")\n        self.__stock_level = self.__stock_level + count\n\n    def sell_stock(self, count):\n        \"\"\"\n        Sell stock of an item\n\n        Decreases the item's stock level\n\n        Parameters\n        ----------\n        count : int\n            amount of stock to sell\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        Exception\n            raised if `count` &lt; 1 or `count` is greater than the available stock\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem sell_stock called\")\n        if count &lt; 1:\n            raise Exception(\"Invalid number of items to sell\")\n        if count &gt; self.__stock_level:\n            raise Exception(\"Not enough stock to sell\")\n        self.__stock_level = self.__stock_level - count\n\n\nLet’s use unittest to write some unit tests\nunittest provides a class (TestCase) that acts as a superclass for tests\nWe create our tests by subclassing TestCase\n\nWe populate the class with method which implement our tests\n\nFirst we’ll write a test for the initializer\n\n  class TestStockItem(unittest.TestCase):\n\n      def test_StockItem_init(self):\n          item = StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n          self.assertEqual(item.stock_ref, \"Test\")\n          self.assertEqual(item.price, 10)\n          self.assertEqual(item.stock_level, 0)\n          self.assertEqual(item.tags, \"test:tag\")\n\nTestStockItem is our test class\n\nThe method test_StockItem_init tests the __init__ correctly sets the values on a StockItem instance\n\nself.assertEqual is a method inherited from the TestCase superclass\n\nPerforms the test\nFunctions like an assert in that it checks that the value passed as the first argument matches the value in the second argument\n\nIf equal the test passes\nElse, test fails\n\n\nWe can run the test by calling the main method for the unittest module\n  unittest.main()\n\n\n\n.\n----------------------------------------------------------------------\nRan 1 test in 0.001s\n\nOK\n\n\n**StockItem __init__ called\n**StockItem get price called\n**StockItem get stock_level called\n\n\n&lt;unittest.main.TestProgram at 0x7f195c843ef0&gt;\n\n\n\nThe above should show that our test executed successfully\nIf we want more detail we can use the verbosity parameter\n\nInteger number which represents the level of output detail\n\n\n    unittest.main(verbosity=2)\n\n\ntest_StockItem_init (__main__.TestStockItem.test_StockItem_init) ... ok\n\n----------------------------------------------------------------------\nRan 1 test in 0.001s\n\nOK\n\n\n**StockItem __init__ called\n**StockItem get price called\n**StockItem get stock_level called\n\n\n&lt;unittest.main.TestProgram at 0x7f195c8437a0&gt;\n\n\n\nWe can now see the name and status of each individual test\n\n\n\n\n\n\n\nWarning\n\n\n\nAttempting to run unittest in an IPython Notebook may cause issues\nFor IPython Notebooks such as the ones I have used to type up these notes, calling unittest.main() as written above fails to work due to intricacies with how the IPython works. The correct usage in that case is,\nunittest.main(argv=['first-arg-is-ignored'], exit=False)\nSee Stack Overflow for an explanation\n\n\n\nWhat happens if a test fails?\n\n    class TestAlwaysFails(unittest.TestCase):\n\n      def test_that_fails(self):\n          self.assertEqual(1, 0)\n\nThe above defines a test that trivially fails, if we run our unit tests then\n  unittest.main()\n\n\n\nF.\n======================================================================\nFAIL: test_that_fails (__main__.TestAlwaysFails.test_that_fails)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/ipykernel_3242/3483629732.py\", line 4, in test_that_fails\n    self.assertEqual(1, 0)\nAssertionError: 1 != 0\n\n----------------------------------------------------------------------\nRan 2 tests in 0.001s\n\nFAILED (failures=1)\n\n\n**StockItem __init__ called\n**StockItem get price called\n**StockItem get stock_level called\n\n\n&lt;unittest.main.TestProgram at 0x7f195c83e600&gt;\n\n\n\nThe output indicates that tests have failed\nAlso specifies the specific failed test\nThere are a range of possible assertion conditions for statements\n\nSee the table below\n\n\n\n\n\n\n\n\n\n\nTest Function\nTest Action\nUse Case\n\n\n\n\nassertEqual(a,b)\nAsserts that a is the same as b\nTest that two values are the same\n\n\nassertNotEqual(a, b)\nAsserts that a is not the same as b\nTest that two values differ\n\n\nassertTrue(a)\nAsserts that a is True\nTest a boolean expression is true\n\n\nassertFalse(b)\nAsserts that b is False\nTest a boolean expression is false\n\n\nassertIs(a, b)\nAssert that a and b refer to the same object\nTest if two references (variables) refer to the same underlying memory object\n\n\nassertIsNot(a, b)\nAssert that a and b refer to different objects\nTest two references refer to different memory objects\n\n\nassertIsNone(a)\nAssert that r is None\nTest a variable is explicitly the None value\n\n\nassertIsNotNone(a)\nAssert that a is not None\nTest a variable is explicitly not the None value\n\n\nassertIn(a, b)\nAssert that a is in the collection b\nTest a value is in a collection\n\n\nassertNotIn(a, b)\nAssert that a is not in the collection b\nTest a value is not in a collection\n\n\nassertIsInstance(a, b)\nAssert that a is an instance of type b\nTest that a reference refers to an object of a specific type\n\n\nassertNotIsInstance(a, b)\nAssert that a is not an instance of type b\nTest a reference does not refer to a particular object type\n\n\n\n\n\n\nThe above table shows how we perform a value-based unit test\n\ni.e we execute a statement and check it’s value or type against an expected result\n\nWhat is want to perform a behaviour based unit test?\n\ne.g. What if we want to test that code correctly throws an exception?\nFor example the code below attempts to add negative stock\n\nShould raise an exception!\n\n  item = StockItem(stock_ref=\"Test\", price=10,  tags=\"test:tag\")\n  item.add_stock(-1)\n\nWe can use assertRaises to test for exceptions, e.g.\n\n\nimport unittest\n\nclass TestStockItem(unittest.TestCase):\n\n    def test_StockItem_invalid_sell_stock_raises_exception(self):\n        item = StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n        with self.assertRaises(Exception):\n            item.add_stock(-1)\n\n\nRunning the unit test (hidden)\n\n\n\n.\n\n\n**StockItem __init__ called\n**StockItem add_stock called\n\n\n\n----------------------------------------------------------------------\nRan 1 test in 0.001s\n\nOK\n\n\n&lt;unittest.main.TestProgram at 0x7f195cae5490&gt;\n\n\n\nIf we wanted to test for specific exceptions we can pass them to assertRaises as arguments\nNote that assertRaises works slightly differently to the other tests\nWe have to wrap the functionality we want to test in the assertRaises context manager using the with keyword\n\nassertRaises then attempts to catch the exception specified in it’s initializer\n\nIf the exception is not raised the test will fail\n\n\n\n\n\n\nunittest makes it very easy to add tests to a project\nTests force you to think about how a component should behave\nTests might need you to clarify requirements with a client\n\ne.g. We might ask our client to define a maximum amount of stock that could be added\n\nThen implement a test to check that behaviour\n\n\nFirst step is to test that an object is created correctly\nAfter that can test specific behaviours\n\ne.g. we want to test that the normal process of adding and selling stock works\n\n\n  class TestStockItem(unittest.TestCase):\n\n      def test_StockItem_add_and_sell_stock(self):\n          item = StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n          self.assertEqual(item.stock_level, 0)\n          item.add_stock(10)\n          self.assertEqual(item.stock_level, 10)\n          item.sell_stock(2)\n          self.assertEqual(item.stock_level, 8)\n\nWhich should pass when run,\n\n    unittest.main(verbosity=2)\n\n\ntest_StockItem_add_and_sell_stock (__main__.TestStockItem.test_StockItem_add_and_sell_stock) ... ok\n\n----------------------------------------------------------------------\nRan 1 test in 0.001s\n\nOK\n\n\n**StockItem __init__ called\n**StockItem get stock_level called\n**StockItem add_stock called\n**StockItem get stock_level called\n**StockItem sell_stock called\n**StockItem get stock_level called\n\n\n&lt;unittest.main.TestProgram at 0x7f195cae6000&gt;\n\n\n\nunittest can be used to create more complex testing scenarios\n\nRead the docs at the python website\n\nThe tests shown above are implemented in TestStockItem.py\n\n\n\n\n\n\n\nCaution\n\n\n\nTests only prove the existence of faults\nTests are important and should always be included when making a program. Test’s do not guarantee that a program is correctly implemented, just that it passes the specific tests. It is typically impossible to test all possible paths through a program. Bugs can therefore exist even for extensive testing suites. You should form a habit of reviewing your code to ensure it works, alongside using automated testing to provide an additional layer of protection\n\n\n\n\n\nThe provided example tests, check only a limited portion of the StockItem functionality. First remove the automatically failing test, then implement additional tests to check more features of StockItem. For example, you should check that an exception is raised if sell_stock is passed a value greater than the current value of stock_level\nWe’ll try and implement a logical sequence of tests, such that each test, tests one functionality, and relies only on functionality that is tested by another test. In general we want to typically only have a single assert in a test, so that we can clearly identify the failure point. Let’s go through method by method\nclass TestStockItem(unittest.TestCase):\n    def test_init(self):\n        item = StockItem.StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n        self.assertEqual(item.stock_ref, \"Test\")\n        self.assertEqual(item.price, 10)\n        self.assertEqual(item.stock_level, 0)\n        self.assertEqual(item.tags, \"test:tag\")\n\nWe don’t need to modify this __init__ check, it checks all the attributes\n\nExcept the version, but this is a private variable so not easy to check\nNo methods let us interrogate the value\n\nNot easy to test!\nWhen things are hard to test, its generally a sign that they are not implemented in a very robust way\nRight now version checking is a manual warning, but in future updates, we might seek to change this API to a more testable interface\n\n\nNext we want to test the __str__ method\n  def test_str(self):\n      item = StockItem.StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n      expected_str = \"\"\"Stock Reference: Test\nPrice: 10\nStock level: 0\nTags: test:tag\"\"\"\n      self.assertEqual(str(item), expected_str)\n\nWe rely on the fact that __init__ has been tested\nThen explicitly write out what the filled in string template should look like\nFinally call assertEqual on the str(item) call, and then expected_str\n\nNow lets test the add_stock method\nThere are three cases to consider here\n\nThe normal case - stock is added as expected\nTrying to add more than the maximum - an exception is raised\nTrying to add negative stock - an exception is raised\n\nLet’s implement these as three distinct tests\n  def test_add_stock(self):\n      item = StockItem.StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n      item.add_stock(10)\n      self.assertEqual(item.stock_level, 10)\n\n  def test_add_stock_greater_than_maximum_raises_exception(self):\n      item = StockItem.StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n      with self.assertRaises(Exception):\n          item.add_stock(StockItem.StockItem.max_stock_add + 1)\n\n  def test_add_negative_stock_raises_exception(self):\n      item = StockItem.StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n      with self.assertRaises(Exception):\n          item.add_stock(-1)\n\nEach test checks one case\nMakes each test small and easy to understand\nLet’s us write long, descriptive names for all of them\n\nNow lastly, we have to implement the corresponding checks for sell_stock\n\nSelling stock \\(&lt;\\) current stock level and \\(&gt; 0\\) - stock is reduced as expected\nSelling \\(0\\) stock - an exception is raised\nSelling negative stock - an exception is raised\nSelling stock \\(&gt;\\) current stock level - an exception is raised\n\nAgain we’ll implement these as independent tests\n    def test_sell_stock(self):\n      item = StockItem.StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n      item.add_stock(10)\n      item.sell_stock(2)\n      self.assertEqual(item.stock_level, 8)\n\n  def test_sell_zero_stock_raises_exception(self):\n      item = StockItem.StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n      item.add_stock(10)\n      with self.assertRaises(Exception):\n          item.sell_stock(0)\n\n  def test_sell_negative_stock_raises_exception(self):\n      item = StockItem.StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n      item.add_stock(10)\n      with self.assertRaises(Exception):\n          item.sell_stock(-1)\n\n  def test_sell_stock_greater_than_stock_level_raises_exception(self):\n      item = StockItem.StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n      with self.assertRaises(Exception):\n          item.sell_stock(1)\n\nThese all follow a similar structure to those for add_stock\nFor test_sell_zero_stock_raises_exception and test_sell_negative_stock_raises_exception we use add_stock\n\nadd_stock is tested, so we know it won’t break these tests\nLet’s us be sure that these tests fail because the specific scenario is violated and not because of a different overlapping fail case (e.g. selling more stock than we have)\n\n\nWe can then run these tests,\n\nunittest.main(verbosity=2)\n\n\ntest_add_negative_stock_raises_exception (__main__.TestStockItem.test_add_negative_stock_raises_exception) ... ok\ntest_add_stock (__main__.TestStockItem.test_add_stock) ... ok\ntest_add_stock_greater_than_maximum_raises_exception (__main__.TestStockItem.test_add_stock_greater_than_maximum_raises_exception) ... ok\ntest_init (__main__.TestStockItem.test_init) ... ok\ntest_sell_negative_stock_raises_exception (__main__.TestStockItem.test_sell_negative_stock_raises_exception) ... ok\ntest_sell_stock (__main__.TestStockItem.test_sell_stock) ... ok\ntest_sell_stock_greater_than_stock_level_raises_exception (__main__.TestStockItem.test_sell_stock_greater_than_stock_level_raises_exception) ... ok\ntest_sell_zero_stock_raises_exception (__main__.TestStockItem.test_sell_zero_stock_raises_exception) ... ok\ntest_str (__main__.TestStockItem.test_str) ... ok\n\n----------------------------------------------------------------------\nRan 9 tests in 0.008s\n\nOK\n\n\n&lt;unittest.main.TestProgram at 0x7f195cae7530&gt;\n\n\n\n\n\nIn Chapter 5 we designed the Ride Selector Program. When designing the UI, we considered how we would implement testing. Update the program to use unittest. You may need to refactor the code to introduce testability\nThe most recent version of Ride Selector is given as an exercise in Chapter 7 so we’ll use that version as our starting point.\nAs noted, the program as written is not amenable to testing. Everything is one big nested loop and the outputs printed directly to the terminal. We first need to refactor this program into one suitable for testing.\nLet’s first start by defining a lightweight Ride class. Looking at our code we can see a ride has a name, and then optionally a maximum or minimum age. There is also a global minimum and maximum age limit.\nclass Ride:\n    \"\"\"\n    A class representing a theme park amuse ride rider limitations\n\n    Attributes\n    ----------\n    name : str\n        name of the ride\n\n    min_age : int\n        minimum age in years to ride\n\n    max_age : int\n        maximum age in years to ride, must be greater than or equal to `min_age`\n\n    Class Attributes\n    ----------------\n    ride_min_age : int\n        minimum `min_age` for any ride\n\n    ride_max_age : int\n        maximum `max_age` for any ride\n\n    \"\"\"\n\n    ride_min_age = 1\n    ride_max_age = 95\n\n    @staticmethod\n    def is_valid_age_limit(age):\n        \"\"\"\n        Check a proposed ride age limit is valid\n\n        Parameters\n        ----------\n        age : int\n            proposed age limit in years\n\n        Returns\n        -------\n        bool\n            `True` if `age` is an allowed age limit, else `False`\n\n        See Also\n        --------\n        Ride.ride_min_age : minimum valid age limit for a ride\n        Ride.ride_max_age : maximum valid age limit for a ride\n        \"\"\"\n        return Ride.ride_min_age &lt;= age &lt;= Ride.ride_max_age\n\n    def __init__(self, name, min_age, max_age):\n        \"\"\"\n        Creates a new `Ride` instance\n\n        Parameters\n        ----------\n        name : str\n            name of the ride\n        min_age : int\n            minimum age (inclusive) to ride in years\n        max_age : int\n            maximum age to ride (inclusive) to ride in years.\n            `max_age` must be `&gt;= min_age`\n\n        Raises\n        ------\n        ValueError\n            Raised if `max_age` is `&lt; min_age`\n        ValueError\n            Raised if `min_age` or `max_age` is not a valid age limit\n\n        See Also\n        --------\n        Ride.is_valid_age_limit : Checks that ages are valid\n        \"\"\"\n        if not Ride.is_valid_age_limit(min_age):\n            raise ValueError(\n                \"{0} is not a valid age for the minimum age limit\".format(min_age)\n            )\n        if not Ride.is_valid_age_limit(max_age):\n            raise ValueError(\n                \"{0} is not a valid age for the maximum age limit\".format(max_age)\n            )\n        if max_age &lt; min_age:\n            raise ValueError(\n                \"maximum age ({0}) must be greater than or equal to minimum age ({1})\".format(\n                    max_age, min_age\n                )\n            )\n        self.name = name\n        self.min_age = min_age\n        self.max_age = max_age\n\n    def __str__(self):\n        return str(self.name)\n\n    def in_age_limit(self, age):\n        \"\"\"\n        Validate that an age is within the limits of the ride\n\n        Parameters\n        ----------\n        age : int\n            age in years to validate is within the age limit\n\n        Returns\n        -------\n        bool\n            `True` if the age is within the ride limits, else `False`\n        \"\"\"\n        return self.min_age &lt;= age &lt;= self.max_age\n\nThe resulting class is lightweight\nWe define class variables ride_min_age and ride_max_age for the global minimum and maximum ages\nWe provide a function, is_age_valid_age_limit as a static method that checks a provided age is within these limits\n\nRide uses this internally to validate the min_age and max_age passed in __init__\nCan also be used externally to check if an age is allowed on any ride\n\nDefining our tests for is_age_valid_age_limit\n  class TestRide(unittest.TestCase):\n  \"\"\"\n  Test class implementing unit tests for the `Ride` class\n  \"\"\"\n\n      # Test case for `is_valid_age_limit`\n\n      def test_is_valid_age_accepts_normal_age(self):\n          self.assertTrue(RideSelector.Ride.is_valid_age_limit(always_valid_middle_age))\n\n      def test_is_valid_age_accepts_min_age(self):\n          self.assertTrue(\n              RideSelector.Ride.is_valid_age_limit(RideSelector.Ride.ride_min_age)\n          )\n\n      def test_is_valid_age_accepts_max_age(self):\n          self.assertTrue(\n              RideSelector.Ride.is_valid_age_limit(RideSelector.Ride.ride_max_age)\n          )\n\n      def test_is_valid_age_rejects_less_than_min_age(self):\n          self.assertFalse(\n              RideSelector.Ride.is_valid_age_limit(RideSelector.Ride.ride_min_age - 1)\n          )\n\n      def test_is_valid_age_rejects_greater_than_max_age(self):\n          self.assertFalse(\n              RideSelector.Ride.is_valid_age_limit(RideSelector.Ride.ride_max_age + 1)\n          )\n\nWe can see there a range of test cases\n\nTest a standard value within the range is accepted\nTest the boundary values (ride_min_age and ride_max_age) are accepted\nTest values outside the boundaries are rejected\n\n\nNext we can define our __init__ and __str__ methods\n\n    def __init__(self, name, min_age, max_age):\n        \"\"\"\n        Creates a new `Ride` instance\n\n        Parameters\n        ----------\n        name : str\n            name of the ride\n        min_age : int\n            minimum age (inclusive) to ride in years\n        max_age : int\n            maximum age to ride (inclusive) to ride in years.\n            `max_age` must be `&gt;= min_age`\n\n        Raises\n        ------\n        ValueError\n            Raised if `max_age` is `&lt; min_age`\n        ValueError\n            Raised if `min_age` or `max_age` is not a valid age limit\n\n        See Also\n        --------\n        Ride.is_valid_age_limit : Checks that ages are valid\n        \"\"\"\n        if not Ride.is_valid_age_limit(min_age):\n            raise ValueError(\n                \"{0} is not a valid age for the minimum age limit\".format(min_age)\n            )\n        if not Ride.is_valid_age_limit(max_age):\n            raise ValueError(\n                \"{0} is not a valid age for the maximum age limit\".format(max_age)\n            )\n        if max_age &lt; min_age:\n            raise ValueError(\n                \"maximum age ({0}) must be greater than or equal to minimum age ({1})\".format(\n                    max_age, min_age\n                )\n            )\n        self.name = name\n        self.min_age = min_age\n        self.max_age = max_age\n\n    def __str__(self):\n        return str(self.name)\n\nThe __init__ checks that the passed min_range and max_range are valid\n\nThen checks that min_range and max_range follow the correct ordering\n\nOnce the input is validated just sets the appropriate data values\n\nWe’re leaving them public for the simplicity of demonstration\n\nOur __str__ method is defined to simply return self.name as a string\nWe have a few tests here\n\nTest that we can construct an object normally and have the values set\nTest that an invalid min_age is rejected\nTest that an invalid max_age is rejected\nTest that min_age may not be greater than max_age\nCheck that the appropriate string is returned\n\n\n    # Test cases for init\n\n    def test_init_sets_attributes_correctly(self):\n        ride = RideSelector.Ride(\n            \"Test\", min_age=always_valid_middle_age, max_age=always_valid_middle_age\n        )\n        self.assertEqual(ride.name, \"Test\")\n        self.assertEqual(ride.min_age, always_valid_middle_age)\n        self.assertEqual(ride.max_age, always_valid_middle_age)\n\n    def test_init_raises_valueerror_on_invalid_min_age(self):\n        with self.assertRaises(ValueError):\n            ride = RideSelector.Ride(  # noqa: F841\n                \"Test\",\n                min_age=RideSelector.Ride.ride_min_age - 1,\n                max_age=always_valid_middle_age,\n            )\n\n    def test_init_raises_valueerror_on_invalid_max_age(self):\n        with self.assertRaises(ValueError):\n            ride = RideSelector.Ride(  # noqa: F841\n                \"Test\",\n                min_age=always_valid_middle_age,\n                max_age=RideSelector.Ride.ride_max_age + 1,\n            )\n\n    def test_init_raises_value_error_if_max_age_less_than_min_age(self):\n        with self.assertRaises(ValueError):\n            ride = RideSelector.Ride(  # noqa: F841\n                \"Test\",\n                min_age=RideSelector.Ride.ride_max_age + 1,\n                max_age=RideSelector.Ride.ride_min_age - 1,\n            )\n\n    def test_str_returns_ride_name(self):\n        ride = RideSelector.Ride(\n            \"Test\",\n            min_age=always_valid_middle_age,\n            max_age=always_valid_middle_age,\n        )\n        self.assertEqual(str(ride), \"Test\")\n\nThe last method on Ride is one that now checks if a given age is accepted by the specific Ride instance\n\n    def in_age_limit(self, age):\n        \"\"\"\n        Validate that an age is within the limits of the ride\n\n        Parameters\n        ----------\n        age : int\n            age in years to validate is within the age limit\n\n        Returns\n        -------\n        bool\n            `True` if the age is within the ride limits, else `False`\n        \"\"\"\n        return self.min_age &lt;= age &lt;= self.max_age\n\nWe pretty much want to test the same cases as for is_valid_age_limit\n      def test_in_age_limit_accepts_valid_age(self):\n      ride = RideSelector.Ride(\n          \"Test\",\n          min_age=always_valid_middle_age,\n          max_age=always_valid_middle_age,\n      )\n      self.assertTrue(ride.in_age_limit(always_valid_middle_age))\n\n  def test_in_age_limit_rejects_too_small_age(self):\n      ride = RideSelector.Ride(\n          \"Test\",\n          min_age=always_valid_middle_age,\n          max_age=always_valid_middle_age,\n      )\n      self.assertFalse(ride.in_age_limit(ride.min_age - 1))\n\n  def test_in_age_limit_rejects_too_large_age(self):\n      ride = RideSelector.Ride(\n          \"Test\",\n          min_age=always_valid_middle_age,\n          max_age=always_valid_middle_age,\n      )\n      self.assertFalse(ride.in_age_limit(ride.max_age + 1))\nNext we construct our RideSelector class\n\nFor simplicity this implementation mixes some of the container management aspects with the UI presentation aspects\nSince some of the functionality requires user input or provides output to the user, we can’t test absolutely everything\nGoal is to factor out the individual steps into functions that accept arguments and return values\nThese can then be tested against\n\nRideSelector starts with a basic __init__ method that populates it with a preset lookup table of rides\nThe __str__ method converts the tuple of rides into an indexed list as a string\nWe’ll ignore testing the __init__ method for now\n\nSince it’s not interesting\n\n__str__ uses a quite complicated lambda though to perform it’s magic\n\nThe idea is to map the tuple elements to their enumerated pair\n\ni.e. a tuple containing the index and the value\n\nWe then write use a lambda that maps the enumerated pair to the form x. value where x is the \\(index + 1\\) (since we want to convert from \\(0\\)-indexed to \\(1\\)-indexed) and value is the actual value\nWe then use map to apply the lambda to all elements of the enumerate object\nLastly convert into our string using \"\\n\".join\nThis is quite a complicated set of steps and so should be tested\n\nWe’ll define a new test class for the RideSelector tests\n\nThis is to make them distinct\nIn a bigger program we would probably separate out each components tests into their own test file\nOur __str__ test will take define an expected string and compare this to the result of calling the __str__ method\n\n  class TestRideSelector(unittest.TestCase):\n  \"\"\"\n  Test cases for the `RideSelector` class\n  \"\"\"\n\n  # test str method\n      def test_str_creates_enumerated_table(self):\n          ride_selector = RideSelector.RideSelector()\n          expected_str = \"\"\"1. Scenic River Cruise\n  2. Carnival Carousel\n  3. Jungle Adventure Water Splash\n  4. Downhill Mountain Run\n  5. The Regurgitator\"\"\"\n          self.assertEqual(str(ride_selector), expected_str)\nNext we define a get_ride method that converts a user selection of a ride into the corresponding ride object\nThis has a simple implementation\n      def get_ride(self, index):\n      \"\"\"\n      Get's the ride associated with a given index\n\n      Parameters\n      ----------\n      index : int\n          integer greater than zero corresponding a ride index\n\n      Returns\n      -------\n      Ride\n          the ride stored by the given index\n\n      Raises\n      ------\n      ValueError\n          Raised if `index &lt;= 0`\n      IndexError\n          Raised if the no ride exists for the given index\n      \"\"\"\n      if index &lt;= 0:\n          raise ValueError(\"index must be a positive integer\")\n      return self._rides[index - 1]\nThere are clear cases to test here\n\nThat a valid index returns the correct Ride instance\nThat a non-positive index returns a ValueError\nThat an invalid index returns an IndexError\n\n  # test get_ride method\n\n  def test_get_ride_returns_expected_ride(self):\n      ride_selector = RideSelector.RideSelector()\n      ride = ride_selector.get_ride(1)\n      self.assertEqual(str(ride), \"Scenic River Cruise\")\n\n  def test_get_ride_raises_valueerror_on_zero_index(self):\n      ride_selector = RideSelector.RideSelector()\n\n      with self.assertRaises(ValueError):\n          ride_selector.get_ride(0)\n\n  def test_get_ride_raises_valueerror_on_invalid_index(self):\n      ride_selector = RideSelector.RideSelector()\n\n      with self.assertRaises(IndexError):\n          ride_selector.get_ride(99)\nOur last testable component in then, check_age_against_ride\n\nThis takes in an age and a ride\nChecks in a person of that age can ride the ride\nThis has two stages\n\nFirst validate that person can ride any ride\n\nUsing Ride.is_valid_age_limit\n\nValidate that person can ride the specific ride they selected\n\nUsing that ride’s in_age_limit method\n\n\nReturns a string to display to the caller the outcome\n\n  def check_age_against_ride(self, ride, age):\n      \"\"\"\n      Provides a string describing in a rider of `age` years can ride the Ride `ride`\n\n      Parameters\n      ----------\n      ride : Ride\n          ride to check the age against\n      age : int\n          age of the prospective rider in years\n\n      Returns\n      -------\n      str\n          string describing if a rider of `age` years can ride `ride`\n      \"\"\"\n      if age &lt; Ride.ride_min_age:\n          return \"You are too young to go on any rides\"\n      elif age &gt; Ride.ride_max_age:\n          return \"You are too old to go on any rides\"\n      elif age &lt; ride.min_age:\n          return \"Sorry, you are too young\"\n      elif age &gt; ride.max_age:\n          return \"Sorry, you are too old\"\n      else:\n          return \"You can go on the ride\"\n\nWe want to test these strings are returned correctly\nThere are a few cases\n\nToo young to go on any ride\nToo young to go on this specific ride\nToo old to go on any ride\nToo old to go on this specific ride\nAble to go on the ride\n\nLuckily since string literals are returned, we can check this easily\n\n      # test check age against ride\n\n  def test_too_young_for_any_ride(self):\n      ride_selector = RideSelector.RideSelector()\n      ride = ride_selector.get_ride(1)\n      self.assertEqual(\n          \"You are too young to go on any rides\",\n          ride_selector.check_age_against_ride(\n              ride, RideSelector.Ride.ride_min_age - 1\n          ),\n      )\n\n  def test_too_old_for_any_ride(self):\n      ride_selector = RideSelector.RideSelector()\n      ride = ride_selector.get_ride(1)\n      self.assertEqual(\n          \"You are too old to go on any rides\",\n          ride_selector.check_age_against_ride(\n              ride, RideSelector.Ride.ride_max_age + 1\n          ),\n      )\n\n  def test_too_young_for_specific_ride(self):\n      ride_selector = RideSelector.RideSelector()\n      ride = ride_selector.get_ride(5)\n      self.assertEqual(\n          \"Sorry, you are too young\",\n          ride_selector.check_age_against_ride(ride, ride.min_age - 1),\n      )\n\n  def test_too_old_for_specific_ride(self):\n      ride_selector = RideSelector.RideSelector()\n      ride = ride_selector.get_ride(5)\n      self.assertEqual(\n          \"Sorry, you are too old\",\n          ride_selector.check_age_against_ride(ride, ride.max_age + 1),\n      )\n\n  def test_valid_age_is_accepted(self):\n      ride_selector = RideSelector.RideSelector()\n      ride = ride_selector.get_ride(5)\n      self.assertEqual(\n          \"You can go on the ride\",\n          ride_selector.check_age_against_ride(ride, ride.min_age),\n      )\nThe last step is to the then run the tests\n\nunitttest.main()\n\n\n...............................\n----------------------------------------------------------------------\nRan 31 tests in 0.013s\n\nOK\n\n\n&lt;unittest.main.TestProgram at 0x7f195ceecfe0&gt;\n\n\n\n\n\n\n\n\nNote\n\n\n\nBe careful with how you design your tests\nTests are designed generally to test expected behaviours. This is why test-driven development typically expects you to write the test before the implementation. The idea being that by first defining the behaviour you want rather than testing a specific implementation you avoid coupling your test directly to your implementation.\nThis can be hard to avoid to some degree when dealing with unit tests because by their nature they test a specific unit. However, let’s look at our tests and some of the design choices. One of the main things I have done for some of the tests is to parameterise the values being tested, rather than hard-coding values. There is a trade-off here. The tests are a bit more opaque but are in theory flexible to changes. For example I have used the Ride.ride_min_age and Ride.ride_max_age points are:\n\nBy using the values, we make the tests test the behaviour rather than the specific chosen values\nWe couple the test to the implementation providing those class attributes\nIf we change those values we might actually want the tests to fail, so that we can then manually ensure that the change is correct\n\nThen update the test\nHowever, this has the problem, that our test is then being dictated by the implementation\nIf we revert a change we would have to again rework the tests\n\n\nThe notion of using parameters versus specific-values is a choice in testing, the above is just an example of how to think about how to test. The other consideration is if the testing framework fits with the design of your program. In rewiring the ride selector program we’ve arguably made it more complex and harder to reason about by trying to fit it into the individual component model that unittest expects. For Ride Selector which provides a fairly simple user interface where we mostly care about the user receiving the correct response a better testing implementation might actually be to test the program externally. By this we mean, we generate a test set of inputs, feed them into the program and record the outputs. We then compare these outputs to the expected outputs.\nDoing the testing this way has some tradeoffs. By testing the system as a whole it’s harder to identify where the sources of failures arise. However, the overall program doesn’t need to be refactored into a more complicated form just to facilitate the tests\n\n\n\n\n\n\n\nWe saw that you could add docstrings to functions to describe their behaviour\nImplicitly in the examples you’ve also seen these added to classes\nModules can also have docstrings too!\n\nThe only rule across all three is that the docstring is the first statement after the start\n\ni.e. for a function, after the function definition\nfor a class, after the class definition\nfor a module, the first statement in the file\n\n\n\n\n\nPydoc is a program written in python that can be run from the command line. Work through the following steps to see how it works\n\nNavigate to the folder 10_FashionShopWithDocumentation\nOpen a terminal in this folder (or navigate to this folder in the terminal)\nRun the pydoc module, by executing the following command,\n python -m pydoc\n\nThe -m following the call to python means “execute the following module”\nRunning on pydoc with no additional arguments we can see it provides documentation about pydoc itself\n\n  ! python -m pydoc\n\npydoc - the Python documentation tool\n\npydoc &lt;name&gt; ...\n    Show text documentation on something.  &lt;name&gt; may be the name of a\n    Python keyword, topic, function, module, or package, or a dotted\n    reference to a class or function within a module or module in a\n    package.  If &lt;name&gt; contains a '/', it is used as the path to a\n    Python source file to document. If name is 'keywords', 'topics',\n    or 'modules', a listing of these things is displayed.\n\npydoc -k &lt;keyword&gt;\n    Search for a keyword in the synopsis lines of all available modules.\n\npydoc -n &lt;hostname&gt;\n    Start an HTTP server with the given hostname (default: localhost).\n\npydoc -p &lt;port&gt;\n    Start an HTTP server on the given port on the local machine.  Port\n    number 0 can be used to get an arbitrary unused port.\n\npydoc -b\n    Start an HTTP server on an arbitrary unused port and open a web browser\n    to interactively browse documentation.  This option can be used in\n    combination with -n and/or -p.\n\npydoc -w &lt;name&gt; ...\n    Write out the HTML documentation for a module to a file in the current\n    directory.  If &lt;name&gt; contains a '/', it is treated as a filename; if\n    it names a directory, documentation is written for all the contents.\n\n\n\nWe can see from the output that pydoc is a documentation tool\nThere a number of different arguments we can supply that modify how it runs\n\nFor now we want to start a webpage to read our documentation. Reading the documentation we can see this can be done using the -b flag. Enter the following\n python -m pydoc -b\n\npydoc will then start a website that can be used to view the documentation\nThe result should look something like the screenshot below\n\n\n\nGenerated Pydoc Website\n\n\nWe can see the site contains links to python’s built-in modules\nBut there is also a section for our own documented modules,\n\nI’ve included the generated html so you can interact with them directly\n\nData\nFashionShopShellUI\nRunTests\n\n\nYou can also use the built-in search bar\nThe docstrings are now displayed for the module, class and each method\n\n\n\n\n\n\n\n\nWarning\n\n\n\nModules that run as programs can break pydoc\nRecall that when loaded a module will execute all of the statements that it includes. For pydoc to generate the docstrings and site material from a module it first has to load it. This means that it will lead to those statements being executed.\nThis means that if we had a module that represented an entry point to looping user input (such as FashionShopShellUI.py) it would immediately start executing and freeze pydoc. This is a reminder to use name guards to control the context in which a module can be executed.\n    if __name__ = \"__main__\":\n        # do things that should only occur if the module is executed directly",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 12: Python Applications"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/12_PythonApplications/Chapter_12.html#notes",
    "href": "02_AdvancedProgramming/12_PythonApplications/Chapter_12.html#notes",
    "title": "Chapter 12: Python Applications",
    "section": "",
    "text": "Python functions are powerful and can be used in some interesting ways\n\n\n\n\nWe’ve seen that we can use references to functions much like variables\ne.g. map in Chapter 10 took a reference to a function and applied it element-wise to a list\n\nAnother example was filter\n\nLet’s explore this in more detail, consider the following code snippet (see SimpleFunctionReferences.py)\n\n  # Example 12.1 Simple Function References\n\n  def func_1():\n      print(\"Hello from function 1\")\n\n  def func_2():\n      print(\"Hello from function 2\")\n\n  x = func_1\n  x()\n  x = func_2\n  x()\n\nHello from function 1\nHello from function 2\n\n\nWe have two functions func_1 and func_2\nWe can assign the variable x to refer to and call each of these in turn\n\nThe dereference operator () called on x resolves to the function it references\n\nThe variable is effectively another name for the function\nWe still have to call it properly, e.g. (see InvalidFunctionReferences.py)\n\n  # Example 12.2 Invalid Function References\n\n  def func_1():\n      print(\"Hello from func_1\")\n\n  x = func_1\n  x(99)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[2], line 7\n      4     print(\"Hello from func_1\")\n      6 x = func_1\n----&gt; 7 x(99)\n\nTypeError: func_1() takes 0 positional arguments but 1 was given\n\n\n\nThe above generates an error as expected, because x is given an argument 99\nfunc_1 takes no arguments\nThe error resolves to the original function name (here func_1)\n\n\n\n\nRecall back in Chapter 7 we created a module for getting validated user input, BTCInput\nWe wrote code for reading integers and floating points with an additional ranged API\nBoth functions pretty much looked the same except one used int() to convert user input, the other used float()\nAs a refresher here is read_int\n  def read_int(prompt):\n      while True:\n          try:\n              # read in the number\n              number_text = read_text(prompt)\n              # perform conversion to int\n              result = int(number_text)\n              break\n          except ValueError:\n              print(\"Please enter an integer\")\n      return result\nWe could combine these two functions into one by using a function-valued variable\ni.e. the function now accepts as a argument a function that takes in a string and converts the result to the appropriate type of number\n  def read_number(prompt, number_converter):\n      \"\"\"\n      Read and convert a user-provided number\n\n      User is prompted for a number, and the resulting\n      string is converted by the supplied `number_converter`\n      function\n\n      Parameters\n      ----------\n      prompt : str\n          string to display to the user when asking for input\n      number_converter : Callable[[[str], int | float]\n          function that converts a string to a number. Must\n          raise a `ValueError` on invalid input\n\n      Returns\n      -------\n      int | float\n          User input converted to a number\n      \"\"\"\n      while True:\n          try:\n              number_text = read_text(prompt)\n              result = number_converter(number_text)\n              break\n          except ValueError:\n              print(\"Please enter a number\")\n      return result\nNow the call to int or float is instead replaced with a call to number_converter\nAs part of the documentation we have to specify the required behaviour of the number_converter function\n\nHere we need it to be a one parameter function that accepts a string\nThe returned result should be an int or float\nAdditionally a key requirement is that any failed conversion raises a ValueError so that the error-handling code in read_number catches it\n\nread_number is a great function from our programmer perspective\n\nBut not necessarily the cleanest implementation for a downstream user\nThey would still likely just want to call read_int or read_float\nWe’ll provide wrapper functions read_int and read_float that pass the appropriate parameters through to read_number\n\nWe’ll make them match the old API for input so a downstream user sees no change\n\n\n  def read_float(prompt):\n      return read_number(prompt=prompt, number_converter=float)\nObserve when we pass a function we just pass the name, don’t use ()\n\n\n\n\nFunction references are complicated, work through the following questions to help your understanding\n\nWhat is a function reference?\n\nOne piece of a program telling another what to do\nread_number is given a prompt, and a function\n\nThe function tells read_number how to convert to a number\n\n\nWhy is using function references like this a good idea?\n\nMakes code more maintainable\nRather than having basically the same code in two places read_int and read_float we have it in one place\nIf we later need to modify the code, we can now do it in one place read_number rather than making sure both functions remain consistent\n\nIf I wrote a function that converted Roman numerals into a numeric result, could I use read_number to read Roman Numbers?\n\nYes, as long as that function matches the requirements for number_converter\ni.e. Only takes in a string\n\nEasy enough, this should be the roman numerals\n\nReturns either an int or float\n\nEasy again Roman numerals convert to integers\n\nRaises a ValueError if an invalid Roman numeral is encountered\nIf we meet this API we could then use read_number e.g.\n  number = read_number(\"Enter your age in roman numerals: \", number_converter=roman_converter)\nThere is in fact nothing (other than the name read_number) that prevents us from using this function more generally\nWe could let number_converter be any function that takes a string argument, and returns a value, raising a ValueError on invalid input\n\ne.g. we could write date_converter that asks the user for a valid date string (e.g. 12/10/2017)\nCould convert this into a date object\n\nFunction parameters are thus a form of abstraction\n\nWe step away from a more concrete implementation (read_int, read_float etc)\nUse a more general solution read_number\nWe may then find that our solution is more general then we thought\n\ne.g. read_number actually provides a structure to parse a lot of input depending on the provided parsing function (number_converter)\ni.e. we might instead call read_number as parse_input\n\n\n\n\n\n\n\nWrite a function that takes a string representing roman numerals and converts it to an integer. Make this function work with the read_number API\nFirst lets set out some ground rules. The valid roman numerals are:\n\n\n\nSymbol\nI\nV\nX\nL\nC\nD\nM\n\n\n\n\nValue\n1\n5\n10\n50\n100\n500\n1000\n\n\n\nThe standard form for the roman numerals is given by,\n\n\n\n\nThousands\nHundreds\nTens\nOnes\n\n\n\n\n1\nM\nC\nX\nI\n\n\n2\nMM\nCC\nXX\nII\n\n\n3\nMMM\nCCC\nXXX\nIII\n\n\n4\n\nCD\nXL\nIV\n\n\n5\n\nD\nL\nV\n\n\n6\n\nDC\nLX\nVI\n\n\n7\n\nDCC\nLXX\nVII\n\n\n8\n\nDCCC\nLXXX\nVIII\n\n\n9\n\nCM\nXC\nIX\n\n\n\nTo create a value we append the appropriate thousands, hundreds, tens, and ones.\ne.g. \\(3698 = MMM + DC + XC + VIII = MMMDCXCVIII\\)\nThe basic conversion rules are as follows,\n\nRead from left to right\nConsider a “digit”.\n\nIf the next digit is the same value or less, then it is added to the total\n\ne.g. in \\(II\\) and \\(XI\\), we read these as \\(1 = 1\\), and \\(10 &gt; 1\\), so the running total is \\(1\\) and \\(10\\) respectively\n\nIf the next digit is a greater value, then we subtract from the total\n\ne.g. in \\(IV\\) we read this as \\(1 &lt; 4\\), so the running total is \\(-1\\)\n\nIf there is no next digit, then the value is added\n\n\nThis is the basic ruleset, we could write a function to convert using these rules and be perfectly happy with it. However, in many modern use cases there are stricter syntax rules which for fun we’ll also implement, namely\n\n\\(M\\), \\(C\\), \\(X\\), \\(I\\) can be repeated no more than three times sequentially, e.g. \\(IIII\\) is invalid\n\\(V\\), \\(L\\), \\(D\\) can’t be sequentially repeated, e.g. \\(VV\\) is invalid\nThere can be no repeated sequence of the same value before a subtraction, i.e. \\(IIV\\) is invalid because this should translate to \\(5 - 2\\).\nThere are precedence rules\n\n“Tens”-like values can only precede smaller or the next two largest valued characters\n\ne.g. \\(IV\\) or \\(IX\\) are valid, but not \\(IM\\)\ne.g. \\(XL\\) or \\(XC\\) are valid, but not \\(XD\\)\n\n“Fives”-like can values can only precede smaller\n\ne.g. \\(VI\\) is valid, but not \\(VX\\)\ne.g. \\(LI\\) and \\(LX\\) are valid, but not \\(LD\\)\n\n\n\nLet’s now plan out our algorithm, before considering valid syntax the basic structure will be as follows,\n\nset a running total to \\(0\\)\nIterate over each character\n\nConvert the character to their integer value\nIf the next character exists and it’s value is larger subtract the current value from the total\nElse, add the current value\n\nOnce all the characters have been processed return the total\n\nThe easiest way to do this would be to use a dictionary lookup. We can directly convert the symbol to a value. Now let’s go one step further. We’ll define a lightweight class RomanNumeral this holds the symbol, the value and importantly also a set bookkeeping what other roman numerals this one is allowed to precede\n\nclass RomanNumeral:\n    \"\"\"\n    Lightweight class representing a roman numeral\n\n    Attributes\n    ----------\n    symbol : str\n        latin character symbolising the roman numeral\n    value : int\n        numeric value of a roman numeral\n    precedes : set[str]\n        set of strings representing other roman numerals this numeral may precede\n    \"\"\"\n\n    def __init__(self, symbol, value, precedes):\n        \"\"\"\n        Create a new `RomanNumeral` Instance\n\n        Parameters\n        ----------\n        symbol : str\n            latin character symbolising the roman numeral\n        value : int\n            numeric value of a roman numeral\n        repetition_limit : int\n            maximum number of times the same numeral can be repeated\n        precedes : set[str]\n            set of strings representing other roman numerals this numeral may precede\n        \"\"\"\n        self.symbol = symbol\n        self.value = value\n        self.precedes = precedes\n\n    def may_precede(self, roman_numeral):\n        \"\"\"\n        Checks if this numeral may precede another\n\n        Parameters\n        ----------\n        roman_numeral : str\n            character representing roman numeral to check if we can precede\n\n        Returns\n        -------\n        `True` if `self` may precede `roman_numeral` else, `False`\n        \"\"\"\n        return roman_numeral in self.precedes\n\n\nWe define one helper function may_precede which is used to check if one symbol may precede another\nWe then define at the start of our function a dictionary containing the valid roman numerals\n\ndef roman_numeral_converter(number_string):\n    \"\"\"\n    Convert a number written in roman numerals to an int\n\n    The string must be a valid roman numeral in `standard format`__\n\n    Parameters\n    ----------\n    number_string : str\n        A valid roman numeral expression\n\n    Returns\n    -------\n    int\n        Result of converting the roman numeral to an int\n\n    Raises\n    ------\n    ValueError\n        Raised if `number_string` is not a valid roman numeral\n\n    .. _standard format: https://en.wikipedia.org/wiki/Roman_numerals#Standard_form\n    \"\"\"\n    roman_numerals = {\n        \"I\": RomanNumeral(\"I\", 1, {\"I\", \"V\", \"X\"}),\n        \"V\": RomanNumeral(\"V\", 5, {\"I\"}),\n        \"X\": RomanNumeral(\"X\", 10, {\"I\", \"X\", \"L\", \"C\"}),\n        \"L\": RomanNumeral(\"L\", 50, {\"I\", \"V\", \"X\"}),\n        \"C\": RomanNumeral(\"C\", 100, {\"I\", \"V\", \"X\", \"L\", \"C\", \"M\"}),\n        \"D\": RomanNumeral(\"D\", 500, {\"C\", \"L\", \"X\", \"V\", \"I\"}),\n        \"M\": RomanNumeral(\"M\", 1000, {\"I\", \"V\", \"X\", \"L\", \"C\", \"D\", \"M\"}),\n    }\n\n    def get_roman_numeral(numeral):\n        \"\"\"\n        Returns the `RomanNumeral` corresponding to the provided string\n\n        Parameters\n        ----------\n        numeral : str\n            character representing a roman numeral digit\n\n        Returns\n        -------\n        RomanNumeral\n            object describing the corresponding roman numeral\n\n        Raises\n        ------\n        ValueError\n            The provided character is not a valid roman numeral digit\n\n        \"\"\"\n        try:\n            return roman_numerals[numeral]\n        except KeyError:\n            raise ValueError(numeral, \"is not a valid character for a roman numeral\")\n\nThe function get_roman_numeral is a helper function defined inside our converter\n\nIt wraps the error handling of getting the roman numeral from the dictionary\nIt’s main purpose is to convert a KeyError for an invalid character into a ValueError as required by the read_number interface\n\nNow lets work through our previous algorithm and add in the syntax checking at the appropriate steps\n\n\nset a running total to \\(0\\), and previous to None\nIterate over each character\n\nIf the character doesn’t exist, a ValueError is raised\nIf this character is the same as the previous increment the number of repetitions\n\nIf it’s more than three, raise a ValueError for violation of the repetition rule\nElse reset the number of repetitions\n\nCheck if we’re at the end of the string\n\nIf so, add the current character’s value to the total and return\nElse, attempt to get the next character’s roman numeral data\n\nAgain raise a ValueError if it doesn’t exist\n\n\nCheck that the current character is allowed to precede the next character\n\nRaise a ValueError if it can’t\n\nCheck the next character’s value is larger\n\nIf it is\n\nCheck if the number of repetitions is greater than \\(1\\)\n\nIf it is, raise a ValueError since there can be no repetitions before a subtraction\nElse subtract the value of the current character from the total\n\n\nElse\n\nAdd the value to the current total\n\n\nSet the previous to the current character\n\n\nThe complete implementation is given by,\n\ndef roman_numeral_converter(number_string):\n    \"\"\"\n    Convert a number written in roman numerals to an int\n\n    The string must be a valid roman numeral in `standard format`__\n\n    Parameters\n    ----------\n    number_string : str\n        A valid roman numeral expression\n\n    Returns\n    -------\n    int\n        Result of converting the roman numeral to an int\n\n    Raises\n    ------\n    ValueError\n        Raised if `number_string` is not a valid roman numeral\n\n    .. _standard format: https://en.wikipedia.org/wiki/Roman_numerals#Standard_form\n    \"\"\"\n    roman_numerals = {\n        \"I\": RomanNumeral(\"I\", 1, {\"I\", \"V\", \"X\"}),\n        \"V\": RomanNumeral(\"V\", 5, {\"I\"}),\n        \"X\": RomanNumeral(\"X\", 10, {\"I\", \"X\", \"L\", \"C\"}),\n        \"L\": RomanNumeral(\"L\", 50, {\"I\", \"V\", \"X\"}),\n        \"C\": RomanNumeral(\"C\", 100, {\"I\", \"V\", \"X\", \"L\", \"C\", \"M\"}),\n        \"D\": RomanNumeral(\"D\", 500, {\"C\", \"L\", \"X\", \"V\", \"I\"}),\n        \"M\": RomanNumeral(\"M\", 1000, {\"I\", \"V\", \"X\", \"L\", \"C\", \"D\", \"M\"}),\n    }\n\n    def get_roman_numeral(numeral):\n        \"\"\"\n        Returns the `RomanNumeral` corresponding to the provided string\n\n        Parameters\n        ----------\n        numeral : str\n            character representing a roman numeral digit\n\n        Returns\n        -------\n        RomanNumeral\n            object describing the corresponding roman numeral\n\n        Raises\n        ------\n        ValueError\n            The provided character is not a valid roman numeral digit\n\n        \"\"\"\n        try:\n            return roman_numerals[numeral]\n        except KeyError:\n            raise ValueError(numeral, \"is not a valid character for a roman numeral\")\n\n    total = 0\n    previous = None\n    n_reps = 0\n    number_string = number_string.upper().strip()\n    max_repeats = 3\n\n    for i, ch in enumerate(number_string):\n        # get the roman numeral associated with the next character\n        numeral = get_roman_numeral(ch)\n        if numeral.value == previous:\n            # check that we haven't repeated this numeral too many times\n            n_reps += 1\n            if n_reps &gt; max_repeats:\n                raise ValueError(\n                    ch,\n                    \"repeated {0} times, maximum is {1}\".format(n_reps, max_repeats),\n                )\n        else:\n            n_reps = 1\n        if i + 1 == len(number_string):  # reached the end and stop\n            return total + numeral.value\n        else:\n            next_numeral = get_roman_numeral(number_string[i + 1])\n\n            if not numeral.may_precede(next_numeral.symbol):\n                raise ValueError(\n                    \"Invalid roman numeral: {0} may not precede {1}\".format(\n                        numeral.symbol, next_numeral.symbol\n                    )\n                )\n            # if next is larger perform subtraction if valid\n            if next_numeral.value &gt; numeral.value:\n                if n_reps &gt; 1:\n                    raise ValueError(\n                        \"Invalid roman numeral: cannot repeat digits for subtraction\"\n                    )\n                else:\n                    total -= numeral.value\n            else:\n                total += numeral.value\n        previous = numeral.value\n    return total\n\nWhich we can see on some sample valid inputs,\n\nprint(\"I: Expected: 1, Received: {0}\".format(roman_numeral_converter(\"I\")))\nprint(\"V: Expected: 5, Received: {0}\".format(roman_numeral_converter(\"V\")))\nprint(\"X: Expected: 10, Received: {0}\".format(roman_numeral_converter(\"X\")))\nprint(\"II: Expected: 2, Received: {0}\".format(roman_numeral_converter(\"II\")))\nprint(\"III: Expected: 3, Received: {0}\".format(roman_numeral_converter(\"III\")))\nprint(\n    \"MMMDCXCVIII: Expected: 3698, Result: {0}\".format(\n        roman_numeral_converter(\"MMMDCXCVIII\")\n    )\n)\n\nI: Expected: 1, Received: 1\nV: Expected: 5, Received: 5\nX: Expected: 10, Received: 10\nII: Expected: 2, Received: 2\nIII: Expected: 3, Received: 3\nMMMDCXCVIII: Expected: 3698, Result: 3698\n\n\nAnd on a sample invalid input,\n\n    print(\n        \"VV: Expected: Invalid Number, Received: {0}\".format(\n            roman_numeral_converter(\"VV\")\n        )\n    )\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[6], line 3\n      1 print(\n      2     \"VV: Expected: Invalid Number, Received: {0}\".format(\n----&gt; 3         roman_numeral_converter(\"VV\")\n      4     )\n      5 )\n\nCell In[4], line 84, in roman_numeral_converter(number_string)\n     81 next_numeral = get_roman_numeral(number_string[i + 1])\n     83 if not numeral.may_precede(next_numeral.symbol):\n---&gt; 84     raise ValueError(\n     85         \"Invalid roman numeral: {0} may not precede {1}\".format(\n     86             numeral.symbol, next_numeral.symbol\n     87         )\n     88     )\n     89 # if next is larger perform subtraction if valid\n     90 if next_numeral.value &gt; numeral.value:\n\nValueError: Invalid roman numeral: V may not precede V\n\n\n\nA more comprehensive set of tests can be found in the complete program\n\n\n\n\n\n\nNote\n\n\n\nTrusting vs Checking the Input\nYou can see that compared to the simple algorithm outlined for the case were we assumed the input was valid, the final algorithm is a lot longer. This is most due to it performing syntax validation at the same time as it calculates the result.\nThis is a common philosophical argument. Should roman_numeral_converter validate it’s input. In principle we could write a function validate_roman_numeral which would check that the string is valid. Doing it this way means we could make roman_numeral_converter itself quite lean. This has the downside that we would need to make two passes through the string now. The first to validate and the second to convert it.\nThere are two sides here, the safer version of roman_numeral_converter can be used anywhere and always ensures it’s input is valid. This comes at the cost that for valid input we are doing extra work checking it. Thus it’s a tradeoff, if we expect to receive valid input then we can use the fast version (and if there is perhaps a separate path that can supply invalid input we might use validate_roman_numeral), but if not we should use a protected version.\nSince our implementation is designed to be for parsing user input, I’ve combined the code into one function. In the future if the design requirements changed I might revisit this choice\n\n\nThere’s another more simple implementation of this. If we restrict ourselves as above to the standard form then we can only represent \\(1\\) to \\(3999\\), and each has a unique representation. Thus we could create an explicit conversion dictionary that makes the string representation to the integer representation. This is a form of lookup table. We set the lookup table to be generated when the roman numeral conversion code is loaded.\n# Exercise 12.1b Roman Numeral Converter\n#\n# Write a function that converts strings of roman numerals to an integer\n#\n# This implementation uses a lookup table\n\nimport itertools\n\nimport BTCInput\n\nthousands = {\"\": 0, \"M\": 1000, \"MM\": 2000, \"MMM\": 3000}\nhundreds = {\n    \"\": 0,\n    \"C\": 100,\n    \"CC\": 200,\n    \"CCC\": 300,\n    \"CD\": 400,\n    \"D\": 500,\n    \"DC\": 600,\n    \"DCC\": 700,\n    \"DCCC\": 800,\n    \"CM\": 900,\n}\ntens = {\n    \"\": 0,\n    \"X\": 10,\n    \"XX\": 20,\n    \"XXX\": 30,\n    \"XL\": 40,\n    \"L\": 50,\n    \"LX\": 60,\n    \"LXX\": 70,\n    \"VXXX\": 80,\n    \"XC\": 90,\n}\nones = {\n    \"\": 0,\n    \"I\": 1,\n    \"II\": 2,\n    \"III\": 3,\n    \"IV\": 4,\n    \"V\": 5,\n    \"VI\": 6,\n    \"VII\": 7,\n    \"VIII\": 8,\n    \"IX\": 9,\n}\n\n\nroman_numeral_dictionary = {}\n\nfor p in itertools.product(\n    thousands.items(), hundreds.items(), tens.items(), ones.items()\n):\n    key = \"\"\n    value = 0\n    for symbol_value_pair in p:\n        key += symbol_value_pair[0]\n        value += symbol_value_pair[1]\n    roman_numeral_dictionary[key] = value\n\nroman_numeral_dictionary.pop(\"\")\nWe define component dictionaries for each valid roman numeral that is purely a thousands, hundreds, tens or singles expression. Any valid expression is then given by the concatenation of the strings and addition of the values. The valid expressions are thus all possible pairings which is given by the cartesian product of all the dictionaries. (We add the empty string as a key to give a \\(0\\) value to represent not choosing from a given set)\nOnce we generated all the possible pairings we then build the dictionary by iterating over the pairings and concatenating the string components to create the string. The value is similarly created by adding all the value components.\nOur actual implementation of the roman numeral lookup parser is simple, we normalise the input (convert to upper case and strip whitespace), and then simply try to get the value from the dictionary. As before we convert KeyError for missing values to ValueError to comply with the read_number interface\ndef roman_numeral_converter(number_string):\n    \"\"\"\n    Convert a number written in roman numerals to an int\n\n    The string must be a valid roman numeral in `standard format`__\n\n    Parameters\n    ----------\n    number_string : str\n        A valid roman numeral expression\n\n    Returns\n    -------\n    int\n        Result of converting the roman numeral to an int\n\n    Raises\n    ------\n    ValueError\n        Raised if `number_string` is not a valid roman numeral\n\n    .. _standard format: https://en.wikipedia.org/wiki/Roman_numerals#Standard_form\n    \"\"\"\n    try:\n        return roman_numeral_dictionary[number_string.upper().strip()]\n    except KeyError:\n        raise ValueError(\"{0} is not a valid roman numeral\".format(number_string))\nIf we wanted to make this even faster, we could have used a python program to generate the dictionary, print that out and copy the lookup table into the file. However for demonstration purposes seeing how it’s generated is useful\nThis implementation is found in RomanNumeralLookupTable.py and passes all the same tests as the previous one\n\n\n\n\n\nFunction references can be used as any other references\nFor example, we can create collections\n\n# Example 12.3 Robot Dancer\n#\n# Demonstrates creating collections of function references\n\nimport time\n\n\ndef forward():\n    print(\"Robot moving forward\")\n    time.sleep(1)\n\n\ndef back():\n    print(\"Robot moving backwards\")\n    time.sleep(1)\n\n\ndef left():\n    print(\"Robot moving left\")\n    time.sleep(1)\n\n\ndef right():\n    print(\"robot moving right\")\n    time.sleep(1)\n\n\ndance_moves = [forward, back, left, right]\n\nprint(\"Dance starting\")\nfor move in dance_moves:\n    move()\nprint(\"Dance over\")\n\n\nDance starting\nRobot moving forward\nRobot moving backwards\nRobot moving left\nrobot moving right\nDance over\n\n\n\nWe define a set of functions\nThen create a collection referencing them\nHere they represent a robot performing a sequence of dance moves\nA longer program can then be created by increasing the length of the function\n\n\n\n\n\nA lambda function is like a tiny one line function\nHas the following structure\n\n\n\n\n\n\nblock-beta\n    columns 4\n    space\n    title[\"Breakdown of an Lambda Expression\"]:2\n    space\n\n    block:LambdaStatement\n    columns 1\n        lambda[\"lambda\"]\n        lambdaDescr[\"(start of the lambda)\"]\n    end\n\n    block:Arguments\n    columns 1\n        argument[\"arguments\"]\n        argumentDescr[\"(comma-separated list of arguments values)\"]\n    end\n\n    block:Colon\n    columns 1\n        colon[\":\"]\n        colonDescr[\"colon\"]\n    end\n\n    block:Expression\n    columns 1\n        expression[\"expression\"]\n        expressionDescr[\"(expression to be evaluated)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass argument BG\nclass argumentDescr BG\nclass colon BG\nclass colonDescr BG\nclass lambda BG\nclass lambdaDescr BG\nclass expression BG\nclass expressionDescr BG\n\n\n\n\n\n\n\nColon separates arguments (supplied values) from expression (results coming out), e.g.\n\ndef increment(x):\n    return x + 1\n\nIs equivalent to,\n\n\nincrement = lambda x : x + 1\nprint(increment(1))\n\n2\n\n\n\nWe can see this is called like a function, and returns the increment of the provided value\n\n\n\nWork through the following steps to understand lambda expressions\n\nEnter the following statement\n\n numbers = [1, 2, 3, 4, 5, 6, 7, 8]\n\n\nThis creates some sample data to work with\nLet’s say we want to increment very value of numbers by \\(1\\)\nWe could do this normally by defining a function and using map\n\nDefine a function increment as below, and run the following code\n\n def increment(x):\n     return x + 1\n\n new_numbers = map(increment, numbers)\n print(list(new_numbers))\n\n[2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nThis works, but has two downsides\nOne have to name and define a function increment\nThe function then exists for the remaining lifetime of the scope\nThis is a natural use for a lambda\n\nNo need to associate a name\nexistence is restricted to the use of map\n\n\nRepeat the previous steps, but use a lambda as below instead of an explicit function\n\n new_numbers = map(lambda x : x + 1, numbers)\n print(list(new_numbers))\n\n[2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nThe same behaviour is observed\nBut the code is more compact, and the behaviour is localised to the map\n\nCreate the following lambda\n\n adder = lambda x, y : x + y\n\n\naddr is a lambda expression that takes two arguments and adds them\nWe can now use the lambda as we want\n\nRun the following expressions to demonstrate using the lambda\n\n adder(1, 2)\n\n3\n\n\n\nWe can see this evaluates like any other function call\n\n\n\n\n\nConsider the following questions about lambda expressions\n\nWhat are lambda expressions?\n\nCan think of them as data representing an operation to perform\nRather than passing a function reference we create a value containing that behaviour\nlambda expressions are sometimes called anonymous functions\n\nThey are functional behaviour without a named handle\n\n\nMust I use lambda expressions in my programs?\n\nNo\nLambdas don’t add any new behaviour over defining functions\nHowever, they can make code cleaner or more compact\nThey are especially useful for defining small temporary functions that are passed to things like map and filter\n\nCan a lambda function contain more than one action?\n\nNo\nThe active part of a lambda function is a single expression that calculates a return value\n\nCan a lambda expression accept multiple arguments?\n\nYes, we saw this with the addr lambda which took two arguments\nLambda’s can also technically take no arguments\n\nCan a lambda expression make decisions?\n\nA lambda could return True or False\nCan then use as a condition in programs\nWe can define conditional expressions to choose a value to return\n\n  hour = 8\n  print(\"morning\" if hour &lt; 12 else \"afternoon\")\n\nmorning\n\n\nFunctions as an in line if statement\n\nFirst value returned if condition evaluates true, else false\n\n\n\n\n\n\n\n\n        block-beta\n            columns 5\n            space\n            title[\"Breakdown of a Conditional Expression\"]:3\n            space\n\n            block:ValueStatement\n            columns 1\n                value[\"value\"]\n                valueDescr[\"(value of expression if true)\"]\n            end\n\n            block:If\n            columns 1\n                if[\"if\"]\n            end\n\n            block:Condition\n            columns 1\n                condition[\"condition\"]\n                conditionDescr[\"(True or False condition)\"]\n            end\n\n            block:Else\n            columns 1\n                else[\"else\"]\n            end\n\n            block:Value2\n            columns 1\n                value2[\"value\"]\n                value2Descr[\"(value of expression if true)\"]\n            end\n\n        classDef BG stroke:transparent, fill:transparent\n        class title BG\n        class value BG\n        class valueDescr BG\n        class if BG\n        class else BG\n        class colon BG\n        class colonDescr BG\n        class condition BG\n        class conditionDescr BG\n        class value2 BG\n        class value2Descr BG\n\n\n\n\n\n\n- Conditional expressions can be used anywhere an expression can be\n- A lambda can thus return a conditional expression\n\n    day_prompt = lambda hour : \"morning\" if hour &lt; 12 else \"afternoon\"\n    print(\"{0} is during the day: {1}\".format(8, day_prompt(8)))\n    print(\"{0} is during the day: {1}\".format(13, day_prompt(13)))\n\n8 is during the day: morning\n13 is during the day: afternoon\n\n\n\n\n\n\n\n\nNote\n\n\n\nDon’t worry if you don’t get lambda expressions the first time you see them\nLambda expressions can be difficult to understand at first. They blur the lines between data and program code. Our previous programs seperate the data (as values) from the code (as functions). A lambda expression is code as data. Sometimes it’s useful to be able to pass behaviours around as data and lambdas provide a way to do that\n\n\n\n\n\n\n\nRecall python has a concept of an iterator\nGenerally when we encounter iterators we work through the values they generate\nrange is an example, e.g. creating a sequence of numbers\n\n  for i in range(1, 5):\n      print(i)\n\n1\n2\n3\n4\n\n\nrange returns a result that is an iterator producing the values \\(1\\) to \\(4\\).\nWhen then consume the values to print them in order\n\nRemember range does not include the end point\n\nIterators can be made by using the yield keyword\n\nA yield is like a function return but the function remembers its state\nfunctions that yield can be used to create a sequence of values\n\n\n\n\nUse an interpreter to work through the following steps to learn about the yield keyword\n\nEnter the following into the interpreter\n\n def my_yield():\n     yield 1\n     yield 2\n     yield 3\n     yield 4\n\n\nThe function my_yield contains four yield statements\nEach returns a value\nLet’s see what happens when we now loop over the function\n\nDefine and run the following loop\n\n for i in my_yield():\n     print(i)\n\n1\n2\n3\n4\n\n\n\nWe can see that the value returned by each yield is printed out in turn\nWe could also convert this to a list\n\nDefine and run the following\n\n list(my_yield())\n\n[1, 2, 3, 4]\n\n\n\nlist accepts an iterator and converts it to list\n\n\n\n\n\n\nyield can be used to make a flexible test data generator\n\ne.g. for Time Tracker\ne.g. If we want to do load testing for when we have hundreds of contacts rather than say tens\n\n\n\n\n\n\n\n\nTip\n\n\n\nUsing a program to create test data is a great idea\nIf you find yourself entering lots of test data into your programs, you should write a program to do the work for you. Remember that computers were created to spare us from drudgery, not create more of it\n\n\n\n# Example 12.5 Test Contact Generator\n#\n# Demonstrates using yield to generate test Contacts for the\n# time tracker application\n\n\nclass Contact:\n    def __init__(self, name, address, telephone):\n        self.name = name\n        self.address = address\n        self.telephone = telephone\n        self.hours_worked = 0\n\n    @staticmethod\n    def create_test_contacts():\n        phone_number = 1000000\n        hours_worked = 0\n        for first_name in (\"Rob\", \"Mary\", \"Jenny\", \"Davis\", \"Chris\", \"Imogen\"):\n            for second_name in (\"Miles\", \"Brown\"):\n                full_name = first_name + \" \" + second_name\n                address = full_name + \"'s house\"\n                telephone = str(phone_number)\n                telephone = telephone + str(1)\n                contact = Contact(full_name, address, telephone)\n                contact.hours_worked = hours_worked\n                hours_worked = hours_worked + 1\n                yield contact\n\n\nThe test data generation is implemented as a static method\n\nLet’s us access and set hidden attributes on the Contact class\n\nImplementation (make_test_contacts) cycles through a set of first and last names\n\nContacts are then generated with a generated name, a simplified address (we simply append 's house' to the end of the name), a telephone number and hours_worked\nEach iteration increases the telephone number and hours worked by one\n\nWe can the use the method as a iterator, see\n\n\nfor contact in Contact.create_test_contacts():\n    print(contact.name)\n\ncontacts = list(Contact.create_test_contacts())\n\nfor contact in contacts:\n    print(\n        \"\"\"{0}\nAddress: {1}\nTelephone: {2}\nHours worked: {3}\n\"\"\".format(contact.name, contact.address, contact.telephone, contact.hours_worked)\n    )\n\nRob Miles\nRob Brown\nMary Miles\nMary Brown\nJenny Miles\nJenny Brown\nDavis Miles\nDavis Brown\nChris Miles\nChris Brown\nImogen Miles\nImogen Brown\nRob Miles\nAddress: Rob Miles's house\nTelephone: 10000001\nHours worked: 0\n\nRob Brown\nAddress: Rob Brown's house\nTelephone: 10000001\nHours worked: 1\n\nMary Miles\nAddress: Mary Miles's house\nTelephone: 10000001\nHours worked: 2\n\nMary Brown\nAddress: Mary Brown's house\nTelephone: 10000001\nHours worked: 3\n\nJenny Miles\nAddress: Jenny Miles's house\nTelephone: 10000001\nHours worked: 4\n\nJenny Brown\nAddress: Jenny Brown's house\nTelephone: 10000001\nHours worked: 5\n\nDavis Miles\nAddress: Davis Miles's house\nTelephone: 10000001\nHours worked: 6\n\nDavis Brown\nAddress: Davis Brown's house\nTelephone: 10000001\nHours worked: 7\n\nChris Miles\nAddress: Chris Miles's house\nTelephone: 10000001\nHours worked: 8\n\nChris Brown\nAddress: Chris Brown's house\nTelephone: 10000001\nHours worked: 9\n\nImogen Miles\nAddress: Imogen Miles's house\nTelephone: 10000001\nHours worked: 10\n\nImogen Brown\nAddress: Imogen Brown's house\nTelephone: 10000001\nHours worked: 11\n\n\n\n\n\n\nAnswer the following questions about the previous bits of code\n\nWhy is create_test_contacts a static method?\n\nWe don’t want to ask a specific Contact for test information\nWe want to generate a new Contact as test data\nBelongs with the Contact class itself\n\nWhat is the difference between yield and return?\n\nyield pauses function execution and bookmarks where it is, returning the yield\n\nSubsequent call follows on from this position\n\nreturn returns the value and ends function execution\n\nAll subsequent executions will begin from the start of the function\n\nreturn does not support iteration\nConsider the following,\n\n  def yield_return():\n      yield 1\n      yield 2\n      return 3\n      yield 4\n\n  for i in yield_return():\n      print(i)\n\n1\n2\n\n\nThe iteration only prints 1 and 2 since the third iteration encounters a return which ends the iteration (and is not included)\n\nWe never reach the yield 4 statement\n\n\nDoes a function using yield have to return?\n\nNo\nAn iterator using yield could in theory run forever, e.g.\n\n  def forever_tens():\n      result = 0\n      while True:\n          yield result\n          result = result + 10\n\nThis creates an infinitely long iteration\nEach value is ten times larger than before\n\n  for result in forever_tens():\n      print(result)\n      if result &gt; 100:\n          break\n\n0\n10\n20\n30\n40\n50\n60\n70\n80\n90\n100\n110\n\n\nLoop continues until the result returned by the iterator is too large\n\nWhat happens to local variables in a yielded function?\n\nLocal variables are retained when the function yields a result\ne.g. forever_tens() relies on the value of result being preserved between calls to generate the continuing sequence\n\n\n\n\n\n\n\nWe’ve seen functions like print which seem to accept a variety of arguments, e.g.\n\n  print(\"a\")\n  print(\"a\", \"b\")\n\na\na b\n\n\nWhen we’ve written functions, we’ve been able to define optional or default-valued parameters\nHowever, we’ve always had to specify the number of variables\nprint accepts an arbitrary number of arguments\n\n\n\nLet’s learn about arbitrary-argument functions by working through the following steps in the interpreter\n\nDefine the following function\n\n def add_function(x, y):\n     return x + y\n\n\nThis is a function that adds two numbers\n\n  add_function(1, 2)\n\n3\n\n\nHowever if we tried to add three numbers,\n\n  add_function(1, 2, 3)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[28], line 1\n----&gt; 1 add_function(1, 2, 3)\n\nTypeError: add_function() takes 2 positional arguments but 3 were given\n\n\n\nWe see that we get an error because there’s a mismatch between the number of arguments required and supplied\n\n\n\nIt might make sense to have a function like add_function that accepts an arbitrary number of numbers and adds them all together\nWe can specify to a python function that an arbitrary number of arguments are accepted with the * identifier, e.g.\n\n  def add_function(*values):\n      total = 0\n      for value in values:\n          total = total + value\n      return total\n\nThe above could accept any number of arguments, including zero\n\n  print(add_function())\n  print(add_function(1))\n  print(add_function(1,2))\n  print(add_function(1,2,3))\n\n0\n1\n3\n6\n\n\nA parameter indicating an arbitrary number of parameters may be preceded by normal parameters\nFor example, if we wanted to force the add_function to receive at least one value\n\n  def add_function(start, *values):\n      total = start\n      for value in values:\n          total = total + value\n      return total\n\n  print(add_function(1))\n  print(add_function(1,2))\n\n1\n3\n\n\nIf we try and pass nothing to the above, we get an error\n\n      add_function()\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[32], line 1\n----&gt; 1 add_function()\n\nTypeError: add_function() missing 1 required positional argument: 'start'\n\n\n\nWhat happens if the user already has an arbitrary number of values stored in a collection?\nHow do they translate a tuple say x = (1,2,3, 4) into the correct call structure?\n\nCan’t just write add_function(x) since that will treat x as one variable\n\nNeed a way to unpack the contents\nThis is provided by the * operator\n\nUnpacks a collection\n\nFor example,\n\n  numbers = (1, 2, 3, 4)\n  add_function(0, *numbers)\n\n10\n\n\nEach element in numbers is unpacked out into their own argument\n\n\n\n\n\n\n\nWarning\n\n\n\nThe * Character in function arguments can cause confusion with C and C++ syntax\nAs discussed in python * is used to represent unpacking a collection into it’s constituent values. Other languages may use * for different meanings. An example is C and C++ where * is used to handle and manipulate pointers (memory addresses). Something to learn as you work with multiple languages - be careful not to get your syntax’s confused.\n\n\n\nPython provides an inbuilt function that performs the functionality of the add_function called sum\n\nsum expects its arguments to passed as an iterable though\n\n\n  sum(numbers)\n\n10\n\n\nSome sample code for arbitrary argument functions is provided in ArbitaryArgumentFunctions.py\n\n\n\n\n\n\nWe’ve already seen that we can build python programs out of multiple source files. In this section we’ll look more closely at ways of structuring large python projects split across multiple files through the concepts of modules and packages\n\n\n\nA python module is essentially a python file\nFor example the file BTCInput.py is a file that contains function definitions for reading valid input\n\nWe also call it a module\n\nTypically the difference between a module and a script is that a module is designed to be imported by another program\n\nA script typically runs standalone\nThis is just a heuristic though\n\nWe’ve seen that we can include a module using the import statement\nSo if we wanted to use BTCInput to read an integer restricted to a range, we write\n  import BTCInput\n\n  age = BTCInput.read_int_ranged(prompt=\"Enter age: \", min_value=5, max_value=95)\n  print(\"Your age is: \", age)\nA sample interaction might then be,\n\n\n\nEnter age:  31\n\nYour age is: 31\n\n\n\n\nPython will execute and obey all statements in a module when a module is imported\nFor BTCInput these are function definitions\nA module could also define variables or other code that should be executed on load-\n\n\n\n\nWe could add a readme function to BTCInput that describes the modules contents\n\n  VERSION = \"1.0.0\"\n\n\n  def readme():\n      print(\n          \"\"\"Welcome to the BTCInput functions module version {0}\n\n  BTCInput provides functions for reading numbers and strings and validating the\n  user input.\n\n  The functions are used as follows:\n  text = read_text(prompt)\n  int_value = read_int(prompt)\n  int_float = read_float(prompt)\n  int_value = read_int_ranged(prompt, min_value, max_value)\n  float_value = read_float_ranged(prompt, min_value, max_value)\n\n  BTCInput also provides read_number and read_number_ranged which can be\n  used in conjunction with a user-defined function to provide custom\n  number parsing behaviour\n\n  Have fun with them.\n  Rob Miles\"\"\".format(VERSION)\n      )\n\nreadme displays a string which provides the user with some basic usage information\nWe’ve added a little variable that tracks the version of the file - automatically updated in the documentation\nThe user has to manually call the readme though\nLater we’ll see how to generate the description text directly from the code docstring (View Program Documentation)\n\n\n\n\n\nPython modules are files like any other\nThey can be run by the python interpreter\nFor example, we might add a call to readme\n\nSo someone running BTCInput automatically sees the documentation\n\n\n  # all the BTCInput functions go here\n  # end of the file\n  readme()\n\nWelcome to the BTCInput functions module version 1.0.0\n\nBTCInput provides functions for reading numbers and strings and validating the\nuser input.\n\nThe functions are used as follows:\ntext = read_text(prompt)\nint_value = read_int(prompt)\nint_float = read_float(prompt)\nint_value = read_int_ranged(prompt, min_value, max_value)\nfloat_value = read_float_ranged(prompt, min_value, max_value)\n\nBTCInput also provides read_number and read_number_ranged which can be\nused in conjunction with a user-defined function to provide custom\nnumber parsing behaviour\n\nHave fun with them.\nRob Miles\n\n\nRecall: on importing python executes all the statements in a file\nThis means the readme is displayed even when the user imports the module\n\nProbably not the desired behaviour\n\n\n\n\n\n\nPrinting the readme is useful when the actual module is executed\nHowever, would like a way to turn this off when the module is imported\nPython provides the __name__ variable\n\nHelps define the context in which the program is running\n\nIf a module is imported, __name__ is set to the name of the module\nIf a module is running as the original code that started the program, then __name__ is set to __main__\nCan thus be used to restrict code that we don’t want to run outside of the __main__ context (or alternatively on import)\n  if __name__ == \"__main__\":\n      readme()\n\n\n\nClick here to access the updated version of BTCInput\nRun the file through the interpreter, you should see the readme be displayed. Then replace the implementation of BTCInput in one of the previous examples with this new implementation and run that program. You should see that the the readme will not be displayed even though the file is imported\n\nOften useful to write modules also provide functionality as a program\nFor example, you may provide documentation as above, demonstrate examples alternatively a module may be designed to perform some basic functionality on user input (e.g. a mathematical program might read numbers and perform a calculation) and be imported by more complex programs\n\n\n\n\n\n\n\nLarge programs may contain many different program files\nAt that point we might want to start thinking about how we organise files, rather than have everything in one folder\nThis is the point at which packages can help\nA common organisation pattern (that we’ve previously utilised) is to put every major component in it’s own file\nFor example in our Fashion Shop we created two types of classes\n\nThose that handled the data (StockItem, FashionShop)\nThose that handled the UI (FashionShopApplication)\n\nEach of these components was written as it’s own file, and we wrapped the entry point in our FashionShopApplication.py\n\nFashionShopApplication.py imported StockItem.py and FashionShop.py to get the associated class components\n\nAn alternative arrangement might be to formulate the data components as one package and the UI components as another\nA (local) python package is a directory containing a set of python source files\n\nAn __init__.py file is used to mark a package\n\nBelow show’s how we could restructure the fashion shop application to use a package structure\n\n.\n├── Data\n│   ├── FashionShop.py\n│   ├── StockItem.py\n│   └── __init__.py\n├── FashionShopShellUI.py\n└── UI\n    ├── BTCInput.py\n    ├── FashionShopApplication.py\n    └── __init__.py\n\nUI contains the classes responsible for handling the user\n\nCurrently these are all shell-based\nIf in the future we introduce a GUI option we might create subpackages for UI\n\nShellUI for shell-based interactivity\nGUI for graphical-based interactivity\n\nAlso contains an __init__.py file\n\nData contains the classes responsible for handling the fashion shop data\n\nThis is the StockItem class, and the FashionShop container class\nAgain, we need the __init__.py\n\nOutside the class structure we define a FashionShopShellUI.py which is the entry point file\n\nConsumes the classes in the subpackages\nThis is not a package itself, so no need for an __init__.py\n\n\n\n\nConsider the following questions about modules\n\nHow do I decide which module goes in which package?\n\nRelated classes and functions should be in the same package\nFor the fashion shop as we’ve identified the types of modules are\n\nThose that handle the user interaction (FashionShopApplication.py and BTCInput.py)\nThose that handle the data representation of the fashion shop (FashionShop and StockItem)\n\n\nWhat does the __init__.py file in a package do?\n\n__init__.py controls how a package is loaded\n__init__.py is ran when a package is first opened\n\nLike the constructor for a package\nCan set up resources, e.g. a help string, global constants etc.\n\n\n\n\n\n\n\n\nModules can be imported from packages\n\nSyntax is like that for importing a single class, function or variable from a module\n\n  from Data import FashionShop\nContents of the FashionShop module now available\nCan be used as we’ve seen before\n  shop = FashionShop.FashionShop()\nAs we’ve talked before the FashionShop class is namespaced by the module FashionShop.py (minus the .py extension)\nIf there was another FashionShop defined in another package (say DataStorage.py) we can differentiate them, e.g.\n  shop2 = DataStorage.FashionShop()\nWe could also just import the higher level package (Data) like a module, i.e.\n  import Data\nContents of the Data package now available\n\nAdds another level of namespacing, e.g. setting accessing the FashionShop class is now\n  shop = Data.FashionShop.FashionShop()\n\n\n\n\nClasses can be used as values just as we’ve seen with functions. Work through the following steps in the python interpreter to understand how this works\n\nEnter the statements below into the python interpreter\n\n class VarTest:\n     def __init__(self):\n         print(\"making a VarTest\")\n\n\nThis creates a class VarTest with a constructor\nConstructor simply prints a message\nWe can create a VarTest instance easily enough\n\n  x = VarTest()\n\nmaking a VarTest\n\n\nWe can see the __init__ method is called and we create a new VarTest instance, referenced by x\n\nNow assign the class definition itself to a variable, as in the statement below\n\n y = VarTest\n\n\nObserve no parentheses around VarTest\nMirrors the case where we want a reference to a function\ny has the value of VarTest which is the class definition itself\ny is effectively an alias for VarTest and can be used the same way, e.g.\n\n  z = y()\n\nmaking a VarTest\n\n\nWe can see that this creates a new VarTest instance and assigns it to z\n\nAs if we had written z = Vartest() directly\n\n\n\n\nClass references can be treated as any other data, including\n\nBeing used in collections (e.g. lists, dictionaries)\nPassed as arguments to function calls\n\nThe statement below sets the variable shop to the class definition of the FashionShop\n  shop = FashionShop.FashionShop\nOur UI shouldn’t need to know about the underlying data representation directly\n\nShould just now the interface it needs to work with\nThen we can have it accept any implementation that obeys this interface\nWe could say then pass shop as an argument\n\n\n\n\n\nWork through the following questions to understand how class references work\n\nWhat are the benefits of using class references?\n\nClass references allow to define common implementations and then change the underlying implementation\n\nWe might replace the shell interface with a GUI\nWe might replace the FashionShop in-memory data storage with a database\n\nIf we can make the new implementations conform to the interface then all we need to do is change the class reference\n\nReduces the coupling between components\nMakes the implementation easier to manage\n\n\n\n\nHow do we introduce class references in a program?\nWe’ll write a program FashionShopShellUI.py that handles connecting the components together\n\nCreates the UI and displays it\nStart by importing our modules\n\n  # Example 12.8a Modular Fashion Shop\n  #\n  # Provides the entry point and coordinating behaviour for a modularised\n  # implementation of the Fashion Shop Application\n\n\n  from Data import FashionShop\n  from UI import FashionShopApplication\n\n  # load the UI implementation\n  ui = FashionShopApplication.FashionShopApplication\n\n  # load the data management implementation\n  shop = FashionShop.FashionShop\n\n  app = ui(filename=\"fashionshop.pickle\", storage_class=shop)\nWe start by defining on ui and shop classes which take the UI implementation in FashionShopApplication and FashionShop respectively\nWe then have to create our application\n\nWe create an instance of the application (using the reference ui)\n\nWe pass shop to define how the data is managed\nObserve that this is a new change to the API of FashionShopApplication we’ll have to implement\n\n\nLet’s update the FashionShopApplication API\n\nWe want to accept a class reference now when we construct the object\nSo we have to add one to the __init__ method\nWe then want to replace explicit calls to FashionShop with calls to this class reference\n\n  class FashionShopApplication:\n      \"\"\"\n      Provides a text-based interface for Fashion Shop inventory management\n      \"\"\"\n      def __init__(self, filename, storage_class):\n          \"\"\"\n          Creates a new `FashionShopApplication`\n\n          Attempts to load a `FashionShop` from the provided file. Otherwise\n          an empty instance is created\n\n          Parameters\n          ----------\n          filename : str\n              path to a file containing pickled `FashionShop` data\n          storage_class : Data Manager\n              class that supports the Fashion Shop Data Management API\n\n          See Also\n          --------\n          FashionShop : Main class for handling inventory management\n          \"\"\"\n          FashionShopApplication.__filename = filename\n          try:\n              self.__shop = storage_class.load(filename)\n          except:  # noqa: E722\n              print(\"Failed to load Fashion Shop\")\n              print(\"Creating an empty Fashion Shop\")\n              self.__shop = storage_class()\n\nWe’ve changed the API on the __init__ so we have to make sure we update the docstring appropriately\n\nNow we want to start running the program as before\n  app.main_menu()\nThere is one small step as well which is to update the import statements in FashionShopApplication.py\n\nNo longer explicitly requires FashionShop\nNeeds to import StockItem from the Data package\nNeeds to import BTCInput from the UI package\n  - import BTCInput\n  + from UI import BTCInput\n  - import StockItem\n  + from Data import StockItem\n  - import FashionShop\n\n\n\n\n\n\n\n\nWarning\n\n\n\nPython imports can be Confusing\nAn annoying feature of python import statements is that they are resolved relative to the directory where the entry point is. This means that even though BTCInput is in the same package as FashionShopApplication we can’t write\n    import BTCInput\nbut instead have to write\n    from UI import BTCInput\nThis is rather annoying because in theory FashionShopApplication shouldn’t need to care what folder it’s located in, let alone where the starting point is. If we wanted to write another higher level program that contained our entire fashion shop application as a package this would break the imports. The way to resolve this is to install the packages, but that’s beyond the scope for now\n\n\n\nYou can find the modularised implementation in 08_FashionShopApp\nAs an aside in the future as we add implementations we would likely rename FashionShopApplication to something more descriptive like FashionShopShell\n\n\n\n\n\n\n\nImportant\n\n\n\nUsing classes as values is an extremely powerful programming technique\nThe technique of passing functions or classes as arguments to higher-level classes or functions is called dependency injection. The idea is that if a class or function uses the interface of another class or function rather than hardcoding what the implementation of that interface is, we allow the implementation to be passed in as an argument (i.e. we inject the behaviour we want to implement)\nThe idea is to let us change how the behaviours specified by an API are implemented, for example we can use this to switch between a basic shell ui, a terminal-based ui or a full graphical ui. We might also want to switch our data storage layer from an in-memory approach to one that uses a database. If we hardcode the higher level implementation (i.e. a class that uses an in-memory loader and a shell ui) then we have to create many new implementations to support the desired behaviour. For example if we implement all the above options as hard coded classes we would have,\n\nin-memory loader + shell UI\nin-memory loader + terminal UI\nin-memory loader + graphical UI\ndatabase loader + shell UI\ndatabase loader + terminal UI\ndatabase loader + graphical UI\n\n\n\nIn other words, we created three new classes (2 new UI classes and one data storage class) but then had to define five additional classes to handle creating our application. With dependency injection there is no need to define new classes, we just swap out what class references we are using and pass them through to the high level application constructor.\nThis design also makes it much easier to test large components because we can inject a test implementation.\n\n\n\n\n\n\nTesting is part of the process of validating that a program meets requirements\nTests should be\n\nRepeatable (we can conduct the same test multiple times)\nDocumented (they clearly indicate what they test and the results)\nAutomatic (tests should be an integrated part of development)\n\nLet’s consider implementing tests for the StockItem from the Fashion Shop Application\nWe need to start by defining what features we want to test\n\nValidate that newly constructed StockItem instances have correctly set values for their attributes\nAttempts to create an invalid StockItem are rejected\nStockItem methods behave as expected\n\nWe could start with manual testing\n\ni.e. create a StockItem using the interpreter and check the behaviours\n\nHowever this is clearly not automatic\nIt is difficult to repeat since we have to follow the steps clearly\nHard to document\n\nIdeally the documentation should be colocated with the test\nThe same way we colocate documentation with a function (docstrings)\nClearly not the case if we’re manually entering values\n\nBetter is to write code that automatically tests the class\n\nWe’ve seen similar before where we’ve written print statements that output an expected versus actual value\nSee Roman Numeral Converter for an example\nThis still has the downside that we need to manually parse the output to check the tests passed\nWould be good to automate this part of the process as well!\n\nAn improvement might be to use exceptions, e.g.\n  item = StockItem(stock_ref=\"Test\", price=10, tag=\"test:tag\")\n  if item.stock_level != 0:\n      raise Exception(\"Initial Stock level not 0\")\nThis means that any failed test will stop the program and alert the user\nHow could we test code that is supposed to throw an exception?\nWe could write a wrapper, e.g.\n  excepted = False\n  try:\n      \"\"\"\n      Test behaviour that\n      should raise an exception\n      goes here\n      \"\"\"\n  except: # ideally specify the exact exception we expect\n      excepted = True\n\n  if not excepted:\n      raise Exception(\"Test Failed: No Exception raised\")\nIdeally define lots of small tests\nRepeat the relevant tests each time part of a program is updated\nOn large programs tests might be run automatically every day, night etc.\nPython provides some tools for making testing easier to implement\n\n\n\n\nPython defines the assert keyword\nLet’s programs test as they run\nAssert means “ensure this is true”\nWe can rewrite the previous test using assert\n  item = StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n  assert item.stock_level == 0\nLet’s see what happens if the assert fails\n\nWe’ll define a dummy StockItem class with a non-zero starting stock level\n\n\n  class StockItem:\n      def __init__(self, stock_ref, price, tags):\n          self.stock_level = 1\n\n  item = StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n  assert item.stock_level == 0\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[42], line 6\n      3         self.stock_level = 1\n      5 item = StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n----&gt; 6 assert item.stock_level == 0\n\nAssertionError: \n\n\n\nAs we can see an AssertionError is raised\n\nJust like any other form of exception\n\n\n\n\nWork through the following questions about assert statements\n\nHow many assert statements can a program contain?\n\nThere is no limit\n\nDoes the program continue after an assertion has failed?\n\nDepends on how the program handles it\nIf there’s no exception handling then the program will be stopped\nA try...catch block may allow the program to recover\n\n\n\n\n\n\n\nassert lets us write checks that execute in code\n\nCan be used to halt a program if an invalid state in encountered during execution\nDoesn’t intrinsically help us write many, small, independent tests\n\nPython provides a framework for automating the construction and execution of unit tests\nUnit tests are small, self-contained test designed to verify one behaviour (a unit)\nUnit tests for a component should be created alongside the component itself\n\nIn test-driven development the tests are written before the components themselves\n\nOr at least defined until we stabilise the API\nCode is written such that by implementing the behaviour to pass every more sophisticated tests we create a working component\n\n\nunittest is provided as part of the python standard installation\n\nImported the usual way\n\n  import unittest\n\n\nRecall our complete (tag-based) StockItem implementation\n\n\nclass StockItem:\n    \"\"\"\n    Represents a single inventory item\n\n    Attributes\n    ----------\n    stock_ref : str\n        reference id of the stock item\n    tags : set[str]\n        set of tags describing the stock item\n\n    Class Attributes\n    ----------------\n    show_instrumentation : bool\n        Indicates if instrumentation should be printed\n    max_stock_add : int\n        maximum amount of stock that can be added to an item's stock level at a time\n    min_price : int | float\n        minimum price of any stock item\n    max_price : int | float\n        maximum price of any stock item\n    \"\"\"\n\n    show_instrumentation = True\n\n    max_stock_add = 10\n\n    min_price = 0.5\n    max_price = 500\n\n    def __init__(self, stock_ref, price, tags):\n        \"\"\"\n        Creates a `StockItem` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            stock reference id\n        price : int | float\n            stock price\n        tags : set[str]\n            set of tags describing the stock item\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem __init__ called\")\n        self.stock_ref = stock_ref\n        self.__price = price\n        self.tags = tags\n        self.__stock_level = 0\n        self.__StockItem_version = 4\n\n    def __str__(self):\n        if StockItem.show_instrumentation:\n            print(\"**StockItem __str__ called\")\n        template = \"\"\"Stock Reference: {0}\nPrice: {1}\nStock level: {2}\nTags: {3}\"\"\"\n        return template.format(self.stock_ref, self.price, self.stock_level, self.tags)\n\n    @property\n    def price(self):\n        \"\"\"\n        price : int | float\n            dress price\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem get price called\")\n        return self.__price\n\n    @property\n    def stock_level(self):\n        \"\"\"\n        stock_level : int\n            amount of stock in inventory\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem get stock_level called\")\n        return self.__stock_level\n\n    def check_version(self):\n        \"\"\"\n        Checks the version of a `StockItem` instance and upgrades it if required\n\n        Returns\n        -------\n        None\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem check_version called\")\n        if self.__StockItem_version != 4:\n            print(\"Stock item uses old data model, please recreate this item\")\n\n    def add_stock(self, count):\n        \"\"\"\n        Add stock to an item\n\n        Parameters\n        ----------\n        count : int\n            amount of stock to add to an item\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        Exception\n            raised if `count` &lt; 0 or `count` &gt; `StockItem.max_stock_add`\n\n        See Also\n        --------\n        StockItem.max_stock_add : maximum amount of stock that can be added to a `StockItem`\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem add_stock called\")\n        if count &lt; 0 or count &gt; StockItem.max_stock_add:\n            raise Exception(\"Invalid add amount\")\n        self.__stock_level = self.__stock_level + count\n\n    def sell_stock(self, count):\n        \"\"\"\n        Sell stock of an item\n\n        Decreases the item's stock level\n\n        Parameters\n        ----------\n        count : int\n            amount of stock to sell\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        Exception\n            raised if `count` &lt; 1 or `count` is greater than the available stock\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem sell_stock called\")\n        if count &lt; 1:\n            raise Exception(\"Invalid number of items to sell\")\n        if count &gt; self.__stock_level:\n            raise Exception(\"Not enough stock to sell\")\n        self.__stock_level = self.__stock_level - count\n\n\nLet’s use unittest to write some unit tests\nunittest provides a class (TestCase) that acts as a superclass for tests\nWe create our tests by subclassing TestCase\n\nWe populate the class with method which implement our tests\n\nFirst we’ll write a test for the initializer\n\n  class TestStockItem(unittest.TestCase):\n\n      def test_StockItem_init(self):\n          item = StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n          self.assertEqual(item.stock_ref, \"Test\")\n          self.assertEqual(item.price, 10)\n          self.assertEqual(item.stock_level, 0)\n          self.assertEqual(item.tags, \"test:tag\")\n\nTestStockItem is our test class\n\nThe method test_StockItem_init tests the __init__ correctly sets the values on a StockItem instance\n\nself.assertEqual is a method inherited from the TestCase superclass\n\nPerforms the test\nFunctions like an assert in that it checks that the value passed as the first argument matches the value in the second argument\n\nIf equal the test passes\nElse, test fails\n\n\nWe can run the test by calling the main method for the unittest module\n  unittest.main()\n\n\n\n.\n----------------------------------------------------------------------\nRan 1 test in 0.001s\n\nOK\n\n\n**StockItem __init__ called\n**StockItem get price called\n**StockItem get stock_level called\n\n\n&lt;unittest.main.TestProgram at 0x7f195c843ef0&gt;\n\n\n\nThe above should show that our test executed successfully\nIf we want more detail we can use the verbosity parameter\n\nInteger number which represents the level of output detail\n\n\n    unittest.main(verbosity=2)\n\n\ntest_StockItem_init (__main__.TestStockItem.test_StockItem_init) ... ok\n\n----------------------------------------------------------------------\nRan 1 test in 0.001s\n\nOK\n\n\n**StockItem __init__ called\n**StockItem get price called\n**StockItem get stock_level called\n\n\n&lt;unittest.main.TestProgram at 0x7f195c8437a0&gt;\n\n\n\nWe can now see the name and status of each individual test\n\n\n\n\n\n\n\nWarning\n\n\n\nAttempting to run unittest in an IPython Notebook may cause issues\nFor IPython Notebooks such as the ones I have used to type up these notes, calling unittest.main() as written above fails to work due to intricacies with how the IPython works. The correct usage in that case is,\nunittest.main(argv=['first-arg-is-ignored'], exit=False)\nSee Stack Overflow for an explanation\n\n\n\nWhat happens if a test fails?\n\n    class TestAlwaysFails(unittest.TestCase):\n\n      def test_that_fails(self):\n          self.assertEqual(1, 0)\n\nThe above defines a test that trivially fails, if we run our unit tests then\n  unittest.main()\n\n\n\nF.\n======================================================================\nFAIL: test_that_fails (__main__.TestAlwaysFails.test_that_fails)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/ipykernel_3242/3483629732.py\", line 4, in test_that_fails\n    self.assertEqual(1, 0)\nAssertionError: 1 != 0\n\n----------------------------------------------------------------------\nRan 2 tests in 0.001s\n\nFAILED (failures=1)\n\n\n**StockItem __init__ called\n**StockItem get price called\n**StockItem get stock_level called\n\n\n&lt;unittest.main.TestProgram at 0x7f195c83e600&gt;\n\n\n\nThe output indicates that tests have failed\nAlso specifies the specific failed test\nThere are a range of possible assertion conditions for statements\n\nSee the table below\n\n\n\n\n\n\n\n\n\n\nTest Function\nTest Action\nUse Case\n\n\n\n\nassertEqual(a,b)\nAsserts that a is the same as b\nTest that two values are the same\n\n\nassertNotEqual(a, b)\nAsserts that a is not the same as b\nTest that two values differ\n\n\nassertTrue(a)\nAsserts that a is True\nTest a boolean expression is true\n\n\nassertFalse(b)\nAsserts that b is False\nTest a boolean expression is false\n\n\nassertIs(a, b)\nAssert that a and b refer to the same object\nTest if two references (variables) refer to the same underlying memory object\n\n\nassertIsNot(a, b)\nAssert that a and b refer to different objects\nTest two references refer to different memory objects\n\n\nassertIsNone(a)\nAssert that r is None\nTest a variable is explicitly the None value\n\n\nassertIsNotNone(a)\nAssert that a is not None\nTest a variable is explicitly not the None value\n\n\nassertIn(a, b)\nAssert that a is in the collection b\nTest a value is in a collection\n\n\nassertNotIn(a, b)\nAssert that a is not in the collection b\nTest a value is not in a collection\n\n\nassertIsInstance(a, b)\nAssert that a is an instance of type b\nTest that a reference refers to an object of a specific type\n\n\nassertNotIsInstance(a, b)\nAssert that a is not an instance of type b\nTest a reference does not refer to a particular object type\n\n\n\n\n\n\nThe above table shows how we perform a value-based unit test\n\ni.e we execute a statement and check it’s value or type against an expected result\n\nWhat is want to perform a behaviour based unit test?\n\ne.g. What if we want to test that code correctly throws an exception?\nFor example the code below attempts to add negative stock\n\nShould raise an exception!\n\n  item = StockItem(stock_ref=\"Test\", price=10,  tags=\"test:tag\")\n  item.add_stock(-1)\n\nWe can use assertRaises to test for exceptions, e.g.\n\n\nimport unittest\n\nclass TestStockItem(unittest.TestCase):\n\n    def test_StockItem_invalid_sell_stock_raises_exception(self):\n        item = StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n        with self.assertRaises(Exception):\n            item.add_stock(-1)\n\n\nRunning the unit test (hidden)\n\n\n\n.\n\n\n**StockItem __init__ called\n**StockItem add_stock called\n\n\n\n----------------------------------------------------------------------\nRan 1 test in 0.001s\n\nOK\n\n\n&lt;unittest.main.TestProgram at 0x7f195cae5490&gt;\n\n\n\nIf we wanted to test for specific exceptions we can pass them to assertRaises as arguments\nNote that assertRaises works slightly differently to the other tests\nWe have to wrap the functionality we want to test in the assertRaises context manager using the with keyword\n\nassertRaises then attempts to catch the exception specified in it’s initializer\n\nIf the exception is not raised the test will fail\n\n\n\n\n\n\nunittest makes it very easy to add tests to a project\nTests force you to think about how a component should behave\nTests might need you to clarify requirements with a client\n\ne.g. We might ask our client to define a maximum amount of stock that could be added\n\nThen implement a test to check that behaviour\n\n\nFirst step is to test that an object is created correctly\nAfter that can test specific behaviours\n\ne.g. we want to test that the normal process of adding and selling stock works\n\n\n  class TestStockItem(unittest.TestCase):\n\n      def test_StockItem_add_and_sell_stock(self):\n          item = StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n          self.assertEqual(item.stock_level, 0)\n          item.add_stock(10)\n          self.assertEqual(item.stock_level, 10)\n          item.sell_stock(2)\n          self.assertEqual(item.stock_level, 8)\n\nWhich should pass when run,\n\n    unittest.main(verbosity=2)\n\n\ntest_StockItem_add_and_sell_stock (__main__.TestStockItem.test_StockItem_add_and_sell_stock) ... ok\n\n----------------------------------------------------------------------\nRan 1 test in 0.001s\n\nOK\n\n\n**StockItem __init__ called\n**StockItem get stock_level called\n**StockItem add_stock called\n**StockItem get stock_level called\n**StockItem sell_stock called\n**StockItem get stock_level called\n\n\n&lt;unittest.main.TestProgram at 0x7f195cae6000&gt;\n\n\n\nunittest can be used to create more complex testing scenarios\n\nRead the docs at the python website\n\nThe tests shown above are implemented in TestStockItem.py\n\n\n\n\n\n\n\nCaution\n\n\n\nTests only prove the existence of faults\nTests are important and should always be included when making a program. Test’s do not guarantee that a program is correctly implemented, just that it passes the specific tests. It is typically impossible to test all possible paths through a program. Bugs can therefore exist even for extensive testing suites. You should form a habit of reviewing your code to ensure it works, alongside using automated testing to provide an additional layer of protection\n\n\n\n\n\nThe provided example tests, check only a limited portion of the StockItem functionality. First remove the automatically failing test, then implement additional tests to check more features of StockItem. For example, you should check that an exception is raised if sell_stock is passed a value greater than the current value of stock_level\nWe’ll try and implement a logical sequence of tests, such that each test, tests one functionality, and relies only on functionality that is tested by another test. In general we want to typically only have a single assert in a test, so that we can clearly identify the failure point. Let’s go through method by method\nclass TestStockItem(unittest.TestCase):\n    def test_init(self):\n        item = StockItem.StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n        self.assertEqual(item.stock_ref, \"Test\")\n        self.assertEqual(item.price, 10)\n        self.assertEqual(item.stock_level, 0)\n        self.assertEqual(item.tags, \"test:tag\")\n\nWe don’t need to modify this __init__ check, it checks all the attributes\n\nExcept the version, but this is a private variable so not easy to check\nNo methods let us interrogate the value\n\nNot easy to test!\nWhen things are hard to test, its generally a sign that they are not implemented in a very robust way\nRight now version checking is a manual warning, but in future updates, we might seek to change this API to a more testable interface\n\n\nNext we want to test the __str__ method\n  def test_str(self):\n      item = StockItem.StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n      expected_str = \"\"\"Stock Reference: Test\nPrice: 10\nStock level: 0\nTags: test:tag\"\"\"\n      self.assertEqual(str(item), expected_str)\n\nWe rely on the fact that __init__ has been tested\nThen explicitly write out what the filled in string template should look like\nFinally call assertEqual on the str(item) call, and then expected_str\n\nNow lets test the add_stock method\nThere are three cases to consider here\n\nThe normal case - stock is added as expected\nTrying to add more than the maximum - an exception is raised\nTrying to add negative stock - an exception is raised\n\nLet’s implement these as three distinct tests\n  def test_add_stock(self):\n      item = StockItem.StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n      item.add_stock(10)\n      self.assertEqual(item.stock_level, 10)\n\n  def test_add_stock_greater_than_maximum_raises_exception(self):\n      item = StockItem.StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n      with self.assertRaises(Exception):\n          item.add_stock(StockItem.StockItem.max_stock_add + 1)\n\n  def test_add_negative_stock_raises_exception(self):\n      item = StockItem.StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n      with self.assertRaises(Exception):\n          item.add_stock(-1)\n\nEach test checks one case\nMakes each test small and easy to understand\nLet’s us write long, descriptive names for all of them\n\nNow lastly, we have to implement the corresponding checks for sell_stock\n\nSelling stock \\(&lt;\\) current stock level and \\(&gt; 0\\) - stock is reduced as expected\nSelling \\(0\\) stock - an exception is raised\nSelling negative stock - an exception is raised\nSelling stock \\(&gt;\\) current stock level - an exception is raised\n\nAgain we’ll implement these as independent tests\n    def test_sell_stock(self):\n      item = StockItem.StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n      item.add_stock(10)\n      item.sell_stock(2)\n      self.assertEqual(item.stock_level, 8)\n\n  def test_sell_zero_stock_raises_exception(self):\n      item = StockItem.StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n      item.add_stock(10)\n      with self.assertRaises(Exception):\n          item.sell_stock(0)\n\n  def test_sell_negative_stock_raises_exception(self):\n      item = StockItem.StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n      item.add_stock(10)\n      with self.assertRaises(Exception):\n          item.sell_stock(-1)\n\n  def test_sell_stock_greater_than_stock_level_raises_exception(self):\n      item = StockItem.StockItem(stock_ref=\"Test\", price=10, tags=\"test:tag\")\n      with self.assertRaises(Exception):\n          item.sell_stock(1)\n\nThese all follow a similar structure to those for add_stock\nFor test_sell_zero_stock_raises_exception and test_sell_negative_stock_raises_exception we use add_stock\n\nadd_stock is tested, so we know it won’t break these tests\nLet’s us be sure that these tests fail because the specific scenario is violated and not because of a different overlapping fail case (e.g. selling more stock than we have)\n\n\nWe can then run these tests,\n\nunittest.main(verbosity=2)\n\n\ntest_add_negative_stock_raises_exception (__main__.TestStockItem.test_add_negative_stock_raises_exception) ... ok\ntest_add_stock (__main__.TestStockItem.test_add_stock) ... ok\ntest_add_stock_greater_than_maximum_raises_exception (__main__.TestStockItem.test_add_stock_greater_than_maximum_raises_exception) ... ok\ntest_init (__main__.TestStockItem.test_init) ... ok\ntest_sell_negative_stock_raises_exception (__main__.TestStockItem.test_sell_negative_stock_raises_exception) ... ok\ntest_sell_stock (__main__.TestStockItem.test_sell_stock) ... ok\ntest_sell_stock_greater_than_stock_level_raises_exception (__main__.TestStockItem.test_sell_stock_greater_than_stock_level_raises_exception) ... ok\ntest_sell_zero_stock_raises_exception (__main__.TestStockItem.test_sell_zero_stock_raises_exception) ... ok\ntest_str (__main__.TestStockItem.test_str) ... ok\n\n----------------------------------------------------------------------\nRan 9 tests in 0.008s\n\nOK\n\n\n&lt;unittest.main.TestProgram at 0x7f195cae7530&gt;\n\n\n\n\n\nIn Chapter 5 we designed the Ride Selector Program. When designing the UI, we considered how we would implement testing. Update the program to use unittest. You may need to refactor the code to introduce testability\nThe most recent version of Ride Selector is given as an exercise in Chapter 7 so we’ll use that version as our starting point.\nAs noted, the program as written is not amenable to testing. Everything is one big nested loop and the outputs printed directly to the terminal. We first need to refactor this program into one suitable for testing.\nLet’s first start by defining a lightweight Ride class. Looking at our code we can see a ride has a name, and then optionally a maximum or minimum age. There is also a global minimum and maximum age limit.\nclass Ride:\n    \"\"\"\n    A class representing a theme park amuse ride rider limitations\n\n    Attributes\n    ----------\n    name : str\n        name of the ride\n\n    min_age : int\n        minimum age in years to ride\n\n    max_age : int\n        maximum age in years to ride, must be greater than or equal to `min_age`\n\n    Class Attributes\n    ----------------\n    ride_min_age : int\n        minimum `min_age` for any ride\n\n    ride_max_age : int\n        maximum `max_age` for any ride\n\n    \"\"\"\n\n    ride_min_age = 1\n    ride_max_age = 95\n\n    @staticmethod\n    def is_valid_age_limit(age):\n        \"\"\"\n        Check a proposed ride age limit is valid\n\n        Parameters\n        ----------\n        age : int\n            proposed age limit in years\n\n        Returns\n        -------\n        bool\n            `True` if `age` is an allowed age limit, else `False`\n\n        See Also\n        --------\n        Ride.ride_min_age : minimum valid age limit for a ride\n        Ride.ride_max_age : maximum valid age limit for a ride\n        \"\"\"\n        return Ride.ride_min_age &lt;= age &lt;= Ride.ride_max_age\n\n    def __init__(self, name, min_age, max_age):\n        \"\"\"\n        Creates a new `Ride` instance\n\n        Parameters\n        ----------\n        name : str\n            name of the ride\n        min_age : int\n            minimum age (inclusive) to ride in years\n        max_age : int\n            maximum age to ride (inclusive) to ride in years.\n            `max_age` must be `&gt;= min_age`\n\n        Raises\n        ------\n        ValueError\n            Raised if `max_age` is `&lt; min_age`\n        ValueError\n            Raised if `min_age` or `max_age` is not a valid age limit\n\n        See Also\n        --------\n        Ride.is_valid_age_limit : Checks that ages are valid\n        \"\"\"\n        if not Ride.is_valid_age_limit(min_age):\n            raise ValueError(\n                \"{0} is not a valid age for the minimum age limit\".format(min_age)\n            )\n        if not Ride.is_valid_age_limit(max_age):\n            raise ValueError(\n                \"{0} is not a valid age for the maximum age limit\".format(max_age)\n            )\n        if max_age &lt; min_age:\n            raise ValueError(\n                \"maximum age ({0}) must be greater than or equal to minimum age ({1})\".format(\n                    max_age, min_age\n                )\n            )\n        self.name = name\n        self.min_age = min_age\n        self.max_age = max_age\n\n    def __str__(self):\n        return str(self.name)\n\n    def in_age_limit(self, age):\n        \"\"\"\n        Validate that an age is within the limits of the ride\n\n        Parameters\n        ----------\n        age : int\n            age in years to validate is within the age limit\n\n        Returns\n        -------\n        bool\n            `True` if the age is within the ride limits, else `False`\n        \"\"\"\n        return self.min_age &lt;= age &lt;= self.max_age\n\nThe resulting class is lightweight\nWe define class variables ride_min_age and ride_max_age for the global minimum and maximum ages\nWe provide a function, is_age_valid_age_limit as a static method that checks a provided age is within these limits\n\nRide uses this internally to validate the min_age and max_age passed in __init__\nCan also be used externally to check if an age is allowed on any ride\n\nDefining our tests for is_age_valid_age_limit\n  class TestRide(unittest.TestCase):\n  \"\"\"\n  Test class implementing unit tests for the `Ride` class\n  \"\"\"\n\n      # Test case for `is_valid_age_limit`\n\n      def test_is_valid_age_accepts_normal_age(self):\n          self.assertTrue(RideSelector.Ride.is_valid_age_limit(always_valid_middle_age))\n\n      def test_is_valid_age_accepts_min_age(self):\n          self.assertTrue(\n              RideSelector.Ride.is_valid_age_limit(RideSelector.Ride.ride_min_age)\n          )\n\n      def test_is_valid_age_accepts_max_age(self):\n          self.assertTrue(\n              RideSelector.Ride.is_valid_age_limit(RideSelector.Ride.ride_max_age)\n          )\n\n      def test_is_valid_age_rejects_less_than_min_age(self):\n          self.assertFalse(\n              RideSelector.Ride.is_valid_age_limit(RideSelector.Ride.ride_min_age - 1)\n          )\n\n      def test_is_valid_age_rejects_greater_than_max_age(self):\n          self.assertFalse(\n              RideSelector.Ride.is_valid_age_limit(RideSelector.Ride.ride_max_age + 1)\n          )\n\nWe can see there a range of test cases\n\nTest a standard value within the range is accepted\nTest the boundary values (ride_min_age and ride_max_age) are accepted\nTest values outside the boundaries are rejected\n\n\nNext we can define our __init__ and __str__ methods\n\n    def __init__(self, name, min_age, max_age):\n        \"\"\"\n        Creates a new `Ride` instance\n\n        Parameters\n        ----------\n        name : str\n            name of the ride\n        min_age : int\n            minimum age (inclusive) to ride in years\n        max_age : int\n            maximum age to ride (inclusive) to ride in years.\n            `max_age` must be `&gt;= min_age`\n\n        Raises\n        ------\n        ValueError\n            Raised if `max_age` is `&lt; min_age`\n        ValueError\n            Raised if `min_age` or `max_age` is not a valid age limit\n\n        See Also\n        --------\n        Ride.is_valid_age_limit : Checks that ages are valid\n        \"\"\"\n        if not Ride.is_valid_age_limit(min_age):\n            raise ValueError(\n                \"{0} is not a valid age for the minimum age limit\".format(min_age)\n            )\n        if not Ride.is_valid_age_limit(max_age):\n            raise ValueError(\n                \"{0} is not a valid age for the maximum age limit\".format(max_age)\n            )\n        if max_age &lt; min_age:\n            raise ValueError(\n                \"maximum age ({0}) must be greater than or equal to minimum age ({1})\".format(\n                    max_age, min_age\n                )\n            )\n        self.name = name\n        self.min_age = min_age\n        self.max_age = max_age\n\n    def __str__(self):\n        return str(self.name)\n\nThe __init__ checks that the passed min_range and max_range are valid\n\nThen checks that min_range and max_range follow the correct ordering\n\nOnce the input is validated just sets the appropriate data values\n\nWe’re leaving them public for the simplicity of demonstration\n\nOur __str__ method is defined to simply return self.name as a string\nWe have a few tests here\n\nTest that we can construct an object normally and have the values set\nTest that an invalid min_age is rejected\nTest that an invalid max_age is rejected\nTest that min_age may not be greater than max_age\nCheck that the appropriate string is returned\n\n\n    # Test cases for init\n\n    def test_init_sets_attributes_correctly(self):\n        ride = RideSelector.Ride(\n            \"Test\", min_age=always_valid_middle_age, max_age=always_valid_middle_age\n        )\n        self.assertEqual(ride.name, \"Test\")\n        self.assertEqual(ride.min_age, always_valid_middle_age)\n        self.assertEqual(ride.max_age, always_valid_middle_age)\n\n    def test_init_raises_valueerror_on_invalid_min_age(self):\n        with self.assertRaises(ValueError):\n            ride = RideSelector.Ride(  # noqa: F841\n                \"Test\",\n                min_age=RideSelector.Ride.ride_min_age - 1,\n                max_age=always_valid_middle_age,\n            )\n\n    def test_init_raises_valueerror_on_invalid_max_age(self):\n        with self.assertRaises(ValueError):\n            ride = RideSelector.Ride(  # noqa: F841\n                \"Test\",\n                min_age=always_valid_middle_age,\n                max_age=RideSelector.Ride.ride_max_age + 1,\n            )\n\n    def test_init_raises_value_error_if_max_age_less_than_min_age(self):\n        with self.assertRaises(ValueError):\n            ride = RideSelector.Ride(  # noqa: F841\n                \"Test\",\n                min_age=RideSelector.Ride.ride_max_age + 1,\n                max_age=RideSelector.Ride.ride_min_age - 1,\n            )\n\n    def test_str_returns_ride_name(self):\n        ride = RideSelector.Ride(\n            \"Test\",\n            min_age=always_valid_middle_age,\n            max_age=always_valid_middle_age,\n        )\n        self.assertEqual(str(ride), \"Test\")\n\nThe last method on Ride is one that now checks if a given age is accepted by the specific Ride instance\n\n    def in_age_limit(self, age):\n        \"\"\"\n        Validate that an age is within the limits of the ride\n\n        Parameters\n        ----------\n        age : int\n            age in years to validate is within the age limit\n\n        Returns\n        -------\n        bool\n            `True` if the age is within the ride limits, else `False`\n        \"\"\"\n        return self.min_age &lt;= age &lt;= self.max_age\n\nWe pretty much want to test the same cases as for is_valid_age_limit\n      def test_in_age_limit_accepts_valid_age(self):\n      ride = RideSelector.Ride(\n          \"Test\",\n          min_age=always_valid_middle_age,\n          max_age=always_valid_middle_age,\n      )\n      self.assertTrue(ride.in_age_limit(always_valid_middle_age))\n\n  def test_in_age_limit_rejects_too_small_age(self):\n      ride = RideSelector.Ride(\n          \"Test\",\n          min_age=always_valid_middle_age,\n          max_age=always_valid_middle_age,\n      )\n      self.assertFalse(ride.in_age_limit(ride.min_age - 1))\n\n  def test_in_age_limit_rejects_too_large_age(self):\n      ride = RideSelector.Ride(\n          \"Test\",\n          min_age=always_valid_middle_age,\n          max_age=always_valid_middle_age,\n      )\n      self.assertFalse(ride.in_age_limit(ride.max_age + 1))\nNext we construct our RideSelector class\n\nFor simplicity this implementation mixes some of the container management aspects with the UI presentation aspects\nSince some of the functionality requires user input or provides output to the user, we can’t test absolutely everything\nGoal is to factor out the individual steps into functions that accept arguments and return values\nThese can then be tested against\n\nRideSelector starts with a basic __init__ method that populates it with a preset lookup table of rides\nThe __str__ method converts the tuple of rides into an indexed list as a string\nWe’ll ignore testing the __init__ method for now\n\nSince it’s not interesting\n\n__str__ uses a quite complicated lambda though to perform it’s magic\n\nThe idea is to map the tuple elements to their enumerated pair\n\ni.e. a tuple containing the index and the value\n\nWe then write use a lambda that maps the enumerated pair to the form x. value where x is the \\(index + 1\\) (since we want to convert from \\(0\\)-indexed to \\(1\\)-indexed) and value is the actual value\nWe then use map to apply the lambda to all elements of the enumerate object\nLastly convert into our string using \"\\n\".join\nThis is quite a complicated set of steps and so should be tested\n\nWe’ll define a new test class for the RideSelector tests\n\nThis is to make them distinct\nIn a bigger program we would probably separate out each components tests into their own test file\nOur __str__ test will take define an expected string and compare this to the result of calling the __str__ method\n\n  class TestRideSelector(unittest.TestCase):\n  \"\"\"\n  Test cases for the `RideSelector` class\n  \"\"\"\n\n  # test str method\n      def test_str_creates_enumerated_table(self):\n          ride_selector = RideSelector.RideSelector()\n          expected_str = \"\"\"1. Scenic River Cruise\n  2. Carnival Carousel\n  3. Jungle Adventure Water Splash\n  4. Downhill Mountain Run\n  5. The Regurgitator\"\"\"\n          self.assertEqual(str(ride_selector), expected_str)\nNext we define a get_ride method that converts a user selection of a ride into the corresponding ride object\nThis has a simple implementation\n      def get_ride(self, index):\n      \"\"\"\n      Get's the ride associated with a given index\n\n      Parameters\n      ----------\n      index : int\n          integer greater than zero corresponding a ride index\n\n      Returns\n      -------\n      Ride\n          the ride stored by the given index\n\n      Raises\n      ------\n      ValueError\n          Raised if `index &lt;= 0`\n      IndexError\n          Raised if the no ride exists for the given index\n      \"\"\"\n      if index &lt;= 0:\n          raise ValueError(\"index must be a positive integer\")\n      return self._rides[index - 1]\nThere are clear cases to test here\n\nThat a valid index returns the correct Ride instance\nThat a non-positive index returns a ValueError\nThat an invalid index returns an IndexError\n\n  # test get_ride method\n\n  def test_get_ride_returns_expected_ride(self):\n      ride_selector = RideSelector.RideSelector()\n      ride = ride_selector.get_ride(1)\n      self.assertEqual(str(ride), \"Scenic River Cruise\")\n\n  def test_get_ride_raises_valueerror_on_zero_index(self):\n      ride_selector = RideSelector.RideSelector()\n\n      with self.assertRaises(ValueError):\n          ride_selector.get_ride(0)\n\n  def test_get_ride_raises_valueerror_on_invalid_index(self):\n      ride_selector = RideSelector.RideSelector()\n\n      with self.assertRaises(IndexError):\n          ride_selector.get_ride(99)\nOur last testable component in then, check_age_against_ride\n\nThis takes in an age and a ride\nChecks in a person of that age can ride the ride\nThis has two stages\n\nFirst validate that person can ride any ride\n\nUsing Ride.is_valid_age_limit\n\nValidate that person can ride the specific ride they selected\n\nUsing that ride’s in_age_limit method\n\n\nReturns a string to display to the caller the outcome\n\n  def check_age_against_ride(self, ride, age):\n      \"\"\"\n      Provides a string describing in a rider of `age` years can ride the Ride `ride`\n\n      Parameters\n      ----------\n      ride : Ride\n          ride to check the age against\n      age : int\n          age of the prospective rider in years\n\n      Returns\n      -------\n      str\n          string describing if a rider of `age` years can ride `ride`\n      \"\"\"\n      if age &lt; Ride.ride_min_age:\n          return \"You are too young to go on any rides\"\n      elif age &gt; Ride.ride_max_age:\n          return \"You are too old to go on any rides\"\n      elif age &lt; ride.min_age:\n          return \"Sorry, you are too young\"\n      elif age &gt; ride.max_age:\n          return \"Sorry, you are too old\"\n      else:\n          return \"You can go on the ride\"\n\nWe want to test these strings are returned correctly\nThere are a few cases\n\nToo young to go on any ride\nToo young to go on this specific ride\nToo old to go on any ride\nToo old to go on this specific ride\nAble to go on the ride\n\nLuckily since string literals are returned, we can check this easily\n\n      # test check age against ride\n\n  def test_too_young_for_any_ride(self):\n      ride_selector = RideSelector.RideSelector()\n      ride = ride_selector.get_ride(1)\n      self.assertEqual(\n          \"You are too young to go on any rides\",\n          ride_selector.check_age_against_ride(\n              ride, RideSelector.Ride.ride_min_age - 1\n          ),\n      )\n\n  def test_too_old_for_any_ride(self):\n      ride_selector = RideSelector.RideSelector()\n      ride = ride_selector.get_ride(1)\n      self.assertEqual(\n          \"You are too old to go on any rides\",\n          ride_selector.check_age_against_ride(\n              ride, RideSelector.Ride.ride_max_age + 1\n          ),\n      )\n\n  def test_too_young_for_specific_ride(self):\n      ride_selector = RideSelector.RideSelector()\n      ride = ride_selector.get_ride(5)\n      self.assertEqual(\n          \"Sorry, you are too young\",\n          ride_selector.check_age_against_ride(ride, ride.min_age - 1),\n      )\n\n  def test_too_old_for_specific_ride(self):\n      ride_selector = RideSelector.RideSelector()\n      ride = ride_selector.get_ride(5)\n      self.assertEqual(\n          \"Sorry, you are too old\",\n          ride_selector.check_age_against_ride(ride, ride.max_age + 1),\n      )\n\n  def test_valid_age_is_accepted(self):\n      ride_selector = RideSelector.RideSelector()\n      ride = ride_selector.get_ride(5)\n      self.assertEqual(\n          \"You can go on the ride\",\n          ride_selector.check_age_against_ride(ride, ride.min_age),\n      )\nThe last step is to the then run the tests\n\nunitttest.main()\n\n\n...............................\n----------------------------------------------------------------------\nRan 31 tests in 0.013s\n\nOK\n\n\n&lt;unittest.main.TestProgram at 0x7f195ceecfe0&gt;\n\n\n\n\n\n\n\n\nNote\n\n\n\nBe careful with how you design your tests\nTests are designed generally to test expected behaviours. This is why test-driven development typically expects you to write the test before the implementation. The idea being that by first defining the behaviour you want rather than testing a specific implementation you avoid coupling your test directly to your implementation.\nThis can be hard to avoid to some degree when dealing with unit tests because by their nature they test a specific unit. However, let’s look at our tests and some of the design choices. One of the main things I have done for some of the tests is to parameterise the values being tested, rather than hard-coding values. There is a trade-off here. The tests are a bit more opaque but are in theory flexible to changes. For example I have used the Ride.ride_min_age and Ride.ride_max_age points are:\n\nBy using the values, we make the tests test the behaviour rather than the specific chosen values\nWe couple the test to the implementation providing those class attributes\nIf we change those values we might actually want the tests to fail, so that we can then manually ensure that the change is correct\n\nThen update the test\nHowever, this has the problem, that our test is then being dictated by the implementation\nIf we revert a change we would have to again rework the tests\n\n\nThe notion of using parameters versus specific-values is a choice in testing, the above is just an example of how to think about how to test. The other consideration is if the testing framework fits with the design of your program. In rewiring the ride selector program we’ve arguably made it more complex and harder to reason about by trying to fit it into the individual component model that unittest expects. For Ride Selector which provides a fairly simple user interface where we mostly care about the user receiving the correct response a better testing implementation might actually be to test the program externally. By this we mean, we generate a test set of inputs, feed them into the program and record the outputs. We then compare these outputs to the expected outputs.\nDoing the testing this way has some tradeoffs. By testing the system as a whole it’s harder to identify where the sources of failures arise. However, the overall program doesn’t need to be refactored into a more complicated form just to facilitate the tests\n\n\n\n\n\n\n\nWe saw that you could add docstrings to functions to describe their behaviour\nImplicitly in the examples you’ve also seen these added to classes\nModules can also have docstrings too!\n\nThe only rule across all three is that the docstring is the first statement after the start\n\ni.e. for a function, after the function definition\nfor a class, after the class definition\nfor a module, the first statement in the file\n\n\n\n\n\nPydoc is a program written in python that can be run from the command line. Work through the following steps to see how it works\n\nNavigate to the folder 10_FashionShopWithDocumentation\nOpen a terminal in this folder (or navigate to this folder in the terminal)\nRun the pydoc module, by executing the following command,\n python -m pydoc\n\nThe -m following the call to python means “execute the following module”\nRunning on pydoc with no additional arguments we can see it provides documentation about pydoc itself\n\n  ! python -m pydoc\n\npydoc - the Python documentation tool\n\npydoc &lt;name&gt; ...\n    Show text documentation on something.  &lt;name&gt; may be the name of a\n    Python keyword, topic, function, module, or package, or a dotted\n    reference to a class or function within a module or module in a\n    package.  If &lt;name&gt; contains a '/', it is used as the path to a\n    Python source file to document. If name is 'keywords', 'topics',\n    or 'modules', a listing of these things is displayed.\n\npydoc -k &lt;keyword&gt;\n    Search for a keyword in the synopsis lines of all available modules.\n\npydoc -n &lt;hostname&gt;\n    Start an HTTP server with the given hostname (default: localhost).\n\npydoc -p &lt;port&gt;\n    Start an HTTP server on the given port on the local machine.  Port\n    number 0 can be used to get an arbitrary unused port.\n\npydoc -b\n    Start an HTTP server on an arbitrary unused port and open a web browser\n    to interactively browse documentation.  This option can be used in\n    combination with -n and/or -p.\n\npydoc -w &lt;name&gt; ...\n    Write out the HTML documentation for a module to a file in the current\n    directory.  If &lt;name&gt; contains a '/', it is treated as a filename; if\n    it names a directory, documentation is written for all the contents.\n\n\n\nWe can see from the output that pydoc is a documentation tool\nThere a number of different arguments we can supply that modify how it runs\n\nFor now we want to start a webpage to read our documentation. Reading the documentation we can see this can be done using the -b flag. Enter the following\n python -m pydoc -b\n\npydoc will then start a website that can be used to view the documentation\nThe result should look something like the screenshot below\n\n\n\nGenerated Pydoc Website\n\n\nWe can see the site contains links to python’s built-in modules\nBut there is also a section for our own documented modules,\n\nI’ve included the generated html so you can interact with them directly\n\nData\nFashionShopShellUI\nRunTests\n\n\nYou can also use the built-in search bar\nThe docstrings are now displayed for the module, class and each method\n\n\n\n\n\n\n\n\nWarning\n\n\n\nModules that run as programs can break pydoc\nRecall that when loaded a module will execute all of the statements that it includes. For pydoc to generate the docstrings and site material from a module it first has to load it. This means that it will lead to those statements being executed.\nThis means that if we had a module that represented an entry point to looping user input (such as FashionShopShellUI.py) it would immediately start executing and freeze pydoc. This is a reminder to use name guards to control the context in which a module can be executed.\n    if __name__ = \"__main__\":\n        # do things that should only occur if the module is executed directly",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 12: Python Applications"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/12_PythonApplications/Chapter_12.html#summary",
    "href": "02_AdvancedProgramming/12_PythonApplications/Chapter_12.html#summary",
    "title": "Chapter 12: Python Applications",
    "section": "Summary",
    "text": "Summary\n\nWe’ve seen that testing can be automated and integrated into a program\nunittest is an in-built framework for performing unit testing\n\nUnit tests are small tests that test a specific behaviour\n\nDocumentation is an important part of software development\n\nDocumentation can be added as docstrings to functions, classes and modules\nDocumentation can automatically be rendered\n\npydoc is an inbuilt python program for generating html sites of python documentation\n\n\nVariables can refer to functions\n\nFunction references allow us to be flexible in implementing an interface\n\nLambda expressions allow us to write small expressions that apply actions to data\n\nLambda’s can also be treated as data themselves\n\nyield allows us to write functions that serve as iterators\nWe can create packages in python\n\nPackages organise and group up modules\n\nVariables can refer to classes\n\nAllows us to be flexible in implementation like with function references",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 12: Python Applications"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/12_PythonApplications/Chapter_12.html#questions-and-answers",
    "href": "02_AdvancedProgramming/12_PythonApplications/Chapter_12.html#questions-and-answers",
    "title": "Chapter 12: Python Applications",
    "section": "Questions and Answers",
    "text": "Questions and Answers\n\nIs everything in python an object?\n\nYes\nThe advantage of python’s dynamic typing system is that everything is an object and can be treated as one\nlet’s us pass around a lot of different things to various parts of a system\n\nGives us lots of why to be flexible in implementation\n\nThe downside is that since there is no strict type checking we can get into situations where invalid objects are being passed\n\ne.g. we might try to call a method on an int that it doesn’t possess\n\n\nShould I feel bad if I don’t understand things like lambda expressions and yield?\n\nNo\nThese are advanced and complicated features\nIt’s also natural for a concept to require repeated exposure and multiple passes to sink in\nWith simple programs you generally will not have a natural use for these features\n\nWhen you do have those use cases though, they are powerful\n\n\nWhat happens when I move python packages from one computer to another?\n\nThey should work out of the box as long as a user has the correct version of python installed\nIf you mess with the directory structure you may need to update the packages\n\n(See the comments about importing in packages made earlier)\n\nA more permanent way is to publish a package, so that it can be installed (and preferably downloaded from the internet)\n\nWhen should I write my documentation and tests?\n\nAs you go along\nThere is a natural back and forth between documentation, tests and implementation\nFor a typical example workflow we might have a part of project we’re working on\n\nWe start by documenting the design process\nWe right some simple tests that we should aim to fulfill\nWe then create an implementation\nWe document the implementation as we go (preferably in code)\nWe ensure the implementation passes the basic tests\nWe add further tests to capture any unexpected behaviour found while implementing\n\nGenerally it is much easier to document a program as you write it and things are fresh than it is to go back and do it all\nSame for tests\n\nWrite small bits of code then test them\nEasier and more likely to result in a working program than writing one large block and a bunch of tests\nPythons dynamic typing and runtime error handling makes it very painful to try and fix large broken programs",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 12: Python Applications"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/10_UseClassesToCreateActiveObjects/Chapter_10.html",
    "href": "02_AdvancedProgramming/10_UseClassesToCreateActiveObjects/Chapter_10.html",
    "title": "Chapter 10: Using Classes to Create Active Objects",
    "section": "",
    "text": "Program’s tend to evolve in scope over time\n\nSometimes due to scope underestimation\nAlso because customers tend to request new features\n\nConsider the Tiny Contacts\n\nClient now wants to functionality to track the time spent with a client\n\nAs usual start with the interface,\n\nTime Tracker\n\n1. New Contact\n2. Find Contact\n3. Edit Contact\n4. Add Session\n5. Exit Program\n\nEnter your command:\nWe want to now storyboard out the new Add Session option\nEnter your command: 4\nAdd Hours\nEnter the Contact Name: Rob\nName: Rob Miles\nPrevious Hours worked: 0\nSession Length: 3\nUpdated hours worked: 3.0\nWe also want to update the Find Contact option to include the hours,\nFind Contact\nEnter the Contact Name: Rob\nName: Rob Miles\nAddress: 18 Pussycat Mews, London, NE1 410S\nTelephone: 1234 56789\nHours worked: 3.0\n\n\n\nWe need to store the hours worked\nSimplest approach is to redefine the Contact class\n\nAdd an hours_worked field\n\n\n\nclass Contact:\n    \"\"\"\n    Contact with a name, address and telephone number.\n    Tracks the hours worked with a client\n\n    Attributes\n    ----------\n    name : str\n        Contact Name\n    address : str\n        Contact's postal or street address.\n    telephone : str\n        Contact phone number (stored as a string).\n    hours_worked : int | float\n        Hours worked with a Contact, initialised to 0\n\n    Examples\n    --------\n    &gt;&gt;&gt; Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"+44(1234) 56789\")\n    &lt;Contact ...&gt;\n    \"\"\"\n\n    def __init__(self, name, address, telephone):\n        \"\"\"\n        Create a new `Contact` instance\n\n        Parameters\n        ----------\n        name : str\n            Contact Name\n        address : str\n            Contact's postal or street address.\n        telephone : str\n            Contact phone number (stored as a string).\n        \"\"\"\n        self.name = name\n        self.address = address\n        self.telephone = telephone\n        self.hours_worked = 0\n\n\nDefaulted to 0 as part of the constructor\n\nWe might discuss this with the client, it’s possible a contact might have some initial consult hours\n\nFrom here we can add a new add_session function (see the complete updated code, in our version which supports duplicate names in the search)\n  def add_session():\n      \"\"\"\n      Prompts the user to add hours worked to contacts matching a search\n\n      Returns\n      -------\n      None\n\n      See Also\n      --------\n      find_contacts : returns contacts matching a search name\n      \"\"\"\n      print(\"add session\")\n      search_name = read_text(\"Enter the contact name: \")\n      contact = find_contact(search_name)\n      if contact != None:\n          #found a contact\n          print(\"Name: \", contact.name)\n          print(\"Previous hours worked:\", contact.hours_worked)\n          session_length = BTCInput.read_float_ranged(prompt=\"Session length: \", min_value=0.5, max_value=3.5)\n          contact.hours_worked = contact.hours_worked + session_length\n          print(\"Updated hours worked:\", contact.hours_worked)\n      else:\n          print(\"This name was not found\")\nDon’t forget we also have to update how we display contacts for the Find Contact functionality (or in our case the display_contact) function.\n\n  def display_contact(contact):\n      \"\"\"\n      Displays the Contact details for the supplied contact\n\n      Parameters\n      ----------\n      contact : Contact\n          contact to display\n\n      Returns\n      -------\n      None\n\n      See Also\n      --------\n      display_contacts : Displays all contacts matching a search name\n      \"\"\"\n      print(\"Name:\", contact.name)\n      print(\"Address:\", contact.address)\n      print(\"Telephone:\", contact.telephone)\n      print(\"Hours worked for this Contact:\", contact.hours_worked, \"\\n\")\n\nIf we create a new Contact object then we can see how this looks,\n\n  contact = Contact(name=\"Alice\", address=\"Bob St\", telephone=\"555\")\n  display_contact(contact)\n  contact.hours_worked = 5.0\n  display_contact(contact)\n\nName: Alice\nAddress: Bob St\nTelephone: 555\nHours worked for this Contact: 0 \n\nName: Alice\nAddress: Bob St\nTelephone: 555\nHours worked for this Contact: 5.0 \n\n\n\n\n\n\n\nWhen extending a program you should always look at its design\nCode rots as it gets older\n\nGets harder to maintain and understand\n\nWant to make the design as clear and simple as possible\nLike a builder we want to make houses out of walls, walls out of bricks and bricks out of clay\n\ni.e. clear progression in scale and responsibility\n\nA technique for this is called object-oriented design\n\nObjects are designed to be cohesive\nA cohesive object should contain all the attributes and methods to work with its domain\n\nFor the Contact object we want it to be responsible for all contact information\n\nCurrently not very cohesive\nTime Tracker works directly on Contact object attributes\n\nBusiness logic that applies to a Contact is outside the function\n\ne.g. in the add_session function, we have hardcoded a minimum session time of half an hour and a maximum session time of three and half hours\nThis is problematic\n\nBecause the numbers are just written there as opposed to being defined as constants with meaning (they are magic constants)\nThis data validation is external to the data storage object itself, the Contact\n\nWe also perform the act of updating the Contact’s hours worked, outside the Contact object\n\n  session_length = BTCInput.read_float_ranged(prompt=\"Session length: \", min_value=0.5, max_value=3.5)\n  contact.hours_worked = contact.hours_worked + session_length\nThe magic constant problem is one issue,\n\nIf we were to use the Contact as a library object in another application, (like a graphical version) then we would have to maintain the validation code in two separate places\n\n\n\n\n\n\n\n\nTip\n\n\n\nKeep Business Rules in Business Objects\nThe issue here is we have defined business rules (things our customer asks the system to do) outside of the business objects (things created to implement the customer’s system).\n\n\n\nA solution is to make the Contact object responsible for validating the session length\n\nAny application that uses the Contact object will naturally use its internal validation\nOnly one location to change now\n\n\n\n\n\n\n\nAny python code can access hours_worked in a Contact\n\nReally only need hours_worked to be accessed to,\n\nDisplay time spent with a contact\nAdd the length of a session to hours_worked\n\n\nPython objects can hold method attributes\n\nFunctions bound to the object\n\nLet us ask an object to do something\nE.g. the string object has the method upper (seen in Chapter 5)\nLet us define two method attributes for Contact\n\nRemoves the need to directly access the attribute\n\nStart by defining a method to access the hours worked\n\n\nclass Contact:\n    \"\"\"\n    Contact with a name, address and telephone number.\n    Tracks the hours worked with a client\n\n    Attributes\n    ----------\n    name : str\n        Contact Name\n    address : str\n        Contact's postal or street address\n    telephone : str\n        Contact phone number (stored as a string)\n    hours_worked : int | float\n        Hours worked with a Contact, initialised to 0\n\n    Examples\n    --------\n    &gt;&gt;&gt; Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"+44(1234) 56789\")\n    &lt;Contact ...&gt;\n    \"\"\"\n\n    def __init__(self, name, address, telephone):\n        \"\"\"\n        Create a new `Contact` instance\n\n        Parameters\n        ----------\n        name : str\n            Contact Name\n        address : str\n            Contact's postal or street address.\n        telephone : str\n            Contact phone number (stored as a string).\n        \"\"\"\n        self.name = name\n        self.address = address\n        self.telephone = telephone\n        self.hours_worked = 0\n\n    def get_hours_worked(self):\n        \"\"\"\n        Get the hours worked for this contact\n        \"\"\"\n        return self.hours_worked\n\n\n\nConsider the following questions regarding the get_hours_worked function\n\nWhat is the parameter self used to accomplish?\n\nA method is part of an object\nself tells the method which object it is a part of\nThe code sample below shows how the method doesn’t need an additional reference to the Contact it refers to\n\n  # set up\n  rob = Contact(\"Rob\", \"A St\", \"1\")\n  rob.hours_worked = 1\n  jim = Contact(\"Jim\", \"B St\", \"555\")\n  jim.hours_worked = 2\n\n  # demonstration\n  rob_work = rob.get_hours_worked()\n  jim_work = jim.get_hours_worked()\n  if rob_work &gt; jim_work:\n      print(\"More work for rob\")\n  else:\n      print(\"More work for jim\")\n\nMore work for jim\n\n\n\nIs the get_hours_worked method stored when we save contact information in a file\n\nNo, if we use pickle to store a contact list, the method attributes are not stored. Pickle only stores the data attributes\n\nCan a program still access the hours_worked attribute of a Contact class\n\nYes, it can. Using method attributes to get data doesn’t stop a program accessing the data directly\nWe simply remove the desire to\nLater chapters look at techniques for enforcing this more robustly\n\n\n\nWe can create a second method to handle adding a session to a Contact\n\n  # existing class definition\n  class Contact:\n      def __init__(self, name, address, telephone):\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n          self.hours_worked = 0\n\n      def get_hours_worked(self):\n          \"\"\"\n          Gets the hours worked for this contact\n\n          Returns\n          -------\n          int | float\n              hours worked for this contact\n          \"\"\"\n          return self.hours_worked\n\n      # new method\n      def add_session(self, session_length):\n          \"\"\"\n          Adds a session (in hours) to the Contacts hours\n\n          Parameters\n          ----------\n          session_length : int | float\n              time spent on session in hours\n\n          Returns\n          -------\n          None\n          \"\"\"\n          self.hours_worked = self.hours_worked + session_length\n\nTakes two parameters\n\nself - the object the method is attached to\n\nHere the Contact being updated\n\nsession_length\n\nThe length of the session to be added\n\n\n\nYou can see the above implementation integrated into our TimeTracker implementation. Aside from defining these new functions we have to update the file scope add_session function (distinct from the class scope add_session method) and the display_contact functions to use the new methods\n\n\n\n\n\nCurrently add_session would allow function calls like,\n\n  rob = Contact(\"Rob\", \"A St\", \"555\")\n  rob.add_session(-10)\n  print(rob.get_hours_worked())\n\n-10\n\n\nLegal call\n\nMakes no logical sense\nCan’t work negative hours\n\nAt the moment the validation is performed in the global add_session function\n\nSuppose this was maintained by another team\nThey could change it, and break your code\n\n\n\n\n\n\n\n\nNote\n\n\n\nThink Carefully about Valid Input\nYou should think carefully about what is valid input for any function, especially when you restrict it. As observed here, a negative number of hours doesn’t make sense on the surface. However, it might make sense in the case of,\n\nCorrecting an overestimated number of hours\nThe Client wants to give a client a discounted number of hours\n\n\n\n\nWe want to move the validation inside the Contact object\n\nWant add_session to reject hours that are less than half-an-hour or greater than three and a half\n\nWe could add these as variables for each instance of a Contact\n\nBut they’re the same for every instance\nWould be nice to have a way to define it once for the class\n\n\n\n\n\nA class variable is data not attached to a specific object instance\nCan define the min and max hours as a class variable\n\nNo longer magic constants\nAccessible by all Contact instances\n\n\n  class Contact:\n      \"\"\"\n      Contact with a name, address and telephone number.\n      Tracks the hours worked with a client\n\n      Attributes\n      ----------\n      name : str\n          Contact Name\n      address : str\n          Contact's postal or street address.\n      telephone : str\n          Contact phone number (stored as a string).\n      hours_worked : int | float\n          Hours worked with a Contact, initialised to 0\n\n      Class Attributes\n      ----------------\n      min_session_length : Final[int | float]\n          minimum length of a billable session\n\n      max_session_length : Final[int | float]\n          maximum length of a billable session\n\n\n      Examples\n      --------\n      &gt;&gt;&gt; Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"+44(1234) 56789\")\n      &lt;Contact ...&gt;\n      \"\"\"\n\n      min_session_length = 0.5\n      max_session_length = 3.5\n\n      def __init__(self, name, address, telephone):\n          \"\"\"\n          Create a new `Contact` instance\n\n          Parameters\n          ----------\n          name : str\n              Contact Name\n          address : str\n              Contact's postal or street address.\n          telephone : str\n              Contact phone number (stored as a string).\n          \"\"\"\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n          self.hours_worked = 0\n\n          def get_hours_worked(self):\n              \"\"\"\n              Gets the hours worked for this contact\n\n              Returns\n              -------\n              int | float\n                  hours worked for this contact\n              \"\"\"\n              return self.hours_worked\n\n          # new method\n          def add_session(self, session_length):\n              \"\"\"\n              Adds a session (in hours) to the Contacts hours\n\n              Parameters\n              ----------\n              session_length : int | float\n                  time spent on session in hours\n\n              Returns\n              -------\n              None\n              \"\"\"\n              if session_length &lt; Contact.min_session_length or session_length &gt; Contact.max_session_length:\n                  return\n              self.hours_worked = self.hours_worked + session_length\n\nadd_session now silently rejects invalid session_length values\nThe idiom of first checking for invalid input and performing a return if encountered is called an early return and is a common technique\n\nReduces the need for indentation on the happy path - the error free path\n\nObserve we have to prefix the class variables with the class name as a namespace\nThe Final label in the docstring indicates that the session length variables are expected to be constant and should not be modified by a consuming program\n\n\n\nBuild your understanding of class variables by answering the following questions about their use-cases\n\nShould I use a class variable to hold the age of a contact?\n\nNo. Each contact will have an age, so the age must be a data attribute unique to each object instance\n\nShould I use a class variable to hold the maximum age of a contact?\n\nYes, we don’t need to store a copy of this value for every Contact instance, so it can be a class variable\n\nShould I use a class variable to hold the price per hour that the lawyer will charge?\n\nIt depends, if the lawyer charges the same for every client then it may be reasonable\nIf the lawyer wishes to charge different contacts different rates, then we would have to store it as a data attribute\n\nIn that case we might store the minimum and maximum hourly rate as class variables\n\n\n\n\n\n\n\n\nCohesion generally means objects shouldn’t expose attributes for external clients\nIdeally clients interact with a Contact via method calls\n\ne.g. get_hours_worked and add_session\nEliminates direct dependency on hours_worked data attribute\n\nIn the same vein, we don’t want users to directly interact with class variables\n\ne.g. max_session_length and min_session_length are used for internal validation\nExternal client should have no reason to directly modify them\n\nCould create a method, validate_session_length\n\nReceive a session_length argument\nReturn True if valid, else False\n\nValidation information (max_session_length and min_session_length) is held at the class level\n\nWould be nice to also have this validation method at the class level too\n\nWe can create class level methods through a Static Method\n\nStatic methods can be considered as methods defined on a class rather than an object instance\n\nWe can define one as below,\n\n  class Contact:\n      \"\"\"\n      Contact with a name, address and telephone number.\n      Tracks the hours worked with a client\n\n      Attributes\n      ----------\n      name : str\n          Contact Name\n      address : str\n          Contact's postal or street address.\n      telephone : str\n          Contact phone number (stored as a string).\n      hours_worked : int | float\n          Hours worked with a Contact, initialised to 0\n\n      Class Attributes\n      ----------------\n      min_session_length : Final[int | float]\n          minimum length of a billable session\n\n      max_session_length : Final[int | float]\n          maximum length of a billable session\n\n      Examples\n      --------\n      &gt;&gt;&gt; Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"+44(1234) 56789\")\n      &lt;Contact ...&gt;\n      \"\"\"\n\n      min_session_length = 0.5\n      max_session_length = 3.5\n\n      @staticmethod\n      def valid_session_length(session_length):\n          \"\"\"\n          Check a session length is valid\n\n          Parameters\n          ----------\n          session_length : int | float\n              length of a consult session in hours\n\n          Returns\n          -------\n          bool\n              `True` if the session length is valid else `False`\n          \"\"\"\n          if (\n              session_length &lt; Contact.min_session_length\n              or session_length &gt; Contact.max_session_length\n          ):\n              return False\n          return True\n\n      def __init__(self, name, address, telephone):\n          \"\"\"\n          Create a new `Contact` instance\n\n          Parameters\n          ----------\n          name : str\n              Contact Name\n          address : str\n              Contact's postal or street address.\n          telephone : str\n              Contact phone number (stored as a string).\n          \"\"\"\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n          self.hours_worked = 0\n\n      def get_hours_worked(self):\n          \"\"\"\n          Gets the hours worked for this contact\n\n          Returns\n          -------\n          int | float\n              hours worked for this contact\n          \"\"\"\n          return self.hours_worked\n\n      # new method\n      def add_session(self, session_length):\n          \"\"\"\n          Adds a session (in hours) to the Contacts hours\n\n          Parameters\n          ----------\n          session_length : int | float\n              time spent on session in hours\n\n          Returns\n          -------\n          None\n\n          See Also\n          --------\n          Contact.valid_session_length : checks a session length is valid\n          \"\"\"\n          if not Contact.valid_session_length(session_length):\n              return\n          self.hours_worked = self.hours_worked + session_length\n\nThe @staticmethod tag above the definition of valid_session_length is called a decorator\nA decorator wraps a function to modify how it works\nDecorators are added by writing @ followed by the decorator name above the function to be wrapped\n\nYou can wrap a function with multiple decorators\n\nThe @staticmethod decorator is a python language built-in\n\nConverts a method into a static method\nStatic methods can exist even without an instance of the given class\n\nStatic methods can be called directly from the class e.g.\n\n  print(Contact.valid_session_length(5))\n\nFalse\n\n\n\n\n\nInput validation is a very common use-case for static methods. Consider the following questions to understand static validation methods\n\nWhy does the valid_session_length method not have a self parameter?\n\nself refers to a particular object instance\nstatic methods are not associated with an instance\n\nAssociated with the class\nThus no self to refer to\n\n\nWhy does the valid_session_length method not print a message to the user communicating that the session length is invalid?\n\nvalid_session_length only has responsibility for checking if a session length is valid\nHow to handle an invalid session length is the responsibility of the caller\n\ne.g. a text-based vs graphical interface may want to handle this differently\n\ne.g. display text vs a window\n\n\nThis concept of making a function responsible for one thing is called either\n\nThe single responsibility principle,\nor more generally separation of concerns\n\nHere a Contact object performs behaviours that modify or capture a the state of a clients interactions with a client\n\nHow the user responds to those states is not its responsibility\n\n\nWhat does a decorator do?\n\nA decorator is a function that wraps another function\nThey can do some work, call a function then do some clean-up\n\nCan I create my own decorators?\n\nYes\nThey are beyond the scope of this book though\n\nHow do I know when to create a static method in a class?\n\nYou want to create behaviour associated with a class, but\n\nIndependent of specific instance of a class\n\n\n\n\n\n\n\n\nadd_session prevents invalid session lengths being added to a Contact\nCurrently user has no way of knowing if a session was added\n\nMistakes might be missed\nRecords then lost\n\nNeed to indicate if add_session succeeded\nCan do so by returning a status flag from add_session rather than None\n\nTrue indicates session added\nFalse indicates session failed\n\n  def add_session(self, session_length):\n  \"\"\"\n  Adds a session (in hours) to the Contacts hours\n\n  Parameters\n  ----------\n  session_length : int | float\n      time spent on session in hours\n\n  Returns\n  -------\n  bool\n      `True` if session successfully added, else `False`\n\n  See Also\n  --------\n  Contact.valid_session_length : checks a session length is valid\n  \"\"\"\n  if not Contact.valid_session_length(session_length):\n      return False\n  self.hours_worked = self.hours_worked + session_length\n  return True\nThe calling program can then check the status\n\nBehave as appropriate on error\n\n  session_length = BTCInput.read_float(prompt=\"Session Length: \")\n  if contact.add_session(session_length):\n      print(\"Updated hours succeeded\", contact.get_hours_worked())\n  else:\n      print(\"Add hours failed\")\nThe above uses the status\n\nOn success the new hours are reported\nOn failure, the user is notified of the error\n\nThe full implementation is given in TimeTrackerWithStatusReporting.py\nThe problem with status messages is that the user can ignore them, e.g. the below variation of the previous example, ignores the return value\n\n   contact.add_session(BTCInput.read_float(prompt=\"Session Length: \"))\n   print(\"Updated hours:\", contact.get_hours_worked())\n\nThus no guarantee that failure will be handled\n\n\n\n\n\nExceptions force the caller to deal with them\n\nUnhandled exceptions crash the program\n\nExceptions are designed for when an error occurs where continuing makes no sense\n\ne.g. converting strings to numbers\nmeaningless to continue with an unconverted number\nUnless the caller specifies what to do in that case\nSo this causes an exception\n\n  x = int(\"Rob\")\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[11], line 1\n----&gt; 1 x = int(\"Rob\")\n\nValueError: invalid literal for int() with base 10: 'Rob'\n\n\n\n\nWe can make our on code throw exceptions\n\nWe use the raise keyword\n\n\n  def add_session(self, session_length):\n      \"\"\"\n      Adds a session (in hours) to the Contacts hours\n\n      Parameters\n      ----------\n      session_length : int | float\n          time spent on session in hours\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      Exception\n          Raised if invalid session length passed\n\n      See Also\n      --------\n      Contact.valid_session_length : checks a session length is valid\n      \"\"\"\n      if not Contact.valid_session_length(session_length):\n          raise Exception(\"Invalid Session Length\")\n      self.hours_worked = self.hours_worked + session_length\n\nContact’s add_session now raises an Exception if the session length is invalid\nException somewhat like a message\n\nTells the program what went wrong\n\nException class provides behaviours for exceptions\n\nTakes a string as an initializer argument\nstring should describe the error\n\nOnce raised, the exception is either,\n\nhandled by an Except handler inside a try block\nStops the program with an error\n\nThe complete integration of the above is given byy TimeTrackerWithException.py\n\n\n\n\nInvestigate how exceptions are raised using the sample program Time Tracker with Exception\nStart a python interpreter and run the example program above, select option \\(1\\) on the menu, and enter the following,\n\n\n\nTime Tracker\n\n\n\n1. New Contact\n\n2. Find Contact\n\n3. Edit Contact\n\n4. Add Session\n\n5. Exit Program\n\n\n\nEnter your command: 1\n\nCreate new contact\n\nEnter the contact name:  Rob Miles\n\nEnter the contact address:  18 Pussycat Mews, London, NE1 410S\n\nEnter the contact phone:  1234 56789 \n\n\n\n\nNow add a session lasting 2 hours to the contact using option 4:\n\n\n\nEnter your command:  4\n\nadd session\n\nEnter the contact name:  Rob Miles\n\nName: Rob Miles\n\nPrevious hours worked: 0\n\nSession Length:  2\n\nUpdated hours worked: 2.0\n\n\n\n\nThis should work because \\(2\\) is a valid session length, now repeat but attempt to add a session length of \\(4\\), which should be invalid,\n\n\n\nEnter your command:  4\n\nadd session\n\nEnter the contact name:  Rob Miles\n\nName: Rob Miles\n\nPrevious hours worked: 2.0\n\nSession Length:  4\n\n\n\n\n\n\n\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\nCell In[16], line 3\n      1 rob = Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"1234 56789\")\n      2 add_session(rob, 2)\n----&gt; 3 add_session(rob, 4)\n\nCell In[12], line 24, in add_session(self, session_length)\n      2 \"\"\"\n      3 Adds a session (in hours) to the Contacts hours\n      4 \n   (...)     21 Contact.valid_session_length : checks a session length is valid\n     22 \"\"\"\n     23 if not Contact.valid_session_length(session_length):\n---&gt; 24     raise Exception(\"Invalid Session Length\")\n     25 self.hours_worked = self.hours_worked + session_length\n\nException: Invalid Session Length\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nOur implementation will look slightly different to the above (which is the book code) because it has additional logic for handling duplicates. But follow the steps and the prompts and you should get roughly the same process\n\n\n\n\n\n\nNow that we can raise exceptions, how do we handle them?\nWe’ve seen that we control jumps to an appropriate except but what if we want to access the message in the exception?\n\nWe can use the as keyword to assign the exception a variable label\nWe modify the user call to the Contact object, add_session as, (see the full implementation as TimeTrackerWithExceptionHandler.py)\n\n  hours_worked = BTCInput.read_float(prompt=\"Enter hours spent: \")\n  try:\n      contact.add_session(hours_worked)\n      print(\"Updated hours succeeded:\", contact.get_hours_worked())\n  except Exception as e:\n      print(\"Add failed:\", e)\nThe main change is rather than just going except Exception: we add a as e\n\nDefines a variable e that stores the exception\ne exists for the scope of the except block\n\nPassing an exception to print prints our the message associated with the exception\nA representative use might look like,\n\n\n\n\nEnter your command:  4\n\nadd session\n\nEnter the contact name:  Rob Miles\n\nName: Rob Miles\n\nPrevious hours worked: 2.0\n\nSession Length:  -1\n\nAdd failed: Invalid Session Length\n\n\n\n\n\n\n\nRepeat the steps in the previous example but this time use the new code in Time Tracker with Exception Handler. You should find the program runs and the errors are captured without causing a crash\n\n\n\nConsider the following questions about dealing with exceptions\n\nWhy does this version of the program not check the result returned by add_session?\n\nThis implementation of add_session returns None\nInstead an exception is raised to indicate a failure state\nThere is therefore nothing to check\n\nIsn’t raising an exception and stopping the program when something goes wrong a bit harsh?\n\nDepends on your philosophy\nGenerally you want to avoid silent errors\ni.e. errors that are undetected by the user\nExceptions force the user to handle the error rather than silently ignore it\nIf the user wants to avoid exception handling, they can explicitly use validate_session_length\n\nCan a method be resumed once it has raised an exception?\n\nNo\nExceptions immediately terminate the normal control flow\nThe user can always call the function again\n\nWhy would you want to create your own types of exceptions?\n\nAllows any errors returned to be descriptive to your specific code\ne.g. if your program relies on a specific file being loaded you might want a more descriptive error message than the standard FileException provides\nError management and reporting should be decided early in a program\n\nShould I always use exceptions to indicate something has gone wrong?\n\nDepends\n\nYou may not care about handling all types of errors\n\nExceptions ensure errors are dealt with\n\nUser can customise the error handling in response to exception\ne.g. for a text-based vs GUI interface\n\n\nWhy have we made add_session work like this? The program worked before we made this change\n\nTechnically correct\n\nOld code used the error status to validate code\n\nArguably cleaner with the new error handling\n\nKnowledge about the Contact class has been centralised in the Contact class itself\nNo need to have external variables storing information about valid session length or doing the validation\n\nTypically a good idea to put all knowledge about a classes behaviour in the class itself\n\n\n\n\n\n\n\nClient no longer needs to directly interact with hours_worked\nHowever, client can still modify hours_worked\n\nProgrammer could accidentally change the value\nCould also intentionally change it to break the code\n\nIdeally we want to prevent it being directly modified\n\n\n\n\n\n\n\nWarning\n\n\n\nPython protects against mistakes, not attacks\nPython provides features to help protect data attributes against accidental modifications. However, they don’t stop a programmer who intentionally (and perhaps maliciously) decides they want to modify the data attributes.\nThere is no mechanism in the python language to prevent another programmer adding code that changes hours_worked in the Contact object\n\n\n\nBy convention, python dictates that an attribute name starting with _ should not be used outside the class\n\nAlso referred to as being internal to the class\ne.g. _hours_worked means that the variable should not be touched\n  def get_hours_worked(self):\n      \"\"\"\n      Gets the hours worked for this contact\n\n      Returns\n      -------\n      int | float\n          hours worked for this contact\n      \"\"\"\n      return self._hours_worked\n\nAbove we provide a get_hours_worked method to get the value of _hours_worked\n\n_ indicates not to modify hours_worked itself\n\nNo actual protection for _hours_worked\n\nCould still be ignored by a programmer\n\nCan get greater security through, name-mangling\n\nstarting a variable name with double underscores __\n\nname-mangling makes it harder to access and modify the variable\n\n\n\nFollow the following steps to examine how to make a python class secure. Open a python interpreter and enter the statements below\n\n    class Secret:\n        def __init__(self):\n            self._secret = 99\n            self.__top_secret = 100\n\nThe above creates a class Secret which has two attributes, _secret and __top_secret\nCreate an instance of the Secret class\n\n    x = Secret()\n\nThe above creates a new instance of a Secret class and stores it with the variable x.\nTry to access the _secret attribute on x\n\n    x._secret\n\n99\n\n\nEven though we said that _ indicates we should not access the data attribute, we can see that nothing stops us from doing so\nNow try to access the __top_secret attribute\n\n    x.__top_secret\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[21], line 1\n----&gt; 1 x.__top_secret\n\nAttributeError: 'Secret' object has no attribute '__top_secret'\n\n\n\nThis time we get an AttributeError which suggests that there is no __top_secret attribute associated with the Secret class\nHowever, Python has performed some “name-mangling” to the name __top_secret. Inside the Secret class we can refer to __top_secret. Outside the class, the variable name is prepended with the class name (and an underscore). So we can still access it, as the below proves\n\n    x._Secret__top_secret\n\n100\n\n\nName-mangling thus secures us against accidental attribute use, however any one who knows the name mangling scheme and our attributes can still modify the data attribute if they want to\nThere are programs that check against this kind of bad code behaviour. One example is pylint\n\n\n\n\n\nOur current methods for the Contact class are all intended to be used by clients\n\nReferred to as public methods\n\nWe might also want to protect methods in a class\nCan use _ prefix to indicate that it should not be used\nOr __ prefix to name mangle\n\n\n\n\n\n\n\nTip\n\n\n\nWriting secure code is all about workflow\nMaking a secure program is all about establishing a workflow to generate quality code. For example, using prototypes to make sure that a customer agrees with the direction of a program early in the development\nThe next step is to sensible design and tools like pylint to make sure we’re writing good quality code.\n\n\n\n\n\n\n\nWe’ve talked about protecting hours_spent for our Contact\nWe should add more business logic to ensure that name, address and telephone items are sensible\n\nAs a purely toy example, lets say they must each be \\(4\\) characters long\n\nRealistically they would be discussed and confirmed with the customer\n\n\nclass Contact:\n\n    __min_text_length = 4\n\n    @staticmethod\n    def valid_text(text):\n        \"\"\"\n        Validates text to be stored in the contact storage\n\n        Parameters\n        ----------\n        text : str\n            text string to store\n\n        Returns\n        -------\n        bool\n            `True` if the text is valid, else `False`\n        \"\"\"\n\n        if len(text) &lt; Contact.__min_text_length:\n            return False\n        else:\n            return True\n\n\nAbove mirrors valid_session_length\nCalled to validate text to be stored in a Contact\nWe could then name mangle name, address, telephone\nSupply methods to get and set these attributes\n\ne.g. set_name and get_name for example\n\nPython has a built-in way for providing read and write access to protected data\nThis is called a Property\n\nProperties preserve simple access, while allowing us to implement validation\n\n\n\n\n\nclass Contact:\n    __min_text_length = 4\n\n    @staticmethod\n    def valid_text(text):\n        \"\"\"\n        Validates text to be stored in the contact storage\n\n        Valid input must be have a length greater than or\n        equal to `Contact.__min_text_length`\n\n        Parameters\n        ----------\n        text : str\n            text string to store\n\n        Returns\n        -------\n        bool\n            `True` if the text is valid, else `False`\n        \"\"\"\n        if len(text) &lt; Contact.__min_text_length:\n            return False\n        else:\n            return True\n\n    @property  # decorator makes name a property\n    def name(self):  # name of property function to get the name\n        \"\"\"\n        name : str\n            Contact Name\n\n        Raises\n        ------\n        Exception\n            raised if new name is invalid\n\n        See Also\n        --------\n        Contact.valid_text : validates text input\n        \"\"\"\n        return self.__name  # return private attribute containing the name\n\n    @name.setter  # decorator to identify the setter for name\n    def name(self, name):\n        if not Contact.validate_text(name):\n            raise Exception(\"Invalid name\")\n        self.__name = name\n\nThe code above shows how to implement a property for name in the Contact class. The property implements validation and rejects invalid names. Work through the following questions to understand properties\n\nHow does the value being set in the property get into the setter?\n\nsetter is called with two parameters\nself refers to the object on which the setter is being called\nThe second is the proposed value to set the property to\n\nHere it is setting the name attribute\n\n\nHow does the program know which setter method to call for a particular property?\n\nThe setter decorator has the format property.setter\n\nAssociates a setter to a property\n\n\nMust the setter method raise an exception if the value is being set is not valid?\n\nNo\nsetter could ignore invalid values, or assign a default\nExceptions allow us to inform the user that the set has failed\n\nAnd also forces the user to deal with the error\n\n\nDo we need to perform the same validation for all properties in a class?\n\nNo\nWe could test that telephone is purely numeric (for example)\n\nThis is not a good idea for real telephone numbers\n\nWe could ensure address matches a certain structure for a valid address\n\nMust a property have a setter?\n\nNo\nProperties without a setter are read-only\nThey cannot be modified\nWe could use this to remove the get_hours_worked method\n\nUse a property instead\n\n\n\n\n\n\nInvestigate how properties work. Open up the python interpreter and enter the statements below\n\nclass Prop:\n    @property\n    def x(self):\n        print(\"got property x\")\n        return self.__x\n    @x.setter\n    def x(self, x):\n        print(\"set property x:\", x)\n        self.__x = x\n\nThis creates a new class Prop with a property x that has a setter\nNow create an instance of this class as below\n\n    test = Prop()\n\nPut a value for x into the test instance\n\n    test.x = 99\n\nset property x: 99\n\n\nWhen python executes the above, it runs the setter method for the property. As we can see from the output above.\nNow try to read the property\n\n    print(test.x)\n\ngot property x\n99\n\n\nWhen reading the property, python runs the property method, as indicated above\nWe can combine getting and setting in complex expressions, execute the following\n\n    test.x = test.x + 1\n\ngot property x\nset property x: 100\n\n\nWe can see that first the getter is called to get the current value of x, then the setter is called to update it to the expression on the right\nTo convert the Contact class to use properties for name, telephone and address we have to add properties and then setters\n\nThe relevant changes to the Contact class are then,\n\n\nclass Contact:\n    \"\"\"\n    Contact with a name, address and telephone number.\n    Tracks the hours worked with a client\n\n    Attributes\n    ----------\n    name : str\n        Contact Name\n    address : str\n        Contact's postal or street address.\n    telephone : str\n        Contact phone number (stored as a string).\n\n\n    Examples\n    --------\n    &gt;&gt;&gt; Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"+44(1234) 56789\")\n    &lt;Contact ...&gt;\n    \"\"\"\n\n    __min_session_length = 0.5\n    __max_session_length = 3.5\n\n    @staticmethod\n    def valid_session_length(session_length):\n        \"\"\"\n        Check a session length is valid\n\n        Parameters\n        ----------\n        session_length : int | float\n            length of a consult session in hours\n\n        Returns\n        -------\n        bool\n            `True` if the session length is valid else `False`\n        \"\"\"\n        if (\n            session_length &lt; Contact.__min_session_length\n            or session_length &gt; Contact.__max_session_length\n        ):\n            return False\n        return True\n\n    __min_text_length = 4\n\n    @staticmethod\n    def valid_text(text):\n        \"\"\"\n        Validates text to be stored in the contact storage\n\n        Valid input must be have a length greater than or\n        equal to `Contact.__min_text_length`\n\n        Parameters\n        ----------\n        text : str\n            text string to store\n\n        Returns\n        -------\n        bool\n            `True` if the text is valid, else `False`\n        \"\"\"\n        if len(text) &lt; Contact.__min_text_length:\n            return False\n        else:\n            return True\n\n    @property\n    def name(self):\n        \"\"\"\n        name : str\n            Contact Name\n\n        Raises\n        ------\n        Exception\n            raised if new name is invalid\n\n        See Also\n        --------\n        Contact.valid_text : validates text input\n        \"\"\"\n        return self.__name\n\n    @name.setter\n    def name(self, name):\n        if not Contact.valid_text(name):\n            raise Exception(\"Invalid name\")\n        self.__name = name\n\n    @property\n    def address(self):\n        \"\"\"\n        address : str\n            Contact Address\n\n        Raises\n        ------\n        Exception\n            raised if new address is invalid\n\n        See Also\n        --------\n        Contact.valid_text : validates text input\n        \"\"\"\n        return self.__address\n\n    @address.setter\n    def address(self, address):\n        if not Contact.valid_text(address):\n            raise Exception(\"Invalid address\")\n        self.__address = address\n\n    @property\n    def telephone(self):\n        \"\"\"\n        telephone : str\n            Contact Telephone\n\n        Raises\n        ------\n        Exception\n            raised if new telephone is invalid\n\n        See Also\n        --------\n        Contact.valid_text : validates text input\n        \"\"\"\n        return self.__telephone\n\n    @telephone.setter\n    def telephone(self, telephone):\n        if not Contact.valid_text(telephone):\n            raise Exception(\"Invalid telephone\")\n        self.__telephone = telephone\n\n    def __init__(self, name, address, telephone):\n        \"\"\"\n        Create a new Contact instance\n\n        Parameters\n        ----------\n        name : str\n            Contact Name\n        address : str\n            Contact's postal or street address.\n        telephone : str\n            Contact phone number (stored as a string).\n        \"\"\"\n        self.name = name\n        self.address = address\n        self.telephone = telephone\n        self.__hours_worked = 0\n\n\nThe great thing about properties is they can be effectively drop in for traditional attributes\n\nWe make the attributes themselves name mangled\nDefine properties to mask the original names\n\nNo need to update the downstream calling code\n\nproperty syntax matches the traditional access pattern\n\nThe complete integration is seen in TimeTrackerWithProperties.py\n\n\n\n\n\n\n\nCaution\n\n\n\nFailures in property code can be confusing\nThe example program implements the name, address and telephone number elements of a contact as properties. Setting a property to an invalid value will cause an exception. The initializer looks like,\n    def __init__(self, name, address, telephone):\n        self.name = name\n        self.address = address\n        self.telephone = telephone\n        self.__hours_worked = 0\nThese statements look like normal variable assignments, nothing here indicates that these steps can fail. However, the following statement fails,\n\n    rob = Contact(name=\"Rob\", address=\"18 Pussycat Mews, London NE1 410S\", telephone=\"1234 56789\")\n\n\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\nCell In[31], line 1\n----&gt; 1 rob = Contact(name=\"Rob\", address=\"18 Pussycat Mews, London NE1 410S\", telephone=\"1234 56789\")\n\nCell In[30], line 154, in Contact.__init__(self, name, address, telephone)\n    141 def __init__(self, name, address, telephone):\n    142     \"\"\"\n    143     Create a new Contact instance\n    144 \n   (...)    152         Contact phone number (stored as a string).\n    153     \"\"\"\n--&gt; 154     self.name = name\n    155     self.address = address\n    156     self.telephone = telephone\n\nCell In[30], line 92, in Contact.name(self, name)\n     89 @name.setter\n     90 def name(self, name):\n     91     if not Contact.valid_text(name):\n---&gt; 92         raise Exception(\"Invalid name\")\n     93     self.__name = name\n\nException: Invalid name\n\n\n\nThe above raises an exception because the value Rob passed for the name property is too short. __init__ attempts to set name which calls the setter, and the property code raises an exception.\nProgrammers may expect methods or functions to cause exceptions but they typically do not expect statements that look like variable assignments. When implementing properties you need to be clear about how they work and how to handle failure.\nWe could extend our previous error handling code to add additional exception handlers to handle invalid assignments\n\n\n\n\n\n\n\nScenario\nThe lawyer likes your program but would now like to use it for billing. The program should track both the hours worked for a client and the the billing amount owed by each contact\nPrices are calculated as follows, for every session worked there is - A $30 flat case fee - A $50 hourly fee\nFor example a one hour session would cost $80\nThe client wants the billing amount to be automatically updated each time they add a session. Displaying a contact should then also display the billing amount\nName: Rob Miles\nAddress: 18 Pussycat Mews, London, NE1 410S\nTelephone: 1234 56789\nHours on the case: 2.0\nBilling amount: 130.0\n\n\n\nWork through the following questions to understand how we design managing the billing amount\n\nHow would we store the billing amount for a contact?\n\nStore as a data attribute on a Contact object\nManage like __hours_worked with validators\nLet’s call it __billing_amount\n\nWhy does __billing_amount have two leading underscores in the name?\n\nIndicates the variable is private to the class\nProvides name-mangling to reduce chance for accidental use\nProvide access via a read-only property\n  @property\n  def billing_amount(self):\n      return self.__billing_amount\nWe omit a setter, the property cannot be directly modified\nCan then access the property as we would expect\n  print(\"Rob owes:\", rob.billing_amount)\nSame output might look like,\n  #| echo: false\n  print(\"Rob owes:\", 130.0)\n\nWhat would the statement calculating the billable amount for a session look like?\n\nAt it’s most basic the statement might look like,\n  amount_to_bill = 30 + (50 * session_length)\nsession_length value is multiplied by the hourly rate (\\(50\\))\nflat fee \\(30\\) is added to the total\nCan then add this to the billing amount\n  self.__billing_amount = self.billing_amount + amount_to_bill\nObserve that this approach means that each session incurs the same \\(30\\) case opening fee\nIt’s possible multiple sessions might be spent on the same case\n\nMight not incur the \\(30\\) fee each time\nThis would be something to confirm with the client\n\n\nIs it sensible to just use the values \\(30\\) and \\(50\\) in this code?\n\nNo\nThey are magic constants\nBetter to make them internal class variables of the Contact class\n  class Contact\n      __open_fee = 30\n      __hourly_fee = 50\nObserve that we flag them as private, they are internals for the class\nThe new amount to bill statement is then,\n  amount_to_bill = Contact.__open_fee + (Contact.__hourly_fee * session_length)\n\nWhere should the above statement go?\n\nAdjusting the billing is something that occurs when we add a session\nMakes sense to go in the add_session code of the Contact class\n  def add_session(self, session_length):\n      \"\"\"\n      Adds a session (in hours) to the Contacts hours\n\n      Updates the Contact's session hours and calculates\n      the billable amount owed\n\n      Parameters\n      ----------\n      session_length : int | float\n          time spent on session in hours\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      Exception\n          Raised if invalid session length passed\n\n      See Also\n      --------\n      Contact.valid_session_length : checks a session length is valid\n      \"\"\"\n      if not Contact.validate_session_length(session_length):\n          raise Exception(\"Invalid session length\")\n      self.__hours_worked = self.__hours_worked + session_length\n      amount_to_bill = Contact.__open_fee + (Contact.__hourly_fee * session_length)\n      self.__billing_amount = self.__billing_amount + amount_to_bill\n      return\nBilling amount is updated after we have validated and updated the hours worked\n\n\n\nWe change the display_contact method to add the billing amount\n\ndef display_contact(contact):\n    \"\"\"\n    Displays the Contact details for the supplied contact\n\n    Parameters\n    ----------\n    contact : Contact\n        contact to display\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_contacts : Displays all contacts matching a search name\n    \"\"\"\n    print(\"Name:\", contact.name)\n    print(\"Address:\", contact.address)\n    print(\"Telephone:\", contact.telephone)\n    print(\"Hours worked for this Contact:\", contact.get_hours_worked(), \"\\n\")\n    print(\"Amount to bill:\", contact.billing_amount)\n\nThe complete program can be found in Time Tracker with Billing Amount\n\n\n\n\n\nThe new program works, but it has a problem\nContacts saved under the old system, won’t work\n\nThey will load\nBut whe we try to display or add a session we’ll get an error, like\n\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[32], line 1\n----&gt; 1 raise AttributeError(\"'Contact' object has no attribute '_Contact__billing_amount'\")\n\nAttributeError: 'Contact' object has no attribute '_Contact__billing_amount'\n\n\n\n\nThis occurs because the program attempts to access the __billing_access attribute\nOld versions of the Contact class didn’t have this\n\nSo error occurs\n\nSame might occur if we make more modifications in the future\n\n\n\n\nWe can solve this by versioning a class\nAdd a version attribute to each class\n\nSimply a numeric attribute\n\n  def __init__(self, name, address, telephone):\n      \"\"\"\n      Create a new `Contact` instance\n\n      Parameters\n      ----------\n      name : str\n          Contact Name\n      address : str\n          Contact's postal or street address.\n      telephone : str\n          Contact phone number (stored as a string).\n      \"\"\"\n      self.name = name\n      self.address = address\n      self.telephone = telephone\n      self.__hours_worked = 0\n      self.__billing_amount = 0\n      self.__version = 1\nversion is set as a private variable\n\n\n\n\n\nThen create a method to check the version of a Contact\n\nLet’s us check that a Contact object matches the current version\n\n  def check_version(self):\n      \"\"\"\n      Check the version of a `Contact` instance\n\n      Upgrades the instance to the most recent version\n      if required\n\n      Returns\n      -------\n      None\n      \"\"\"\n      pass\nLeave it as a stub for now\nWe want to use it when we load contacts to check versions\nUpdated load_contacts is below\n  def load_contacts(file_name):\n  \"\"\"\n  Loads the contacts from the given file\n\n  Contacts are stored in binary as a pickled file\n\n  Parameters\n  ----------\n  file_name : str\n      string giving the path to the file where the contacts data is stored\n\n  Returns\n  -------\n  None\n      Contact detail is loaded into the global `contacts` value\n\n  Raises\n  ------\n      Exceptions if contacts failed to load\n\n  See Also\n  --------\n  save_contacts : saves contacts to a pickled file\n  \"\"\"\n  global contacts\n  print(\"Load contacts\")\n  with open(file_name, \"rb\") as input_file:\n      contacts = pickle.load(input_file)\n  # Update version of loaded contacts if required\n  for contact in contacts:\n      contact.check_version()\n\n\n\n\n\nNow we want to write code to upgrade a Contact\nFor our version \\(1\\), we want to upgrade any class that does not have a __billing_amount attribute\nIn future we might define a version \\(2\\), then we would redefine the check_version method to upgrade any class that isn’t version \\(2\\)\n  def check_version(self):\n  \"\"\"\n  Check the version of a `Contact` instance\n\n  Upgrades the instance to the most recent version\n  if required\n\n  Returns\n  -------\n  None\n  \"\"\"\n  try:\n      if not self.__version == 1:\n          self.__billing_amount = 0\n          self.__version = 1\n  except AttributeError:\n      self.__billing_amount = 0\n      self.__version = 1\nWe first attempt to check the version number\nIf it’s not the current version (\\(1\\)) we upgrade the class\n\nAdd a .__billing_amount attribute defaulted to zero\nUpgrade the version number\n\nUse a try...except block to catch the AttributeError if the version doesn’t exist (i.e. for old instances pre-versioning)\n\nPerform the upgrade\n\n\n\n\n\nTo get a better understanding of versioning, work through the following steps\nStart by running the program TimeTrackerWithPropertiesAndExceptionHandling.py. Create a new contact as below\n\n\n\nEnter your command: 1\n\nCreate new contact\n\nEnter the contact name: Rob Miles\n\nEnter the contact address: 18 Pussycat Mews, London, NE1 410S\n\nEnter the contact phone: 1234 56789\n\n\n\n\nThis creates a new contact, which looks like, (use Find Contact)\n\n\nName: Rob Miles\nAddress: 18 Pussycat Mews, London, NE1 410S\nTelephone: 1234 56789\nHours on the case: 0\n\n\nAs we can see this version is missing the billable hours information\nExit the program so the contact is saved. Now load this pickle file with TimeTrackerWithVersion.py\nThis should load the contact (which is unversioned), and upgrade it to the versioned variant with a billing amount\nAttempt to display this contact, you should see something like\n\n\nName: Rob Miles\nAddress: 18 Pussycat Mews, London, NE1 410S\nTelephone: 1234 56789\nHours on the case: 0\nAmount to bill: 0\n\n\nAs we can see, the amount to bill is now correctly displayed\n\n\n\n\n\n\nImportant\n\n\n\nAdd version management when you design data storage\nWhen starting a project you should consider which items are being stored and if they need version management. For example in the Time Tracker program we expect that the client will request changes to the features, so we should consider versioning it from the start\nEvery time a new version of a program is installed, we then have to go through the process of updating the underlying data to the new version\nWhen writing a program for a customer, you should consider how long it will take to write code that deal with data updates (or migrations). This can make trivial programs significantly more complex\n\n\n\n\n\n\n\nEach time we add a new attribute to the Contact class we have to modify display_contact\nWould be nice just to be able to print a Contact directly\nHowever, doing so, we find the output is pretty useless (using the mock below)\n\n  class Contact:\n      def __init__(self, name, address, telephone):\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n\n  contact = Contact(\"Rob Miles\", \"Pussycat Mews\", \"1234\")\n\n  def display_contact(contact):\n      print(contact)\n\n  display_contact(contact)\n\n&lt;__main__.Contact object at 0x7f479c69f650&gt;\n\n\ndefault for objects is the class name following by the memory address of the object\npython objects have a __str__ method\n\nUsed whenever the an object needs to be converted to a string\n\nTo change the default behaviour for our objects we need to redefine __str__\n  class Contact:\n      ...\n      def __str__(self):\n          return \"Name: \" + self.name + \"\\n\" + \\\n          \"Address: \" + self.address + \"\\n\" + \\\n          \"Telephone: \" + self.telephone + \"\\n\" + \\\n          \"Hours on the case: \" + str(self.hours_worked) + \"\\n\" + \\\n          \"Amount to bill: \" + str(self.billing_amount)\nThe \\ character above is used to continue the string onto a new line\nprinting now, we get what we expect\n\n  display_contact(contact)\n\nName: Rob Miles\nAddress: Pussycat Mews\nTelephone: 1234\nHours on the case: 0\nAmount to bill: 0\n\n\n\n\n\n\nWriting the string as a series of concatenations isn’t the cleanest\nDifficult to maintain and ensure correctness as we modify the class\nWe can use format to create a formatted string\n\nLets us write a shorter string\nformat is a string method\nformat takes in values as arguments and injects them into the string\n\n  class Contact:\n      ...\n      def __str__(self):\n          template = \"\"\"Name: {0}\nAddress: {1}\nTelephone: {2}\nHours on the case: {3}\nAmount to bill: {4}\"\"\"\n          return template.format(self.name, self.address, self.telephone, self.hours_worked, self.billing_amount)\nValues in format are inserted at marked points in the string\nMarked points are {n} where \\(n\\) is the index of the argument to substitute\n\nStarting from \\(0\\)\n\n\n\n\n\nOpen the python interpreter and work through the following steps to understand how string formatting works\nEnter the statements below\n\nname = \"Rob Miles\"\nage = 21\n\nThe above creates two variables name and age\nNow create the following template string\n\ntemplate = \"My name is {0} and my age is {1}\"\n\nThe just creates a string called template, {0} and {1} are two placeholder indicators for the format function\nNow call the format method on template\n\ntemplate.format(name, age)\n\n'My name is Rob Miles and my age is 21'\n\n\nAs we can see the placeholder values have been substituted with the values of the name and age value\nWe can add additional formatting information. Redefine and format the template as follows\n\ntemplate = \"My name is {0:20} and my age is {1:10}\"\ntemplate.format(name, age)\n\n'My name is Rob Miles            and my age is         21'\n\n\nWe write the placeholder as {n:w} where \\(n\\) is the index of the placeholder. \\(w\\) is the width value, as you can see from above, the value is still substituted but then spaces are added to pad out to the width. This is useful for defining columns. We use a : to separate the format specifiers from the placeholder index\nFor floating point values you can also specify the number of decimal places to be printed\n\ntemplate = \"My name is {0:20} and my age is {1:10.2f}\"\ntemplate.format(name, age)\n\n'My name is Rob Miles            and my age is      21.00'\n\n\nThe above now prints the age with two decimal places. The full details of the string formatting mini language can be found at the python docs\nYou can find the full version of Time Tracker using the string method in\n\n\n\n\n\n\nOur client now gives us a new scenario\n\n\nThe client would like to record when each specific session for a contact took place. You and the client specify the following design,\n\nTime Tracker\n1. New Contact\n2. Find Contact\n3. Edit Contact\n4. Add Session\n5. Exit Program\n\nEnter you command: 2\nEnter  the contact name: Rob\nName: Rob Miles\nAddress: 18 Pussycat Mews, London, NE1 410S\nTelephone: 1234 56789\nHours on the case: 10.0\nAmount to bill: 470.0\nSessions\nDate: Mon Jul 10 11:30:00 2017 Length: 1.0\nDate: Tue Jul 12 11:30:00 2017 Length: 2.0\nDate: Wed Jul 19 11:30:00 2017 Length: 2.5\nDate: Wed Jul 26 10:30:00 2017 Length: 2.5\nDate: Mon Jul 31 16:51:45 2017 Length: 1.0\nDate: Mon Aug 14 16:51:45 2017 Length: 1.0\n\n\nFinding a contact now displays the sessions as a list\nNot immediately clear how we would add this to our class\n\n\n\nLet’s do some design work, for handling a session. Work through the following questions\n\nHow will we store information about a session?\n\nWe need to store a bunch of heterogeneous related data\nGood idea to consider a class, say Session\nNeed to consider data to store\n\nlength of a session\ndate and time of the session\n\nWe should also move the Contact class attributes validating a session length to the Session class\n\n\n import time\n class Session:\n     \"\"\"\n     Session with a length and a date time it was conducted\n     \"\"\"\n\n     __min_session_length = 0.5\n     __max_session_length = 3.5\n\n     @staticmethod\n     def valid_session_length(session_length):\n         \"\"\"\n         Check a session length is valid\n\n         Parameters\n         ----------\n         session_length : int | float\n             length of a consult session in hours\n\n         Returns\n         -------\n         bool\n             `True` if the session length is valid else `False`\n         \"\"\"\n         if (\n             session_length &lt; Session.__min_session_length\n             or session_length &gt; Session.__max_session_length\n         ):\n             return False\n         return True\n\n     def __init__(self, session_length):\n         \"\"\"\n         Create a new `Session` instance\n\n         Parameters\n         ----------\n         session_length : int | float\n             length of a session\n\n         Raises\n         ------\n         Exception\n             Raised if `session_length` is invalid\n\n         See Also\n         --------\n         Session.valid_session_length : validates session lengths\n         \"\"\"\n         if not Session.valid_session_length(session_length):\n             raise Exception(\"Invalid session length\")\n         self.__session_length = session_length\n         self.__session_end_time = time.localtime()\n         self.__version = 1\n\n\nWe can now create Session objects\n\n  session_length = 2\n  session_record = Session(session_length)\n  print(session_record)\n\n&lt;__main__.Session object at 0x7f479c6b8410&gt;\n\n\ncreates a Session with the passed session_length parameter\nvalidate_session_length moved to Session\n\nvalidates session lengths at object creation\nException raised if invalid session length is passed\n\n__init__ uses time library to get the local time\n\nStored in __session_end_time attribute\n\n\nAre we using version control for the Session class?\n\nYes\nHighly likely the Session object might change\nEspecially if we change our mind on what responsibility is in the Contact class vs the Session class\nThus also want to implement a check_version method\n  def check_version(self):\n      \"\"\"\n      Check the version of a `Contact` instance\n\n      Upgrades the instance to the most recent version\n      if required\n\n      Returns\n      -------\n      None\n      \"\"\"\n      pass\nCurrently does nothing\n\nAll Session instances will be versioned\nOnly one version, so no need to edit\n\n\nHow will we allow users of the Session class to get the session length and session end time items from a Session object?\n\nWe add these as properties\nWant these to be read-only so no setter is provided\n\n @property\n def session_length(self):\n     \"\"\"\n     session_length : int | float\n         length (in hours) of this session\n     \"\"\"\n     return self.__session_length\n\n @property\n def session_end_time(self):\n     \"\"\"\n     session_end_time : time.struct_time\n         date and time of the session\n     \"\"\"\n     return self.__session_end_time\nWill the Session class have a __str__ method?\n\nYes\nReturn a string describing a Session instance\n\n def __str__(self):\n     template = \"Date: {0} Length: {1}\"\n     #convert time object string\n     date_string = time.asctime(self.__session_end_time)\n     return template.format(date_string, self.__session_length)\n\ntime library contains asctime\n\nTakes a localtime value and returns a string representation\n\nThen format the string\n\n\n\nGiven the Session object, we now need to incorporate this into the Contact object\nContact objects contain a list of sessions\n\nInitialised empty\n\nWe also need to bump the version number\n\nWhich means we also need to update the check_version method\nNow need to handle the conversion from no version to version 2 and version 1 to version 2\n\n  def check_version(self):\n      \"\"\"\n      Check the version of a `Contact` instance\n\n      Upgrades the instance to the most recent version\n      if required. This includes upgrading any Session\n      instances associated with this Contact instance\n\n      See Also\n      --------\n      Session.check_version : Checks and upgrades `Session` instances\n      \"\"\"\n      try:\n          if self.__version == 1:\n              # does not have session list\n              self.__sessions = []\n              self.__version = 2\n      except AttributeError:\n          self.__billing_amount = 0\n          self.__sessions = []\n          self.__version = 2\n\n      # now upgrade all sessions in a contact\n      for session in self.__sessions:\n          session.check_version()\nAny version \\(1\\) instance will be upgraded to version \\(2\\)\nFor old, unversioned instances, we still use the try...except to force an upgrade to the most recent\nWe also want to check that the sessions stored with a Contact are up to date\n\nSo after upgrading a Contact we check that the Session instances are up to date\n\nWe’ve written the code so that if the Session is upgraded, instances will still be upgraded even if the Contact object is the most recent version\nWe now need to modify adding a session to add a new Session instance, rather than just update the hours\n  def add_session(self, session_length):\n      \"\"\"\n      Adds a session (in hours) to the Contacts sessions\n\n      Parameters\n      ----------\n      session_length : int | float\n          time spent on session in hours\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      Exception\n          Raised if invalid session length passed\n\n      See Also\n      --------\n      Contact.valid_session_length : checks a session length is valid\n      \"\"\"\n      try:\n          self.__sessions.append(Session(session_length))\n          self.__hours_worked = self.__hours_worked + session_length\n          amount_to_bill = Contact.__open_fee + (\n              Contact.__hourly_fee * session_length\n          )\n          self.__billing_amount = self.__billing_amount + amount_to_bill\n      except Exception as e:\n          print(e)\nWe could validate the session length in add_session explicitly\n\nHowever, the Session constructor does this, via exceptions\n\nWe first try to create the Session\n\nIf it’s invalid we get an exception which we catch and handle\n\nIf created successfully we then update the hours worked and amount to bill\nLast step is to now work out how we want to display our Session instances when we report on a client\n\nOur client wants a line for each individual session\nWe need to convert the list of sessions to a string in this format\n\n  @property\n  def session_report(self):\n      \"\"\"\n      session_report : str\n          provides a string representation of a Contact's sessions\n      \"\"\"\n\n      # map converts each session to a string\n      report_strings = map(str, self.__sessions)\n      result = \"\\n\".join(report_strings)\n      return result\nUses map to convert a list of session objects to a list of their string representations\nUses join to then convert the list of strings to a single string with each element separated by a newline\n\n\n\n\n\nOur aim is to convert a list of Session objects into a list of strings\nCould do this with a loop\nAlternative is to use map\nmap takes two arguments\n\nA function name\n\nThe function must accept a single argument and return a result\n\nList of items to apply the function to\n\nfunctions can be stored in variables and passed as arguments\nmap applies the function provided (first argument) to the list (second argument) and returns the result\n\n\n\nThese next few steps go on for a quite a while. So work through it at your own pace. However, this will give you a good understanding of not just map but also some fundamentals for python\nOpen up a python interpreter and work through the following steps. We’ll use map to indent a list of strings. Run the following steps\n\ncode = ['line1', 'line2', 'line3']\n\nThis creates a list containing three strings, we can easily view the contents\n\ncode\n\n['line1', 'line2', 'line3']\n\n\nNow we need to create our indentation function. We can do this by adding four spaces (or a tab etc.) at the beginning of a string. Define the following python function\n\ndef indent(x):\n    return \"    \" + x\n\nWe can test this function, on a sample string,\n\nprint(\"Rob\")\nindent(\"Rob\")\n\nRob\n\n\n'    Rob'\n\n\nWe would like to apply the indent function to every string in the code list. We could do this using a for loop, instead we use a map function\nNow run the following statements\n\nindented_code = map(indent, code)\nindented_code\n\n&lt;map at 0x7f479c6bab30&gt;\n\n\nNaively we expected a list of indented strings. Instead we have something called a map object. map returns something called an iterator. Iterators return items from a collection or sequence one at a time. We can work through iterators using a for loop. This is how we can work through lists. range also returns an iterator\nNow run the following for loop to get the indented_code values\n\nfor s in indented_code:\n    print(s)\n\n    line1\n    line2\n    line3\n\n\nNow we have the list of strings as we were expecting. Each time around the loop the next s value is retrieved from the iterator\nIterators allow us to save memory, rather than having to store the entire result in memory we can simply generate each one as needed. Each time we ask for a new result from the map object, map gets the next value from the original collection (code) and applies the function indent to it. Once the map iterator runs out of values to return, it raises StopIteration as an exception. This stops the loop.\nLets explore this in more detail\nRecreate the statement creating the map\n\nindented_code = map(indent, code)\n\nWe can then ask for the next item from an iterator using the __next__ method.\nCall this method on indented_code\n\nindented_code.__next__()\n\n'    line1'\n\n\nWe can see this produces the next value, though in this case, it’s the first item. We can keep repeating this\nRun the following\n\nprint(indented_code.__next__())\nprint(indented_code.__next__())\nprint(indented_code.__next__())\n\n    line2\n    line3\n\n\n\n---------------------------------------------------------------------------\nStopIteration                             Traceback (most recent call last)\nCell In[54], line 3\n      1 print(indented_code.__next__())\n      2 print(indented_code.__next__())\n----&gt; 3 print(indented_code.__next__())\n\nStopIteration: \n\n\n\nWe can see that we get the next two items from the iterator, and then finally after trying to get an non-existent value we see a StopIteration exception is raised\nYou can’t reuse a iterator once it has run out of items. You have to recreate it\n\nindent_iterator = map(indent, code)\n\nIf we want to convert this to normal collection, we can do something like call list to convert to a list\nCheck this out by running the following statements\n\nindented_code = list(indent_iterator)\nindented_code\n\n['    line1', '    line2', '    line3']\n\n\nWhat happens if we make the input of a map function an iterator\nEnter the following statements to explore\n\ni1 = map(indent, code)\ni2 = map(indent, i1)\n\nWe first create the iterator i1 to apply the indent function to the list code. We then create a second iterator i2 to apply the indent function to the items of the i1 iterator\nUse list to convert i2 to a list\n\nlist(i2)\n\n['        line1', '        line2', '        line3']\n\n\nWe can see that each item is indented twice. Once by i1 and again by i2. Observe that the nested iterator i1 was also applied as part of the conversion process. Python makes it very easy to chain iterators together\nLet us return to our original use of map\nreport_strings = map(str, self.__sessions)\nHere self.__sessions is a list of Session objects. map creates an iterator that applies str to each element of self.__sessions. str itself converts each Session to a string by calling the __str__ method. We then use the join method to work through this iterator to build the final output string\n\n\n\n\n\nWe can call string methods on string literals, e.g.\n\n  \"FRED\".lower()\n\n'fred'\n\n\nAnother string method is join\nTakes an iterator as an argument\njoin merges all strings in an iterator\n\nthe string on which join is called is inserted between each item\n\n\n  report_strings = [\"1\", \"2\", \"3\"]\n  report_results = \"\\n\".join(report_strings)\n\n\n\n\nWork through the following steps with the python interpreter to understand join\nEnter the statement below\n\nreport_strings = [\"report1\", \"report2\", \"report3\", \"report4\"]\n\nThe above creates a list of four strings, report_strings. Lists are iterators so we can pass this to join\nCall the join function as below\n\n\"**\".join(report_strings)\n\n'report1**report2**report3**report4'\n\n\nAs observed we iterate over the strings, merging them with ** inserted in between. Observe that ** is not placed at the start or end of the resulting string\nRerun the statement with the newline character below\n\nprint(\"\\n\".join(report_strings))\n\nreport1\nreport2\nreport3\nreport4\n\n\nThis does the same but instead each string is printed on its own line\nWe can use join to concatenate strings by using the empty string\nRun the following statement\n\n\"\".join(report_strings)\n\n'report1report2report3report4'\n\n\n\nAfter this discussion, we have completed this version of the Time Tracker\nAside from one final thing, updating the __str__ method in Contact to use the session_report property\n  def __str__(self):\n      template = \"\"\"Name: {0}\n  Address: {1}\n  Telephone: {2}\n  Hours on the case: {3}\n  Amount to bill: {4}\n  Sessions: \\n{5}\"\"\"\n      return template.format(\n          self.name,\n          self.address,\n          self.telephone,\n          self.hours_worked,\n          self.billing_amount,\n          self.session_report,\n      )\nYou can find the final implementation in Time Tracker with Session History\n\n\n\n\n\nThe time tracker application is a very good starting point for any program that you might like to write that stores and manages information. You could replace the sessions with albums and music tracks, salesman and sales artists and pictures - or anything else you want to track\nIn the previous chapter we created a Music Storage app that stored songs and could be used to manage a single playlist. Using the framework provided by Time Tracker extend the Music Storage app to be able to manage and store multiple playlists at a time\nThankfully this isn’t as in depth as building the application the first time around. We start by defining our Playlist class\nLet us first focus on the data attributes, we want a name and a list of songs. We also want the total runtime. Now for simplicity we’ll leave the name and tracks as public attributes, but we’ll define the runtime as a property, interfacing with a protected variable __runtime. We do this because the runtime is calculated from tracks so we don’t want the caller to modify it themselves.\nInspired by Time Tracker’s session_report we’ll also define a track_report property using that interfaces with map to provide a string representation of the tracks in a playlist where each track is on its own line\nclass Playlist:\n    \"\"\"\n    A class representing a music playlist with a name and list of tracks\n\n    Tracks and records the length of the playlist\n    \"\"\"\n\n    def __init__(self, name, tracks=[]):\n        \"\"\"\n        Create a new `Playlist` instance\n\n        Parameters\n        ----------\n        name : str\n            name to associate with the playlist\n        tracks : list, optional\n            list of songs in the playlist, by default []\n        \"\"\"\n        self.name = name\n        self.tracks = tracks\n        self.__runtime = 0\n        for song in self.tracks:\n            self.__runtime += song.length_in_seconds\n\n    def __str__(self):\n        template = \"\"\"Playlist: {0}\nTotal Length: {1} s\nSongs:\n{2}\"\"\"\n        return template.format(self.name, self.runtime, self.track_report)\n\n    @property\n    def runtime(self):\n        \"\"\"\n        runtime : int\n            total run time of the playlist in seconds\n        \"\"\"\n        return self.__runtime\n\n    @property\n    def track_report(self):\n        \"\"\"\n        track_report : str\n            string representation of tracks in the playlist, giving each track\n            on its own line\n        \"\"\"\n        song_strings = map(str, self.tracks)\n        return \"\\n\".join(song_strings)\nObserve that the constructor takes an optional list of tracks (by default its empty). This means that a user can create a Playlist by name only and then add songs to it (as used in create_playlist below) or we can create a playlist with a list of songs already (as used by suggest_playlist_of_given_length)\nNow we want to keep the internal track list and the runtime synchronised, so we add methods on the Playlist class to handle adding, removing and clearing tracks from the playlist\ndef add_track(self, track):\n    \"\"\"\n    Add a new track to the playlist\n\n    Updates the playlist length\n\n    Parameters\n    ----------\n    track : MusicTrack\n        track to add to the playlist\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    Playlist.remove_track : removes a track from a playlist\n    \"\"\"\n    # first update runtime so a non-track objects causes an error\n    self.__runtime += track.length_in_seconds\n    self.tracks.append(track)\n\ndef remove_track(self, track):\n    \"\"\"\n    Remove a track from the playlist\n\n    Parameters\n    ----------\n    track : MusicTrack\n        track to remove from the playlist\n\n    See Also\n    --------\n    Playlist.add_track : add a track to a playlist\n    Playlist.clear_tracks : remove all tracks from a playlist\n    \"\"\"\n    try:\n        self.tracks.remove(track)\n        self.__runtime -= track.length_in_seconds\n    except ValueError:\n        print(\"Could not find track:\", track.name, \"in the playlist\")\n\ndef clear_tracks(self):\n    \"\"\"\n    Remove all tracks from a playlist\n\n    Runtime is set to 0\n\n    See Also\n    --------\n    Playlist.remove_track : remove a single track from a playlist\n    \"\"\"\n    self.tracks.clear()\n    self.__runtime = 0\nThese are all relatively simple, the takeaway is that as we update the track list, we also ensure the runtime is kept synchronised\n\n\n\n\n\n\nWarning\n\n\n\nIt is important to keep data synchronised\nWe store the runtime as a separate variable so that we don’t need to calculate it on the fly every time a function requires it. However this introduces the difficulty that we have to keep runtime synched with the data it is representing (the sum of the length of the tracks in the tracks attribute). This is important in real world scenarios, as if these two data attributes diverge we might get nonsense results.\nThis is actually one of the big reasons why we like to make data attributes private, it ensures we can maintain the relationships between elements.\n\n\nAs written our code has the problem that data could become desynchronised because the user can directly modify the tracks list. We can’t get around this easily by making a read-only property, because it we return a reference to a list, than any changes on that reference would propagate to the original list\nOne option would be to provide a deep copy (a unique copy for each call), or another would be make tracks private and define methods on the class for all the necessary interactions. I haven’t done this to minimise the disruption to the overall API, since this current API lets us reuse the adding and searching functionality we defined for the complete list of tracks. This could be something we change in the future\nLets now consider how we want to program to work. Previously we had one playlist. Now like the tracks, we want a list of them. However we still want to be able to work on and modify a playlist. To minimise the changes from the original design lets use the following approach\n\nThere will be a list of playlists\n\nThese will be loaded and saved to memory like the track list\n\nThere will be one active playlist at a time\n\nAt the start there is no active playlist\nThe user can create a new playlist\nThe user can select an existing playlist\nThe user can use the existing playlist generation feature\n\n\nBy keeping the one active global playlist we can minimise the disruption to our program. We can reuse existing functions making note that the current playlist has changed from a list of tracks to a Playlist object\nOur new Playlist menu now looks like,\ndef run_playlist_management_menu():\n    \"\"\"\n    Provides the user with a looping playlist menu\n\n    1. Create a new playlist\n    2. Select playlist\n    3. Get a suggested playlist of a target length\n    4. Add a track to the playlist\n    5. Remove a track from the playlist\n    6. Clear the playlist\n    7. Display the playlist\n    8. Show the runtime of the playlist\n    9. Export the current playlist\n    10. Return to the main menu\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    ValueError\n        An invalid number is encountered in menu selection, should not\n        occur in live code, please raise a bug report if encountered\n    \"\"\"\n    playlist_management_menu = \"\"\"Playlist Management\nCurrent playlist is {0}\n\n1. Create a new playlist\n2. Select playlist\n3. Get a suggested playlist of a target length\n4. Add a track to the playlist\n5. Remove a track from the playlist\n6. Clear the playlist\n7. Display the playlist\n8. Show the runtime of the playlist\n9. Export the current playlist\n10. Return to the main menu\n\nEnter your command: \"\"\"\n    while True:\n        command = BTCInput.read_int_ranged(\n            prompt=playlist_management_menu.format(current_playlist.name),\n            min_value=1,\n            max_value=10,\n        )\n        if command == 1:\n            create_playlist()\n        elif command == 2:\n            select_playlist()\n        elif command == 3:\n            suggest_playlist_of_given_length()\n        elif command == 10:\n            break\n        elif current_playlist.name == \"None\":\n            print(\"There is no active playlist. Please select or create one\")\n            continue\n        elif command == 4:\n            add_track_to_playlist()\n        elif command == 5:\n            remove_tracks_from_playlist()\n        elif command == 6:\n            clear_playlist()\n        elif command == 7:\n            display_playlist(current_playlist, name_only=False)\n        elif command == 8:\n            calculate_playlist_length()\n        elif command == 9:\n            export_playlist()\n        else:\n            raise ValueError(\n                \"Invalid command id \"\n                + str(command)\n                + \" found in playlist management sub-menu\"\n            )\nYou can see that we’ve defined new functions,\n\ncreate_playlist\nselect_playlist\ndisplay_playlist\n\nand that we’ve renamed the old save_playlist function to export_playlist. This last change is because we’ve introduced save_playlists and load_playlists as functions to pickle and un-pickle the playlists binary data. Renaming save_playlist to export_playlist makes it clear that this function is not related to those two.\nYou also might notice that we’ve reordered the menu so that all the functions dealing with changing the current playlist (create_playlist, select_playlist, suggest_playlist_of_given_length) come first. This allows us to then check that we have an active playlist before running any of the other commands. We also check if user has decided to exit here to, since if we put it after the check for an active playlist the user can’t exit the playlist menu if the don’t have an active playlist\nAs mentioned, at the start there is no active playlist. Now the simplest way to implement this would be to initially set the current_playlist to None. However you can see this has a problem, we want the playlist menu to display the name of the current playlist, this doesn’t work if the current playlist is None. We could add some error checking, but we’ll instead use a technique called a None or Null object. This is an instance of an object that is designed to represent cases where the object does not actually exist. For us, we simply define a Playlist with the name None\n# null object\nno_playlist = Playlist(name=\"None\")\ncurrent_playlist = no_playlist\nLet us look now at the new functions we’ve defined, the first pair\ndef valid_playlist_name(name):\n    \"\"\"\n    Verifies that a playlist name is valid\n\n    Playlist names must be unique\n\n    Parameters\n    ----------\n    name : str\n        proposed name for a playlist\n\n    Returns\n    -------\n    bool\n        `True` if playlist name is valid else, `False`\n    \"\"\"\n    if name == \"None\":\n        return False\n    for playlist in playlists:\n        if name == playlist.name:\n            return False\n    return True\n\n\ndef create_playlist(tracks=[]):\n    \"\"\"\n    Create a new playlist and make it the active playlist\n\n    Prompts the user for a new name for the playlist, and ensures its valid\n    then constructs a playlist and sets it as the current active playlist\n\n    Parameters\n    ----------\n    tracks : list, optional\n        tracks to assign to the playlist, by default []\n\n    See Also\n    --------\n    valid_playlist_name : validates a playlist name\n    Playlist : class used to represent a playlist\n    \"\"\"\n    print(\"Create a new playlist\")\n    global current_playlist\n\n    new_playlist_name = BTCInput.read_text(\"Enter the playlist name: \")\n    while not valid_playlist_name(new_playlist_name):\n        print(\"That playlist name is already in use\")\n        new_playlist_name = BTCInput.read_text(\"Enter the playlist name: \")\n\n    new_playlist = Playlist(new_playlist_name, tracks)\n    current_playlist = new_playlist\n    playlists.append(new_playlist)\nPrompts the user for the name of a new playlist. We add code that means the user can’t override the NoneObject or use duplicate names which is given by the function valid_playlist_name. Unlike the validation code in the Time Tracker this is not in the class, because it is part of the business logic of the application layer, not the playlist itself\nWe then define the select_playlist function,\ndef select_playlist():\n    \"\"\"\n    Select an existing playlist to be the current playlist\n\n    Prompts the user for a search name then returns all playlists\n    that match that string. The user will be displayed each playlist\n    in turn and asked if they want to make that the current playlist\n\n    Notes\n    -----\n    Passing the empty string can be used to display all playlists\n    \"\"\"\n    print(\"Select a playlist\")\n    global current_playlist\n\n    search_name = BTCInput.read_text(\"Enter playlist name (enter to see ): \")\n\n    matched_playlists = []\n\n    for playlist in playlists:\n        if playlist.name.strip().lower().startswith(search_name.strip().lower()):\n            matched_playlists.append(playlist)\n\n    if len(matched_playlists) &gt; 0:\n        print(\"Found {0} matches\".format(len(matched_playlists)))\n        for playlist in matched_playlists:\n            display_playlist(playlist)\n            select = BTCInput.read_int_ranged(\n                \"Select this playlist? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n            )\n            if select:\n                current_playlist = playlist\n                return\n    else:\n        print(\"No playlists found matching that name\")\nSince no other method needs to search for playlist names, we forgo our usual pattern of defining a find and filter function and just combine it all in the one function. Additionally select is also used for letting the user see what playlists are stored in the program. A future version might add an explicit function called this (perhaps list_playlists)\nThis program works pretty simply. We use the standard name matching pattern, then for each match the user is shown the playlist name and runtime, and is given the option to select it. If they do then the current playlist is set to that playlist and the function ends, else it continues to the next.\nLastly we have our display_playlist function, to print a playlist\ndef display_playlist(playlist, name_only=True):\n    \"\"\"\n    Display a playlist\n\n    Can optionally list all the tracks or just the name and length\n\n    Parameters\n    ----------\n    playlist : Playlist\n        playlist to display\n    name_only : bool, optional\n        only display the playlists name and runtime, by default `True`\n\n    Returns\n    -------\n    None\n    \"\"\"\n    if name_only:\n        print(\"{0} ({1} s)\".format(playlist.name, playlist.runtime))\n    else:\n        print(playlist)\nThe optional name_only parameter is used indicate that we only want to print the playlist name and length, otherwise we defer to the Playlist __str__ method and print everything.\nThis captures the last of the high level changes. As mentioned, we have to make minor changes to the existing functions, such as to suggest_playlist_of_given_length shown below\ndef suggest_playlist_of_given_length():\n    \"\"\"\n    Suggests a playlist of length less than or equal to\n    a user prompted length\n\n    Asks the user for a maximum playlist length, and\n    then suggests a playlist by combining tracks randomly\n    such that the suggested playlist is no greater than\n    the length\n\n    The user has the option to review the proposed list\n    and either accept, reject or regenerate the list\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"Suggest playlist of given length\")\n    global current_playlist\n\n    target_length = read_min_valued_integer(\n        \"Enter maximum playlist length: \", min_value=1\n    )\n\n    while True:\n        suggested_tracks = []\n        suggested_tracks_total_length = 0\n        # find tracks that could fit in the playlist\n        candidate_songs = filter_tracks_shorter_than_length(target_length, tracks)\n\n        if len(candidate_songs) == 0:\n            print(\"Could not generate a playlist of that length. Try a longer playlist\")\n            return\n\n        while len(candidate_songs) &gt; 0:  # stop when no more eligible songs\n            # add a random song and update the playlist length\n            song_choice = random.choice(candidate_songs)\n            suggested_tracks.append(song_choice)\n            suggested_tracks_total_length = (\n                suggested_tracks_total_length + song_choice.length_in_seconds\n            )\n\n            # filter out songs that no longer fit\n            candidate_songs = filter_tracks_shorter_than_length(\n                target_length - suggested_tracks_total_length, candidate_songs\n            )\n        print(\"Generated a playlist...\")\n        # let the user review the playlist\n        display_tracks(suggested_tracks)\n        if BTCInput.read_int_ranged(\n            \"Accept this playlist? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        ):\n            create_playlist(suggested_tracks)\n            return\n        else:\n            if BTCInput.read_int_ranged(\n                \"Generate again? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n            ):\n                continue\n            return\nHere we still build up the suggested playlist as before (using a list) but once the user decides to keep this playlist, we then call create_playlist passing in the track list to create a proper named Playlist object\nYou are encouraged to work through the full program yourself (PlaylistStorage.py)\n\n\n\n\n\nLet’s build a simple music keyboard\nWe’ll add a simple music player\nExtend with some playback options\nThe snaps library code provides some music notes to use\n\nstored in MusicNotes\nplay_note lets us play a note\n\n\n\n\n\n\nWarning\n\n\n\nIf when running the program you get a file not found error, you may need to modify the path in play_note to either MusicNotes\\\\ or MusicNotes/\nThis path is relative to snaps and so the folder must in the same directory as snaps\n\n\n\nWe can start with a simple program that plays all the notes,\n  # Example 10.15.1 Play Notes\n  #\n  # Demonstrates using snaps to play notes\n\n  import time\n\n  import snaps\n\n  for note in range(0, 13):\n      snaps.play_note(note)\n      time.sleep(0.5)\n  input(\"Press enter to continue...\")\nWe use time.sleep(0.5) to stagger playing the notes\nWe could also play a tune,\n  # Example 10.15.2 Twinkle Twinkle\n  #\n  # Uses snaps to play a simple tune\n\n  import time\n\n  import snaps\n\n  snaps.play_note(0)\n  time.sleep(0.4)\n  snaps.play_note(0)\n  time.sleep(0.4)\n  snaps.play_note(7)\n  time.sleep(0.4)\n  snaps.play_note(7)\n  time.sleep(0.4)\n  snaps.play_note(9)\n  time.sleep(0.4)\n  snaps.play_note(9)\n  time.sleep(0.4)\n  snaps.play_note(7)\n  time.sleep(0.8)\n  snaps.play_note(5)\n  time.sleep(0.4)\n  snaps.play_note(5)\n  time.sleep(0.4)\n  snaps.play_note(4)\n  time.sleep(0.4)\n  snaps.play_note(4)\n  time.sleep(0.4)\n  snaps.play_note(2)\n  time.sleep(0.4)\n  snaps.play_note(2)\n  time.sleep(0.4)\n  snaps.play_note(0)\n  time.sleep(0.8)\nWe can see this is already becoming tedious\nWe repeatedly write the play_note followed by a sleep time\nHave to manually modify the code\nWe could make this data-driven\nWe supply a list of tuples\n\nEach tuple contains the id for a note and the time to sleep after playing that note\n\nThen simply loop over the list to play the tune\nCan then play anything by just changing the embedded data\n  # Example 10.15.3 Twinkle Twinkle with Tuples\n  #\n  # Converts play notes to a data-driven program using tuples to specify notes\n  # and how long to pause after\n\n  import time\n\n  import snaps\n\n  tune = [\n      (0, 0.4),\n      (0, 0.4),\n      (7, 0.4),\n      (7, 0.4),\n      (9, 0.4),\n      (9, 0.4),\n      (7, 0.8),\n      (5, 0.4),\n      (5, 0.4),\n      (4, 0.4),\n      (4, 0.4),\n      (2, 0.4),\n      (2, 0.4),\n      (0, 0.8),\n  ]\n\n  for note in tune:\n      note_id, sleep_time = note\n      snaps.play_note(note_id)\n      time.sleep(sleep_time)\nEach tuple stores the note and the sleep time\nWe then loop over the tuples\nWe use unpacking to assign the elements of the tuple meaningful names (note_id and sleep_time)\nWhile playback is simple, constructing is not necessarily\n\nThe tuples are undocumented and rely on the programmer knowing the indices\n\nWe could instead define a lightweight class\n  # Example 10.15.4 Twinkle Twinkle with Classes\n  #\n  # Modifies the data driven tuple implementation by defining a lightweight\n  # Note class\n\n  import time\n\n  import snaps\n\n\n  class Note:\n      \"\"\"\n      Musical note with a playback duration.\n      \"\"\"\n\n      def __init__(self, note, duration):\n          \"\"\"\n          Create a `Note` instance\n\n          Parameters\n          ----------\n          note : int\n              id of the note to play\n          duration : int | float\n              duration of the note\n          \"\"\"\n          self.__note = note\n          self.__duration = duration\n\n      def play(self):\n          \"\"\"\n          play the note\n\n          plays the note then pauses for the specified duration\n          \"\"\"\n          snaps.play_note(self.__note)\n          time.sleep(self.__duration)\n\n\n  tune = [\n      Note(note=0, duration=0.4),\n      Note(note=0, duration=0.4),\n      Note(note=7, duration=0.4),\n      Note(note=7, duration=0.4),\n      Note(note=9, duration=0.4),\n      Note(note=9, duration=0.4),\n      Note(note=7, duration=0.8),\n      Note(note=5, duration=0.4),\n      Note(note=5, duration=0.4),\n      Note(note=4, duration=0.4),\n      Note(note=4, duration=0.4),\n      Note(note=2, duration=0.4),\n      Note(note=2, duration=0.4),\n      Note(note=0, duration=0.8),\n  ]\n\n  for note in tune:\n      note.play()\nNote is a lightweight class holding the note’s id and the note duration\n\nKeep these private, since no need to access once set\n\nNote has a play method that captures playing a note\nProgram then defines a list of Note objects which are then played\n\n\n\nConsider the following questions about the design of the note class\n\nWhy does the Note class contain a Play method?\n\ncohesion\nNote contains all the information about a note\nSo should keep the behaviour with the information, i.e. in the Note class\nIf we want to change how a note is played we can change it in the Note class without impacting downstream callers\n\nSo long as we keep the same API\n\n\nCould the Note class have a __str__ method?\n\nIt’s probably a good idea\nA simple implementation is,\ndef __str__(self):\n  template = \"Note: {0} Duration: {1}\"\n  return template.format(self.__note, self.duration)\nWe can then print the tune super easily,\n  tune_strings = map(str, tune)\n  print(\"\\n\".join(tune_strings))\n\n\n\nAll the music playing examples can be found in the Music With Snaps example folder\n\n\n\n\nModify the sample programs to make your own tunes\nFor fun we’ll make two little tunes\n\nThe classic Maccas jingle\n # Exercise 10.2.1  Maccas Jingle\n #\n # Uses the Note playback program to play the Maccas jingle\n\n import time\n\n import snaps\n\n\n class Note:\n     \"\"\"\n     Musical note with a playback duration.\n     \"\"\"\n\n     def __init__(self, note, duration):\n         \"\"\"\n         Create a `Note` instance\n\n         Parameters\n         ----------\n         note : int\n             id of the note to play\n         duration : int | float\n             duration of the note\n         \"\"\"\n         self.__note = note\n         self.__duration = duration\n\n     def __str__(self):\n         template = \"Note: {0} Duration: {1}\"\n         return template.format(self.__note, self.__duration)\n\n     def play(self):\n         \"\"\"\n         play the note\n\n         plays the note then pauses for the specified duration\n         \"\"\"\n         snaps.play_note(self.__note)\n         time.sleep(self.__duration)\n\n\n tune = [\n     Note(note=7, duration=0.3),\n     Note(note=11, duration=0.3),\n     Note(note=2, duration=0.3),\n     Note(note=5, duration=0.3),\n     Note(note=7, duration=0.5),\n ]\n\n for note in tune:\n     note.play()\n\n tune_strings = map(str, tune)\n print(\"\\n\".join(tune_strings))\n\nThis doesn’t sound exactly correct because we don’t have the correct octave progression in the provided wav files but we get a decent approximation\nYou might like to play around with the timings to see if you can make it better\n\nThree Blind Mice\n # Exercise 10.2.2 Three Blind Mice\n #\n # Uses the Note playback program to play three blind mice\n\n import time\n\n import snaps\n\n\n class Note:\n     \"\"\"\n     Musical note with a playback duration.\n     \"\"\"\n\n     def __init__(self, note, duration):\n         \"\"\"\n         Create a `Note` instance\n\n         Parameters\n         ----------\n         note : int\n             id of the note to play\n         duration : int | float\n             duration of the note\n         \"\"\"\n         self.__note = note\n         self.__duration = duration\n\n     def __str__(self):\n         template = \"Note: {0} Duration: {1}\"\n         return template.format(self.__note, self.__duration)\n\n     def play(self):\n         \"\"\"\n         play the note\n\n         plays the note then pauses for the specified duration\n         \"\"\"\n         snaps.play_note(self.__note)\n         time.sleep(self.__duration)\n\n\n tune = [\n     Note(note=4, duration=0.4),\n     Note(note=2, duration=0.4),\n     Note(note=0, duration=0.8),\n     Note(note=4, duration=0.4),\n     Note(note=2, duration=0.4),\n     Note(note=0, duration=0.8),\n     Note(note=7, duration=0.4),\n     Note(note=5, duration=0.4),\n     Note(note=5, duration=0.4),\n     Note(note=4, duration=0.8),\n     Note(note=7, duration=0.4),\n     Note(note=5, duration=0.4),\n     Note(note=5, duration=0.4),\n     Note(note=4, duration=0.8),\n     Note(note=7, duration=0.4),\n     Note(note=12, duration=0.4),\n     Note(note=12, duration=0.4),\n     Note(note=11, duration=0.4),\n     Note(note=9, duration=0.4),\n     Note(note=11, duration=0.4),\n     Note(note=12, duration=0.4),\n     Note(note=7, duration=0.4),\n     Note(note=7, duration=0.8),\n ]\n\n for note in tune:\n     note.play()\n\n tune_strings = map(str, tune)\n print(\"\\n\".join(tune_strings))\n\nThis one we get a much better sounding tune\n\n\n\n\n\nBy combining the structure and style of Time Tracker with the music playback provided by the Note class we could make a simple program that lets users create, edit and play their own tunes. Create this program. A user should be able to create a tune, edit a tune, delete a tune and play a selected tune. Tunes should be saved and persist between uses\nIf you can follow the Playlist Storage App and the Recipe Storage App then this program should fairly easy to follow\nLet’s first define our Note class\nclass Note:\n    \"\"\"\n    Musical note with a playback duration.\n\n    Class Attributes\n    ----------------\n    min_note_id : int\n        minimum valid note id\n    max_note_id : int\n        maximum valid note id\n    \"\"\"\n\n    min_note_id = 0\n    max_note_id = 12\n\n    @staticmethod\n    def valid_note(note):\n        \"\"\"\n        Checks if a note id is valid\n\n        Parameters\n        ----------\n        note : int\n            id of the note to validate\n\n        Returns\n        -------\n        bool\n            `True` if note is valid, else `False`\n        \"\"\"\n        if note &lt; 0 or note &gt; 12:\n            return False\n        return True\n\n    def __init__(self, note, duration):\n        \"\"\"\n        Create a Note instance\n\n        Parameters\n        ----------\n        note : int\n            id of the note to play\n        duration : int | float\n            duration of the note\n        \"\"\"\n        if not Note.valid_note(note):\n            raise ValueError(\n                \"invalid note {0} passed. note must be between {1} and {2}\".format(\n                    note, Note.min_note_id, Note.max_note_id\n                )\n            )\n        self.__note = note\n        self.__duration = duration\n\n    @property\n    def duration(self):\n        \"\"\"\n        duration : str\n            time in seconds the note is played for\n        \"\"\"\n        return self.__duration\n\n    def __str__(self):\n        template = \"Note: {0} Duration: {1}\"\n        return template.format(self.__note, self.__duration)\n\n    def play(self):\n        \"\"\"\n        play the note\n\n        plays the note then pauses for the specified duration\n        \"\"\"\n        snaps.play_note(self.__note)\n        time.sleep(self.__duration)\nThis is pretty much the same as the Note class in the Making Music Section. However we need the duration so that we can report how long the total tune is so we add a read only property for duration. Additionally since we’re now going to be taking user input to create notes we’ll want to validate that input. It makes sense for it to be in the Note class, so we define class variables min_note_id and max_note_id and a corresponding validation method, valid_note that can be used to check that a note (represented by an integer) is valid. We leave the class variables as public so we can use them in the prompts we display to the user\nNow when making our own music, we used a list of notes to create a tune. We want to use this structure but wrap it in a class that captures behaviour. We’ll call this class Tune\nclass Tune:\n    \"\"\"\n    Represents a tune consisting of a sequence of notes of a specified duration\n\n    Attributes\n    ----------\n    name : str\n        name of the tune\n    \"\"\"\n\n    def __init__(self, name):\n        \"\"\"\n        Create a new `Tune` instance\n\n        Parameters\n        ----------\n        name : str\n            name of the tune\n        \"\"\"\n        self.name = name\n        self.__notes = []\n        self.__length = 0\n\n    def __str__(self):\n        notes_string = \"\"\n        for idx, note in enumerate(map(str, self.__notes)):\n            notes_string = notes_string + str(idx) + \": \" + note + \"\\n\"\n\n        template = \"\"\"name: {0}\nduration: {1}\nnotes:\n{2}\n\"\"\"\n        return template.format(self.name, self.__length, notes_string)\n\n    @property\n    def length(self):\n        \"\"\"\n        length : int | float\n            total length of the tune in seconds\n        \"\"\"\n        return self.__length\n\n    @property\n    def number_of_notes(self):\n        \"\"\"\n        number_of_notes : int\n            number of notes in the tune\n        \"\"\"\n        return len(self.__notes)\nThe class has a simple structure. The tune constructor only needs a name, we then create an empty list of notes, and a separate variable that tracks the full length of the tune. Our string representation (__str__) follows the usual pattern, we print the name and duration of the Tune, the the list of Note objects in the tune. We use enumerate to make this a numbered list with each item on its own line. This is because most of our edits will require an index, so we want to user to be able to easily see the index of all the notes. Additionally we define two useful properties, one to get the length of the tune, and the second that returns the total number of notes in the tune. Both properties are read-only, while this last one is mostly used to help with validating user input\nAs you can see the list of notes is private, so we also want to provide some methods that allow us to modify the notes list\n    def add_note(self, note, index=None):\n        \"\"\"\n        Add a new note to the tune\n\n        Adds a new note to the tune, if the index is specified\n        the note is inserted at that index, else the note is appended\n\n        Parameters\n        ----------\n        note : Note\n            note to add to the tune\n        index : int | None, optional\n            index to insert the note at, if `None`, the Note is appended,\n            by default `None`\n\n        Returns\n        -------\n        None\n\n        See Also\n        --------\n        Tune.remove_note : remove a note at a given index from a `Tune` instance\n        \"\"\"\n        if index is not None:\n            self.__notes.insert(index, note)\n        else:\n            self.__notes.append(note)\n        self.__length += note.duration\n\n    def remove_note(self, index):\n        \"\"\"\n        Remove a note from the tune\n\n        Parameters\n        ----------\n        index : int\n            index of the note to remove\n\n        Returns\n        -------\n        Note\n            the removed Note\n\n        See Also\n        --------\n        Tune.add_note : insert or append a new note to a `Tune` instance\n        Tune.clear_tune : remove all notes in a `Tune` instance\n        \"\"\"\n        try:\n            note = self.__notes.pop(index)\n            self.__length -= note.duration\n            return note\n        except IndexError:\n            print(\"Failed to remove the {0}-th note\".format(index + 1))\n\n    def clear_tune(self):\n        \"\"\"\n        Clear all notes from the tune\n\n        Returns\n        -------\n        None\n\n        See Also\n        --------\n        Tune.remove_note : remove a note at a given index from a `Tune`\n        \"\"\"\n        self.__notes.clear()\n        self.__length = 0\nThe first add_note takes a note, and an optional index. If the index is specified the note is inserted into the list (at the specified index), otherwise we append it. The second remove_note requires an index, and removes the note at that index. The removed note is returned as part of this process. We also provide some error handling in case the provided index does not actually exist. Last we provide a clear_tune method which simply removes all the notes\nThe arguably most important function for the Tune class however is play which simply plays the tune\n    def play(self):\n        \"\"\"\n        Plays the tune\n\n        Returns\n        -------\n        None\n        \"\"\"\n        for note in self.__notes:\n            note.play()\nWe define our main menu function as,\ndef run_main_menu():\n    first_option_id = 1\n    last_option_id = 7\n\n    main_menu_template = \"\"\"Tune Editor\nCurrent Tune: {0}\n\n1. New Tune\n2. List Tunes\n3. Select Tune\n4. Play Tune\n5. Edit Tune\n6. Delete Tune\n7. Exit program\n\nEnter your command: \"\"\"\n\n    while True:\n        command = BTCInput.read_int_ranged(\n            main_menu_template.format(current_tune.name),\n            min_value=first_option_id,\n            max_value=last_option_id,\n        )\n        if command == 1:\n            new_tune()\n        elif command == 2:\n            list_tunes()\n        elif command == 3:\n            select_tune()\n        elif command == 7:\n            try:\n                save_tunes(tune_file_name)\n            except:  # noqa: E722\n                print(\"Failed to save tunes\")\n            break\n        elif current_tune.name == \"None\":\n            print(\"No tune currently selected\")\n            continue\n        elif command == 4:\n            current_tune.play()\n        elif command == 5:\n            run_edit_menu()\n        elif command == 6:\n            delete_tune()\n        else:\n            raise ValueError(\n                \"Unexpected command id: {0} found in Main Menu\".format(command)\n            )\nWe use the same save and load paradigm as with all the previous examples so we won’t look at that code again. Of the functions here we have,\n\nnew_tune\n def valid_tune_name(name):\n     \"\"\"\n     Verifies that a tune name is available\n\n     Tune names must be unique\n\n     Parameters\n     ----------\n     name : str\n         proposed name for a tune\n\n     Returns\n     -------\n     bool\n         `True` if tune name is valid else, `False`\n     \"\"\"\n     if name == \"None\":\n         return False\n     for tune in tunes:\n         if name == tune.name:\n             return False\n     return True\n\n\n def prompt_valid_name(prompt):\n     \"\"\"\n     Prompts the user for a valid tune name\n\n     Loops until a valid name is provided\n\n     Parameters\n     ----------\n     prompt : str\n         prompt to display to the user\n\n     Returns\n     -------\n     str\n         string containing a valid tune name\n     \"\"\"\n     tune_name = BTCInput.read_text(prompt)\n     while not valid_tune_name(tune_name):\n         print(\"That tune name is already in use\")\n         tune_name = BTCInput.read_text(prompt)\n\n     return tune_name\n\n\n def new_tune():\n     \"\"\"\n     Create a new tune and make it the active tune\n\n     Prompts the user for a new name for the tune, and ensures its valid\n     then constructs a Tune and sets it as the current active tune\n\n     Returns\n     -------\n     None\n\n     See Also\n     --------\n     valid_tune_name : validates a tune name\n     Tune : class used to represent a tune\n     \"\"\"\n     print(\"New tune\")\n     global current_tune\n     new_tune_name = prompt_valid_name(\"Enter the tune name: \")\n     new_tune = Tune(new_tune_name)\n     current_tune = new_tune\n     tunes.append(new_tune)\n\nWe start by defining a function valid_tune_name\n\nboolean function that ensures a proposed name is unique\nreturns True if the name is valid, else False\n\nWe then wrap this in prompt_valid_name\n\nSince we want to reuse the code that gets a name from a user later\nPrompts the user for a valid name, looping until one is received\nReturns the valid name\n\nOur new_tune is now simple\n\ncall prompt_valid_name to get a new name\nCreate a new Tune object\nset the current tune to this new object\nAdd it to the tunes list\n\n\nlist_tunes\n def filter_tunes_by_name(search_name):\n     \"\"\"\n     Finds tunes matching a search name\n\n     Tunes are matched if their name is prefixed by the search name\n     after normalisation (striping whitespace and lowercasing)\n\n     Parameters\n     ----------\n     search_name : str\n         name to search for (search uses prefix matching)\n\n     Returns\n     -------\n     list[Tune]\n         list of tunes matching the name. If no matches\n         exist the list is empty\n\n     \"\"\"\n     search_name = search_name.strip().lower()\n     print(search_name)\n     matched_tunes = []\n     for tune in tunes:\n         tune_name = tune.name.strip().lower()\n         if tune_name.startswith(search_name):\n             matched_tunes.append(tune)\n     return matched_tunes\n\n\n def list_tunes():\n     \"\"\"\n     List all tunes matching a user-specified search string\n\n     Returns\n     -------\n     None\n\n     See Also\n     --------\n     filter_tunes_by_name : handles searching for tunes by name\n     \"\"\"\n     print(\"List tunes\")\n     search_name = BTCInput.read_text(\"Tune names to search (press enter for all): \")\n     matched_tunes = filter_tunes_by_name(search_name)\n     if len(matched_tunes) == 0:\n         print(\"No matches found\")\n         return\n     print(\"Found {0} matches\".format(len(matched_tunes)))\n     for tune in matched_tunes:\n         print(\"- {0} ({1:.2f} s)\".format(tune.name, tune.length))\n\nWe use the usual pattern of defining a filter_tunes_by_name function to perform the search\nWe then print out the matches as per usual\n\nselect_tune\n def select_tune():\n     \"\"\"\n     Select a tune from tunes matching a user-specified search string\n\n     Returns\n     -------\n     None\n\n     See Also\n     --------\n     filter_tunes_by_name : handles searching for tunes by name\n     \"\"\"\n     print(\"Select tune\")\n     search_name = BTCInput.read_text(\"Enter name of tune to select: \")\n     matched_tunes = filter_tunes_by_name(search_name)\n     if len(matched_tunes) == 0:\n         print(\"No matches found\")\n         return\n     print(\"Found {0} matches\".format(len(matched_tunes)))\n     for tune in matched_tunes:\n         select = BTCInput.read_int_ranged(\n             \"Tune: {0}, select this tune? (1 - Yes, 0 - No): \".format(tune.name),\n             min_value=0,\n             max_value=1,\n         )\n         if select:\n             global current_tune\n             current_tune = tune\n             break\n\nUses filter_tunes_by_name to get matching tunes\nUser is then prompted for each match if they want to make this the new current tune\nExecution stops once they’ve decided to select a new track\n\ndelete_tune\n def delete_tune():\n     \"\"\"\n     Optionally delete tunes matching a user-specified search string\n\n     Returns\n     -------\n     None\n\n     See Also\n     --------\n     filter_tunes_by_name : handles searching for tunes by name\n     \"\"\"\n     print(\"Delete tune\")\n     search_name = BTCInput.read_text(\"Enter name of tune to select: \")\n     matched_tunes = filter_tunes_by_name(search_name)\n     if len(matched_tunes) == 0:\n         print(\"No matches found\")\n         return\n     print(\"Found {0} matches\".format(len(matched_tunes)))\n     for tune in tunes:\n         select = BTCInput.read_int_ranged(\n             \"Tune: {0}, delete this tune? (1 - Yes, 0 - No): \".format(tune.name),\n             min_value=0,\n             max_value=1,\n         )\n         if select:\n             global current_tune\n             if tune == current_tune:\n                 current_tune = no_tune\n             tunes.remove(tune)\n\nAgain, use filter_tunes_by_name to match names\nThen prompt the user if they want to delete\nOnly caveat we have to be careful is that if we delete the currently selected tune we have to set the current tune to no_tune (a null object)\n\n\nNow, the last thing we have to look at is the edit menu. Our edit menu looks as follows,\ndef run_edit_menu():\n    first_option_id = 1\n    last_option_id = 8\n\n    edit_tune_menu_template = \"\"\"Editing Tune\nCurrent Tune: {0}\n1. Rename Tune\n2. Display Tune\n3. Play Tune\n4. New Note\n5. Edit Note\n6. Remove Note\n7. Clear Tune\n8. Finish Editing\n\nEnter your command: \"\"\"\n    while True:\n        command = BTCInput.read_int_ranged(\n            edit_tune_menu_template.format(current_tune.name),\n            min_value=first_option_id,\n            max_value=last_option_id,\n        )\n\n        if command == 1:\n            rename_tune()\n        elif command == 2:\n            print(current_tune)\n        elif command == 3:\n            print(\"Playing\", current_tune.name)\n            current_tune.play()\n        elif command == 4:\n            add_note_to_tune()\n        elif command == 5:\n            edit_note()\n        elif command == 6:\n            if current_tune.number_of_notes == 0:\n                print(\"No notes to remove\")\n            remove_note()\n        elif command == 7:\n            print(\"Cleared\", current_tune.name)\n            current_tune.clear_tune()\n        elif command == 8:\n            break\n        else:\n            raise ValueError(\n                \"Unexpected command id: {0} found in Edit Menu\".format(command)\n            )\nLets work through these functions\n\nrename_tune\n def rename_tune():\n     \"\"\"\n     Rename the current tune to a user prompted string\n\n     Returns\n     -------\n     None\n     \"\"\"\n     print(\"Rename current tune\")\n     new_name = prompt_valid_name(\"Enter new name (or . to leave unchanged): \")\n     if new_name != \".\":\n         current_tune.name = new_name\n\nReuses the prompt_valid_name function from new_tune to get a new name\n\nThis has the issue that we can’t write the same name as the current tune\nSo use . to indicate that we don’t actually want to change\n\n\nadd_note_to_tune\n def get_new_note_from_user():\n     \"\"\"\n     Prompts the user for a new Note\n\n     The user is prompted for the note and duration, and the input validated\n     to ensure that a valid Note object is created\n\n     Returns\n     -------\n     Note\n         Note object containing the user specified note id and duration\n     \"\"\"\n\n     note_prompt = \"Enter note ({0} - {1}): \".format(Note.min_note_id, Note.max_note_id)\n     note = BTCInput.read_int_ranged(\n         prompt=note_prompt, min_value=Note.min_note_id, max_value=Note.max_note_id\n     )\n\n     min_note_length = 0.1\n     max_note_length = 1\n     duration_prompt = \"Enter duration ({0} - {1}): \".format(\n         min_note_length, max_note_length\n     )\n     duration = BTCInput.read_float_ranged(\n         duration_prompt, min_value=min_note_length, max_value=max_note_length\n     )\n\n     return Note(note, duration)\n\n\n def add_note_to_tune():\n     \"\"\"\n     Adds a note to the current tune\n\n     Prompts the user to specify a new note as well as an index of\n     where to insert the note in the tune (`-1` indicating append). The created\n     note is then added to the current tune at the indicated index (or appended)\n\n     Returns\n     -------\n     None\n     \"\"\"\n     print(\"Add note to current tune\")\n     new_note = get_new_note_from_user()\n     if current_tune.number_of_notes == 0:\n         current_tune.add_note(new_note)\n         print(\"Added note:\", new_note)\n         return\n\n     insert_prompt = \"Enter index to add note (0 - {0}) or -1 to append: \".format(\n         current_tune.number_of_notes - 1\n     )\n     insertion_idx = BTCInput.read_int_ranged(\n         insert_prompt, -1, current_tune.number_of_notes - 1\n     )\n     if insertion_idx == -1:\n         insertion_idx = None\n     current_tune.add_note(new_note, insertion_idx)\n     print(\"Added note:\", new_note)\n\nWe start by defining a function get_new_note_from_user\n\nGets a valid Note object from the user\nUses the class attributes on Note to limit the user’s input for the note id\nEnforces a program set limit on the duration\n\nThen define add_note_to_tune\n\nWe get a new note from the user\nIf there’s no notes on the Tune we can immediately add the note to the tune\nOtherwise we prompt the user for the index to add\n\n\\(-1\\) is used to indicate that the value should be appended\n\nCan then call the add_note method on the Tune object\n\n\nedit_note\n def edit_note():\n     \"\"\"\n     Modifies an existing note in the current tune\n\n     Prompts the user for the index of the existing note to overwrite and\n     then the details of the new note\n\n     Returns\n     -------\n     None\n     \"\"\"\n     print(\"Edit note in current tune\")\n     if current_tune.number_of_notes == 0:\n         print(\"There are no notes in the current tune to edit\")\n         return\n\n     edit_prompt = \"Enter index of note to edit (0 - {0}): \".format(\n         current_tune.number_of_notes - 1\n     )\n     insertion_idx = BTCInput.read_int_ranged(\n         edit_prompt, 0, current_tune.number_of_notes - 1\n     )\n     old_note = current_tune.remove_note(insertion_idx)\n\n     if insertion_idx == current_tune.number_of_notes:\n         insertion_idx = None  # we removed the last index, so now need to append\n\n     new_note = get_new_note_from_user()\n     current_tune.add_note(new_note, insertion_idx)\n     print(\"Note successfully edited\")\n     print(\"Note was:\", old_note)\n     print(\"Note now:\", new_note)\n\nWorks similar to add_note_to_tune\n\nThis time however we first prompt the user for which note they want to edit\n\nWe create a new Note\n“Editing” a note is achieved by removing the old note, and inserting the new note, where the old one was\n\nremove_note\n def remove_note():\n     \"\"\"\n     Remove the note at a user prompted index from the current tune\n\n     Returns\n     -------\n     None\n     \"\"\"\n     print(\"Remove note from current tune\")\n     remove_prompt = \"Enter index of note to remove (0 - {0}): \".format(\n         current_tune.number_of_notes - 1\n     )\n     remove_idx = BTCInput.read_int_ranged(\n         remove_prompt, 0, current_tune.number_of_notes - 1\n     )\n     current_tune.remove_note(remove_idx)\n\nCalling code responsible for ensuring that we don’t call this on an empty tune\nRemoves the note at the user prompted index\n\n\nWith those functions worked through that covers pretty much all the functionality of the program. You can see the full implementation in TuneCreator.py. The associated pickle file should load the example tunes we created earlier which you can play and edit to test the program",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 10: Using Classes to Create Active Objects"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/10_UseClassesToCreateActiveObjects/Chapter_10.html#notes",
    "href": "02_AdvancedProgramming/10_UseClassesToCreateActiveObjects/Chapter_10.html#notes",
    "title": "Chapter 10: Using Classes to Create Active Objects",
    "section": "",
    "text": "Program’s tend to evolve in scope over time\n\nSometimes due to scope underestimation\nAlso because customers tend to request new features\n\nConsider the Tiny Contacts\n\nClient now wants to functionality to track the time spent with a client\n\nAs usual start with the interface,\n\nTime Tracker\n\n1. New Contact\n2. Find Contact\n3. Edit Contact\n4. Add Session\n5. Exit Program\n\nEnter your command:\nWe want to now storyboard out the new Add Session option\nEnter your command: 4\nAdd Hours\nEnter the Contact Name: Rob\nName: Rob Miles\nPrevious Hours worked: 0\nSession Length: 3\nUpdated hours worked: 3.0\nWe also want to update the Find Contact option to include the hours,\nFind Contact\nEnter the Contact Name: Rob\nName: Rob Miles\nAddress: 18 Pussycat Mews, London, NE1 410S\nTelephone: 1234 56789\nHours worked: 3.0\n\n\n\nWe need to store the hours worked\nSimplest approach is to redefine the Contact class\n\nAdd an hours_worked field\n\n\n\nclass Contact:\n    \"\"\"\n    Contact with a name, address and telephone number.\n    Tracks the hours worked with a client\n\n    Attributes\n    ----------\n    name : str\n        Contact Name\n    address : str\n        Contact's postal or street address.\n    telephone : str\n        Contact phone number (stored as a string).\n    hours_worked : int | float\n        Hours worked with a Contact, initialised to 0\n\n    Examples\n    --------\n    &gt;&gt;&gt; Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"+44(1234) 56789\")\n    &lt;Contact ...&gt;\n    \"\"\"\n\n    def __init__(self, name, address, telephone):\n        \"\"\"\n        Create a new `Contact` instance\n\n        Parameters\n        ----------\n        name : str\n            Contact Name\n        address : str\n            Contact's postal or street address.\n        telephone : str\n            Contact phone number (stored as a string).\n        \"\"\"\n        self.name = name\n        self.address = address\n        self.telephone = telephone\n        self.hours_worked = 0\n\n\nDefaulted to 0 as part of the constructor\n\nWe might discuss this with the client, it’s possible a contact might have some initial consult hours\n\nFrom here we can add a new add_session function (see the complete updated code, in our version which supports duplicate names in the search)\n  def add_session():\n      \"\"\"\n      Prompts the user to add hours worked to contacts matching a search\n\n      Returns\n      -------\n      None\n\n      See Also\n      --------\n      find_contacts : returns contacts matching a search name\n      \"\"\"\n      print(\"add session\")\n      search_name = read_text(\"Enter the contact name: \")\n      contact = find_contact(search_name)\n      if contact != None:\n          #found a contact\n          print(\"Name: \", contact.name)\n          print(\"Previous hours worked:\", contact.hours_worked)\n          session_length = BTCInput.read_float_ranged(prompt=\"Session length: \", min_value=0.5, max_value=3.5)\n          contact.hours_worked = contact.hours_worked + session_length\n          print(\"Updated hours worked:\", contact.hours_worked)\n      else:\n          print(\"This name was not found\")\nDon’t forget we also have to update how we display contacts for the Find Contact functionality (or in our case the display_contact) function.\n\n  def display_contact(contact):\n      \"\"\"\n      Displays the Contact details for the supplied contact\n\n      Parameters\n      ----------\n      contact : Contact\n          contact to display\n\n      Returns\n      -------\n      None\n\n      See Also\n      --------\n      display_contacts : Displays all contacts matching a search name\n      \"\"\"\n      print(\"Name:\", contact.name)\n      print(\"Address:\", contact.address)\n      print(\"Telephone:\", contact.telephone)\n      print(\"Hours worked for this Contact:\", contact.hours_worked, \"\\n\")\n\nIf we create a new Contact object then we can see how this looks,\n\n  contact = Contact(name=\"Alice\", address=\"Bob St\", telephone=\"555\")\n  display_contact(contact)\n  contact.hours_worked = 5.0\n  display_contact(contact)\n\nName: Alice\nAddress: Bob St\nTelephone: 555\nHours worked for this Contact: 0 \n\nName: Alice\nAddress: Bob St\nTelephone: 555\nHours worked for this Contact: 5.0 \n\n\n\n\n\n\n\nWhen extending a program you should always look at its design\nCode rots as it gets older\n\nGets harder to maintain and understand\n\nWant to make the design as clear and simple as possible\nLike a builder we want to make houses out of walls, walls out of bricks and bricks out of clay\n\ni.e. clear progression in scale and responsibility\n\nA technique for this is called object-oriented design\n\nObjects are designed to be cohesive\nA cohesive object should contain all the attributes and methods to work with its domain\n\nFor the Contact object we want it to be responsible for all contact information\n\nCurrently not very cohesive\nTime Tracker works directly on Contact object attributes\n\nBusiness logic that applies to a Contact is outside the function\n\ne.g. in the add_session function, we have hardcoded a minimum session time of half an hour and a maximum session time of three and half hours\nThis is problematic\n\nBecause the numbers are just written there as opposed to being defined as constants with meaning (they are magic constants)\nThis data validation is external to the data storage object itself, the Contact\n\nWe also perform the act of updating the Contact’s hours worked, outside the Contact object\n\n  session_length = BTCInput.read_float_ranged(prompt=\"Session length: \", min_value=0.5, max_value=3.5)\n  contact.hours_worked = contact.hours_worked + session_length\nThe magic constant problem is one issue,\n\nIf we were to use the Contact as a library object in another application, (like a graphical version) then we would have to maintain the validation code in two separate places\n\n\n\n\n\n\n\n\nTip\n\n\n\nKeep Business Rules in Business Objects\nThe issue here is we have defined business rules (things our customer asks the system to do) outside of the business objects (things created to implement the customer’s system).\n\n\n\nA solution is to make the Contact object responsible for validating the session length\n\nAny application that uses the Contact object will naturally use its internal validation\nOnly one location to change now\n\n\n\n\n\n\n\nAny python code can access hours_worked in a Contact\n\nReally only need hours_worked to be accessed to,\n\nDisplay time spent with a contact\nAdd the length of a session to hours_worked\n\n\nPython objects can hold method attributes\n\nFunctions bound to the object\n\nLet us ask an object to do something\nE.g. the string object has the method upper (seen in Chapter 5)\nLet us define two method attributes for Contact\n\nRemoves the need to directly access the attribute\n\nStart by defining a method to access the hours worked\n\n\nclass Contact:\n    \"\"\"\n    Contact with a name, address and telephone number.\n    Tracks the hours worked with a client\n\n    Attributes\n    ----------\n    name : str\n        Contact Name\n    address : str\n        Contact's postal or street address\n    telephone : str\n        Contact phone number (stored as a string)\n    hours_worked : int | float\n        Hours worked with a Contact, initialised to 0\n\n    Examples\n    --------\n    &gt;&gt;&gt; Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"+44(1234) 56789\")\n    &lt;Contact ...&gt;\n    \"\"\"\n\n    def __init__(self, name, address, telephone):\n        \"\"\"\n        Create a new `Contact` instance\n\n        Parameters\n        ----------\n        name : str\n            Contact Name\n        address : str\n            Contact's postal or street address.\n        telephone : str\n            Contact phone number (stored as a string).\n        \"\"\"\n        self.name = name\n        self.address = address\n        self.telephone = telephone\n        self.hours_worked = 0\n\n    def get_hours_worked(self):\n        \"\"\"\n        Get the hours worked for this contact\n        \"\"\"\n        return self.hours_worked\n\n\n\nConsider the following questions regarding the get_hours_worked function\n\nWhat is the parameter self used to accomplish?\n\nA method is part of an object\nself tells the method which object it is a part of\nThe code sample below shows how the method doesn’t need an additional reference to the Contact it refers to\n\n  # set up\n  rob = Contact(\"Rob\", \"A St\", \"1\")\n  rob.hours_worked = 1\n  jim = Contact(\"Jim\", \"B St\", \"555\")\n  jim.hours_worked = 2\n\n  # demonstration\n  rob_work = rob.get_hours_worked()\n  jim_work = jim.get_hours_worked()\n  if rob_work &gt; jim_work:\n      print(\"More work for rob\")\n  else:\n      print(\"More work for jim\")\n\nMore work for jim\n\n\n\nIs the get_hours_worked method stored when we save contact information in a file\n\nNo, if we use pickle to store a contact list, the method attributes are not stored. Pickle only stores the data attributes\n\nCan a program still access the hours_worked attribute of a Contact class\n\nYes, it can. Using method attributes to get data doesn’t stop a program accessing the data directly\nWe simply remove the desire to\nLater chapters look at techniques for enforcing this more robustly\n\n\n\nWe can create a second method to handle adding a session to a Contact\n\n  # existing class definition\n  class Contact:\n      def __init__(self, name, address, telephone):\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n          self.hours_worked = 0\n\n      def get_hours_worked(self):\n          \"\"\"\n          Gets the hours worked for this contact\n\n          Returns\n          -------\n          int | float\n              hours worked for this contact\n          \"\"\"\n          return self.hours_worked\n\n      # new method\n      def add_session(self, session_length):\n          \"\"\"\n          Adds a session (in hours) to the Contacts hours\n\n          Parameters\n          ----------\n          session_length : int | float\n              time spent on session in hours\n\n          Returns\n          -------\n          None\n          \"\"\"\n          self.hours_worked = self.hours_worked + session_length\n\nTakes two parameters\n\nself - the object the method is attached to\n\nHere the Contact being updated\n\nsession_length\n\nThe length of the session to be added\n\n\n\nYou can see the above implementation integrated into our TimeTracker implementation. Aside from defining these new functions we have to update the file scope add_session function (distinct from the class scope add_session method) and the display_contact functions to use the new methods\n\n\n\n\n\nCurrently add_session would allow function calls like,\n\n  rob = Contact(\"Rob\", \"A St\", \"555\")\n  rob.add_session(-10)\n  print(rob.get_hours_worked())\n\n-10\n\n\nLegal call\n\nMakes no logical sense\nCan’t work negative hours\n\nAt the moment the validation is performed in the global add_session function\n\nSuppose this was maintained by another team\nThey could change it, and break your code\n\n\n\n\n\n\n\n\nNote\n\n\n\nThink Carefully about Valid Input\nYou should think carefully about what is valid input for any function, especially when you restrict it. As observed here, a negative number of hours doesn’t make sense on the surface. However, it might make sense in the case of,\n\nCorrecting an overestimated number of hours\nThe Client wants to give a client a discounted number of hours\n\n\n\n\nWe want to move the validation inside the Contact object\n\nWant add_session to reject hours that are less than half-an-hour or greater than three and a half\n\nWe could add these as variables for each instance of a Contact\n\nBut they’re the same for every instance\nWould be nice to have a way to define it once for the class\n\n\n\n\n\nA class variable is data not attached to a specific object instance\nCan define the min and max hours as a class variable\n\nNo longer magic constants\nAccessible by all Contact instances\n\n\n  class Contact:\n      \"\"\"\n      Contact with a name, address and telephone number.\n      Tracks the hours worked with a client\n\n      Attributes\n      ----------\n      name : str\n          Contact Name\n      address : str\n          Contact's postal or street address.\n      telephone : str\n          Contact phone number (stored as a string).\n      hours_worked : int | float\n          Hours worked with a Contact, initialised to 0\n\n      Class Attributes\n      ----------------\n      min_session_length : Final[int | float]\n          minimum length of a billable session\n\n      max_session_length : Final[int | float]\n          maximum length of a billable session\n\n\n      Examples\n      --------\n      &gt;&gt;&gt; Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"+44(1234) 56789\")\n      &lt;Contact ...&gt;\n      \"\"\"\n\n      min_session_length = 0.5\n      max_session_length = 3.5\n\n      def __init__(self, name, address, telephone):\n          \"\"\"\n          Create a new `Contact` instance\n\n          Parameters\n          ----------\n          name : str\n              Contact Name\n          address : str\n              Contact's postal or street address.\n          telephone : str\n              Contact phone number (stored as a string).\n          \"\"\"\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n          self.hours_worked = 0\n\n          def get_hours_worked(self):\n              \"\"\"\n              Gets the hours worked for this contact\n\n              Returns\n              -------\n              int | float\n                  hours worked for this contact\n              \"\"\"\n              return self.hours_worked\n\n          # new method\n          def add_session(self, session_length):\n              \"\"\"\n              Adds a session (in hours) to the Contacts hours\n\n              Parameters\n              ----------\n              session_length : int | float\n                  time spent on session in hours\n\n              Returns\n              -------\n              None\n              \"\"\"\n              if session_length &lt; Contact.min_session_length or session_length &gt; Contact.max_session_length:\n                  return\n              self.hours_worked = self.hours_worked + session_length\n\nadd_session now silently rejects invalid session_length values\nThe idiom of first checking for invalid input and performing a return if encountered is called an early return and is a common technique\n\nReduces the need for indentation on the happy path - the error free path\n\nObserve we have to prefix the class variables with the class name as a namespace\nThe Final label in the docstring indicates that the session length variables are expected to be constant and should not be modified by a consuming program\n\n\n\nBuild your understanding of class variables by answering the following questions about their use-cases\n\nShould I use a class variable to hold the age of a contact?\n\nNo. Each contact will have an age, so the age must be a data attribute unique to each object instance\n\nShould I use a class variable to hold the maximum age of a contact?\n\nYes, we don’t need to store a copy of this value for every Contact instance, so it can be a class variable\n\nShould I use a class variable to hold the price per hour that the lawyer will charge?\n\nIt depends, if the lawyer charges the same for every client then it may be reasonable\nIf the lawyer wishes to charge different contacts different rates, then we would have to store it as a data attribute\n\nIn that case we might store the minimum and maximum hourly rate as class variables\n\n\n\n\n\n\n\n\nCohesion generally means objects shouldn’t expose attributes for external clients\nIdeally clients interact with a Contact via method calls\n\ne.g. get_hours_worked and add_session\nEliminates direct dependency on hours_worked data attribute\n\nIn the same vein, we don’t want users to directly interact with class variables\n\ne.g. max_session_length and min_session_length are used for internal validation\nExternal client should have no reason to directly modify them\n\nCould create a method, validate_session_length\n\nReceive a session_length argument\nReturn True if valid, else False\n\nValidation information (max_session_length and min_session_length) is held at the class level\n\nWould be nice to also have this validation method at the class level too\n\nWe can create class level methods through a Static Method\n\nStatic methods can be considered as methods defined on a class rather than an object instance\n\nWe can define one as below,\n\n  class Contact:\n      \"\"\"\n      Contact with a name, address and telephone number.\n      Tracks the hours worked with a client\n\n      Attributes\n      ----------\n      name : str\n          Contact Name\n      address : str\n          Contact's postal or street address.\n      telephone : str\n          Contact phone number (stored as a string).\n      hours_worked : int | float\n          Hours worked with a Contact, initialised to 0\n\n      Class Attributes\n      ----------------\n      min_session_length : Final[int | float]\n          minimum length of a billable session\n\n      max_session_length : Final[int | float]\n          maximum length of a billable session\n\n      Examples\n      --------\n      &gt;&gt;&gt; Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"+44(1234) 56789\")\n      &lt;Contact ...&gt;\n      \"\"\"\n\n      min_session_length = 0.5\n      max_session_length = 3.5\n\n      @staticmethod\n      def valid_session_length(session_length):\n          \"\"\"\n          Check a session length is valid\n\n          Parameters\n          ----------\n          session_length : int | float\n              length of a consult session in hours\n\n          Returns\n          -------\n          bool\n              `True` if the session length is valid else `False`\n          \"\"\"\n          if (\n              session_length &lt; Contact.min_session_length\n              or session_length &gt; Contact.max_session_length\n          ):\n              return False\n          return True\n\n      def __init__(self, name, address, telephone):\n          \"\"\"\n          Create a new `Contact` instance\n\n          Parameters\n          ----------\n          name : str\n              Contact Name\n          address : str\n              Contact's postal or street address.\n          telephone : str\n              Contact phone number (stored as a string).\n          \"\"\"\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n          self.hours_worked = 0\n\n      def get_hours_worked(self):\n          \"\"\"\n          Gets the hours worked for this contact\n\n          Returns\n          -------\n          int | float\n              hours worked for this contact\n          \"\"\"\n          return self.hours_worked\n\n      # new method\n      def add_session(self, session_length):\n          \"\"\"\n          Adds a session (in hours) to the Contacts hours\n\n          Parameters\n          ----------\n          session_length : int | float\n              time spent on session in hours\n\n          Returns\n          -------\n          None\n\n          See Also\n          --------\n          Contact.valid_session_length : checks a session length is valid\n          \"\"\"\n          if not Contact.valid_session_length(session_length):\n              return\n          self.hours_worked = self.hours_worked + session_length\n\nThe @staticmethod tag above the definition of valid_session_length is called a decorator\nA decorator wraps a function to modify how it works\nDecorators are added by writing @ followed by the decorator name above the function to be wrapped\n\nYou can wrap a function with multiple decorators\n\nThe @staticmethod decorator is a python language built-in\n\nConverts a method into a static method\nStatic methods can exist even without an instance of the given class\n\nStatic methods can be called directly from the class e.g.\n\n  print(Contact.valid_session_length(5))\n\nFalse\n\n\n\n\n\nInput validation is a very common use-case for static methods. Consider the following questions to understand static validation methods\n\nWhy does the valid_session_length method not have a self parameter?\n\nself refers to a particular object instance\nstatic methods are not associated with an instance\n\nAssociated with the class\nThus no self to refer to\n\n\nWhy does the valid_session_length method not print a message to the user communicating that the session length is invalid?\n\nvalid_session_length only has responsibility for checking if a session length is valid\nHow to handle an invalid session length is the responsibility of the caller\n\ne.g. a text-based vs graphical interface may want to handle this differently\n\ne.g. display text vs a window\n\n\nThis concept of making a function responsible for one thing is called either\n\nThe single responsibility principle,\nor more generally separation of concerns\n\nHere a Contact object performs behaviours that modify or capture a the state of a clients interactions with a client\n\nHow the user responds to those states is not its responsibility\n\n\nWhat does a decorator do?\n\nA decorator is a function that wraps another function\nThey can do some work, call a function then do some clean-up\n\nCan I create my own decorators?\n\nYes\nThey are beyond the scope of this book though\n\nHow do I know when to create a static method in a class?\n\nYou want to create behaviour associated with a class, but\n\nIndependent of specific instance of a class\n\n\n\n\n\n\n\n\nadd_session prevents invalid session lengths being added to a Contact\nCurrently user has no way of knowing if a session was added\n\nMistakes might be missed\nRecords then lost\n\nNeed to indicate if add_session succeeded\nCan do so by returning a status flag from add_session rather than None\n\nTrue indicates session added\nFalse indicates session failed\n\n  def add_session(self, session_length):\n  \"\"\"\n  Adds a session (in hours) to the Contacts hours\n\n  Parameters\n  ----------\n  session_length : int | float\n      time spent on session in hours\n\n  Returns\n  -------\n  bool\n      `True` if session successfully added, else `False`\n\n  See Also\n  --------\n  Contact.valid_session_length : checks a session length is valid\n  \"\"\"\n  if not Contact.valid_session_length(session_length):\n      return False\n  self.hours_worked = self.hours_worked + session_length\n  return True\nThe calling program can then check the status\n\nBehave as appropriate on error\n\n  session_length = BTCInput.read_float(prompt=\"Session Length: \")\n  if contact.add_session(session_length):\n      print(\"Updated hours succeeded\", contact.get_hours_worked())\n  else:\n      print(\"Add hours failed\")\nThe above uses the status\n\nOn success the new hours are reported\nOn failure, the user is notified of the error\n\nThe full implementation is given in TimeTrackerWithStatusReporting.py\nThe problem with status messages is that the user can ignore them, e.g. the below variation of the previous example, ignores the return value\n\n   contact.add_session(BTCInput.read_float(prompt=\"Session Length: \"))\n   print(\"Updated hours:\", contact.get_hours_worked())\n\nThus no guarantee that failure will be handled\n\n\n\n\n\nExceptions force the caller to deal with them\n\nUnhandled exceptions crash the program\n\nExceptions are designed for when an error occurs where continuing makes no sense\n\ne.g. converting strings to numbers\nmeaningless to continue with an unconverted number\nUnless the caller specifies what to do in that case\nSo this causes an exception\n\n  x = int(\"Rob\")\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[11], line 1\n----&gt; 1 x = int(\"Rob\")\n\nValueError: invalid literal for int() with base 10: 'Rob'\n\n\n\n\nWe can make our on code throw exceptions\n\nWe use the raise keyword\n\n\n  def add_session(self, session_length):\n      \"\"\"\n      Adds a session (in hours) to the Contacts hours\n\n      Parameters\n      ----------\n      session_length : int | float\n          time spent on session in hours\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      Exception\n          Raised if invalid session length passed\n\n      See Also\n      --------\n      Contact.valid_session_length : checks a session length is valid\n      \"\"\"\n      if not Contact.valid_session_length(session_length):\n          raise Exception(\"Invalid Session Length\")\n      self.hours_worked = self.hours_worked + session_length\n\nContact’s add_session now raises an Exception if the session length is invalid\nException somewhat like a message\n\nTells the program what went wrong\n\nException class provides behaviours for exceptions\n\nTakes a string as an initializer argument\nstring should describe the error\n\nOnce raised, the exception is either,\n\nhandled by an Except handler inside a try block\nStops the program with an error\n\nThe complete integration of the above is given byy TimeTrackerWithException.py\n\n\n\n\nInvestigate how exceptions are raised using the sample program Time Tracker with Exception\nStart a python interpreter and run the example program above, select option \\(1\\) on the menu, and enter the following,\n\n\n\nTime Tracker\n\n\n\n1. New Contact\n\n2. Find Contact\n\n3. Edit Contact\n\n4. Add Session\n\n5. Exit Program\n\n\n\nEnter your command: 1\n\nCreate new contact\n\nEnter the contact name:  Rob Miles\n\nEnter the contact address:  18 Pussycat Mews, London, NE1 410S\n\nEnter the contact phone:  1234 56789 \n\n\n\n\nNow add a session lasting 2 hours to the contact using option 4:\n\n\n\nEnter your command:  4\n\nadd session\n\nEnter the contact name:  Rob Miles\n\nName: Rob Miles\n\nPrevious hours worked: 0\n\nSession Length:  2\n\nUpdated hours worked: 2.0\n\n\n\n\nThis should work because \\(2\\) is a valid session length, now repeat but attempt to add a session length of \\(4\\), which should be invalid,\n\n\n\nEnter your command:  4\n\nadd session\n\nEnter the contact name:  Rob Miles\n\nName: Rob Miles\n\nPrevious hours worked: 2.0\n\nSession Length:  4\n\n\n\n\n\n\n\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\nCell In[16], line 3\n      1 rob = Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"1234 56789\")\n      2 add_session(rob, 2)\n----&gt; 3 add_session(rob, 4)\n\nCell In[12], line 24, in add_session(self, session_length)\n      2 \"\"\"\n      3 Adds a session (in hours) to the Contacts hours\n      4 \n   (...)     21 Contact.valid_session_length : checks a session length is valid\n     22 \"\"\"\n     23 if not Contact.valid_session_length(session_length):\n---&gt; 24     raise Exception(\"Invalid Session Length\")\n     25 self.hours_worked = self.hours_worked + session_length\n\nException: Invalid Session Length\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nOur implementation will look slightly different to the above (which is the book code) because it has additional logic for handling duplicates. But follow the steps and the prompts and you should get roughly the same process\n\n\n\n\n\n\nNow that we can raise exceptions, how do we handle them?\nWe’ve seen that we control jumps to an appropriate except but what if we want to access the message in the exception?\n\nWe can use the as keyword to assign the exception a variable label\nWe modify the user call to the Contact object, add_session as, (see the full implementation as TimeTrackerWithExceptionHandler.py)\n\n  hours_worked = BTCInput.read_float(prompt=\"Enter hours spent: \")\n  try:\n      contact.add_session(hours_worked)\n      print(\"Updated hours succeeded:\", contact.get_hours_worked())\n  except Exception as e:\n      print(\"Add failed:\", e)\nThe main change is rather than just going except Exception: we add a as e\n\nDefines a variable e that stores the exception\ne exists for the scope of the except block\n\nPassing an exception to print prints our the message associated with the exception\nA representative use might look like,\n\n\n\n\nEnter your command:  4\n\nadd session\n\nEnter the contact name:  Rob Miles\n\nName: Rob Miles\n\nPrevious hours worked: 2.0\n\nSession Length:  -1\n\nAdd failed: Invalid Session Length\n\n\n\n\n\n\n\nRepeat the steps in the previous example but this time use the new code in Time Tracker with Exception Handler. You should find the program runs and the errors are captured without causing a crash\n\n\n\nConsider the following questions about dealing with exceptions\n\nWhy does this version of the program not check the result returned by add_session?\n\nThis implementation of add_session returns None\nInstead an exception is raised to indicate a failure state\nThere is therefore nothing to check\n\nIsn’t raising an exception and stopping the program when something goes wrong a bit harsh?\n\nDepends on your philosophy\nGenerally you want to avoid silent errors\ni.e. errors that are undetected by the user\nExceptions force the user to handle the error rather than silently ignore it\nIf the user wants to avoid exception handling, they can explicitly use validate_session_length\n\nCan a method be resumed once it has raised an exception?\n\nNo\nExceptions immediately terminate the normal control flow\nThe user can always call the function again\n\nWhy would you want to create your own types of exceptions?\n\nAllows any errors returned to be descriptive to your specific code\ne.g. if your program relies on a specific file being loaded you might want a more descriptive error message than the standard FileException provides\nError management and reporting should be decided early in a program\n\nShould I always use exceptions to indicate something has gone wrong?\n\nDepends\n\nYou may not care about handling all types of errors\n\nExceptions ensure errors are dealt with\n\nUser can customise the error handling in response to exception\ne.g. for a text-based vs GUI interface\n\n\nWhy have we made add_session work like this? The program worked before we made this change\n\nTechnically correct\n\nOld code used the error status to validate code\n\nArguably cleaner with the new error handling\n\nKnowledge about the Contact class has been centralised in the Contact class itself\nNo need to have external variables storing information about valid session length or doing the validation\n\nTypically a good idea to put all knowledge about a classes behaviour in the class itself\n\n\n\n\n\n\n\nClient no longer needs to directly interact with hours_worked\nHowever, client can still modify hours_worked\n\nProgrammer could accidentally change the value\nCould also intentionally change it to break the code\n\nIdeally we want to prevent it being directly modified\n\n\n\n\n\n\n\nWarning\n\n\n\nPython protects against mistakes, not attacks\nPython provides features to help protect data attributes against accidental modifications. However, they don’t stop a programmer who intentionally (and perhaps maliciously) decides they want to modify the data attributes.\nThere is no mechanism in the python language to prevent another programmer adding code that changes hours_worked in the Contact object\n\n\n\nBy convention, python dictates that an attribute name starting with _ should not be used outside the class\n\nAlso referred to as being internal to the class\ne.g. _hours_worked means that the variable should not be touched\n  def get_hours_worked(self):\n      \"\"\"\n      Gets the hours worked for this contact\n\n      Returns\n      -------\n      int | float\n          hours worked for this contact\n      \"\"\"\n      return self._hours_worked\n\nAbove we provide a get_hours_worked method to get the value of _hours_worked\n\n_ indicates not to modify hours_worked itself\n\nNo actual protection for _hours_worked\n\nCould still be ignored by a programmer\n\nCan get greater security through, name-mangling\n\nstarting a variable name with double underscores __\n\nname-mangling makes it harder to access and modify the variable\n\n\n\nFollow the following steps to examine how to make a python class secure. Open a python interpreter and enter the statements below\n\n    class Secret:\n        def __init__(self):\n            self._secret = 99\n            self.__top_secret = 100\n\nThe above creates a class Secret which has two attributes, _secret and __top_secret\nCreate an instance of the Secret class\n\n    x = Secret()\n\nThe above creates a new instance of a Secret class and stores it with the variable x.\nTry to access the _secret attribute on x\n\n    x._secret\n\n99\n\n\nEven though we said that _ indicates we should not access the data attribute, we can see that nothing stops us from doing so\nNow try to access the __top_secret attribute\n\n    x.__top_secret\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[21], line 1\n----&gt; 1 x.__top_secret\n\nAttributeError: 'Secret' object has no attribute '__top_secret'\n\n\n\nThis time we get an AttributeError which suggests that there is no __top_secret attribute associated with the Secret class\nHowever, Python has performed some “name-mangling” to the name __top_secret. Inside the Secret class we can refer to __top_secret. Outside the class, the variable name is prepended with the class name (and an underscore). So we can still access it, as the below proves\n\n    x._Secret__top_secret\n\n100\n\n\nName-mangling thus secures us against accidental attribute use, however any one who knows the name mangling scheme and our attributes can still modify the data attribute if they want to\nThere are programs that check against this kind of bad code behaviour. One example is pylint\n\n\n\n\n\nOur current methods for the Contact class are all intended to be used by clients\n\nReferred to as public methods\n\nWe might also want to protect methods in a class\nCan use _ prefix to indicate that it should not be used\nOr __ prefix to name mangle\n\n\n\n\n\n\n\nTip\n\n\n\nWriting secure code is all about workflow\nMaking a secure program is all about establishing a workflow to generate quality code. For example, using prototypes to make sure that a customer agrees with the direction of a program early in the development\nThe next step is to sensible design and tools like pylint to make sure we’re writing good quality code.\n\n\n\n\n\n\n\nWe’ve talked about protecting hours_spent for our Contact\nWe should add more business logic to ensure that name, address and telephone items are sensible\n\nAs a purely toy example, lets say they must each be \\(4\\) characters long\n\nRealistically they would be discussed and confirmed with the customer\n\n\nclass Contact:\n\n    __min_text_length = 4\n\n    @staticmethod\n    def valid_text(text):\n        \"\"\"\n        Validates text to be stored in the contact storage\n\n        Parameters\n        ----------\n        text : str\n            text string to store\n\n        Returns\n        -------\n        bool\n            `True` if the text is valid, else `False`\n        \"\"\"\n\n        if len(text) &lt; Contact.__min_text_length:\n            return False\n        else:\n            return True\n\n\nAbove mirrors valid_session_length\nCalled to validate text to be stored in a Contact\nWe could then name mangle name, address, telephone\nSupply methods to get and set these attributes\n\ne.g. set_name and get_name for example\n\nPython has a built-in way for providing read and write access to protected data\nThis is called a Property\n\nProperties preserve simple access, while allowing us to implement validation\n\n\n\n\n\nclass Contact:\n    __min_text_length = 4\n\n    @staticmethod\n    def valid_text(text):\n        \"\"\"\n        Validates text to be stored in the contact storage\n\n        Valid input must be have a length greater than or\n        equal to `Contact.__min_text_length`\n\n        Parameters\n        ----------\n        text : str\n            text string to store\n\n        Returns\n        -------\n        bool\n            `True` if the text is valid, else `False`\n        \"\"\"\n        if len(text) &lt; Contact.__min_text_length:\n            return False\n        else:\n            return True\n\n    @property  # decorator makes name a property\n    def name(self):  # name of property function to get the name\n        \"\"\"\n        name : str\n            Contact Name\n\n        Raises\n        ------\n        Exception\n            raised if new name is invalid\n\n        See Also\n        --------\n        Contact.valid_text : validates text input\n        \"\"\"\n        return self.__name  # return private attribute containing the name\n\n    @name.setter  # decorator to identify the setter for name\n    def name(self, name):\n        if not Contact.validate_text(name):\n            raise Exception(\"Invalid name\")\n        self.__name = name\n\nThe code above shows how to implement a property for name in the Contact class. The property implements validation and rejects invalid names. Work through the following questions to understand properties\n\nHow does the value being set in the property get into the setter?\n\nsetter is called with two parameters\nself refers to the object on which the setter is being called\nThe second is the proposed value to set the property to\n\nHere it is setting the name attribute\n\n\nHow does the program know which setter method to call for a particular property?\n\nThe setter decorator has the format property.setter\n\nAssociates a setter to a property\n\n\nMust the setter method raise an exception if the value is being set is not valid?\n\nNo\nsetter could ignore invalid values, or assign a default\nExceptions allow us to inform the user that the set has failed\n\nAnd also forces the user to deal with the error\n\n\nDo we need to perform the same validation for all properties in a class?\n\nNo\nWe could test that telephone is purely numeric (for example)\n\nThis is not a good idea for real telephone numbers\n\nWe could ensure address matches a certain structure for a valid address\n\nMust a property have a setter?\n\nNo\nProperties without a setter are read-only\nThey cannot be modified\nWe could use this to remove the get_hours_worked method\n\nUse a property instead\n\n\n\n\n\n\nInvestigate how properties work. Open up the python interpreter and enter the statements below\n\nclass Prop:\n    @property\n    def x(self):\n        print(\"got property x\")\n        return self.__x\n    @x.setter\n    def x(self, x):\n        print(\"set property x:\", x)\n        self.__x = x\n\nThis creates a new class Prop with a property x that has a setter\nNow create an instance of this class as below\n\n    test = Prop()\n\nPut a value for x into the test instance\n\n    test.x = 99\n\nset property x: 99\n\n\nWhen python executes the above, it runs the setter method for the property. As we can see from the output above.\nNow try to read the property\n\n    print(test.x)\n\ngot property x\n99\n\n\nWhen reading the property, python runs the property method, as indicated above\nWe can combine getting and setting in complex expressions, execute the following\n\n    test.x = test.x + 1\n\ngot property x\nset property x: 100\n\n\nWe can see that first the getter is called to get the current value of x, then the setter is called to update it to the expression on the right\nTo convert the Contact class to use properties for name, telephone and address we have to add properties and then setters\n\nThe relevant changes to the Contact class are then,\n\n\nclass Contact:\n    \"\"\"\n    Contact with a name, address and telephone number.\n    Tracks the hours worked with a client\n\n    Attributes\n    ----------\n    name : str\n        Contact Name\n    address : str\n        Contact's postal or street address.\n    telephone : str\n        Contact phone number (stored as a string).\n\n\n    Examples\n    --------\n    &gt;&gt;&gt; Contact(\"Rob Miles\", \"18 Pussycat Mews, London, NE1 410S\", \"+44(1234) 56789\")\n    &lt;Contact ...&gt;\n    \"\"\"\n\n    __min_session_length = 0.5\n    __max_session_length = 3.5\n\n    @staticmethod\n    def valid_session_length(session_length):\n        \"\"\"\n        Check a session length is valid\n\n        Parameters\n        ----------\n        session_length : int | float\n            length of a consult session in hours\n\n        Returns\n        -------\n        bool\n            `True` if the session length is valid else `False`\n        \"\"\"\n        if (\n            session_length &lt; Contact.__min_session_length\n            or session_length &gt; Contact.__max_session_length\n        ):\n            return False\n        return True\n\n    __min_text_length = 4\n\n    @staticmethod\n    def valid_text(text):\n        \"\"\"\n        Validates text to be stored in the contact storage\n\n        Valid input must be have a length greater than or\n        equal to `Contact.__min_text_length`\n\n        Parameters\n        ----------\n        text : str\n            text string to store\n\n        Returns\n        -------\n        bool\n            `True` if the text is valid, else `False`\n        \"\"\"\n        if len(text) &lt; Contact.__min_text_length:\n            return False\n        else:\n            return True\n\n    @property\n    def name(self):\n        \"\"\"\n        name : str\n            Contact Name\n\n        Raises\n        ------\n        Exception\n            raised if new name is invalid\n\n        See Also\n        --------\n        Contact.valid_text : validates text input\n        \"\"\"\n        return self.__name\n\n    @name.setter\n    def name(self, name):\n        if not Contact.valid_text(name):\n            raise Exception(\"Invalid name\")\n        self.__name = name\n\n    @property\n    def address(self):\n        \"\"\"\n        address : str\n            Contact Address\n\n        Raises\n        ------\n        Exception\n            raised if new address is invalid\n\n        See Also\n        --------\n        Contact.valid_text : validates text input\n        \"\"\"\n        return self.__address\n\n    @address.setter\n    def address(self, address):\n        if not Contact.valid_text(address):\n            raise Exception(\"Invalid address\")\n        self.__address = address\n\n    @property\n    def telephone(self):\n        \"\"\"\n        telephone : str\n            Contact Telephone\n\n        Raises\n        ------\n        Exception\n            raised if new telephone is invalid\n\n        See Also\n        --------\n        Contact.valid_text : validates text input\n        \"\"\"\n        return self.__telephone\n\n    @telephone.setter\n    def telephone(self, telephone):\n        if not Contact.valid_text(telephone):\n            raise Exception(\"Invalid telephone\")\n        self.__telephone = telephone\n\n    def __init__(self, name, address, telephone):\n        \"\"\"\n        Create a new Contact instance\n\n        Parameters\n        ----------\n        name : str\n            Contact Name\n        address : str\n            Contact's postal or street address.\n        telephone : str\n            Contact phone number (stored as a string).\n        \"\"\"\n        self.name = name\n        self.address = address\n        self.telephone = telephone\n        self.__hours_worked = 0\n\n\nThe great thing about properties is they can be effectively drop in for traditional attributes\n\nWe make the attributes themselves name mangled\nDefine properties to mask the original names\n\nNo need to update the downstream calling code\n\nproperty syntax matches the traditional access pattern\n\nThe complete integration is seen in TimeTrackerWithProperties.py\n\n\n\n\n\n\n\nCaution\n\n\n\nFailures in property code can be confusing\nThe example program implements the name, address and telephone number elements of a contact as properties. Setting a property to an invalid value will cause an exception. The initializer looks like,\n    def __init__(self, name, address, telephone):\n        self.name = name\n        self.address = address\n        self.telephone = telephone\n        self.__hours_worked = 0\nThese statements look like normal variable assignments, nothing here indicates that these steps can fail. However, the following statement fails,\n\n    rob = Contact(name=\"Rob\", address=\"18 Pussycat Mews, London NE1 410S\", telephone=\"1234 56789\")\n\n\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\nCell In[31], line 1\n----&gt; 1 rob = Contact(name=\"Rob\", address=\"18 Pussycat Mews, London NE1 410S\", telephone=\"1234 56789\")\n\nCell In[30], line 154, in Contact.__init__(self, name, address, telephone)\n    141 def __init__(self, name, address, telephone):\n    142     \"\"\"\n    143     Create a new Contact instance\n    144 \n   (...)    152         Contact phone number (stored as a string).\n    153     \"\"\"\n--&gt; 154     self.name = name\n    155     self.address = address\n    156     self.telephone = telephone\n\nCell In[30], line 92, in Contact.name(self, name)\n     89 @name.setter\n     90 def name(self, name):\n     91     if not Contact.valid_text(name):\n---&gt; 92         raise Exception(\"Invalid name\")\n     93     self.__name = name\n\nException: Invalid name\n\n\n\nThe above raises an exception because the value Rob passed for the name property is too short. __init__ attempts to set name which calls the setter, and the property code raises an exception.\nProgrammers may expect methods or functions to cause exceptions but they typically do not expect statements that look like variable assignments. When implementing properties you need to be clear about how they work and how to handle failure.\nWe could extend our previous error handling code to add additional exception handlers to handle invalid assignments\n\n\n\n\n\n\n\nScenario\nThe lawyer likes your program but would now like to use it for billing. The program should track both the hours worked for a client and the the billing amount owed by each contact\nPrices are calculated as follows, for every session worked there is - A $30 flat case fee - A $50 hourly fee\nFor example a one hour session would cost $80\nThe client wants the billing amount to be automatically updated each time they add a session. Displaying a contact should then also display the billing amount\nName: Rob Miles\nAddress: 18 Pussycat Mews, London, NE1 410S\nTelephone: 1234 56789\nHours on the case: 2.0\nBilling amount: 130.0\n\n\n\nWork through the following questions to understand how we design managing the billing amount\n\nHow would we store the billing amount for a contact?\n\nStore as a data attribute on a Contact object\nManage like __hours_worked with validators\nLet’s call it __billing_amount\n\nWhy does __billing_amount have two leading underscores in the name?\n\nIndicates the variable is private to the class\nProvides name-mangling to reduce chance for accidental use\nProvide access via a read-only property\n  @property\n  def billing_amount(self):\n      return self.__billing_amount\nWe omit a setter, the property cannot be directly modified\nCan then access the property as we would expect\n  print(\"Rob owes:\", rob.billing_amount)\nSame output might look like,\n  #| echo: false\n  print(\"Rob owes:\", 130.0)\n\nWhat would the statement calculating the billable amount for a session look like?\n\nAt it’s most basic the statement might look like,\n  amount_to_bill = 30 + (50 * session_length)\nsession_length value is multiplied by the hourly rate (\\(50\\))\nflat fee \\(30\\) is added to the total\nCan then add this to the billing amount\n  self.__billing_amount = self.billing_amount + amount_to_bill\nObserve that this approach means that each session incurs the same \\(30\\) case opening fee\nIt’s possible multiple sessions might be spent on the same case\n\nMight not incur the \\(30\\) fee each time\nThis would be something to confirm with the client\n\n\nIs it sensible to just use the values \\(30\\) and \\(50\\) in this code?\n\nNo\nThey are magic constants\nBetter to make them internal class variables of the Contact class\n  class Contact\n      __open_fee = 30\n      __hourly_fee = 50\nObserve that we flag them as private, they are internals for the class\nThe new amount to bill statement is then,\n  amount_to_bill = Contact.__open_fee + (Contact.__hourly_fee * session_length)\n\nWhere should the above statement go?\n\nAdjusting the billing is something that occurs when we add a session\nMakes sense to go in the add_session code of the Contact class\n  def add_session(self, session_length):\n      \"\"\"\n      Adds a session (in hours) to the Contacts hours\n\n      Updates the Contact's session hours and calculates\n      the billable amount owed\n\n      Parameters\n      ----------\n      session_length : int | float\n          time spent on session in hours\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      Exception\n          Raised if invalid session length passed\n\n      See Also\n      --------\n      Contact.valid_session_length : checks a session length is valid\n      \"\"\"\n      if not Contact.validate_session_length(session_length):\n          raise Exception(\"Invalid session length\")\n      self.__hours_worked = self.__hours_worked + session_length\n      amount_to_bill = Contact.__open_fee + (Contact.__hourly_fee * session_length)\n      self.__billing_amount = self.__billing_amount + amount_to_bill\n      return\nBilling amount is updated after we have validated and updated the hours worked\n\n\n\nWe change the display_contact method to add the billing amount\n\ndef display_contact(contact):\n    \"\"\"\n    Displays the Contact details for the supplied contact\n\n    Parameters\n    ----------\n    contact : Contact\n        contact to display\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_contacts : Displays all contacts matching a search name\n    \"\"\"\n    print(\"Name:\", contact.name)\n    print(\"Address:\", contact.address)\n    print(\"Telephone:\", contact.telephone)\n    print(\"Hours worked for this Contact:\", contact.get_hours_worked(), \"\\n\")\n    print(\"Amount to bill:\", contact.billing_amount)\n\nThe complete program can be found in Time Tracker with Billing Amount\n\n\n\n\n\nThe new program works, but it has a problem\nContacts saved under the old system, won’t work\n\nThey will load\nBut whe we try to display or add a session we’ll get an error, like\n\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[32], line 1\n----&gt; 1 raise AttributeError(\"'Contact' object has no attribute '_Contact__billing_amount'\")\n\nAttributeError: 'Contact' object has no attribute '_Contact__billing_amount'\n\n\n\n\nThis occurs because the program attempts to access the __billing_access attribute\nOld versions of the Contact class didn’t have this\n\nSo error occurs\n\nSame might occur if we make more modifications in the future\n\n\n\n\nWe can solve this by versioning a class\nAdd a version attribute to each class\n\nSimply a numeric attribute\n\n  def __init__(self, name, address, telephone):\n      \"\"\"\n      Create a new `Contact` instance\n\n      Parameters\n      ----------\n      name : str\n          Contact Name\n      address : str\n          Contact's postal or street address.\n      telephone : str\n          Contact phone number (stored as a string).\n      \"\"\"\n      self.name = name\n      self.address = address\n      self.telephone = telephone\n      self.__hours_worked = 0\n      self.__billing_amount = 0\n      self.__version = 1\nversion is set as a private variable\n\n\n\n\n\nThen create a method to check the version of a Contact\n\nLet’s us check that a Contact object matches the current version\n\n  def check_version(self):\n      \"\"\"\n      Check the version of a `Contact` instance\n\n      Upgrades the instance to the most recent version\n      if required\n\n      Returns\n      -------\n      None\n      \"\"\"\n      pass\nLeave it as a stub for now\nWe want to use it when we load contacts to check versions\nUpdated load_contacts is below\n  def load_contacts(file_name):\n  \"\"\"\n  Loads the contacts from the given file\n\n  Contacts are stored in binary as a pickled file\n\n  Parameters\n  ----------\n  file_name : str\n      string giving the path to the file where the contacts data is stored\n\n  Returns\n  -------\n  None\n      Contact detail is loaded into the global `contacts` value\n\n  Raises\n  ------\n      Exceptions if contacts failed to load\n\n  See Also\n  --------\n  save_contacts : saves contacts to a pickled file\n  \"\"\"\n  global contacts\n  print(\"Load contacts\")\n  with open(file_name, \"rb\") as input_file:\n      contacts = pickle.load(input_file)\n  # Update version of loaded contacts if required\n  for contact in contacts:\n      contact.check_version()\n\n\n\n\n\nNow we want to write code to upgrade a Contact\nFor our version \\(1\\), we want to upgrade any class that does not have a __billing_amount attribute\nIn future we might define a version \\(2\\), then we would redefine the check_version method to upgrade any class that isn’t version \\(2\\)\n  def check_version(self):\n  \"\"\"\n  Check the version of a `Contact` instance\n\n  Upgrades the instance to the most recent version\n  if required\n\n  Returns\n  -------\n  None\n  \"\"\"\n  try:\n      if not self.__version == 1:\n          self.__billing_amount = 0\n          self.__version = 1\n  except AttributeError:\n      self.__billing_amount = 0\n      self.__version = 1\nWe first attempt to check the version number\nIf it’s not the current version (\\(1\\)) we upgrade the class\n\nAdd a .__billing_amount attribute defaulted to zero\nUpgrade the version number\n\nUse a try...except block to catch the AttributeError if the version doesn’t exist (i.e. for old instances pre-versioning)\n\nPerform the upgrade\n\n\n\n\n\nTo get a better understanding of versioning, work through the following steps\nStart by running the program TimeTrackerWithPropertiesAndExceptionHandling.py. Create a new contact as below\n\n\n\nEnter your command: 1\n\nCreate new contact\n\nEnter the contact name: Rob Miles\n\nEnter the contact address: 18 Pussycat Mews, London, NE1 410S\n\nEnter the contact phone: 1234 56789\n\n\n\n\nThis creates a new contact, which looks like, (use Find Contact)\n\n\nName: Rob Miles\nAddress: 18 Pussycat Mews, London, NE1 410S\nTelephone: 1234 56789\nHours on the case: 0\n\n\nAs we can see this version is missing the billable hours information\nExit the program so the contact is saved. Now load this pickle file with TimeTrackerWithVersion.py\nThis should load the contact (which is unversioned), and upgrade it to the versioned variant with a billing amount\nAttempt to display this contact, you should see something like\n\n\nName: Rob Miles\nAddress: 18 Pussycat Mews, London, NE1 410S\nTelephone: 1234 56789\nHours on the case: 0\nAmount to bill: 0\n\n\nAs we can see, the amount to bill is now correctly displayed\n\n\n\n\n\n\nImportant\n\n\n\nAdd version management when you design data storage\nWhen starting a project you should consider which items are being stored and if they need version management. For example in the Time Tracker program we expect that the client will request changes to the features, so we should consider versioning it from the start\nEvery time a new version of a program is installed, we then have to go through the process of updating the underlying data to the new version\nWhen writing a program for a customer, you should consider how long it will take to write code that deal with data updates (or migrations). This can make trivial programs significantly more complex\n\n\n\n\n\n\n\nEach time we add a new attribute to the Contact class we have to modify display_contact\nWould be nice just to be able to print a Contact directly\nHowever, doing so, we find the output is pretty useless (using the mock below)\n\n  class Contact:\n      def __init__(self, name, address, telephone):\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n\n  contact = Contact(\"Rob Miles\", \"Pussycat Mews\", \"1234\")\n\n  def display_contact(contact):\n      print(contact)\n\n  display_contact(contact)\n\n&lt;__main__.Contact object at 0x7f479c69f650&gt;\n\n\ndefault for objects is the class name following by the memory address of the object\npython objects have a __str__ method\n\nUsed whenever the an object needs to be converted to a string\n\nTo change the default behaviour for our objects we need to redefine __str__\n  class Contact:\n      ...\n      def __str__(self):\n          return \"Name: \" + self.name + \"\\n\" + \\\n          \"Address: \" + self.address + \"\\n\" + \\\n          \"Telephone: \" + self.telephone + \"\\n\" + \\\n          \"Hours on the case: \" + str(self.hours_worked) + \"\\n\" + \\\n          \"Amount to bill: \" + str(self.billing_amount)\nThe \\ character above is used to continue the string onto a new line\nprinting now, we get what we expect\n\n  display_contact(contact)\n\nName: Rob Miles\nAddress: Pussycat Mews\nTelephone: 1234\nHours on the case: 0\nAmount to bill: 0\n\n\n\n\n\n\nWriting the string as a series of concatenations isn’t the cleanest\nDifficult to maintain and ensure correctness as we modify the class\nWe can use format to create a formatted string\n\nLets us write a shorter string\nformat is a string method\nformat takes in values as arguments and injects them into the string\n\n  class Contact:\n      ...\n      def __str__(self):\n          template = \"\"\"Name: {0}\nAddress: {1}\nTelephone: {2}\nHours on the case: {3}\nAmount to bill: {4}\"\"\"\n          return template.format(self.name, self.address, self.telephone, self.hours_worked, self.billing_amount)\nValues in format are inserted at marked points in the string\nMarked points are {n} where \\(n\\) is the index of the argument to substitute\n\nStarting from \\(0\\)\n\n\n\n\n\nOpen the python interpreter and work through the following steps to understand how string formatting works\nEnter the statements below\n\nname = \"Rob Miles\"\nage = 21\n\nThe above creates two variables name and age\nNow create the following template string\n\ntemplate = \"My name is {0} and my age is {1}\"\n\nThe just creates a string called template, {0} and {1} are two placeholder indicators for the format function\nNow call the format method on template\n\ntemplate.format(name, age)\n\n'My name is Rob Miles and my age is 21'\n\n\nAs we can see the placeholder values have been substituted with the values of the name and age value\nWe can add additional formatting information. Redefine and format the template as follows\n\ntemplate = \"My name is {0:20} and my age is {1:10}\"\ntemplate.format(name, age)\n\n'My name is Rob Miles            and my age is         21'\n\n\nWe write the placeholder as {n:w} where \\(n\\) is the index of the placeholder. \\(w\\) is the width value, as you can see from above, the value is still substituted but then spaces are added to pad out to the width. This is useful for defining columns. We use a : to separate the format specifiers from the placeholder index\nFor floating point values you can also specify the number of decimal places to be printed\n\ntemplate = \"My name is {0:20} and my age is {1:10.2f}\"\ntemplate.format(name, age)\n\n'My name is Rob Miles            and my age is      21.00'\n\n\nThe above now prints the age with two decimal places. The full details of the string formatting mini language can be found at the python docs\nYou can find the full version of Time Tracker using the string method in\n\n\n\n\n\n\nOur client now gives us a new scenario\n\n\nThe client would like to record when each specific session for a contact took place. You and the client specify the following design,\n\nTime Tracker\n1. New Contact\n2. Find Contact\n3. Edit Contact\n4. Add Session\n5. Exit Program\n\nEnter you command: 2\nEnter  the contact name: Rob\nName: Rob Miles\nAddress: 18 Pussycat Mews, London, NE1 410S\nTelephone: 1234 56789\nHours on the case: 10.0\nAmount to bill: 470.0\nSessions\nDate: Mon Jul 10 11:30:00 2017 Length: 1.0\nDate: Tue Jul 12 11:30:00 2017 Length: 2.0\nDate: Wed Jul 19 11:30:00 2017 Length: 2.5\nDate: Wed Jul 26 10:30:00 2017 Length: 2.5\nDate: Mon Jul 31 16:51:45 2017 Length: 1.0\nDate: Mon Aug 14 16:51:45 2017 Length: 1.0\n\n\nFinding a contact now displays the sessions as a list\nNot immediately clear how we would add this to our class\n\n\n\nLet’s do some design work, for handling a session. Work through the following questions\n\nHow will we store information about a session?\n\nWe need to store a bunch of heterogeneous related data\nGood idea to consider a class, say Session\nNeed to consider data to store\n\nlength of a session\ndate and time of the session\n\nWe should also move the Contact class attributes validating a session length to the Session class\n\n\n import time\n class Session:\n     \"\"\"\n     Session with a length and a date time it was conducted\n     \"\"\"\n\n     __min_session_length = 0.5\n     __max_session_length = 3.5\n\n     @staticmethod\n     def valid_session_length(session_length):\n         \"\"\"\n         Check a session length is valid\n\n         Parameters\n         ----------\n         session_length : int | float\n             length of a consult session in hours\n\n         Returns\n         -------\n         bool\n             `True` if the session length is valid else `False`\n         \"\"\"\n         if (\n             session_length &lt; Session.__min_session_length\n             or session_length &gt; Session.__max_session_length\n         ):\n             return False\n         return True\n\n     def __init__(self, session_length):\n         \"\"\"\n         Create a new `Session` instance\n\n         Parameters\n         ----------\n         session_length : int | float\n             length of a session\n\n         Raises\n         ------\n         Exception\n             Raised if `session_length` is invalid\n\n         See Also\n         --------\n         Session.valid_session_length : validates session lengths\n         \"\"\"\n         if not Session.valid_session_length(session_length):\n             raise Exception(\"Invalid session length\")\n         self.__session_length = session_length\n         self.__session_end_time = time.localtime()\n         self.__version = 1\n\n\nWe can now create Session objects\n\n  session_length = 2\n  session_record = Session(session_length)\n  print(session_record)\n\n&lt;__main__.Session object at 0x7f479c6b8410&gt;\n\n\ncreates a Session with the passed session_length parameter\nvalidate_session_length moved to Session\n\nvalidates session lengths at object creation\nException raised if invalid session length is passed\n\n__init__ uses time library to get the local time\n\nStored in __session_end_time attribute\n\n\nAre we using version control for the Session class?\n\nYes\nHighly likely the Session object might change\nEspecially if we change our mind on what responsibility is in the Contact class vs the Session class\nThus also want to implement a check_version method\n  def check_version(self):\n      \"\"\"\n      Check the version of a `Contact` instance\n\n      Upgrades the instance to the most recent version\n      if required\n\n      Returns\n      -------\n      None\n      \"\"\"\n      pass\nCurrently does nothing\n\nAll Session instances will be versioned\nOnly one version, so no need to edit\n\n\nHow will we allow users of the Session class to get the session length and session end time items from a Session object?\n\nWe add these as properties\nWant these to be read-only so no setter is provided\n\n @property\n def session_length(self):\n     \"\"\"\n     session_length : int | float\n         length (in hours) of this session\n     \"\"\"\n     return self.__session_length\n\n @property\n def session_end_time(self):\n     \"\"\"\n     session_end_time : time.struct_time\n         date and time of the session\n     \"\"\"\n     return self.__session_end_time\nWill the Session class have a __str__ method?\n\nYes\nReturn a string describing a Session instance\n\n def __str__(self):\n     template = \"Date: {0} Length: {1}\"\n     #convert time object string\n     date_string = time.asctime(self.__session_end_time)\n     return template.format(date_string, self.__session_length)\n\ntime library contains asctime\n\nTakes a localtime value and returns a string representation\n\nThen format the string\n\n\n\nGiven the Session object, we now need to incorporate this into the Contact object\nContact objects contain a list of sessions\n\nInitialised empty\n\nWe also need to bump the version number\n\nWhich means we also need to update the check_version method\nNow need to handle the conversion from no version to version 2 and version 1 to version 2\n\n  def check_version(self):\n      \"\"\"\n      Check the version of a `Contact` instance\n\n      Upgrades the instance to the most recent version\n      if required. This includes upgrading any Session\n      instances associated with this Contact instance\n\n      See Also\n      --------\n      Session.check_version : Checks and upgrades `Session` instances\n      \"\"\"\n      try:\n          if self.__version == 1:\n              # does not have session list\n              self.__sessions = []\n              self.__version = 2\n      except AttributeError:\n          self.__billing_amount = 0\n          self.__sessions = []\n          self.__version = 2\n\n      # now upgrade all sessions in a contact\n      for session in self.__sessions:\n          session.check_version()\nAny version \\(1\\) instance will be upgraded to version \\(2\\)\nFor old, unversioned instances, we still use the try...except to force an upgrade to the most recent\nWe also want to check that the sessions stored with a Contact are up to date\n\nSo after upgrading a Contact we check that the Session instances are up to date\n\nWe’ve written the code so that if the Session is upgraded, instances will still be upgraded even if the Contact object is the most recent version\nWe now need to modify adding a session to add a new Session instance, rather than just update the hours\n  def add_session(self, session_length):\n      \"\"\"\n      Adds a session (in hours) to the Contacts sessions\n\n      Parameters\n      ----------\n      session_length : int | float\n          time spent on session in hours\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      Exception\n          Raised if invalid session length passed\n\n      See Also\n      --------\n      Contact.valid_session_length : checks a session length is valid\n      \"\"\"\n      try:\n          self.__sessions.append(Session(session_length))\n          self.__hours_worked = self.__hours_worked + session_length\n          amount_to_bill = Contact.__open_fee + (\n              Contact.__hourly_fee * session_length\n          )\n          self.__billing_amount = self.__billing_amount + amount_to_bill\n      except Exception as e:\n          print(e)\nWe could validate the session length in add_session explicitly\n\nHowever, the Session constructor does this, via exceptions\n\nWe first try to create the Session\n\nIf it’s invalid we get an exception which we catch and handle\n\nIf created successfully we then update the hours worked and amount to bill\nLast step is to now work out how we want to display our Session instances when we report on a client\n\nOur client wants a line for each individual session\nWe need to convert the list of sessions to a string in this format\n\n  @property\n  def session_report(self):\n      \"\"\"\n      session_report : str\n          provides a string representation of a Contact's sessions\n      \"\"\"\n\n      # map converts each session to a string\n      report_strings = map(str, self.__sessions)\n      result = \"\\n\".join(report_strings)\n      return result\nUses map to convert a list of session objects to a list of their string representations\nUses join to then convert the list of strings to a single string with each element separated by a newline\n\n\n\n\n\nOur aim is to convert a list of Session objects into a list of strings\nCould do this with a loop\nAlternative is to use map\nmap takes two arguments\n\nA function name\n\nThe function must accept a single argument and return a result\n\nList of items to apply the function to\n\nfunctions can be stored in variables and passed as arguments\nmap applies the function provided (first argument) to the list (second argument) and returns the result\n\n\n\nThese next few steps go on for a quite a while. So work through it at your own pace. However, this will give you a good understanding of not just map but also some fundamentals for python\nOpen up a python interpreter and work through the following steps. We’ll use map to indent a list of strings. Run the following steps\n\ncode = ['line1', 'line2', 'line3']\n\nThis creates a list containing three strings, we can easily view the contents\n\ncode\n\n['line1', 'line2', 'line3']\n\n\nNow we need to create our indentation function. We can do this by adding four spaces (or a tab etc.) at the beginning of a string. Define the following python function\n\ndef indent(x):\n    return \"    \" + x\n\nWe can test this function, on a sample string,\n\nprint(\"Rob\")\nindent(\"Rob\")\n\nRob\n\n\n'    Rob'\n\n\nWe would like to apply the indent function to every string in the code list. We could do this using a for loop, instead we use a map function\nNow run the following statements\n\nindented_code = map(indent, code)\nindented_code\n\n&lt;map at 0x7f479c6bab30&gt;\n\n\nNaively we expected a list of indented strings. Instead we have something called a map object. map returns something called an iterator. Iterators return items from a collection or sequence one at a time. We can work through iterators using a for loop. This is how we can work through lists. range also returns an iterator\nNow run the following for loop to get the indented_code values\n\nfor s in indented_code:\n    print(s)\n\n    line1\n    line2\n    line3\n\n\nNow we have the list of strings as we were expecting. Each time around the loop the next s value is retrieved from the iterator\nIterators allow us to save memory, rather than having to store the entire result in memory we can simply generate each one as needed. Each time we ask for a new result from the map object, map gets the next value from the original collection (code) and applies the function indent to it. Once the map iterator runs out of values to return, it raises StopIteration as an exception. This stops the loop.\nLets explore this in more detail\nRecreate the statement creating the map\n\nindented_code = map(indent, code)\n\nWe can then ask for the next item from an iterator using the __next__ method.\nCall this method on indented_code\n\nindented_code.__next__()\n\n'    line1'\n\n\nWe can see this produces the next value, though in this case, it’s the first item. We can keep repeating this\nRun the following\n\nprint(indented_code.__next__())\nprint(indented_code.__next__())\nprint(indented_code.__next__())\n\n    line2\n    line3\n\n\n\n---------------------------------------------------------------------------\nStopIteration                             Traceback (most recent call last)\nCell In[54], line 3\n      1 print(indented_code.__next__())\n      2 print(indented_code.__next__())\n----&gt; 3 print(indented_code.__next__())\n\nStopIteration: \n\n\n\nWe can see that we get the next two items from the iterator, and then finally after trying to get an non-existent value we see a StopIteration exception is raised\nYou can’t reuse a iterator once it has run out of items. You have to recreate it\n\nindent_iterator = map(indent, code)\n\nIf we want to convert this to normal collection, we can do something like call list to convert to a list\nCheck this out by running the following statements\n\nindented_code = list(indent_iterator)\nindented_code\n\n['    line1', '    line2', '    line3']\n\n\nWhat happens if we make the input of a map function an iterator\nEnter the following statements to explore\n\ni1 = map(indent, code)\ni2 = map(indent, i1)\n\nWe first create the iterator i1 to apply the indent function to the list code. We then create a second iterator i2 to apply the indent function to the items of the i1 iterator\nUse list to convert i2 to a list\n\nlist(i2)\n\n['        line1', '        line2', '        line3']\n\n\nWe can see that each item is indented twice. Once by i1 and again by i2. Observe that the nested iterator i1 was also applied as part of the conversion process. Python makes it very easy to chain iterators together\nLet us return to our original use of map\nreport_strings = map(str, self.__sessions)\nHere self.__sessions is a list of Session objects. map creates an iterator that applies str to each element of self.__sessions. str itself converts each Session to a string by calling the __str__ method. We then use the join method to work through this iterator to build the final output string\n\n\n\n\n\nWe can call string methods on string literals, e.g.\n\n  \"FRED\".lower()\n\n'fred'\n\n\nAnother string method is join\nTakes an iterator as an argument\njoin merges all strings in an iterator\n\nthe string on which join is called is inserted between each item\n\n\n  report_strings = [\"1\", \"2\", \"3\"]\n  report_results = \"\\n\".join(report_strings)\n\n\n\n\nWork through the following steps with the python interpreter to understand join\nEnter the statement below\n\nreport_strings = [\"report1\", \"report2\", \"report3\", \"report4\"]\n\nThe above creates a list of four strings, report_strings. Lists are iterators so we can pass this to join\nCall the join function as below\n\n\"**\".join(report_strings)\n\n'report1**report2**report3**report4'\n\n\nAs observed we iterate over the strings, merging them with ** inserted in between. Observe that ** is not placed at the start or end of the resulting string\nRerun the statement with the newline character below\n\nprint(\"\\n\".join(report_strings))\n\nreport1\nreport2\nreport3\nreport4\n\n\nThis does the same but instead each string is printed on its own line\nWe can use join to concatenate strings by using the empty string\nRun the following statement\n\n\"\".join(report_strings)\n\n'report1report2report3report4'\n\n\n\nAfter this discussion, we have completed this version of the Time Tracker\nAside from one final thing, updating the __str__ method in Contact to use the session_report property\n  def __str__(self):\n      template = \"\"\"Name: {0}\n  Address: {1}\n  Telephone: {2}\n  Hours on the case: {3}\n  Amount to bill: {4}\n  Sessions: \\n{5}\"\"\"\n      return template.format(\n          self.name,\n          self.address,\n          self.telephone,\n          self.hours_worked,\n          self.billing_amount,\n          self.session_report,\n      )\nYou can find the final implementation in Time Tracker with Session History\n\n\n\n\n\nThe time tracker application is a very good starting point for any program that you might like to write that stores and manages information. You could replace the sessions with albums and music tracks, salesman and sales artists and pictures - or anything else you want to track\nIn the previous chapter we created a Music Storage app that stored songs and could be used to manage a single playlist. Using the framework provided by Time Tracker extend the Music Storage app to be able to manage and store multiple playlists at a time\nThankfully this isn’t as in depth as building the application the first time around. We start by defining our Playlist class\nLet us first focus on the data attributes, we want a name and a list of songs. We also want the total runtime. Now for simplicity we’ll leave the name and tracks as public attributes, but we’ll define the runtime as a property, interfacing with a protected variable __runtime. We do this because the runtime is calculated from tracks so we don’t want the caller to modify it themselves.\nInspired by Time Tracker’s session_report we’ll also define a track_report property using that interfaces with map to provide a string representation of the tracks in a playlist where each track is on its own line\nclass Playlist:\n    \"\"\"\n    A class representing a music playlist with a name and list of tracks\n\n    Tracks and records the length of the playlist\n    \"\"\"\n\n    def __init__(self, name, tracks=[]):\n        \"\"\"\n        Create a new `Playlist` instance\n\n        Parameters\n        ----------\n        name : str\n            name to associate with the playlist\n        tracks : list, optional\n            list of songs in the playlist, by default []\n        \"\"\"\n        self.name = name\n        self.tracks = tracks\n        self.__runtime = 0\n        for song in self.tracks:\n            self.__runtime += song.length_in_seconds\n\n    def __str__(self):\n        template = \"\"\"Playlist: {0}\nTotal Length: {1} s\nSongs:\n{2}\"\"\"\n        return template.format(self.name, self.runtime, self.track_report)\n\n    @property\n    def runtime(self):\n        \"\"\"\n        runtime : int\n            total run time of the playlist in seconds\n        \"\"\"\n        return self.__runtime\n\n    @property\n    def track_report(self):\n        \"\"\"\n        track_report : str\n            string representation of tracks in the playlist, giving each track\n            on its own line\n        \"\"\"\n        song_strings = map(str, self.tracks)\n        return \"\\n\".join(song_strings)\nObserve that the constructor takes an optional list of tracks (by default its empty). This means that a user can create a Playlist by name only and then add songs to it (as used in create_playlist below) or we can create a playlist with a list of songs already (as used by suggest_playlist_of_given_length)\nNow we want to keep the internal track list and the runtime synchronised, so we add methods on the Playlist class to handle adding, removing and clearing tracks from the playlist\ndef add_track(self, track):\n    \"\"\"\n    Add a new track to the playlist\n\n    Updates the playlist length\n\n    Parameters\n    ----------\n    track : MusicTrack\n        track to add to the playlist\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    Playlist.remove_track : removes a track from a playlist\n    \"\"\"\n    # first update runtime so a non-track objects causes an error\n    self.__runtime += track.length_in_seconds\n    self.tracks.append(track)\n\ndef remove_track(self, track):\n    \"\"\"\n    Remove a track from the playlist\n\n    Parameters\n    ----------\n    track : MusicTrack\n        track to remove from the playlist\n\n    See Also\n    --------\n    Playlist.add_track : add a track to a playlist\n    Playlist.clear_tracks : remove all tracks from a playlist\n    \"\"\"\n    try:\n        self.tracks.remove(track)\n        self.__runtime -= track.length_in_seconds\n    except ValueError:\n        print(\"Could not find track:\", track.name, \"in the playlist\")\n\ndef clear_tracks(self):\n    \"\"\"\n    Remove all tracks from a playlist\n\n    Runtime is set to 0\n\n    See Also\n    --------\n    Playlist.remove_track : remove a single track from a playlist\n    \"\"\"\n    self.tracks.clear()\n    self.__runtime = 0\nThese are all relatively simple, the takeaway is that as we update the track list, we also ensure the runtime is kept synchronised\n\n\n\n\n\n\nWarning\n\n\n\nIt is important to keep data synchronised\nWe store the runtime as a separate variable so that we don’t need to calculate it on the fly every time a function requires it. However this introduces the difficulty that we have to keep runtime synched with the data it is representing (the sum of the length of the tracks in the tracks attribute). This is important in real world scenarios, as if these two data attributes diverge we might get nonsense results.\nThis is actually one of the big reasons why we like to make data attributes private, it ensures we can maintain the relationships between elements.\n\n\nAs written our code has the problem that data could become desynchronised because the user can directly modify the tracks list. We can’t get around this easily by making a read-only property, because it we return a reference to a list, than any changes on that reference would propagate to the original list\nOne option would be to provide a deep copy (a unique copy for each call), or another would be make tracks private and define methods on the class for all the necessary interactions. I haven’t done this to minimise the disruption to the overall API, since this current API lets us reuse the adding and searching functionality we defined for the complete list of tracks. This could be something we change in the future\nLets now consider how we want to program to work. Previously we had one playlist. Now like the tracks, we want a list of them. However we still want to be able to work on and modify a playlist. To minimise the changes from the original design lets use the following approach\n\nThere will be a list of playlists\n\nThese will be loaded and saved to memory like the track list\n\nThere will be one active playlist at a time\n\nAt the start there is no active playlist\nThe user can create a new playlist\nThe user can select an existing playlist\nThe user can use the existing playlist generation feature\n\n\nBy keeping the one active global playlist we can minimise the disruption to our program. We can reuse existing functions making note that the current playlist has changed from a list of tracks to a Playlist object\nOur new Playlist menu now looks like,\ndef run_playlist_management_menu():\n    \"\"\"\n    Provides the user with a looping playlist menu\n\n    1. Create a new playlist\n    2. Select playlist\n    3. Get a suggested playlist of a target length\n    4. Add a track to the playlist\n    5. Remove a track from the playlist\n    6. Clear the playlist\n    7. Display the playlist\n    8. Show the runtime of the playlist\n    9. Export the current playlist\n    10. Return to the main menu\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    ValueError\n        An invalid number is encountered in menu selection, should not\n        occur in live code, please raise a bug report if encountered\n    \"\"\"\n    playlist_management_menu = \"\"\"Playlist Management\nCurrent playlist is {0}\n\n1. Create a new playlist\n2. Select playlist\n3. Get a suggested playlist of a target length\n4. Add a track to the playlist\n5. Remove a track from the playlist\n6. Clear the playlist\n7. Display the playlist\n8. Show the runtime of the playlist\n9. Export the current playlist\n10. Return to the main menu\n\nEnter your command: \"\"\"\n    while True:\n        command = BTCInput.read_int_ranged(\n            prompt=playlist_management_menu.format(current_playlist.name),\n            min_value=1,\n            max_value=10,\n        )\n        if command == 1:\n            create_playlist()\n        elif command == 2:\n            select_playlist()\n        elif command == 3:\n            suggest_playlist_of_given_length()\n        elif command == 10:\n            break\n        elif current_playlist.name == \"None\":\n            print(\"There is no active playlist. Please select or create one\")\n            continue\n        elif command == 4:\n            add_track_to_playlist()\n        elif command == 5:\n            remove_tracks_from_playlist()\n        elif command == 6:\n            clear_playlist()\n        elif command == 7:\n            display_playlist(current_playlist, name_only=False)\n        elif command == 8:\n            calculate_playlist_length()\n        elif command == 9:\n            export_playlist()\n        else:\n            raise ValueError(\n                \"Invalid command id \"\n                + str(command)\n                + \" found in playlist management sub-menu\"\n            )\nYou can see that we’ve defined new functions,\n\ncreate_playlist\nselect_playlist\ndisplay_playlist\n\nand that we’ve renamed the old save_playlist function to export_playlist. This last change is because we’ve introduced save_playlists and load_playlists as functions to pickle and un-pickle the playlists binary data. Renaming save_playlist to export_playlist makes it clear that this function is not related to those two.\nYou also might notice that we’ve reordered the menu so that all the functions dealing with changing the current playlist (create_playlist, select_playlist, suggest_playlist_of_given_length) come first. This allows us to then check that we have an active playlist before running any of the other commands. We also check if user has decided to exit here to, since if we put it after the check for an active playlist the user can’t exit the playlist menu if the don’t have an active playlist\nAs mentioned, at the start there is no active playlist. Now the simplest way to implement this would be to initially set the current_playlist to None. However you can see this has a problem, we want the playlist menu to display the name of the current playlist, this doesn’t work if the current playlist is None. We could add some error checking, but we’ll instead use a technique called a None or Null object. This is an instance of an object that is designed to represent cases where the object does not actually exist. For us, we simply define a Playlist with the name None\n# null object\nno_playlist = Playlist(name=\"None\")\ncurrent_playlist = no_playlist\nLet us look now at the new functions we’ve defined, the first pair\ndef valid_playlist_name(name):\n    \"\"\"\n    Verifies that a playlist name is valid\n\n    Playlist names must be unique\n\n    Parameters\n    ----------\n    name : str\n        proposed name for a playlist\n\n    Returns\n    -------\n    bool\n        `True` if playlist name is valid else, `False`\n    \"\"\"\n    if name == \"None\":\n        return False\n    for playlist in playlists:\n        if name == playlist.name:\n            return False\n    return True\n\n\ndef create_playlist(tracks=[]):\n    \"\"\"\n    Create a new playlist and make it the active playlist\n\n    Prompts the user for a new name for the playlist, and ensures its valid\n    then constructs a playlist and sets it as the current active playlist\n\n    Parameters\n    ----------\n    tracks : list, optional\n        tracks to assign to the playlist, by default []\n\n    See Also\n    --------\n    valid_playlist_name : validates a playlist name\n    Playlist : class used to represent a playlist\n    \"\"\"\n    print(\"Create a new playlist\")\n    global current_playlist\n\n    new_playlist_name = BTCInput.read_text(\"Enter the playlist name: \")\n    while not valid_playlist_name(new_playlist_name):\n        print(\"That playlist name is already in use\")\n        new_playlist_name = BTCInput.read_text(\"Enter the playlist name: \")\n\n    new_playlist = Playlist(new_playlist_name, tracks)\n    current_playlist = new_playlist\n    playlists.append(new_playlist)\nPrompts the user for the name of a new playlist. We add code that means the user can’t override the NoneObject or use duplicate names which is given by the function valid_playlist_name. Unlike the validation code in the Time Tracker this is not in the class, because it is part of the business logic of the application layer, not the playlist itself\nWe then define the select_playlist function,\ndef select_playlist():\n    \"\"\"\n    Select an existing playlist to be the current playlist\n\n    Prompts the user for a search name then returns all playlists\n    that match that string. The user will be displayed each playlist\n    in turn and asked if they want to make that the current playlist\n\n    Notes\n    -----\n    Passing the empty string can be used to display all playlists\n    \"\"\"\n    print(\"Select a playlist\")\n    global current_playlist\n\n    search_name = BTCInput.read_text(\"Enter playlist name (enter to see ): \")\n\n    matched_playlists = []\n\n    for playlist in playlists:\n        if playlist.name.strip().lower().startswith(search_name.strip().lower()):\n            matched_playlists.append(playlist)\n\n    if len(matched_playlists) &gt; 0:\n        print(\"Found {0} matches\".format(len(matched_playlists)))\n        for playlist in matched_playlists:\n            display_playlist(playlist)\n            select = BTCInput.read_int_ranged(\n                \"Select this playlist? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n            )\n            if select:\n                current_playlist = playlist\n                return\n    else:\n        print(\"No playlists found matching that name\")\nSince no other method needs to search for playlist names, we forgo our usual pattern of defining a find and filter function and just combine it all in the one function. Additionally select is also used for letting the user see what playlists are stored in the program. A future version might add an explicit function called this (perhaps list_playlists)\nThis program works pretty simply. We use the standard name matching pattern, then for each match the user is shown the playlist name and runtime, and is given the option to select it. If they do then the current playlist is set to that playlist and the function ends, else it continues to the next.\nLastly we have our display_playlist function, to print a playlist\ndef display_playlist(playlist, name_only=True):\n    \"\"\"\n    Display a playlist\n\n    Can optionally list all the tracks or just the name and length\n\n    Parameters\n    ----------\n    playlist : Playlist\n        playlist to display\n    name_only : bool, optional\n        only display the playlists name and runtime, by default `True`\n\n    Returns\n    -------\n    None\n    \"\"\"\n    if name_only:\n        print(\"{0} ({1} s)\".format(playlist.name, playlist.runtime))\n    else:\n        print(playlist)\nThe optional name_only parameter is used indicate that we only want to print the playlist name and length, otherwise we defer to the Playlist __str__ method and print everything.\nThis captures the last of the high level changes. As mentioned, we have to make minor changes to the existing functions, such as to suggest_playlist_of_given_length shown below\ndef suggest_playlist_of_given_length():\n    \"\"\"\n    Suggests a playlist of length less than or equal to\n    a user prompted length\n\n    Asks the user for a maximum playlist length, and\n    then suggests a playlist by combining tracks randomly\n    such that the suggested playlist is no greater than\n    the length\n\n    The user has the option to review the proposed list\n    and either accept, reject or regenerate the list\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"Suggest playlist of given length\")\n    global current_playlist\n\n    target_length = read_min_valued_integer(\n        \"Enter maximum playlist length: \", min_value=1\n    )\n\n    while True:\n        suggested_tracks = []\n        suggested_tracks_total_length = 0\n        # find tracks that could fit in the playlist\n        candidate_songs = filter_tracks_shorter_than_length(target_length, tracks)\n\n        if len(candidate_songs) == 0:\n            print(\"Could not generate a playlist of that length. Try a longer playlist\")\n            return\n\n        while len(candidate_songs) &gt; 0:  # stop when no more eligible songs\n            # add a random song and update the playlist length\n            song_choice = random.choice(candidate_songs)\n            suggested_tracks.append(song_choice)\n            suggested_tracks_total_length = (\n                suggested_tracks_total_length + song_choice.length_in_seconds\n            )\n\n            # filter out songs that no longer fit\n            candidate_songs = filter_tracks_shorter_than_length(\n                target_length - suggested_tracks_total_length, candidate_songs\n            )\n        print(\"Generated a playlist...\")\n        # let the user review the playlist\n        display_tracks(suggested_tracks)\n        if BTCInput.read_int_ranged(\n            \"Accept this playlist? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        ):\n            create_playlist(suggested_tracks)\n            return\n        else:\n            if BTCInput.read_int_ranged(\n                \"Generate again? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n            ):\n                continue\n            return\nHere we still build up the suggested playlist as before (using a list) but once the user decides to keep this playlist, we then call create_playlist passing in the track list to create a proper named Playlist object\nYou are encouraged to work through the full program yourself (PlaylistStorage.py)\n\n\n\n\n\nLet’s build a simple music keyboard\nWe’ll add a simple music player\nExtend with some playback options\nThe snaps library code provides some music notes to use\n\nstored in MusicNotes\nplay_note lets us play a note\n\n\n\n\n\n\nWarning\n\n\n\nIf when running the program you get a file not found error, you may need to modify the path in play_note to either MusicNotes\\\\ or MusicNotes/\nThis path is relative to snaps and so the folder must in the same directory as snaps\n\n\n\nWe can start with a simple program that plays all the notes,\n  # Example 10.15.1 Play Notes\n  #\n  # Demonstrates using snaps to play notes\n\n  import time\n\n  import snaps\n\n  for note in range(0, 13):\n      snaps.play_note(note)\n      time.sleep(0.5)\n  input(\"Press enter to continue...\")\nWe use time.sleep(0.5) to stagger playing the notes\nWe could also play a tune,\n  # Example 10.15.2 Twinkle Twinkle\n  #\n  # Uses snaps to play a simple tune\n\n  import time\n\n  import snaps\n\n  snaps.play_note(0)\n  time.sleep(0.4)\n  snaps.play_note(0)\n  time.sleep(0.4)\n  snaps.play_note(7)\n  time.sleep(0.4)\n  snaps.play_note(7)\n  time.sleep(0.4)\n  snaps.play_note(9)\n  time.sleep(0.4)\n  snaps.play_note(9)\n  time.sleep(0.4)\n  snaps.play_note(7)\n  time.sleep(0.8)\n  snaps.play_note(5)\n  time.sleep(0.4)\n  snaps.play_note(5)\n  time.sleep(0.4)\n  snaps.play_note(4)\n  time.sleep(0.4)\n  snaps.play_note(4)\n  time.sleep(0.4)\n  snaps.play_note(2)\n  time.sleep(0.4)\n  snaps.play_note(2)\n  time.sleep(0.4)\n  snaps.play_note(0)\n  time.sleep(0.8)\nWe can see this is already becoming tedious\nWe repeatedly write the play_note followed by a sleep time\nHave to manually modify the code\nWe could make this data-driven\nWe supply a list of tuples\n\nEach tuple contains the id for a note and the time to sleep after playing that note\n\nThen simply loop over the list to play the tune\nCan then play anything by just changing the embedded data\n  # Example 10.15.3 Twinkle Twinkle with Tuples\n  #\n  # Converts play notes to a data-driven program using tuples to specify notes\n  # and how long to pause after\n\n  import time\n\n  import snaps\n\n  tune = [\n      (0, 0.4),\n      (0, 0.4),\n      (7, 0.4),\n      (7, 0.4),\n      (9, 0.4),\n      (9, 0.4),\n      (7, 0.8),\n      (5, 0.4),\n      (5, 0.4),\n      (4, 0.4),\n      (4, 0.4),\n      (2, 0.4),\n      (2, 0.4),\n      (0, 0.8),\n  ]\n\n  for note in tune:\n      note_id, sleep_time = note\n      snaps.play_note(note_id)\n      time.sleep(sleep_time)\nEach tuple stores the note and the sleep time\nWe then loop over the tuples\nWe use unpacking to assign the elements of the tuple meaningful names (note_id and sleep_time)\nWhile playback is simple, constructing is not necessarily\n\nThe tuples are undocumented and rely on the programmer knowing the indices\n\nWe could instead define a lightweight class\n  # Example 10.15.4 Twinkle Twinkle with Classes\n  #\n  # Modifies the data driven tuple implementation by defining a lightweight\n  # Note class\n\n  import time\n\n  import snaps\n\n\n  class Note:\n      \"\"\"\n      Musical note with a playback duration.\n      \"\"\"\n\n      def __init__(self, note, duration):\n          \"\"\"\n          Create a `Note` instance\n\n          Parameters\n          ----------\n          note : int\n              id of the note to play\n          duration : int | float\n              duration of the note\n          \"\"\"\n          self.__note = note\n          self.__duration = duration\n\n      def play(self):\n          \"\"\"\n          play the note\n\n          plays the note then pauses for the specified duration\n          \"\"\"\n          snaps.play_note(self.__note)\n          time.sleep(self.__duration)\n\n\n  tune = [\n      Note(note=0, duration=0.4),\n      Note(note=0, duration=0.4),\n      Note(note=7, duration=0.4),\n      Note(note=7, duration=0.4),\n      Note(note=9, duration=0.4),\n      Note(note=9, duration=0.4),\n      Note(note=7, duration=0.8),\n      Note(note=5, duration=0.4),\n      Note(note=5, duration=0.4),\n      Note(note=4, duration=0.4),\n      Note(note=4, duration=0.4),\n      Note(note=2, duration=0.4),\n      Note(note=2, duration=0.4),\n      Note(note=0, duration=0.8),\n  ]\n\n  for note in tune:\n      note.play()\nNote is a lightweight class holding the note’s id and the note duration\n\nKeep these private, since no need to access once set\n\nNote has a play method that captures playing a note\nProgram then defines a list of Note objects which are then played\n\n\n\nConsider the following questions about the design of the note class\n\nWhy does the Note class contain a Play method?\n\ncohesion\nNote contains all the information about a note\nSo should keep the behaviour with the information, i.e. in the Note class\nIf we want to change how a note is played we can change it in the Note class without impacting downstream callers\n\nSo long as we keep the same API\n\n\nCould the Note class have a __str__ method?\n\nIt’s probably a good idea\nA simple implementation is,\ndef __str__(self):\n  template = \"Note: {0} Duration: {1}\"\n  return template.format(self.__note, self.duration)\nWe can then print the tune super easily,\n  tune_strings = map(str, tune)\n  print(\"\\n\".join(tune_strings))\n\n\n\nAll the music playing examples can be found in the Music With Snaps example folder\n\n\n\n\nModify the sample programs to make your own tunes\nFor fun we’ll make two little tunes\n\nThe classic Maccas jingle\n # Exercise 10.2.1  Maccas Jingle\n #\n # Uses the Note playback program to play the Maccas jingle\n\n import time\n\n import snaps\n\n\n class Note:\n     \"\"\"\n     Musical note with a playback duration.\n     \"\"\"\n\n     def __init__(self, note, duration):\n         \"\"\"\n         Create a `Note` instance\n\n         Parameters\n         ----------\n         note : int\n             id of the note to play\n         duration : int | float\n             duration of the note\n         \"\"\"\n         self.__note = note\n         self.__duration = duration\n\n     def __str__(self):\n         template = \"Note: {0} Duration: {1}\"\n         return template.format(self.__note, self.__duration)\n\n     def play(self):\n         \"\"\"\n         play the note\n\n         plays the note then pauses for the specified duration\n         \"\"\"\n         snaps.play_note(self.__note)\n         time.sleep(self.__duration)\n\n\n tune = [\n     Note(note=7, duration=0.3),\n     Note(note=11, duration=0.3),\n     Note(note=2, duration=0.3),\n     Note(note=5, duration=0.3),\n     Note(note=7, duration=0.5),\n ]\n\n for note in tune:\n     note.play()\n\n tune_strings = map(str, tune)\n print(\"\\n\".join(tune_strings))\n\nThis doesn’t sound exactly correct because we don’t have the correct octave progression in the provided wav files but we get a decent approximation\nYou might like to play around with the timings to see if you can make it better\n\nThree Blind Mice\n # Exercise 10.2.2 Three Blind Mice\n #\n # Uses the Note playback program to play three blind mice\n\n import time\n\n import snaps\n\n\n class Note:\n     \"\"\"\n     Musical note with a playback duration.\n     \"\"\"\n\n     def __init__(self, note, duration):\n         \"\"\"\n         Create a `Note` instance\n\n         Parameters\n         ----------\n         note : int\n             id of the note to play\n         duration : int | float\n             duration of the note\n         \"\"\"\n         self.__note = note\n         self.__duration = duration\n\n     def __str__(self):\n         template = \"Note: {0} Duration: {1}\"\n         return template.format(self.__note, self.__duration)\n\n     def play(self):\n         \"\"\"\n         play the note\n\n         plays the note then pauses for the specified duration\n         \"\"\"\n         snaps.play_note(self.__note)\n         time.sleep(self.__duration)\n\n\n tune = [\n     Note(note=4, duration=0.4),\n     Note(note=2, duration=0.4),\n     Note(note=0, duration=0.8),\n     Note(note=4, duration=0.4),\n     Note(note=2, duration=0.4),\n     Note(note=0, duration=0.8),\n     Note(note=7, duration=0.4),\n     Note(note=5, duration=0.4),\n     Note(note=5, duration=0.4),\n     Note(note=4, duration=0.8),\n     Note(note=7, duration=0.4),\n     Note(note=5, duration=0.4),\n     Note(note=5, duration=0.4),\n     Note(note=4, duration=0.8),\n     Note(note=7, duration=0.4),\n     Note(note=12, duration=0.4),\n     Note(note=12, duration=0.4),\n     Note(note=11, duration=0.4),\n     Note(note=9, duration=0.4),\n     Note(note=11, duration=0.4),\n     Note(note=12, duration=0.4),\n     Note(note=7, duration=0.4),\n     Note(note=7, duration=0.8),\n ]\n\n for note in tune:\n     note.play()\n\n tune_strings = map(str, tune)\n print(\"\\n\".join(tune_strings))\n\nThis one we get a much better sounding tune\n\n\n\n\n\nBy combining the structure and style of Time Tracker with the music playback provided by the Note class we could make a simple program that lets users create, edit and play their own tunes. Create this program. A user should be able to create a tune, edit a tune, delete a tune and play a selected tune. Tunes should be saved and persist between uses\nIf you can follow the Playlist Storage App and the Recipe Storage App then this program should fairly easy to follow\nLet’s first define our Note class\nclass Note:\n    \"\"\"\n    Musical note with a playback duration.\n\n    Class Attributes\n    ----------------\n    min_note_id : int\n        minimum valid note id\n    max_note_id : int\n        maximum valid note id\n    \"\"\"\n\n    min_note_id = 0\n    max_note_id = 12\n\n    @staticmethod\n    def valid_note(note):\n        \"\"\"\n        Checks if a note id is valid\n\n        Parameters\n        ----------\n        note : int\n            id of the note to validate\n\n        Returns\n        -------\n        bool\n            `True` if note is valid, else `False`\n        \"\"\"\n        if note &lt; 0 or note &gt; 12:\n            return False\n        return True\n\n    def __init__(self, note, duration):\n        \"\"\"\n        Create a Note instance\n\n        Parameters\n        ----------\n        note : int\n            id of the note to play\n        duration : int | float\n            duration of the note\n        \"\"\"\n        if not Note.valid_note(note):\n            raise ValueError(\n                \"invalid note {0} passed. note must be between {1} and {2}\".format(\n                    note, Note.min_note_id, Note.max_note_id\n                )\n            )\n        self.__note = note\n        self.__duration = duration\n\n    @property\n    def duration(self):\n        \"\"\"\n        duration : str\n            time in seconds the note is played for\n        \"\"\"\n        return self.__duration\n\n    def __str__(self):\n        template = \"Note: {0} Duration: {1}\"\n        return template.format(self.__note, self.__duration)\n\n    def play(self):\n        \"\"\"\n        play the note\n\n        plays the note then pauses for the specified duration\n        \"\"\"\n        snaps.play_note(self.__note)\n        time.sleep(self.__duration)\nThis is pretty much the same as the Note class in the Making Music Section. However we need the duration so that we can report how long the total tune is so we add a read only property for duration. Additionally since we’re now going to be taking user input to create notes we’ll want to validate that input. It makes sense for it to be in the Note class, so we define class variables min_note_id and max_note_id and a corresponding validation method, valid_note that can be used to check that a note (represented by an integer) is valid. We leave the class variables as public so we can use them in the prompts we display to the user\nNow when making our own music, we used a list of notes to create a tune. We want to use this structure but wrap it in a class that captures behaviour. We’ll call this class Tune\nclass Tune:\n    \"\"\"\n    Represents a tune consisting of a sequence of notes of a specified duration\n\n    Attributes\n    ----------\n    name : str\n        name of the tune\n    \"\"\"\n\n    def __init__(self, name):\n        \"\"\"\n        Create a new `Tune` instance\n\n        Parameters\n        ----------\n        name : str\n            name of the tune\n        \"\"\"\n        self.name = name\n        self.__notes = []\n        self.__length = 0\n\n    def __str__(self):\n        notes_string = \"\"\n        for idx, note in enumerate(map(str, self.__notes)):\n            notes_string = notes_string + str(idx) + \": \" + note + \"\\n\"\n\n        template = \"\"\"name: {0}\nduration: {1}\nnotes:\n{2}\n\"\"\"\n        return template.format(self.name, self.__length, notes_string)\n\n    @property\n    def length(self):\n        \"\"\"\n        length : int | float\n            total length of the tune in seconds\n        \"\"\"\n        return self.__length\n\n    @property\n    def number_of_notes(self):\n        \"\"\"\n        number_of_notes : int\n            number of notes in the tune\n        \"\"\"\n        return len(self.__notes)\nThe class has a simple structure. The tune constructor only needs a name, we then create an empty list of notes, and a separate variable that tracks the full length of the tune. Our string representation (__str__) follows the usual pattern, we print the name and duration of the Tune, the the list of Note objects in the tune. We use enumerate to make this a numbered list with each item on its own line. This is because most of our edits will require an index, so we want to user to be able to easily see the index of all the notes. Additionally we define two useful properties, one to get the length of the tune, and the second that returns the total number of notes in the tune. Both properties are read-only, while this last one is mostly used to help with validating user input\nAs you can see the list of notes is private, so we also want to provide some methods that allow us to modify the notes list\n    def add_note(self, note, index=None):\n        \"\"\"\n        Add a new note to the tune\n\n        Adds a new note to the tune, if the index is specified\n        the note is inserted at that index, else the note is appended\n\n        Parameters\n        ----------\n        note : Note\n            note to add to the tune\n        index : int | None, optional\n            index to insert the note at, if `None`, the Note is appended,\n            by default `None`\n\n        Returns\n        -------\n        None\n\n        See Also\n        --------\n        Tune.remove_note : remove a note at a given index from a `Tune` instance\n        \"\"\"\n        if index is not None:\n            self.__notes.insert(index, note)\n        else:\n            self.__notes.append(note)\n        self.__length += note.duration\n\n    def remove_note(self, index):\n        \"\"\"\n        Remove a note from the tune\n\n        Parameters\n        ----------\n        index : int\n            index of the note to remove\n\n        Returns\n        -------\n        Note\n            the removed Note\n\n        See Also\n        --------\n        Tune.add_note : insert or append a new note to a `Tune` instance\n        Tune.clear_tune : remove all notes in a `Tune` instance\n        \"\"\"\n        try:\n            note = self.__notes.pop(index)\n            self.__length -= note.duration\n            return note\n        except IndexError:\n            print(\"Failed to remove the {0}-th note\".format(index + 1))\n\n    def clear_tune(self):\n        \"\"\"\n        Clear all notes from the tune\n\n        Returns\n        -------\n        None\n\n        See Also\n        --------\n        Tune.remove_note : remove a note at a given index from a `Tune`\n        \"\"\"\n        self.__notes.clear()\n        self.__length = 0\nThe first add_note takes a note, and an optional index. If the index is specified the note is inserted into the list (at the specified index), otherwise we append it. The second remove_note requires an index, and removes the note at that index. The removed note is returned as part of this process. We also provide some error handling in case the provided index does not actually exist. Last we provide a clear_tune method which simply removes all the notes\nThe arguably most important function for the Tune class however is play which simply plays the tune\n    def play(self):\n        \"\"\"\n        Plays the tune\n\n        Returns\n        -------\n        None\n        \"\"\"\n        for note in self.__notes:\n            note.play()\nWe define our main menu function as,\ndef run_main_menu():\n    first_option_id = 1\n    last_option_id = 7\n\n    main_menu_template = \"\"\"Tune Editor\nCurrent Tune: {0}\n\n1. New Tune\n2. List Tunes\n3. Select Tune\n4. Play Tune\n5. Edit Tune\n6. Delete Tune\n7. Exit program\n\nEnter your command: \"\"\"\n\n    while True:\n        command = BTCInput.read_int_ranged(\n            main_menu_template.format(current_tune.name),\n            min_value=first_option_id,\n            max_value=last_option_id,\n        )\n        if command == 1:\n            new_tune()\n        elif command == 2:\n            list_tunes()\n        elif command == 3:\n            select_tune()\n        elif command == 7:\n            try:\n                save_tunes(tune_file_name)\n            except:  # noqa: E722\n                print(\"Failed to save tunes\")\n            break\n        elif current_tune.name == \"None\":\n            print(\"No tune currently selected\")\n            continue\n        elif command == 4:\n            current_tune.play()\n        elif command == 5:\n            run_edit_menu()\n        elif command == 6:\n            delete_tune()\n        else:\n            raise ValueError(\n                \"Unexpected command id: {0} found in Main Menu\".format(command)\n            )\nWe use the same save and load paradigm as with all the previous examples so we won’t look at that code again. Of the functions here we have,\n\nnew_tune\n def valid_tune_name(name):\n     \"\"\"\n     Verifies that a tune name is available\n\n     Tune names must be unique\n\n     Parameters\n     ----------\n     name : str\n         proposed name for a tune\n\n     Returns\n     -------\n     bool\n         `True` if tune name is valid else, `False`\n     \"\"\"\n     if name == \"None\":\n         return False\n     for tune in tunes:\n         if name == tune.name:\n             return False\n     return True\n\n\n def prompt_valid_name(prompt):\n     \"\"\"\n     Prompts the user for a valid tune name\n\n     Loops until a valid name is provided\n\n     Parameters\n     ----------\n     prompt : str\n         prompt to display to the user\n\n     Returns\n     -------\n     str\n         string containing a valid tune name\n     \"\"\"\n     tune_name = BTCInput.read_text(prompt)\n     while not valid_tune_name(tune_name):\n         print(\"That tune name is already in use\")\n         tune_name = BTCInput.read_text(prompt)\n\n     return tune_name\n\n\n def new_tune():\n     \"\"\"\n     Create a new tune and make it the active tune\n\n     Prompts the user for a new name for the tune, and ensures its valid\n     then constructs a Tune and sets it as the current active tune\n\n     Returns\n     -------\n     None\n\n     See Also\n     --------\n     valid_tune_name : validates a tune name\n     Tune : class used to represent a tune\n     \"\"\"\n     print(\"New tune\")\n     global current_tune\n     new_tune_name = prompt_valid_name(\"Enter the tune name: \")\n     new_tune = Tune(new_tune_name)\n     current_tune = new_tune\n     tunes.append(new_tune)\n\nWe start by defining a function valid_tune_name\n\nboolean function that ensures a proposed name is unique\nreturns True if the name is valid, else False\n\nWe then wrap this in prompt_valid_name\n\nSince we want to reuse the code that gets a name from a user later\nPrompts the user for a valid name, looping until one is received\nReturns the valid name\n\nOur new_tune is now simple\n\ncall prompt_valid_name to get a new name\nCreate a new Tune object\nset the current tune to this new object\nAdd it to the tunes list\n\n\nlist_tunes\n def filter_tunes_by_name(search_name):\n     \"\"\"\n     Finds tunes matching a search name\n\n     Tunes are matched if their name is prefixed by the search name\n     after normalisation (striping whitespace and lowercasing)\n\n     Parameters\n     ----------\n     search_name : str\n         name to search for (search uses prefix matching)\n\n     Returns\n     -------\n     list[Tune]\n         list of tunes matching the name. If no matches\n         exist the list is empty\n\n     \"\"\"\n     search_name = search_name.strip().lower()\n     print(search_name)\n     matched_tunes = []\n     for tune in tunes:\n         tune_name = tune.name.strip().lower()\n         if tune_name.startswith(search_name):\n             matched_tunes.append(tune)\n     return matched_tunes\n\n\n def list_tunes():\n     \"\"\"\n     List all tunes matching a user-specified search string\n\n     Returns\n     -------\n     None\n\n     See Also\n     --------\n     filter_tunes_by_name : handles searching for tunes by name\n     \"\"\"\n     print(\"List tunes\")\n     search_name = BTCInput.read_text(\"Tune names to search (press enter for all): \")\n     matched_tunes = filter_tunes_by_name(search_name)\n     if len(matched_tunes) == 0:\n         print(\"No matches found\")\n         return\n     print(\"Found {0} matches\".format(len(matched_tunes)))\n     for tune in matched_tunes:\n         print(\"- {0} ({1:.2f} s)\".format(tune.name, tune.length))\n\nWe use the usual pattern of defining a filter_tunes_by_name function to perform the search\nWe then print out the matches as per usual\n\nselect_tune\n def select_tune():\n     \"\"\"\n     Select a tune from tunes matching a user-specified search string\n\n     Returns\n     -------\n     None\n\n     See Also\n     --------\n     filter_tunes_by_name : handles searching for tunes by name\n     \"\"\"\n     print(\"Select tune\")\n     search_name = BTCInput.read_text(\"Enter name of tune to select: \")\n     matched_tunes = filter_tunes_by_name(search_name)\n     if len(matched_tunes) == 0:\n         print(\"No matches found\")\n         return\n     print(\"Found {0} matches\".format(len(matched_tunes)))\n     for tune in matched_tunes:\n         select = BTCInput.read_int_ranged(\n             \"Tune: {0}, select this tune? (1 - Yes, 0 - No): \".format(tune.name),\n             min_value=0,\n             max_value=1,\n         )\n         if select:\n             global current_tune\n             current_tune = tune\n             break\n\nUses filter_tunes_by_name to get matching tunes\nUser is then prompted for each match if they want to make this the new current tune\nExecution stops once they’ve decided to select a new track\n\ndelete_tune\n def delete_tune():\n     \"\"\"\n     Optionally delete tunes matching a user-specified search string\n\n     Returns\n     -------\n     None\n\n     See Also\n     --------\n     filter_tunes_by_name : handles searching for tunes by name\n     \"\"\"\n     print(\"Delete tune\")\n     search_name = BTCInput.read_text(\"Enter name of tune to select: \")\n     matched_tunes = filter_tunes_by_name(search_name)\n     if len(matched_tunes) == 0:\n         print(\"No matches found\")\n         return\n     print(\"Found {0} matches\".format(len(matched_tunes)))\n     for tune in tunes:\n         select = BTCInput.read_int_ranged(\n             \"Tune: {0}, delete this tune? (1 - Yes, 0 - No): \".format(tune.name),\n             min_value=0,\n             max_value=1,\n         )\n         if select:\n             global current_tune\n             if tune == current_tune:\n                 current_tune = no_tune\n             tunes.remove(tune)\n\nAgain, use filter_tunes_by_name to match names\nThen prompt the user if they want to delete\nOnly caveat we have to be careful is that if we delete the currently selected tune we have to set the current tune to no_tune (a null object)\n\n\nNow, the last thing we have to look at is the edit menu. Our edit menu looks as follows,\ndef run_edit_menu():\n    first_option_id = 1\n    last_option_id = 8\n\n    edit_tune_menu_template = \"\"\"Editing Tune\nCurrent Tune: {0}\n1. Rename Tune\n2. Display Tune\n3. Play Tune\n4. New Note\n5. Edit Note\n6. Remove Note\n7. Clear Tune\n8. Finish Editing\n\nEnter your command: \"\"\"\n    while True:\n        command = BTCInput.read_int_ranged(\n            edit_tune_menu_template.format(current_tune.name),\n            min_value=first_option_id,\n            max_value=last_option_id,\n        )\n\n        if command == 1:\n            rename_tune()\n        elif command == 2:\n            print(current_tune)\n        elif command == 3:\n            print(\"Playing\", current_tune.name)\n            current_tune.play()\n        elif command == 4:\n            add_note_to_tune()\n        elif command == 5:\n            edit_note()\n        elif command == 6:\n            if current_tune.number_of_notes == 0:\n                print(\"No notes to remove\")\n            remove_note()\n        elif command == 7:\n            print(\"Cleared\", current_tune.name)\n            current_tune.clear_tune()\n        elif command == 8:\n            break\n        else:\n            raise ValueError(\n                \"Unexpected command id: {0} found in Edit Menu\".format(command)\n            )\nLets work through these functions\n\nrename_tune\n def rename_tune():\n     \"\"\"\n     Rename the current tune to a user prompted string\n\n     Returns\n     -------\n     None\n     \"\"\"\n     print(\"Rename current tune\")\n     new_name = prompt_valid_name(\"Enter new name (or . to leave unchanged): \")\n     if new_name != \".\":\n         current_tune.name = new_name\n\nReuses the prompt_valid_name function from new_tune to get a new name\n\nThis has the issue that we can’t write the same name as the current tune\nSo use . to indicate that we don’t actually want to change\n\n\nadd_note_to_tune\n def get_new_note_from_user():\n     \"\"\"\n     Prompts the user for a new Note\n\n     The user is prompted for the note and duration, and the input validated\n     to ensure that a valid Note object is created\n\n     Returns\n     -------\n     Note\n         Note object containing the user specified note id and duration\n     \"\"\"\n\n     note_prompt = \"Enter note ({0} - {1}): \".format(Note.min_note_id, Note.max_note_id)\n     note = BTCInput.read_int_ranged(\n         prompt=note_prompt, min_value=Note.min_note_id, max_value=Note.max_note_id\n     )\n\n     min_note_length = 0.1\n     max_note_length = 1\n     duration_prompt = \"Enter duration ({0} - {1}): \".format(\n         min_note_length, max_note_length\n     )\n     duration = BTCInput.read_float_ranged(\n         duration_prompt, min_value=min_note_length, max_value=max_note_length\n     )\n\n     return Note(note, duration)\n\n\n def add_note_to_tune():\n     \"\"\"\n     Adds a note to the current tune\n\n     Prompts the user to specify a new note as well as an index of\n     where to insert the note in the tune (`-1` indicating append). The created\n     note is then added to the current tune at the indicated index (or appended)\n\n     Returns\n     -------\n     None\n     \"\"\"\n     print(\"Add note to current tune\")\n     new_note = get_new_note_from_user()\n     if current_tune.number_of_notes == 0:\n         current_tune.add_note(new_note)\n         print(\"Added note:\", new_note)\n         return\n\n     insert_prompt = \"Enter index to add note (0 - {0}) or -1 to append: \".format(\n         current_tune.number_of_notes - 1\n     )\n     insertion_idx = BTCInput.read_int_ranged(\n         insert_prompt, -1, current_tune.number_of_notes - 1\n     )\n     if insertion_idx == -1:\n         insertion_idx = None\n     current_tune.add_note(new_note, insertion_idx)\n     print(\"Added note:\", new_note)\n\nWe start by defining a function get_new_note_from_user\n\nGets a valid Note object from the user\nUses the class attributes on Note to limit the user’s input for the note id\nEnforces a program set limit on the duration\n\nThen define add_note_to_tune\n\nWe get a new note from the user\nIf there’s no notes on the Tune we can immediately add the note to the tune\nOtherwise we prompt the user for the index to add\n\n\\(-1\\) is used to indicate that the value should be appended\n\nCan then call the add_note method on the Tune object\n\n\nedit_note\n def edit_note():\n     \"\"\"\n     Modifies an existing note in the current tune\n\n     Prompts the user for the index of the existing note to overwrite and\n     then the details of the new note\n\n     Returns\n     -------\n     None\n     \"\"\"\n     print(\"Edit note in current tune\")\n     if current_tune.number_of_notes == 0:\n         print(\"There are no notes in the current tune to edit\")\n         return\n\n     edit_prompt = \"Enter index of note to edit (0 - {0}): \".format(\n         current_tune.number_of_notes - 1\n     )\n     insertion_idx = BTCInput.read_int_ranged(\n         edit_prompt, 0, current_tune.number_of_notes - 1\n     )\n     old_note = current_tune.remove_note(insertion_idx)\n\n     if insertion_idx == current_tune.number_of_notes:\n         insertion_idx = None  # we removed the last index, so now need to append\n\n     new_note = get_new_note_from_user()\n     current_tune.add_note(new_note, insertion_idx)\n     print(\"Note successfully edited\")\n     print(\"Note was:\", old_note)\n     print(\"Note now:\", new_note)\n\nWorks similar to add_note_to_tune\n\nThis time however we first prompt the user for which note they want to edit\n\nWe create a new Note\n“Editing” a note is achieved by removing the old note, and inserting the new note, where the old one was\n\nremove_note\n def remove_note():\n     \"\"\"\n     Remove the note at a user prompted index from the current tune\n\n     Returns\n     -------\n     None\n     \"\"\"\n     print(\"Remove note from current tune\")\n     remove_prompt = \"Enter index of note to remove (0 - {0}): \".format(\n         current_tune.number_of_notes - 1\n     )\n     remove_idx = BTCInput.read_int_ranged(\n         remove_prompt, 0, current_tune.number_of_notes - 1\n     )\n     current_tune.remove_note(remove_idx)\n\nCalling code responsible for ensuring that we don’t call this on an empty tune\nRemoves the note at the user prompted index\n\n\nWith those functions worked through that covers pretty much all the functionality of the program. You can see the full implementation in TuneCreator.py. The associated pickle file should load the example tunes we created earlier which you can play and edit to test the program",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 10: Using Classes to Create Active Objects"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/10_UseClassesToCreateActiveObjects/Chapter_10.html#summary",
    "href": "02_AdvancedProgramming/10_UseClassesToCreateActiveObjects/Chapter_10.html#summary",
    "title": "Chapter 10: Using Classes to Create Active Objects",
    "section": "Summary",
    "text": "Summary\n\nClasses can be used to store data attributes\n\nWhen a class instance is created, the data is stored in the object\nThe __init__ or constructor is a function that can be used to set instance attributes at creation\n\nClasses can contain method attributes\n\nan object can asked to perform a function by calling the method\nmethods are effectively functions that contain a reference to the object itself as a first argument\n\nTraditionally called self\n\n\nClasses should strive to be cohesive\n\nMethods let us create cohesive classes\nCohesive classes are less reliant on the internals of other classes\nself contained objects can validate method calls or data assignments\n\nInvalid data or failed methods can be handled in two ways\n\nreturn a status message\n\nUser has the option of ignoring it\n\nraise an exception\n\nUser is forced to handle it or the program crashes\n\n\nPython provides mechanisms for protecting data\n\nNo absolute runtime guarantees\n_ indicates an attribute is supposed to be private to a class\n__ name mangles a variable making it harder to access outside the class\n\nStatic methods can be defined on a class and called without a specific instance\nUseful for creating validation methods, that do not rely on specific instance values\nProperties let us write methods that behave like attributes\n\nCan be used to return values that can be calculated on the fly\nReturn read-only versions of data attributes\nperform data validation on data attribute assignment while still keeping the same syntax i.e. obj.param = new_value\n\nVersion management is important whenever you want to store classes that might change long-term\n\nYou should incorporate methods for upgrading older versions of a class to a new version\n\nThe __str__ method is used to define how a class is represented as a string\nPython string formatting provides a simple way for creating strings containing formatted variable values\nIterators are objects that can produce elements of a sequence for iteration\n\nIterators can come from a list or a different iterator\n\nmap can be used to create an iterator that applies a function to an existing iteration\njoin can be used to merge a list of strings into a larger string",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 10: Using Classes to Create Active Objects"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/10_UseClassesToCreateActiveObjects/Chapter_10.html#questions-and-answers",
    "href": "02_AdvancedProgramming/10_UseClassesToCreateActiveObjects/Chapter_10.html#questions-and-answers",
    "title": "Chapter 10: Using Classes to Create Active Objects",
    "section": "Questions and Answers",
    "text": "Questions and Answers\n\nWhy doesn’t python provide a way for a programmer to completely protect data attributes in an object?\n\nThe creator of python didn’t believe in the traditional object-oriented concepts of public, protected and private variables\nEven these techniques can’t protect against a malicious actor with access to your source code\n\nThey could modify a public function to reveal a private variable\nOr they could just add one\n\nIt is important to still be able to review code to ensure it is secure\n\nWhen would we use a property in a program?\n\nProperties let us control how data attributes are accessed\nProperties let us write traditional get and set methods that still behave like simple data attributes\nWe can also define read-only properties that have no set methods\nProperties are good when you want to manage access to data (or validate it) but without the user having to call methods\n\nWhen would we create static class attributes?\n\nStatic class data attributes are useful to store information about a class\n\ni.e. independent on any specific object instance\n\nA good example is data validation values\n\nThese will typically be common across all instances\n\nSimilarly static method attributes are good for performing this validation\n\nMust all objects be highly cohesive?\n\nNot strictly\nIt’s about scale\n\nFor a small program, that does one thing, that will be used once (or a few times by one person)\nLittle harm in being uncohesive\nThe time spent making it cohesive as opposed to making it is probably wasted\n\nAn overriding rule is to keep it simple\nIf a program is likely to be maintained, or developed by multiple people\n\nProbably beneficial\nShort-term costs of good design are better than the long-term of maintaining a poor design\n\nTime Tracker is pretty close to final product quality\n\nWhat is an iterator again?\n\nAn iterator is an object that provides the __next__ method\n\nProvides the next value in a sequence\n\nSome objects, e.g. list behave as iterators\nSome methods, e.g. map and range return objects that behave as iterators\nPython constructs like for that use iterators can work on any type of iterator\n\nSo long as it fulfills the protocol (__next__ method and raises StopIteration)\nconstruction doesn’t know what its dealing with, just sees the __next__ method\nStopIteration raised once there are no more elements left",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 10: Using Classes to Create Active Objects"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/09_UsingClasses/Chapter_09.html",
    "href": "02_AdvancedProgramming/09_UsingClasses/Chapter_09.html",
    "title": "Chapter 9: Use Classes to Store Data",
    "section": "",
    "text": "Let’s develop a lightweight program to store contact details\n\nNames\nAddresses\nTelephone Numbers\n\nWe storyboard the interface\n  Tiny Contacts\n\n  1. New Contact\n  2. Find Contact\n  3. Exit Program\n\n  Enter your command:\nWe then want to extend the storyboard to the different interface options\n  Create new contact\n\n  Enter the contact name: Rob Miles\n  Enter the contact address: 18 Pussycat Mews, London, NE1 410S\n  Enter the contact phone: +44(1234) 56789\n\n  Contact record stored for Rob Miles\nThe matching storyboard for find is then,\n  Find Contact\n\n  Enter the contact name: Rob Miles\n  Name: Rob Miles\n  Address: 18 Pussycat Mews, London, NE1 410S\n  Phone: +44(1234) 56789\n\nWith a matching storyboard for a contact not existing\n    Find Contact\n\n    Enter the contact name: Fred Bloggs\n    This name was not found\n\n\n\n\n\nWe start by making a prototype\n\nWe stub out the functions with mock messages\n\nThis is good for demoing to the customer for their feedback\n\nAlso helps to start working out how the structure should flow\n\n  # Example 9.1 Tiny Contacts Prototype\n  #\n  # Simple stub implementation of the Tiny Contacts Prototype\n\n  import BTCInput\n\n\n  def new_contact():\n      \"\"\"\n      Creates and adds a new contact to the contact book\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Create the new contact\")\n      BTCInput.read_text(\"Enter the contact name: \")\n      BTCInput.read_text(\"Enter the contact address: \")\n      BTCInput.read_text(\"Enter the contact phone: \")\n\n\n  def find_contact():\n      \"\"\"\n      Displays the contact matching a user-specified name\n\n      Prompts the user for a name, and searches the contacts list.\n      If the contact is found in the list, their full contact details\n      are displayed\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Find contact\")\n      name = BTCInput.read_text(\"Enter the contact name: \")\n      if name == \"Rob Miles\":\n          print(\"Name: Rob Miles\")\n          print(\"Address: 18 Pussycat News, London, NE1 410S\")\n          print(\"Phone: +44(1234) 56789\")\n      else:\n          print(\"This name was not found.\")\n\n\n  menu = \"\"\"Tiny Contacts\n\n  1. New Contact\n  2. Find Contact\n  3. Exit Program\n\n  Enter your command:\"\"\"\n\n  while True:\n      command = BTCInput.read_int_ranged(prompt=menu, min_value=1, max_value=3)\n      if command == 1:\n          new_contact()\n      elif command == 2:\n          find_contact()\n      elif command == 3:\n          break\n      else:\n          raise ValueError(\"Unexpected command id found: \" + str(command))\n\n\n\nThe code above doesn’t introduce any new concepts, but it’s worth examining in detail to make sure you understand how all the parts work. Work through the following questions.\n\nIs this code familiar?\n\nIt should be!, It is very similar to the ride-selector and Ice Cream Sales programs\nThis menu structure is very common for imperative programs\n\nThe value returned by the read_text functions are ignored by the program. Is this legal?\n\nYes, it is perfectly legal.\nread_text is from the BTCInput library, it returns a user-provided string\n\nWe have yet to decide how we store this, so we simply discard it\nWe emulate the behaviour of getting a contact, but not the process of storing it yet\n\n\nHow does the program stop?\n\nThe main loop contains a special option that is used for exiting the program. This is achieved by calling break to get out of the loop, after which the program will finish\n\nIsn’t the prototype a bit basic? Why don’t you make it store data?\n\nThe prototype is not designed to be functional\n\nWe minimise the initial work so that if the customer backs out we haven’t wasted too much time\nWe want to make it clear that the program is a prototype, so that the customer won’t immediately want to use it\n\n\nHow is the telephone number stored?\n\nOur plan is store the number as a string\nWhile referred to as a number, telephone numbers typically have additional characters that make them much more like strings (e.g. +)\n\n\n\n\n\n\n\nStart with storing Contact Details\nSimplest implementation is to maintain a list for each different type of information we store\n\nthe \\(i\\)-th contact them has it’s details in the \\(i\\)-th index of each list\n\n  names = []\n  addresses = []\n  telephones = []\n\n  def new_contact():\n      \"\"\"\n      Creates and adds a new contact to the contact book\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Create the new contact\")\n      names.append(BTCInput.read_text(\"Enter the contact name: \"))\n      addresses.append(BTCInput.read_text(\"Enter the contact address: \"))\n      telephones.append(BTCInput.read_text(\"Enter the contact phone: \"))\nTo find items we then get the index from the names list and use that to access the corresponding indices in the addresses and telephones\n  def find_contact():\n      \"\"\"\n      Displays the contact matching a user-specified name\n\n      Prompts the user for a name, and searches the contacts list.\n      If the contact is found in the list, their full contact details\n      are displayed\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Find contact\")\n      search_name = BTCInput.read_text(\"Enter the contact name: \")\n      search_name = search_name.strip()\n      search_name = search_name.lower()\n      name_index = 0\n      for name in names:\n          name = name.strip()\n          name = name.lower()\n          if name == search_name:\n              break\n          name_index = name_index + 1\n\n      if name_position &lt; len(names):\n          print(\"Name: \", names[name_index])\n          print(\"Address: \", addresses[name_index])\n          print(\"Telephone: \", telephones[name_index])\n      else:\n          print(\"This name was not found\")\nYou can view the complete program all put together in TinyContactsParallelLists.py\n\n\n\nThe find_contact function is probably one of the more sophisticated pieces of code we’ve written. Work through the following questions to make sure you understand what is going on.\n\nHow does this code work?\n\nWe look through the names list until we find a match\nOnce we’ve found it we can immediately stop looking\n\nKeeping track of the index that we’ve been looking at\n\n\nWhat is the name_index variable used for?\n\nThe name_position variable is used to track which index of the names list matches the name we’re trying to find\nWe use this to then grab the address and phone from the addresses and telephones arrays\nThis technique is called parallel lists\n\nHow does the function know if a name has been found?\n\nIf we reach the end of the list without finding a match, then name_index ends the loop as one past the actual last valid index of the loop\n\nWe can check this with len\nWe use an if condition to check this\n\n\nWhat do the calls of strip and lower do?\n\nThese functions normalise the input, so that any extra whitespace or variations in upper and lower case are removed\n\nCan we save the user from having to type in all the names when they search?\n\nYes, we can. We could use startswith to find a name that starts with whatever the user inputs\nThis means they might only need to put in the first name\nThere are more sophisticated search techniques that we could use, but they are outside the scope of this discussion\n  if name.startswith(search_name):\n      break\n\nThe above is integrated into the complete program in TinyContactsQuickSearch.py\n\n\n\n\n\n\n\n\nAn issue with this set-up is we have to ensure that the parallel lists stay aligned\nFor example if we sort the names list alphabetically, we have to ensure we make the same transformations to the addresses and telephones lists\nWe instead would prefer to have one object or container that holds all three values together\nOne option is to use a tuple or a list\n\nBut then we have to remember how values are stored\n\nAlternative is the class\nIn object-oriented programming we use classes to define and construct objects\n\nA class is a type, an object is the instance\n\n\n\n\nOpen the python interpreter and work through the following steps and questions to understand classes\nEnter the statements below\n\nclass Contact:\n    \"\"\"\n    Stores Contact Information\n\n    Attributes\n    ----------\n    name : str\n        Contact Name\n    address : str\n        Contact's postal or street address.\n    telephone : str\n        Contact phone number (stored as a string).\n    \"\"\"\n\n    pass\n\nThe line class Contact: begins a class definition - The class contents is given as an indented block - We use pass To make an empty placeholder class\n\nWhy does the name Contact begin with a capital letter?\n\nIt’s convention, in python\n\nVariables and functions start with lowercase letters\nClasses start with uppercase letters\n\n\nWhy does the Contact class contain a Python pass statement?\n\nThe class definition expects an indented block\nWe haven’t yet decided the contents of the class so we use pass to give an placeholder statement\nWe can create an instance of a Contact with\n\n  x = Contact()\n\n\nThis looks like a function call. Are we calling a function here?\n\nTechnically this is a call to a function called a constructor\nWhich is responsible for creating an instance of a Contact\nBy using capital letters it’s clear that this is an object instantiation\n\nWhat’s an instance?\n\nAn instance is the realisation of a class\nClass is the design, object is the actual thing\nYou can add data attributes to an instance\n\n  x.name = \"Rob Miles\"\n\n\nWhat’s a data attribute?\n\nProvide information about a specific instance\nFor a contact we would want it to have name, address, and phone\nmethods can also be thought of as attributes\nYou can use and manipulate data attributes\n\n  print(x.name)\n  x.name = x.name + \" is a star\"\n  print(x.name)\n\nRob Miles\nRob Miles is a star\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAttributes in Python classes can be confusing\nThe ability to add attributes to an instance is not common across programming languages. For example Java, c# and c++ all prevent this.\nIn these languages a class definition must be fully specified including the attributes before it can be instantiated.\nBoth this static definition and pythons dynamic definitions have it’s advantages and disadvantages. The latter is easier for prototyping and development, but the former is much more type-safe\n\n\n\n\n\n\n\nWe can use the Contact class to eliminate the needs for multiple lists (see TinyContactsClass.py highlighted below)\n  contacts = []\n\n\n  def new_contact():\n      \"\"\"\n      Creates and adds a new contact to the contact book\n\n      Returns\n      -------\n      None\n\n      See Also\n      --------\n      Contact : class for storing contact information\n      \"\"\"\n      print(\"Create the new contact\")\n      new_contact = Contact()\n      new_contact.name = BTCInput.read_text(\"Enter the contact name: \")\n      new_contact.address = BTCInput.read_text(\"Enter the contact address: \")\n      new_contact.telephone = BTCInput.read_text(\"Enter the contact phone: \")\n      contacts.append(new_contact)\n\n\n  def find_contact():\n      \"\"\"\n      Displays the contact matching a user-specified name\n\n      Prompts the user for a name, and searches the contacts list.\n      If the contact is found in the list, their full contact details\n      are displayed\n\n      Returns\n      -------\n      None\n\n      Notes\n      -----\n      Matches any name prefixed by the search name\n      \"\"\"\n      print(\"Find contact\")\n      search_name = BTCInput.read_text(\"Enter the contact name: \")\n      search_name = search_name.strip()\n      search_name = search_name.lower()\n      result = None\n      for contact in contacts:\n          name = contact.name\n          name = name.strip()\n          name = name.lower()\n          if name.startswith(search_name):\n              result = contact\n              break\n\n\n\nAnswer the following questions about the new find_contact implementation\n\nHow does this code work?\n\nThis functions like the previous search, we look for a contact that has a match to the search name\nRather than use the index of the match, we set a reference to the object itself iin the variable* result\nWe use None to indicate no match was found\n\nWhat does the value None mean?\n\nNone in python is used to refer to a value that does not exist\nSemantically here it is used to indicate that no match was found\n\n\n\n\n\nThis program has a fault in that if multiple contacts have the same name as an existing one only the first one will be returned. Modify the program to correct this problem\nWe have two solutions that we could use,\n\nWhen a duplicate name is encountered we simply replace the old one\n\nThis is the simplest approach, however it is quite common for people to have the same names\n\nThe program returns all the valid matches\n\nThis is a bit more complicated\nOur search function now rather than returning one Contact returns a list containing all matching Contacts\nWe only have to change the find_contacts function (the full code is given in TinyContactsDuplicates.py)\n  def find_contact():\n      \"\"\"\n      Displays the contact matching a user-specified name\n\n      Prompts the user for a name, and searches the contacts list.\n      If the contact is found in the list, their full contact details\n      are displayed\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Find contact\")\n      search_name = BTCInput.read_text(\"Enter the contact name: \")\n      search_name = search_name.strip()\n      search_name = search_name.lower()\n      results = []\n      for contact in contacts:\n          name = contact.name\n          name = name.strip()\n          name = name.lower()\n          if name.startswith(search_name):\n              results.append(contact)\n\n      if len(results) &gt; 0:\n          for result in results:\n              print(\"Name: \", result.name)\n              print(\"Address: \", result.address)\n              print(\"Telephone: \", result.telephone, \"\\n\")\n      else:\n          print(\"This name was not found\")\n\n\n\n\n\n\n\n\nImportant\n\n\n\nLook for problems when you receive the specification\nWhen you discuss a specification there’s no guarantee ambiguities like how to deal with duplicate names will be discussed. You will need to consider cases like this that may arise and define the behaviour for them. This behaviour will need to match what the client expects to happen. The best way to make sure that happens is to make sure that is included in the specification\n\n\n\n\n\n\n\nIt might be quite common for contacts to change their contact details\nWe would like to be able to update an existing contact\nThe new interface\n  Tiny Contacts\n\n  1. New Contact\n  2. Find Contact\n  3. Edit Contact\n  4. Exit Program\n\n  Enter your command:\nWe then storyboard out the program,\n\nOur storyboard will be slightly different to the book implementation to better handle duplicates\n\n  Edit Contact\n  Enter the contact name: Rob\n  Found 1 match\n\n  Name: Robert Miles\n  Address: 18 Pussycat News, London, NE1 410S\n  Telephone: +44(1234) 56789\n\n  Edit this contact? (1 - Yes, 0 - No): 1\n\n  Enter new name or . to leave unchanged: .\n  Enter new address or . to leave unchanged: .\n  Enter new telephone or . to leave unchanged: +44 (1482) 465079\nThe edit program first needs us to find search for the contact we wish to edit\nWe then report the number of matches found\nFor each match, we then print the current details and ask the user if this is the contact they want to edit\nWe then give the user the option of editing each attribute or leaving it unchanged with .\n\n\n\n\nOur program is starting to get some structure\n\nGood time to consider a refactor\n\nWe now have two features that need to search for a contact by name\n\nFind and display a contact\nFind and edit a contact\n\nOne option is to copy the find_contact for edit_contact and replace the display code by the edit code\n\nNow we have to maintain two different copies of the search functionality\nEasy for these to become desynchronised if in the future we want to change how the search works (or need to fix a book)\n\nFor our refactor, we’ll do the following\n\nFactor out a core find_contacts function that takes a search name and returns the matches\nChange the name of the old find_contact function to display_contacts function\n\nHere’s the book’s implementation, (we’ll use something different in our implementation to account for duplicates)\n  def find_contact(search_name):\n      \"\"\"\n      Finds the contacts with the matching name\n\n      Parameters\n      ----------\n      search_name : str\n          Name to search for (uses prefix matching)\n\n      Returns\n      -------\n      list[Contact]\n          list of contacts matching the `search_name`, if no\n          matches exist the list is empty\n      \"\"\"\n      search_name = search_name.strip().lower()\n      result = None\n      for contact in contacts:\n          name = contact.name.strip().lower()\n          if name.startswith(search_name):\n              return result\n      return None\n\n\n\nAnswer the following questions, about this new version of find_contact\n\nWhy does the function contain two return statements?\n\nOnly one return will actually be executed\nIf a match is found then the match is returned\nIf not then the program will exit the for loop at which point it encounters the second return and returns None\n\nWhat would happen if another program tried to use the return value of the find_contact function, and the find_contact function had returned None\n\nDepends on what the function tries to do\nIf the function tried to something with that value, then an exception is thrown\n\n  x = None #emulate failed find from find_contact\n  print(x.address)\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[5], line 2\n      1 x = None #emulate failed find from find_contact\n----&gt; 2 print(x.address)\n\nAttributeError: 'NoneType' object has no attribute 'address'\n\n\n\nSince find_contact documents that it can return None it is the responsibility of the consumer of the function to ensure they don’t misuse the None\n\n\n\n\n\n\n\nfind_contact searches through contacts for a match\nReturned object is a reference to the memory object\ne.g. rob = find_contact(\"Rob Miles\") graphically looks like,\n\n\n\n\n\n\n---\nconfig:\n  flowchart:\n    htmlLabels: false\n---\n\n\nflowchart TD\n    A@{shape: tag-doc, label: \"Rob\"}\n    B@{shape: div-rect, label: \"Name: Rob Miles\n    Address: 18 Pussycat Mews, London, NE 410S\n    Telephone: +44(1234) 5678\"}\n\n    A--&gt;B\n\n\n\n\n\n\n\nWe have multiple references to an object, e.g. test = rob creates a new reference test\n\n\n\n\n\n\n---\nconfig:\n  flowchart:\n    htmlLabels: false\n---\n\n\nflowchart TD\n    A@{shape: tag-doc, label: \"Rob\"}\n    B@{shape: div-rect, label: \"Name: Rob Miles\n    Address: 18 Pussycat Mews ..\n    Telephone: +44(1234) 5678\"}\n    C@{shape: tag-doc, label: \"test\"}\n\n    A--&gt;B\n    C--&gt;B\n\n\n\n\n\n\n\nChanges from one reference to the underlying memory object are seen in the other references\ne.g. test.name = \"Robert Miles Man of Mystery\" gives the state as,\n\n\n\n\n\n\n---\nconfig:\n  flowchart:\n    htmlLabels: false\n---\n\n\nflowchart TD\n    A@{shape: tag-doc, label: \"Rob\"}\n    B@{shape: div-rect, label: \"Name: Rob Miles Man ...\n    Address: 18 Pussycat Mews ..\n    Telephone: +44(1234) 5678\"}\n    C@{shape: tag-doc, label: \"test\"}\n\n    A--&gt;B\n    C--&gt;B\n\n\n\n\n\n\n\nThis behaviour is sometimes referred to as shallow copying since we have multiple copies of the object, but they are not distinct, changes are propagated between all the references\n\nThere is only one memory object\n\n\n\n\nThe figure below illustrates how lists and references work. It shows a Tiny Contacts data store with three contacts registered. Each of the tags in the contacts list refers to a different Contact instance in the memory. Work through the following questions to develop your understanding of references\n\n\n\n\n\n---\nconfig:\nflowchart:\n    htmlLabels: false\n---\n\n\n    flowchart TD\n\n        subgraph Contacts\n            A@{shape: tag-doc, label: \"0\"}\n            B@{shape: tag-doc, label: \"1\"}\n            C@{shape: tag-doc, label: \"2\"}\n        end\n\n        A1@{shape: div-rect, label: \"Name: Fred Smith\n        Address: 1605 Main St,\n        New York\n        Telephone: (560) 567-5209\"}\n\n        B1@{shape: div-rect, label: \"Name: Joe Bloggs\n        Address: 2312 Pine Street,\n        Seattle\n        Telephone: (453) 545-1232\"}\n\n        C1@{shape: div-rect, label: \"Name: Rob Miles\n        Address: 18 Pussycat Mews,\n         London, NE1 410S\n        Telephone: +44(1234) 5678\"}\n        D@{shape: tag-doc, label: \"rob\"}\n\n        A--&gt;A1\n        B--&gt;B1\n        C--&gt;C1\n        D--&gt;C1\n\n\n\n\n\n\n\nThe diagram contains four references. How many data objects does it contain?\n\nThere are three data objects, the Contact items themselves\nOne (Rob Miles) is referenced by the list index \\(2\\) and the variable rob\n\nWhat would happen if the program performed the following statement?\n contacts[0] = contacts[1]\n\nThe \\(0\\) index in the list now references the same memory object as that in the \\(1\\) index, the state now looks like,\n\n\n\n\n\n\n\nflowchart TD\n    subgraph Contacts\n        A@{shape: tag-doc, label: \"0\"}\n        B@{shape: tag-doc, label: \"1\"}\n        C@{shape: tag-doc, label: \"2\"}\n    end\n\n    A1@{shape: div-rect, label: \"Name: Fred Smith\n    Address: 1605 Main St,\n    New York\n    Telephone: (560) 567-5209\"}\n\n    B1@{shape: div-rect, label: \"Name: Joe Bloggs\n    Address: 2312 Pine Street,\n    Seattle\n    Telephone: (453) 545-1232\"}\n\n    C1@{shape: div-rect, label: \"Name: Rob Miles\n    Address: 18 Pussycat Mews,\n    London, NE1 410S\n    Telephone: +44(1234) 5678\"}\n    D@{shape: tag-doc, label: \"rob\"}\n\n    A--&gt;B1\n    B--&gt;B1\n    C--&gt;C1\n    D--&gt;C1\n\n\n\n\n\n\n\nLooping through the list would thus refer to the Joe Bloggs Contact twice\nNote that we have now lost the reference to Fred Smith, we can never get it back!\n\nUnreferenced memory objects will be removed by python in a process called garbage collection\n\nReferences make it easy to work with large data objects\n\nAvoid the need to create expensive copies\n\n\n\n\n\n\nEverything in Python is an object\n30 is an instance of an int\nThe following creates a reference age to 30\n\n  age = 30\n\nWhich we can visualise,\n\n\n\n\n\n\n    flowchart TD\n        A@{shape: tag-doc, label: \"age\"}\n\n        A1[\"`int\n            30`\"]\n\n        A--&gt;A1\n\n\n\n\n\n\n\nand verify,\n\n  type(age)\n\nint\n\n\ntype is a built-in function\n\nTakes a reference as an argument\nReturns the type of the referenced object\n\nNow, suppose we define another reference temp via\n\n  temp = age\n\nWhich we can again visualise as,\n\n\n\n\n\n\n    flowchart TD\n        A@{shape: tag-doc, label: \"age\"}\n        B@{shape: tag-doc, label: \"temp\"}\n\n        A1[\"`int\n            30`\"]\n\n        A--&gt;A1\n        B--&gt;A1\n\n\n\n\n\n\n\nage and temp now refer to the same object instance\nWhat happens if we assign temp a new value?\n\n  temp = 99\n  print(age)\n  print(temp)\n\n30\n99\n\n\nSo we have the final state,\n\n\n\n\n\n\n    flowchart TD\n        A@{shape: tag-doc, label: \"age\"}\n        B@{shape: tag-doc, label: \"temp\"}\n\n        A1[\"`int\n            30`\"]\n        B1[\"`int\n            99`\"]\n\n        A--&gt;A1\n        B--&gt;B1\n\n\n\n\n\n\n\nage has not been modified\nInstead a new int with a value of \\(99\\) was created\nThis is because int is an immutable type\n\ni.e. once an int has been created its value can’t be reassigned\nValue assignments thus create a new instance of an int\n\nstring is also an immutable type\n\n  name = \"Rob\"\n  temp = name\n  print(\"temp is\", temp, \"name is\", name)\n  temp = \"Fred\"\n  print(\"temp is now\", temp, \"name is now\", name)\n\ntemp is Rob name is Rob\ntemp is now Fred name is now Rob\n\n\n\n\nWhy does python use immutable data types?\n\nFor some procedures, like simple numerical calculations, treating variables as values is often the most desired approach, e.g.\n  pi = 3.1415\n  x = pi\n  x = 99.99\nWe don’t want the above to accidentally change the value of the constant pi\n\n\n\n\n\n\n\n\nImportant\n\n\n\nProgramming Languages work with values differently\nLanguages handle the distinction between references and values differently. References make it easy to work with large data as the objects remain stationary in memory. However value types make it easy to perform data manipulation with types such as int, bool, float and string\nC# has a similar concept of value types. Java has primitive types, C++ has references. Python implements int, bool, float and string are immutable types, and behave like values\nRemember that the tuple collection type is also immutable\n\n\n\n\n\n\n\nOnce we have found a reference we can read and modify the attributes\nOur program implementation, uses a simple interface optionally modify each attribute one at a time\n\nNeed to read a user string for each modifiable attribute\nOur duplicates implementation also needs to read an int to indicate if we want to modify a specific contact (and print the current contact)\n\nThe book implementation is,\ndef edit_contact():\n  \"\"\"\n  Reads in a name to search for an then allows the user\n  to edit the details of that contact. If there is no\n  contact, the function displays a message indicating\n  that the name was not found\n  \"\"\"\n\n  print(\"Edit Contact\")\n  search_name = read_text(\"Enter the contact name: \")\n  contact=find_contact(search_name)\n  if contact != None:\n      print(\"Name: \", contact.name)\n      new_name = read_text(\"Enter new name or . to leave unchanged\")\n      if new_name != '.':\n          contact.name = new_name\n      new_address = read_text(\"Enter new address or . to leave unchanged\")\n      if new_address != '.':\n          contact.address = new_address\n      new_phone = read_text(\"Enter new phone or . to leave unchanged\")\n      if new_phone != '.':\n          contact.telephone = new_phone\n  else:\n      print(\"This name was not found\")\nEditing as configured performs modifications of the live data\n\nReferred to as in-place because it occurs on the original object not a copy\n\nCan’t easily rollback if there is an error or ask the user wishes to cancel\nTo do so, edit_contact would need to work on a copy of the data\n\n\n\n\n\n\n\nWarning\n\n\n\nMissing Attributes\nedit_function calls find_contact to match a given name. find_contact returns None if no match is found. However, another possible fault in a contact is returned without all the attributes defined, e.g. a contact with a name but no address. Then the program would fail, as the code below demonstrates\n\nclass Contact:\n    pass\n\n# fake contact \"returned without address\"\ncontact = Contact()\ncontact.name = \"Hello\"\n\n# Attempt to access address\nprint(\"contact address is\", contact.address)\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[11], line 9\n      6 contact.name = \"Hello\"\n      8 # Attempt to access address\n----&gt; 9 print(\"contact address is\", contact.address)\n\nAttributeError: 'Contact' object has no attribute 'address'\n\n\n\nSome programming languages e.g. Java, C#, C++ check for these errors before a program executes. Python does not. This means that minor typos e.g. writing address instead of address can lead to runtime errors\n\n\n\n\n\n\n\nWe saw in Chapter 8 that we can save and load data to files\n\nThere we used a human-readable text representation\n\nWe could replicate this for large class based structures\n\ne.g. write out all attributes as comma, separated values\n\nPython provides a process called pickling for storing large data structures\n\npickled data is stored as binary\nData is therefore computer-readable and more compressed than human text\n\nPickling is done through the pickle library, import it to use it\n  import pickle\njpeg, mp3, zip are all different formats of binary data\n\nCommonly a file extension is used to identify what a binary file represents\ne.g.\n\nmyhouse.jpg\ntrack1.mp3\n\nDifferent programs are written to work with different binary file formats\n\n.txt defines a generic text file\n.py defines a text file that is valid python code\nTechnically text is also a binary file, just with those binary values associated to human-readable characters\nPython programs can use the b mode flag to read files as binary, e.g.\n  out_file = open(\"contacts.pickle\", \"wb\")\n\nThe above opens the file contacts.pickle for writing (w) as a binary file (b)\n.pickle indicates the file is a pickled python data object\n\npickle supplies the dump function to write a data structure to a file\n\nThe file must be opened for writing in binary\n\n  pickle.dump(contacts, out_file)\n\ncontacts is the variable to pickle\nout_file is the variable storing the file save the data to\n\nYou can open and modify pickle files\n\nWhile they may contain some readable text, they will also contain a mix of improperly rendered binary\n\n(Unless you have a specially set up text editor like a hexadecimal reader)\n\n\n\n\n\n\nPickled content of the Tiny Contacts app, a mix of human-readable characters and improperly rendered binary is displayed\n\n\n\n\n\n\n\n\nCaution\n\n\n\nBe careful modifying pickle files by hand\nPickle files are not designed to be human-readable. While most text editors will happily let you edit and save a pickle file this is very likely to end up in you breaking the binary format and the file no longer loading properly\n\n\n\nsave_contacts below saves the contacts list into a given file (passed as a path name)\n\nAs in Chapter 8 we use with to handle managing the file access\n\ndef save_contacts(file_name):\n  \"\"\"\n  Saves the contacts to the given file name\n\n  Contacts are stored in binary as a pickled file\n\n  Parameters\n  ----------\n  file_name : str\n      string giving the path to the file to store the contacts data in\n\n  Returns\n  -------\n  None\n\n  Raises\n  ------\n      Exceptions are raised if contacts could not be saved\n\n  See Also\n  --------\n  load_contacts : loads contacts from a pickled file\n  \"\"\"\n  print(\"save contacts\")\n  with open(file_name, \"wb\") as out_file:\n      pickle.dump(contacts, out_file)\n\nThis function does not perform any exception handling\nThis will cause the program to crash if the save fails\n\nProbably fine for a program of this size\nNote: You should never hide a failed save from the user!\n\nIf we wanted to handle exceptions, we would do that in the code outside save_contacts\n\n\n\n\n\n\npickle provides load to read a pickle file\n\nreturns the reconstructed data object\nAs a result, needs only the file\n\nfile needs to be open for reading r and in binary mode b\n  def load_contacts(file_name):\n      \"\"\"\n      Loads the contacts from the given file\n\n      Contacts are stored in binary as a pickled file\n\n      Parameters\n      ----------\n      file_name : str\n          string giving the path to the file where the contacts data is stored\n\n      Returns\n      -------\n      None\n          Contact detail is loaded into the global `contacts` value\n\n      Raises\n      ------\n          Exceptions if contacts failed to load\n\n      See Also\n      --------\n      save_contacts : saves contacts to a pickled file\n      \"\"\"\n      global contacts #connect to the global contacts variable\n      print(\"load contacts\")\n      with open(file_name, \"rb\") as input_file:\n          contacts=pickle.load(input_file)\n\n\n\nWork through the following questions to make sure you understand how load_contacts works\n\nWhat does the global contacts statement do? Why do we need it only in the load function and not the save function?\n\nThe load_contacts function is used to modify the values of the contacts variable\nThe contacts holds all the current contacts, held in the program\nsave_contacts needs the reference to find the list\n\nDoes not modify the list itself\n\nload_contacts does modify the contacts list\n\nNeed to explicitly link to the global variable to write to it\n\n\nHow does the pickle load function know what kind of data to make when loading?\n\nThe information is encoded in the pickle file\nIn a pickle file you should be able to identify the data attributes (name etc.) and their values\nAlso contains the class name\nload looks for matching classes in the program loading the data\n\nConstructs object instances based on those classes\nMeans the class Contact must be defined before pickle is used to load any contact data\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nVersion Control\nPickle is a tool called a serializer because it converts a data structure is a serial stream (i.e. ordered sequence of data) that can be sent to another program and/or stored in a file.\nThis introduces the need for version control. If the design of a class e.g. Contact (say we added an email attribute) then all previously pickled data may no longer load since the class definition is mismatched. To resolve this you need to version control both the version of the class and the pickled files so that data can be migrated (or converted) between versions\n\n\n\n\n\n\n\nLet’s add the save and load functionality to the Tiny Contacts Program\nThere are two options for how we implement this,\n\nThe user manually declares they want to save and load\nWe hardcode a data file\n\nLoad from this file on program start\nSave to this file as part of the exit process\n\n\nFor a small contacts app the user probably doesn’t want to manually have to handle saving and loading files\nMore likely to want to have it “just work”\n\nWe’ll go with option 2\n\nThe new interface now looks like below (see our full implementation which contains an example pickle file)\n  # Example 9.7 Tiny Contacts with Load and Save\n  import pickle\n\n  #Load contacts from file or create empty list if it fails to load\n  file_name = \"contacts.pickle\"\n  try:\n      load_contacts(file_name)\n  except:\n      print(\"Contacts file not found\")\n      contacts=[]\n\n  while True:\n      command = BTCInput.read_int_ranged(prompt=menu, min_value=1, max_value=4)\n      if command == 1:\n          new_contact()\n      elif command == 2:\n          display_contact()\n      elif command == 3:\n          edit_contact()\n      elif command == 4:\n          save_contacts(file_name) #save contacts on exit\n          break\n      else:\n          raise ValueError(\"Unexpected value encountered\")\n\n\n\nConsider the following questions about the code above\n\nWhat happens if the load_contacts function raises an exception?\n\nload_contacts raises an exception if the contacts file can’t be found, or if the load function in pickle fails\nIn this case the exception is caught, an error message is printed and an empty contacts list is created\n\nWhy does the program not catch the exceptions raised by save_contacts?\n\nYou could add this if you wanted\nIf the program crashes, the user should probably expect the save failed\nSince they were trying to quit anyway they probably don’t care\nMy implementation adds try...except block that prints an error message if the save fails (as the book suggests you consider)\n\nWhy does the program use a variable for the file name of the pickled file?\n\nThe contacts are held in a file called* contacts.pickle\nThis file is used in two places* load_contacts and save_contacts\n\nWe could put the string literal in both places\nInstead use a variable\nMeans we can change the file name in one place and the program works\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nAvoiding Magic Constants\nA magic constant is a literal value that appears in multiple places in code without an apparent reason. For example if we just used contacts.pickle that would be a magic constant. The string is a constant but there is no context to explain what the value means. Magic constants are problematic because they are hard to find and if we want to change them we have to find all the places they’re used and then resolve the issue of does this 2 correspond to this magic constant or another magic constant\nIt is a good idea to instead put these constants in a variable so that we need only change the value in one place and we can clearly explain what the constant means\n\n\n\n\n\n\n\nTiny Contacts builds the Contact instance after we create one\n  new_contact = Contact()\n  new_contact.name = BTCInput.read_text(\"Enter the contact name: \")\n  new_contact.address = BTCInput.read_text(\"Enter the contact address: \")\n  new_contact.telephone = BTCInput.read_text(\"Enter the contact phone: \")\nThis makes the program fragile\n\nWe could misspell an attribute\nForget to set one\n\nIdeally want to create a Contact and ensure values are set as part of creation\nWe can do so with a Constructor, a special method called to create the object\n\nAlso sometimes called an initializer method\n\nA method attribute is like a data attribute but as an attached function\n\n\n\n\nHeld inside a python class\nNamed __init__\n\npython uses “dunder methods” marked __function_name__ to mark special functions defined by the language\n\n\n\n\nOpen the python interpreter and work through the following steps to create an understand an initializer, answering the questions\nType the below code in to define a class\n\nclass InitPrint:\n    def __init__(self):\n        print(\"you made an InitPrint instance\")\n\nThe above defines the class InitPrint it defines an initializer method that prints a method. Note the double underscore before and after the init are required, as is the parameter self. The last line of the class is an empty line\n\nThe initializer looks remarkably like a function why is that?\n\nAn initializer is a function that is called when a class instance is created.\nType in the code below, which creates an instance of InitPrint and assigns it to the variable x,observe that the __init__ method is called even without us explicitly putting it\n\n  x = InitPrint()\n\nyou made an InitPrint instance\n\n\n\nHow is the __init__ function made to run?\n\nIt is handled by the python interpreter and how objects are constructed\nIt will run each time an instance of the InitPrint class is created\n\n\n\nNow define the InitName class as below\n\n  class InitName:\n      def __init__(self, new_name):\n          self.name = new_name\n\n\nThe initializer can take arguments like any other function, here it takes new_name\nInitializer no longer prints a message but rather sets a name attribute on the variable self\nself is a reference to the object running the method\n\nIn the initializer this is the object being created\nself is always the first parameter of a method, and must be included\n\nNow replicate the code below to see how the new __init__ method works\n\n  x = InitName(\"Fred\")\n  print(x.name)\n\nFred\n\n\nWhen creating an InitName object we now have to pass the new_name parameter\nObserve we don’t explicitly pass self\n\nOnce an initializer is defined, it is the only way to create an instance\n\nAttempting otherwise leads to an error, e.g. if we exclude the new_name\n\n\n  y = InitName()\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[16], line 1\n----&gt; 1 y = InitName()\n\nTypeError: InitName.__init__() missing 1 required positional argument: 'new_name'\n\n\n\nThis is a way of enforcing that an object is created with a full set of attributes\nOur Contact class, should accept three parameters\n\n  class Contact:\n      def __init__(self, name, address, telephone):\n          \"\"\"\n          Create a new `Contact` instance\n\n          Parameters\n          ----------\n          name : str\n              Contact Name\n          address : str\n              Contact's postal or street address\n          telephone : str\n              Contact phone number (stored as a string)\n          \"\"\"\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n\n\n\n\n\nWork through the following questions to ensure you understand the __init__ method\n\nIt looks like you’ve written the assignments in the initializer so that a value is assigned to itself. What’s going on?\n\nConsider a statement\n  self.telephone = telephone\nThis looks like assigning telephone to telephone it, does not\nThe left is the telephone attribute on the self object\nThe right is the telephone parameter passed to the initializer\nPython variable names are namespaced\n\nnamespaces are regions in which names are uniquely identified\n\nOne namespace is the local namespace of the __init__ method\nThe other namespace is the attribute namespace of the self object\nnamespaces allow different contexts to use the same variable name distinct from each other\nGenerally it is convention to give initializer parameters the same name as their associated object attributes\n\nWhat happens if the user of the constructor supplies silly arguments to it?\n\nCurrently the constructor doesn’t validate the input\ne.g. we could pass name a number, empty string or even None\n\nStill generates a Contact\n\nYou can add error handling code to the constructor and raise exceptions if the provided values are invalid\n\nFor a more robust application this might be required\nFor a small toy program we can generally expect valid input\n\n\n\n\nIf we want to create a new Contact now we can just call,\n\n\n    rob = Contact(name = \"Rob Miles\", address=\"18 Pussycat Mews, London, NE1 410S\", telephone=\"+44(1234) 56789\")\n\n\nWe can integrate this into our Tiny Contacts implementation\n  def new_contact():\n      \"\"\"\n      Creates and adds a new contact to the contact book\n\n      Returns\n      -------\n      None\n\n      See Also\n      --------\n      Contact : class for storing contact information\n      \"\"\"\n      print(\"Create new contact\")\n      name = BTCInput.read_text(\"Enter the contact name: \")\n      address = BTCInput.read_text(\"Enter the contact address: \")\n      telephone = BTCInput.read_text(\"Enter the contact phone: \")\n      new_contact = Contact(name=name, address=address, telephone=telephone)\n      contacts.append(new_contact)\n\n\n\n\n\n\nThe __init__ method supports default arguments\nFor example if we don’t want to make the telephone mandatory we could write\n\n  class Contact:\n      def __init__(self, name, address, telephone=\"No Telephone\"):\n          \"\"\"\n          Create a new Contact instance\n\n          Parameters\n          ----------\n          name : str\n              Contact Name\n          address : str\n              Contact's postal or street address\n          telephone : str\n              Contact phone number (stored as a string)\n          \"\"\"\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n\nWe could then create create a Contact as,\n\n  rob = Contact(name=\"Rob Miles\", address=\"18 Pussycat Mews, London, NE1 410S\")\n  print(rob.telephone)\n\nNo Telephone\n\n\n\nObserve that the telephone attribute still exists and has the default value \"No Telephone\"\n\n\n\n\n\n\n\n\nA Dictionary is another collection type like list and tuple\nDictionaries store data as key-value pairs\n\nA value is looked up by its key\nYou can think of a list as a dictionary where the key is the index\n\n\n\n\n\nLet’s consider creating a dictionary for a coffee shop\nWe want to key coffee products to their price (value)\nWe create an empty dictionary using {}\n\n  prices = {}\n\nItems can be added using the indexing operator to assign a value,\n\n  prices[\"latte\"] = 3.5\n  prices[\"latte\"]\n\n3.5\n\n\nWe can see prices has the key latte and the associated value of \\(3.5\\)\nWe can redefine dictionary values as for lists\n\n  prices[\"latte\"] = 3.6\n  prices[\"latte\"]\n\n3.6\n\n\nKeys are case-sensitive and must be spelled correctly, else a KeyError occurs,\n\n  prices[\"Latte\"]\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[24], line 1\n----&gt; 1 prices[\"Latte\"]\n\nKeyError: 'Latte'\n\n\n\nWe can search a dictionary for keys using the in operator\n\n  print('latte' in prices)\n  print('flat white' in prices)\n\nTrue\nFalse\n\n\nWe can print an entire dictionary just like with lists and tuples\n\n  prices[\"espresso\"] = 3.0\n  prices[\"tea\"] = 2.5\n  prices\n\n{'latte': 3.6, 'espresso': 3.0, 'tea': 2.5}\n\n\nObserve that the key-value pairs are printed with the format key : value\nWe can also create a dictionary with value using the same syntax like the printed output\n\n  prices = {'Latte' : 3.6, 'Espresso' : 3.0, \"Tea\" : 2.5, \"Americano\" : 2.5}\n\n\n\n\n\n\nDictionary elements use the \"key:item\" format\nKeys and values can be a mix of types, e.g. str, int, float e.g.,\n\n  access_control = {1234 : \"complete\", 1111 : \"limited\", 4342 : \"limited\"}\n\nValues can be duplicated\nBut keys must be unique\nConsider a dictionary that controls access to a burglar alarm\n\nUsers provide an access code\nCode keys a dictionary\nAccess is determined by the value in the dictionary\nA missing key (code) indicates no access permissions\n\n  # Example 9.9 Alarm Access Control\n  #\n  # Demonstrates the use of a dictionary as a lookup table to translate\n  # keys into associated values\n\n  import BTCInput\n\n  access_control = {1234: \"complete\", 1111: \"limited\", 4342: \"limited\"}\n\n  access_code = BTCInput.read_int(\"Enter your access code: \")\n  if access_code in access_control:\n      print(\"You have\", access_control[access_code], \"access\")\n  else:\n      print(\"You are not allowed access\")\nWe can delete dictionary entries using the del keyword, e.g.\n\n  del(access_control[1111])\n  print(access_control[1111])\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[29], line 2\n      1 del(access_control[1111])\n----&gt; 2 print(access_control[1111])\n\nKeyError: 1111\n\n\n\nThe KeyError above shows that the key-value has been eliminated\ndel can also be used to remove elements of a list\ndel will raise an exception if the object being deleted doesn’t exist\n\n\n\n\n\nWe’ve seen that programs can use dictionaries as lookup tables\nCan also return a dictionary from a function\n\ne.g. our Pirates Treasure map from Chapter 8 could use a dict instead\n\n\n  # Example 9.10: Pirate Treasure Dictionary\n  #\n  # Implementation of the Pirates Treasure map that uses a\n  # dictionary rather than a tuple to provide contextual\n  # key-value pairs\n\n\n  def get_treasure_location():\n      \"\"\"\n      Get the location of the treasure\n\n      Returns\n      -------\n      dict\n          Dictionary containing the location of the treasure, containing\n          the following keys\n\n          `\"start\"` : str\n\n              landmark to start at\n\n          `\"n\"` : int\n\n              number of paces to walk north relative to the\n              start\n\n          `\"e\"` : int\n\n              number of paces to walk east relative to the\n              start\n      \"\"\"\n      return {\"start\": \"The old oak tree\", \"n\": 20, \"e\": 30}\n\n\n  location = get_treasure_location()\n  print(\n      \"Start at\",\n      location[\"start\"],\n      \"walk\",\n      location[\"n\"],\n      \"paces north, and\",\n      location[\"e\"],\n      \"paces east\",\n  )\n\nStart at The old oak tree walk 20 paces north, and 30 paces east\n\n\nDictionaries let us assign contextual meaning to the returned parameters\nHarder to work with than tuple unpacking though\n\n\n\n\n\nWe could use dictionaries to store contacts in Tiny Contacts\n\nRather than use a class we could represent a contact with a dictionary like\n\n  rob_contact = {\"name\" : \"Rob Miles\", \"address\" : \"18 Pussycat Mews\", \"telephone\" : \"+44(1234) 56789\"}\n\n\nBut the we lost some of the nice class behaviours\n\nlike attributes being accessible via Contact.name etc. and we would instead have to use the string literal keys everywhere\n\n\nAnother option is storing the contacts themselves in a dictionary rather than a list\n\n contact_dictionary = {}\n rob = Contact(name = \"Rob Miles\", address = \"18 Pussycat Mews\", telephone = \"+44(1234) 56789\")\n contact_dictionary[rob.name] = rob\n print(contact_dictionary)\n\n{'Rob Miles': &lt;__main__.Contact object at 0x7f39c8e4d4f0&gt;}\n\n\nWe can then search for a contact by just querying the key\n\n  contact_dictionary[\"Rob Miles\"]\n\n&lt;__main__.Contact at 0x7f39c8e4d4f0&gt;\n\n\nHowever the user would have to type the correct full name\n\nAlso case sensitive\nWe could fix the case sensitivity by rather than using the name directly using a normalised key\n\nsuch as by using strip().lower() to strip excess whitespace and convert to lowercase\n\n\nOur current implementation uses startswith to provide more flexible matching\nIn general though, dictionaries provide fast queries for finding objects when we can easily use the key as a unique identifier\n\n\n\n\n\n\nThe Tiny contacts program is a useful template for any kind of program that stores data and lets a user work with it. You can even add some of the sorting and data-processing features from the ice-cream sales program to make applications that not only store data but let you do interesting things with it.\nExpand on the Tiny Contacts Program to implement the following,\n\nThe Tiny Contacts program will print all contacts if the find_contacts search string is blank, document this for the user\nAdd the sorting features from the ice-cream sales program to print contacts in alphabetical order\nIdentify more common between functions in Tiny Contacts and see what further refactors you can make\n\nThe first step is straightforward. We update the program is two places. First we document the behaviour in the responsible function, find_contacts\ndef find_contacts(search_name):\n    \"\"\"\n    Finds the contacts with the matching name\n\n    If the empty string is given, all contacts\n    are matched\n\n    Parameters\n    ----------\n    search_name : str\n        Name to search for (uses prefix matching)\n\n    Returns\n    -------\n    list[Contact]\n        list of contacts matching `search_name`, if no\n        matches exist the list is empty\n    \"\"\"\n    search_name = search_name.strip().lower()\n    results = []\n    for contact in contacts:\n        name = contact.name.strip().lower()\n        if name.startswith(search_name):\n            results.append(contact)\n    return results\nThis helps anyone who in the future has to edit or maintain our code. However it doesn’t provide much help to the user of the program. So we also document this in the user facing code (display_contacts)\ndef display_contacts():\n    \"\"\"\n    Prompts the user for a contact name and\n    displays all matching contacts\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_contact : displays a single contact\n    \"\"\"\n    print(\"Find contact\")\n    contacts = find_contacts(\n        BTCInput.read_text(\"Enter the contact name (Press enter to display all): \")\n    )\n    if len(contacts) &gt; 0:\n        for contact in contacts:\n            display_contact(contact)\n    else:\n        print(\"This name was not found\")\nThe relevant line being,\n    BTCInput.read_text(\"Enter the contact name (Press enter to display all): \")\nTo add the sorting functionality we first need to put the sorting code in,\ndef sort_contacts():\n    \"\"\"\n    sorts the contacts list into alphabetical order\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"Sort contacts\")\n    for sort_pass in range(0, len(contacts)):\n        done_swap = False\n        for count in range(0, len(contacts) - 1 - sort_pass):\n            if contacts[count].name &gt; contacts[count + 1].name:\n                temp = contacts[count]\n                contacts[count] = contacts[count + 1]\n                contacts[count + 1] = temp\n                done_swap = True\n        if not done_swap:\n            break\nThis code is basically the same as the sorting code in the ice-cream stand example except there might be something that looks odd. namely the line\ncontacts[count].name &gt; contacts[count + 1].name\nThis is because we want to sort the Contact objects alphabetical on the name field. So we have to compare against this field. contacts[count] is a reference to the Contact object stored at the index count so we can access the attributes on the underlying object\nWe then need to include the sorting option in the display menu\nmenu = \"\"\"Tiny Contacts\n\n1. New Contact\n2. Find Contact\n3. Edit Contact\n4. Sort Contacts\n5. Exit Program\n\nEnter your command: \"\"\"\n\nfile_name = \"contacts.pickle\"\ntry:\n    load_contacts(file_name)\nexcept:  # noqa: E722\n    print(\"Contacts file not found\")\n    contacts = []\n\nwhile True:\n    command = BTCInput.read_int_ranged(prompt=menu, min_value=1, max_value=5)\n    if command == 1:\n        new_contact()\n    elif command == 2:\n        display_contacts()\n    elif command == 3:\n        edit_contacts()\n    elif command == 4:\n        sort_contacts()\n    elif command == 5:\n        try:\n            save_contacts(file_name)\n        except:  # noqa: E722\n            print(\"Contacts failed to save\")\n        break\n    else:\n        raise ValueError(\"Unexpected command id found: \" + str(command))\nTo answer the final question of what functionality we can pull out we can see that both display_contacts and edit_contacts contain code for displaying an individual Contact. We can pull this code out into a distinct display_contact function responsible for displaying a single Contact. We can then update display_contacts and edit_contacts to defer the display functionality to display_contact\ndef display_contact(contact):\n    \"\"\"\n    Displays the Contact details for the supplied contact\n\n    Parameters\n    ----------\n    contact : Contact\n        contact to display\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_contacts : Displays all contacts matching a search name\n    \"\"\"\n    print(\"Name:\", contact.name)\n    print(\"Address:\", contact.address)\n    print(\"Telephone:\", contact.telephone, \"\\n\")\nThe new display_contacts now looks like,\ndef display_contacts():\n    \"\"\"\n    Prompts the user for a contact name and\n    displays all matching contacts\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_contact : displays a single contact\n    \"\"\"\n    print(\"Find contact\")\n    contacts = find_contacts(\n        BTCInput.read_text(\"Enter the contact name (Press enter to display all): \")\n    )\n    if len(contacts) &gt; 0:\n        for contact in contacts:\n            display_contact(contact)\n    else:\n        print(\"This name was not found\")\nand edit_contacts looks similar\n\n\n\nThis Chapter also contains two further examples which demonstrate building data storage applications that handle more functionality than tiny contacts.\nDue to the size of the discussion required for each exercise they are linked on a separate page\n\n\nFocuses on demonstrating adding additional functionality to a basic storage application for data interrogation\n\nDevelops an application that can store music tracks\nImplements searching and sorting based on length of the track\nSupports the ability to create and save playlists\nPlaylists can be interrogated for their total length\nThe program can suggest playlists that match the user’s target runtime\n\n\n\n\nDemonstrates working with larger more complicated objects in data storage\n\nDevelops and application for storing recipes\nUsers can search for recipes by their name or their ingredients\nSupports different mechanisms for viewing details about a recipe\n\nViewing the ingredients\nViewing the steps\nStepping through the recipe, step by step\n\n\nYou are encouraged to work through or examine these exercises",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 9: Use Classes to Store Data"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/09_UsingClasses/Chapter_09.html#notes",
    "href": "02_AdvancedProgramming/09_UsingClasses/Chapter_09.html#notes",
    "title": "Chapter 9: Use Classes to Store Data",
    "section": "",
    "text": "Let’s develop a lightweight program to store contact details\n\nNames\nAddresses\nTelephone Numbers\n\nWe storyboard the interface\n  Tiny Contacts\n\n  1. New Contact\n  2. Find Contact\n  3. Exit Program\n\n  Enter your command:\nWe then want to extend the storyboard to the different interface options\n  Create new contact\n\n  Enter the contact name: Rob Miles\n  Enter the contact address: 18 Pussycat Mews, London, NE1 410S\n  Enter the contact phone: +44(1234) 56789\n\n  Contact record stored for Rob Miles\nThe matching storyboard for find is then,\n  Find Contact\n\n  Enter the contact name: Rob Miles\n  Name: Rob Miles\n  Address: 18 Pussycat Mews, London, NE1 410S\n  Phone: +44(1234) 56789\n\nWith a matching storyboard for a contact not existing\n    Find Contact\n\n    Enter the contact name: Fred Bloggs\n    This name was not found\n\n\n\n\n\nWe start by making a prototype\n\nWe stub out the functions with mock messages\n\nThis is good for demoing to the customer for their feedback\n\nAlso helps to start working out how the structure should flow\n\n  # Example 9.1 Tiny Contacts Prototype\n  #\n  # Simple stub implementation of the Tiny Contacts Prototype\n\n  import BTCInput\n\n\n  def new_contact():\n      \"\"\"\n      Creates and adds a new contact to the contact book\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Create the new contact\")\n      BTCInput.read_text(\"Enter the contact name: \")\n      BTCInput.read_text(\"Enter the contact address: \")\n      BTCInput.read_text(\"Enter the contact phone: \")\n\n\n  def find_contact():\n      \"\"\"\n      Displays the contact matching a user-specified name\n\n      Prompts the user for a name, and searches the contacts list.\n      If the contact is found in the list, their full contact details\n      are displayed\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Find contact\")\n      name = BTCInput.read_text(\"Enter the contact name: \")\n      if name == \"Rob Miles\":\n          print(\"Name: Rob Miles\")\n          print(\"Address: 18 Pussycat News, London, NE1 410S\")\n          print(\"Phone: +44(1234) 56789\")\n      else:\n          print(\"This name was not found.\")\n\n\n  menu = \"\"\"Tiny Contacts\n\n  1. New Contact\n  2. Find Contact\n  3. Exit Program\n\n  Enter your command:\"\"\"\n\n  while True:\n      command = BTCInput.read_int_ranged(prompt=menu, min_value=1, max_value=3)\n      if command == 1:\n          new_contact()\n      elif command == 2:\n          find_contact()\n      elif command == 3:\n          break\n      else:\n          raise ValueError(\"Unexpected command id found: \" + str(command))\n\n\n\nThe code above doesn’t introduce any new concepts, but it’s worth examining in detail to make sure you understand how all the parts work. Work through the following questions.\n\nIs this code familiar?\n\nIt should be!, It is very similar to the ride-selector and Ice Cream Sales programs\nThis menu structure is very common for imperative programs\n\nThe value returned by the read_text functions are ignored by the program. Is this legal?\n\nYes, it is perfectly legal.\nread_text is from the BTCInput library, it returns a user-provided string\n\nWe have yet to decide how we store this, so we simply discard it\nWe emulate the behaviour of getting a contact, but not the process of storing it yet\n\n\nHow does the program stop?\n\nThe main loop contains a special option that is used for exiting the program. This is achieved by calling break to get out of the loop, after which the program will finish\n\nIsn’t the prototype a bit basic? Why don’t you make it store data?\n\nThe prototype is not designed to be functional\n\nWe minimise the initial work so that if the customer backs out we haven’t wasted too much time\nWe want to make it clear that the program is a prototype, so that the customer won’t immediately want to use it\n\n\nHow is the telephone number stored?\n\nOur plan is store the number as a string\nWhile referred to as a number, telephone numbers typically have additional characters that make them much more like strings (e.g. +)\n\n\n\n\n\n\n\nStart with storing Contact Details\nSimplest implementation is to maintain a list for each different type of information we store\n\nthe \\(i\\)-th contact them has it’s details in the \\(i\\)-th index of each list\n\n  names = []\n  addresses = []\n  telephones = []\n\n  def new_contact():\n      \"\"\"\n      Creates and adds a new contact to the contact book\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Create the new contact\")\n      names.append(BTCInput.read_text(\"Enter the contact name: \"))\n      addresses.append(BTCInput.read_text(\"Enter the contact address: \"))\n      telephones.append(BTCInput.read_text(\"Enter the contact phone: \"))\nTo find items we then get the index from the names list and use that to access the corresponding indices in the addresses and telephones\n  def find_contact():\n      \"\"\"\n      Displays the contact matching a user-specified name\n\n      Prompts the user for a name, and searches the contacts list.\n      If the contact is found in the list, their full contact details\n      are displayed\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Find contact\")\n      search_name = BTCInput.read_text(\"Enter the contact name: \")\n      search_name = search_name.strip()\n      search_name = search_name.lower()\n      name_index = 0\n      for name in names:\n          name = name.strip()\n          name = name.lower()\n          if name == search_name:\n              break\n          name_index = name_index + 1\n\n      if name_position &lt; len(names):\n          print(\"Name: \", names[name_index])\n          print(\"Address: \", addresses[name_index])\n          print(\"Telephone: \", telephones[name_index])\n      else:\n          print(\"This name was not found\")\nYou can view the complete program all put together in TinyContactsParallelLists.py\n\n\n\nThe find_contact function is probably one of the more sophisticated pieces of code we’ve written. Work through the following questions to make sure you understand what is going on.\n\nHow does this code work?\n\nWe look through the names list until we find a match\nOnce we’ve found it we can immediately stop looking\n\nKeeping track of the index that we’ve been looking at\n\n\nWhat is the name_index variable used for?\n\nThe name_position variable is used to track which index of the names list matches the name we’re trying to find\nWe use this to then grab the address and phone from the addresses and telephones arrays\nThis technique is called parallel lists\n\nHow does the function know if a name has been found?\n\nIf we reach the end of the list without finding a match, then name_index ends the loop as one past the actual last valid index of the loop\n\nWe can check this with len\nWe use an if condition to check this\n\n\nWhat do the calls of strip and lower do?\n\nThese functions normalise the input, so that any extra whitespace or variations in upper and lower case are removed\n\nCan we save the user from having to type in all the names when they search?\n\nYes, we can. We could use startswith to find a name that starts with whatever the user inputs\nThis means they might only need to put in the first name\nThere are more sophisticated search techniques that we could use, but they are outside the scope of this discussion\n  if name.startswith(search_name):\n      break\n\nThe above is integrated into the complete program in TinyContactsQuickSearch.py\n\n\n\n\n\n\n\n\nAn issue with this set-up is we have to ensure that the parallel lists stay aligned\nFor example if we sort the names list alphabetically, we have to ensure we make the same transformations to the addresses and telephones lists\nWe instead would prefer to have one object or container that holds all three values together\nOne option is to use a tuple or a list\n\nBut then we have to remember how values are stored\n\nAlternative is the class\nIn object-oriented programming we use classes to define and construct objects\n\nA class is a type, an object is the instance\n\n\n\n\nOpen the python interpreter and work through the following steps and questions to understand classes\nEnter the statements below\n\nclass Contact:\n    \"\"\"\n    Stores Contact Information\n\n    Attributes\n    ----------\n    name : str\n        Contact Name\n    address : str\n        Contact's postal or street address.\n    telephone : str\n        Contact phone number (stored as a string).\n    \"\"\"\n\n    pass\n\nThe line class Contact: begins a class definition - The class contents is given as an indented block - We use pass To make an empty placeholder class\n\nWhy does the name Contact begin with a capital letter?\n\nIt’s convention, in python\n\nVariables and functions start with lowercase letters\nClasses start with uppercase letters\n\n\nWhy does the Contact class contain a Python pass statement?\n\nThe class definition expects an indented block\nWe haven’t yet decided the contents of the class so we use pass to give an placeholder statement\nWe can create an instance of a Contact with\n\n  x = Contact()\n\n\nThis looks like a function call. Are we calling a function here?\n\nTechnically this is a call to a function called a constructor\nWhich is responsible for creating an instance of a Contact\nBy using capital letters it’s clear that this is an object instantiation\n\nWhat’s an instance?\n\nAn instance is the realisation of a class\nClass is the design, object is the actual thing\nYou can add data attributes to an instance\n\n  x.name = \"Rob Miles\"\n\n\nWhat’s a data attribute?\n\nProvide information about a specific instance\nFor a contact we would want it to have name, address, and phone\nmethods can also be thought of as attributes\nYou can use and manipulate data attributes\n\n  print(x.name)\n  x.name = x.name + \" is a star\"\n  print(x.name)\n\nRob Miles\nRob Miles is a star\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAttributes in Python classes can be confusing\nThe ability to add attributes to an instance is not common across programming languages. For example Java, c# and c++ all prevent this.\nIn these languages a class definition must be fully specified including the attributes before it can be instantiated.\nBoth this static definition and pythons dynamic definitions have it’s advantages and disadvantages. The latter is easier for prototyping and development, but the former is much more type-safe\n\n\n\n\n\n\n\nWe can use the Contact class to eliminate the needs for multiple lists (see TinyContactsClass.py highlighted below)\n  contacts = []\n\n\n  def new_contact():\n      \"\"\"\n      Creates and adds a new contact to the contact book\n\n      Returns\n      -------\n      None\n\n      See Also\n      --------\n      Contact : class for storing contact information\n      \"\"\"\n      print(\"Create the new contact\")\n      new_contact = Contact()\n      new_contact.name = BTCInput.read_text(\"Enter the contact name: \")\n      new_contact.address = BTCInput.read_text(\"Enter the contact address: \")\n      new_contact.telephone = BTCInput.read_text(\"Enter the contact phone: \")\n      contacts.append(new_contact)\n\n\n  def find_contact():\n      \"\"\"\n      Displays the contact matching a user-specified name\n\n      Prompts the user for a name, and searches the contacts list.\n      If the contact is found in the list, their full contact details\n      are displayed\n\n      Returns\n      -------\n      None\n\n      Notes\n      -----\n      Matches any name prefixed by the search name\n      \"\"\"\n      print(\"Find contact\")\n      search_name = BTCInput.read_text(\"Enter the contact name: \")\n      search_name = search_name.strip()\n      search_name = search_name.lower()\n      result = None\n      for contact in contacts:\n          name = contact.name\n          name = name.strip()\n          name = name.lower()\n          if name.startswith(search_name):\n              result = contact\n              break\n\n\n\nAnswer the following questions about the new find_contact implementation\n\nHow does this code work?\n\nThis functions like the previous search, we look for a contact that has a match to the search name\nRather than use the index of the match, we set a reference to the object itself iin the variable* result\nWe use None to indicate no match was found\n\nWhat does the value None mean?\n\nNone in python is used to refer to a value that does not exist\nSemantically here it is used to indicate that no match was found\n\n\n\n\n\nThis program has a fault in that if multiple contacts have the same name as an existing one only the first one will be returned. Modify the program to correct this problem\nWe have two solutions that we could use,\n\nWhen a duplicate name is encountered we simply replace the old one\n\nThis is the simplest approach, however it is quite common for people to have the same names\n\nThe program returns all the valid matches\n\nThis is a bit more complicated\nOur search function now rather than returning one Contact returns a list containing all matching Contacts\nWe only have to change the find_contacts function (the full code is given in TinyContactsDuplicates.py)\n  def find_contact():\n      \"\"\"\n      Displays the contact matching a user-specified name\n\n      Prompts the user for a name, and searches the contacts list.\n      If the contact is found in the list, their full contact details\n      are displayed\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Find contact\")\n      search_name = BTCInput.read_text(\"Enter the contact name: \")\n      search_name = search_name.strip()\n      search_name = search_name.lower()\n      results = []\n      for contact in contacts:\n          name = contact.name\n          name = name.strip()\n          name = name.lower()\n          if name.startswith(search_name):\n              results.append(contact)\n\n      if len(results) &gt; 0:\n          for result in results:\n              print(\"Name: \", result.name)\n              print(\"Address: \", result.address)\n              print(\"Telephone: \", result.telephone, \"\\n\")\n      else:\n          print(\"This name was not found\")\n\n\n\n\n\n\n\n\nImportant\n\n\n\nLook for problems when you receive the specification\nWhen you discuss a specification there’s no guarantee ambiguities like how to deal with duplicate names will be discussed. You will need to consider cases like this that may arise and define the behaviour for them. This behaviour will need to match what the client expects to happen. The best way to make sure that happens is to make sure that is included in the specification\n\n\n\n\n\n\n\nIt might be quite common for contacts to change their contact details\nWe would like to be able to update an existing contact\nThe new interface\n  Tiny Contacts\n\n  1. New Contact\n  2. Find Contact\n  3. Edit Contact\n  4. Exit Program\n\n  Enter your command:\nWe then storyboard out the program,\n\nOur storyboard will be slightly different to the book implementation to better handle duplicates\n\n  Edit Contact\n  Enter the contact name: Rob\n  Found 1 match\n\n  Name: Robert Miles\n  Address: 18 Pussycat News, London, NE1 410S\n  Telephone: +44(1234) 56789\n\n  Edit this contact? (1 - Yes, 0 - No): 1\n\n  Enter new name or . to leave unchanged: .\n  Enter new address or . to leave unchanged: .\n  Enter new telephone or . to leave unchanged: +44 (1482) 465079\nThe edit program first needs us to find search for the contact we wish to edit\nWe then report the number of matches found\nFor each match, we then print the current details and ask the user if this is the contact they want to edit\nWe then give the user the option of editing each attribute or leaving it unchanged with .\n\n\n\n\nOur program is starting to get some structure\n\nGood time to consider a refactor\n\nWe now have two features that need to search for a contact by name\n\nFind and display a contact\nFind and edit a contact\n\nOne option is to copy the find_contact for edit_contact and replace the display code by the edit code\n\nNow we have to maintain two different copies of the search functionality\nEasy for these to become desynchronised if in the future we want to change how the search works (or need to fix a book)\n\nFor our refactor, we’ll do the following\n\nFactor out a core find_contacts function that takes a search name and returns the matches\nChange the name of the old find_contact function to display_contacts function\n\nHere’s the book’s implementation, (we’ll use something different in our implementation to account for duplicates)\n  def find_contact(search_name):\n      \"\"\"\n      Finds the contacts with the matching name\n\n      Parameters\n      ----------\n      search_name : str\n          Name to search for (uses prefix matching)\n\n      Returns\n      -------\n      list[Contact]\n          list of contacts matching the `search_name`, if no\n          matches exist the list is empty\n      \"\"\"\n      search_name = search_name.strip().lower()\n      result = None\n      for contact in contacts:\n          name = contact.name.strip().lower()\n          if name.startswith(search_name):\n              return result\n      return None\n\n\n\nAnswer the following questions, about this new version of find_contact\n\nWhy does the function contain two return statements?\n\nOnly one return will actually be executed\nIf a match is found then the match is returned\nIf not then the program will exit the for loop at which point it encounters the second return and returns None\n\nWhat would happen if another program tried to use the return value of the find_contact function, and the find_contact function had returned None\n\nDepends on what the function tries to do\nIf the function tried to something with that value, then an exception is thrown\n\n  x = None #emulate failed find from find_contact\n  print(x.address)\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[5], line 2\n      1 x = None #emulate failed find from find_contact\n----&gt; 2 print(x.address)\n\nAttributeError: 'NoneType' object has no attribute 'address'\n\n\n\nSince find_contact documents that it can return None it is the responsibility of the consumer of the function to ensure they don’t misuse the None\n\n\n\n\n\n\n\nfind_contact searches through contacts for a match\nReturned object is a reference to the memory object\ne.g. rob = find_contact(\"Rob Miles\") graphically looks like,\n\n\n\n\n\n\n---\nconfig:\n  flowchart:\n    htmlLabels: false\n---\n\n\nflowchart TD\n    A@{shape: tag-doc, label: \"Rob\"}\n    B@{shape: div-rect, label: \"Name: Rob Miles\n    Address: 18 Pussycat Mews, London, NE 410S\n    Telephone: +44(1234) 5678\"}\n\n    A--&gt;B\n\n\n\n\n\n\n\nWe have multiple references to an object, e.g. test = rob creates a new reference test\n\n\n\n\n\n\n---\nconfig:\n  flowchart:\n    htmlLabels: false\n---\n\n\nflowchart TD\n    A@{shape: tag-doc, label: \"Rob\"}\n    B@{shape: div-rect, label: \"Name: Rob Miles\n    Address: 18 Pussycat Mews ..\n    Telephone: +44(1234) 5678\"}\n    C@{shape: tag-doc, label: \"test\"}\n\n    A--&gt;B\n    C--&gt;B\n\n\n\n\n\n\n\nChanges from one reference to the underlying memory object are seen in the other references\ne.g. test.name = \"Robert Miles Man of Mystery\" gives the state as,\n\n\n\n\n\n\n---\nconfig:\n  flowchart:\n    htmlLabels: false\n---\n\n\nflowchart TD\n    A@{shape: tag-doc, label: \"Rob\"}\n    B@{shape: div-rect, label: \"Name: Rob Miles Man ...\n    Address: 18 Pussycat Mews ..\n    Telephone: +44(1234) 5678\"}\n    C@{shape: tag-doc, label: \"test\"}\n\n    A--&gt;B\n    C--&gt;B\n\n\n\n\n\n\n\nThis behaviour is sometimes referred to as shallow copying since we have multiple copies of the object, but they are not distinct, changes are propagated between all the references\n\nThere is only one memory object\n\n\n\n\nThe figure below illustrates how lists and references work. It shows a Tiny Contacts data store with three contacts registered. Each of the tags in the contacts list refers to a different Contact instance in the memory. Work through the following questions to develop your understanding of references\n\n\n\n\n\n---\nconfig:\nflowchart:\n    htmlLabels: false\n---\n\n\n    flowchart TD\n\n        subgraph Contacts\n            A@{shape: tag-doc, label: \"0\"}\n            B@{shape: tag-doc, label: \"1\"}\n            C@{shape: tag-doc, label: \"2\"}\n        end\n\n        A1@{shape: div-rect, label: \"Name: Fred Smith\n        Address: 1605 Main St,\n        New York\n        Telephone: (560) 567-5209\"}\n\n        B1@{shape: div-rect, label: \"Name: Joe Bloggs\n        Address: 2312 Pine Street,\n        Seattle\n        Telephone: (453) 545-1232\"}\n\n        C1@{shape: div-rect, label: \"Name: Rob Miles\n        Address: 18 Pussycat Mews,\n         London, NE1 410S\n        Telephone: +44(1234) 5678\"}\n        D@{shape: tag-doc, label: \"rob\"}\n\n        A--&gt;A1\n        B--&gt;B1\n        C--&gt;C1\n        D--&gt;C1\n\n\n\n\n\n\n\nThe diagram contains four references. How many data objects does it contain?\n\nThere are three data objects, the Contact items themselves\nOne (Rob Miles) is referenced by the list index \\(2\\) and the variable rob\n\nWhat would happen if the program performed the following statement?\n contacts[0] = contacts[1]\n\nThe \\(0\\) index in the list now references the same memory object as that in the \\(1\\) index, the state now looks like,\n\n\n\n\n\n\n\nflowchart TD\n    subgraph Contacts\n        A@{shape: tag-doc, label: \"0\"}\n        B@{shape: tag-doc, label: \"1\"}\n        C@{shape: tag-doc, label: \"2\"}\n    end\n\n    A1@{shape: div-rect, label: \"Name: Fred Smith\n    Address: 1605 Main St,\n    New York\n    Telephone: (560) 567-5209\"}\n\n    B1@{shape: div-rect, label: \"Name: Joe Bloggs\n    Address: 2312 Pine Street,\n    Seattle\n    Telephone: (453) 545-1232\"}\n\n    C1@{shape: div-rect, label: \"Name: Rob Miles\n    Address: 18 Pussycat Mews,\n    London, NE1 410S\n    Telephone: +44(1234) 5678\"}\n    D@{shape: tag-doc, label: \"rob\"}\n\n    A--&gt;B1\n    B--&gt;B1\n    C--&gt;C1\n    D--&gt;C1\n\n\n\n\n\n\n\nLooping through the list would thus refer to the Joe Bloggs Contact twice\nNote that we have now lost the reference to Fred Smith, we can never get it back!\n\nUnreferenced memory objects will be removed by python in a process called garbage collection\n\nReferences make it easy to work with large data objects\n\nAvoid the need to create expensive copies\n\n\n\n\n\n\nEverything in Python is an object\n30 is an instance of an int\nThe following creates a reference age to 30\n\n  age = 30\n\nWhich we can visualise,\n\n\n\n\n\n\n    flowchart TD\n        A@{shape: tag-doc, label: \"age\"}\n\n        A1[\"`int\n            30`\"]\n\n        A--&gt;A1\n\n\n\n\n\n\n\nand verify,\n\n  type(age)\n\nint\n\n\ntype is a built-in function\n\nTakes a reference as an argument\nReturns the type of the referenced object\n\nNow, suppose we define another reference temp via\n\n  temp = age\n\nWhich we can again visualise as,\n\n\n\n\n\n\n    flowchart TD\n        A@{shape: tag-doc, label: \"age\"}\n        B@{shape: tag-doc, label: \"temp\"}\n\n        A1[\"`int\n            30`\"]\n\n        A--&gt;A1\n        B--&gt;A1\n\n\n\n\n\n\n\nage and temp now refer to the same object instance\nWhat happens if we assign temp a new value?\n\n  temp = 99\n  print(age)\n  print(temp)\n\n30\n99\n\n\nSo we have the final state,\n\n\n\n\n\n\n    flowchart TD\n        A@{shape: tag-doc, label: \"age\"}\n        B@{shape: tag-doc, label: \"temp\"}\n\n        A1[\"`int\n            30`\"]\n        B1[\"`int\n            99`\"]\n\n        A--&gt;A1\n        B--&gt;B1\n\n\n\n\n\n\n\nage has not been modified\nInstead a new int with a value of \\(99\\) was created\nThis is because int is an immutable type\n\ni.e. once an int has been created its value can’t be reassigned\nValue assignments thus create a new instance of an int\n\nstring is also an immutable type\n\n  name = \"Rob\"\n  temp = name\n  print(\"temp is\", temp, \"name is\", name)\n  temp = \"Fred\"\n  print(\"temp is now\", temp, \"name is now\", name)\n\ntemp is Rob name is Rob\ntemp is now Fred name is now Rob\n\n\n\n\nWhy does python use immutable data types?\n\nFor some procedures, like simple numerical calculations, treating variables as values is often the most desired approach, e.g.\n  pi = 3.1415\n  x = pi\n  x = 99.99\nWe don’t want the above to accidentally change the value of the constant pi\n\n\n\n\n\n\n\n\nImportant\n\n\n\nProgramming Languages work with values differently\nLanguages handle the distinction between references and values differently. References make it easy to work with large data as the objects remain stationary in memory. However value types make it easy to perform data manipulation with types such as int, bool, float and string\nC# has a similar concept of value types. Java has primitive types, C++ has references. Python implements int, bool, float and string are immutable types, and behave like values\nRemember that the tuple collection type is also immutable\n\n\n\n\n\n\n\nOnce we have found a reference we can read and modify the attributes\nOur program implementation, uses a simple interface optionally modify each attribute one at a time\n\nNeed to read a user string for each modifiable attribute\nOur duplicates implementation also needs to read an int to indicate if we want to modify a specific contact (and print the current contact)\n\nThe book implementation is,\ndef edit_contact():\n  \"\"\"\n  Reads in a name to search for an then allows the user\n  to edit the details of that contact. If there is no\n  contact, the function displays a message indicating\n  that the name was not found\n  \"\"\"\n\n  print(\"Edit Contact\")\n  search_name = read_text(\"Enter the contact name: \")\n  contact=find_contact(search_name)\n  if contact != None:\n      print(\"Name: \", contact.name)\n      new_name = read_text(\"Enter new name or . to leave unchanged\")\n      if new_name != '.':\n          contact.name = new_name\n      new_address = read_text(\"Enter new address or . to leave unchanged\")\n      if new_address != '.':\n          contact.address = new_address\n      new_phone = read_text(\"Enter new phone or . to leave unchanged\")\n      if new_phone != '.':\n          contact.telephone = new_phone\n  else:\n      print(\"This name was not found\")\nEditing as configured performs modifications of the live data\n\nReferred to as in-place because it occurs on the original object not a copy\n\nCan’t easily rollback if there is an error or ask the user wishes to cancel\nTo do so, edit_contact would need to work on a copy of the data\n\n\n\n\n\n\n\nWarning\n\n\n\nMissing Attributes\nedit_function calls find_contact to match a given name. find_contact returns None if no match is found. However, another possible fault in a contact is returned without all the attributes defined, e.g. a contact with a name but no address. Then the program would fail, as the code below demonstrates\n\nclass Contact:\n    pass\n\n# fake contact \"returned without address\"\ncontact = Contact()\ncontact.name = \"Hello\"\n\n# Attempt to access address\nprint(\"contact address is\", contact.address)\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[11], line 9\n      6 contact.name = \"Hello\"\n      8 # Attempt to access address\n----&gt; 9 print(\"contact address is\", contact.address)\n\nAttributeError: 'Contact' object has no attribute 'address'\n\n\n\nSome programming languages e.g. Java, C#, C++ check for these errors before a program executes. Python does not. This means that minor typos e.g. writing address instead of address can lead to runtime errors\n\n\n\n\n\n\n\nWe saw in Chapter 8 that we can save and load data to files\n\nThere we used a human-readable text representation\n\nWe could replicate this for large class based structures\n\ne.g. write out all attributes as comma, separated values\n\nPython provides a process called pickling for storing large data structures\n\npickled data is stored as binary\nData is therefore computer-readable and more compressed than human text\n\nPickling is done through the pickle library, import it to use it\n  import pickle\njpeg, mp3, zip are all different formats of binary data\n\nCommonly a file extension is used to identify what a binary file represents\ne.g.\n\nmyhouse.jpg\ntrack1.mp3\n\nDifferent programs are written to work with different binary file formats\n\n.txt defines a generic text file\n.py defines a text file that is valid python code\nTechnically text is also a binary file, just with those binary values associated to human-readable characters\nPython programs can use the b mode flag to read files as binary, e.g.\n  out_file = open(\"contacts.pickle\", \"wb\")\n\nThe above opens the file contacts.pickle for writing (w) as a binary file (b)\n.pickle indicates the file is a pickled python data object\n\npickle supplies the dump function to write a data structure to a file\n\nThe file must be opened for writing in binary\n\n  pickle.dump(contacts, out_file)\n\ncontacts is the variable to pickle\nout_file is the variable storing the file save the data to\n\nYou can open and modify pickle files\n\nWhile they may contain some readable text, they will also contain a mix of improperly rendered binary\n\n(Unless you have a specially set up text editor like a hexadecimal reader)\n\n\n\n\n\n\nPickled content of the Tiny Contacts app, a mix of human-readable characters and improperly rendered binary is displayed\n\n\n\n\n\n\n\n\nCaution\n\n\n\nBe careful modifying pickle files by hand\nPickle files are not designed to be human-readable. While most text editors will happily let you edit and save a pickle file this is very likely to end up in you breaking the binary format and the file no longer loading properly\n\n\n\nsave_contacts below saves the contacts list into a given file (passed as a path name)\n\nAs in Chapter 8 we use with to handle managing the file access\n\ndef save_contacts(file_name):\n  \"\"\"\n  Saves the contacts to the given file name\n\n  Contacts are stored in binary as a pickled file\n\n  Parameters\n  ----------\n  file_name : str\n      string giving the path to the file to store the contacts data in\n\n  Returns\n  -------\n  None\n\n  Raises\n  ------\n      Exceptions are raised if contacts could not be saved\n\n  See Also\n  --------\n  load_contacts : loads contacts from a pickled file\n  \"\"\"\n  print(\"save contacts\")\n  with open(file_name, \"wb\") as out_file:\n      pickle.dump(contacts, out_file)\n\nThis function does not perform any exception handling\nThis will cause the program to crash if the save fails\n\nProbably fine for a program of this size\nNote: You should never hide a failed save from the user!\n\nIf we wanted to handle exceptions, we would do that in the code outside save_contacts\n\n\n\n\n\n\npickle provides load to read a pickle file\n\nreturns the reconstructed data object\nAs a result, needs only the file\n\nfile needs to be open for reading r and in binary mode b\n  def load_contacts(file_name):\n      \"\"\"\n      Loads the contacts from the given file\n\n      Contacts are stored in binary as a pickled file\n\n      Parameters\n      ----------\n      file_name : str\n          string giving the path to the file where the contacts data is stored\n\n      Returns\n      -------\n      None\n          Contact detail is loaded into the global `contacts` value\n\n      Raises\n      ------\n          Exceptions if contacts failed to load\n\n      See Also\n      --------\n      save_contacts : saves contacts to a pickled file\n      \"\"\"\n      global contacts #connect to the global contacts variable\n      print(\"load contacts\")\n      with open(file_name, \"rb\") as input_file:\n          contacts=pickle.load(input_file)\n\n\n\nWork through the following questions to make sure you understand how load_contacts works\n\nWhat does the global contacts statement do? Why do we need it only in the load function and not the save function?\n\nThe load_contacts function is used to modify the values of the contacts variable\nThe contacts holds all the current contacts, held in the program\nsave_contacts needs the reference to find the list\n\nDoes not modify the list itself\n\nload_contacts does modify the contacts list\n\nNeed to explicitly link to the global variable to write to it\n\n\nHow does the pickle load function know what kind of data to make when loading?\n\nThe information is encoded in the pickle file\nIn a pickle file you should be able to identify the data attributes (name etc.) and their values\nAlso contains the class name\nload looks for matching classes in the program loading the data\n\nConstructs object instances based on those classes\nMeans the class Contact must be defined before pickle is used to load any contact data\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nVersion Control\nPickle is a tool called a serializer because it converts a data structure is a serial stream (i.e. ordered sequence of data) that can be sent to another program and/or stored in a file.\nThis introduces the need for version control. If the design of a class e.g. Contact (say we added an email attribute) then all previously pickled data may no longer load since the class definition is mismatched. To resolve this you need to version control both the version of the class and the pickled files so that data can be migrated (or converted) between versions\n\n\n\n\n\n\n\nLet’s add the save and load functionality to the Tiny Contacts Program\nThere are two options for how we implement this,\n\nThe user manually declares they want to save and load\nWe hardcode a data file\n\nLoad from this file on program start\nSave to this file as part of the exit process\n\n\nFor a small contacts app the user probably doesn’t want to manually have to handle saving and loading files\nMore likely to want to have it “just work”\n\nWe’ll go with option 2\n\nThe new interface now looks like below (see our full implementation which contains an example pickle file)\n  # Example 9.7 Tiny Contacts with Load and Save\n  import pickle\n\n  #Load contacts from file or create empty list if it fails to load\n  file_name = \"contacts.pickle\"\n  try:\n      load_contacts(file_name)\n  except:\n      print(\"Contacts file not found\")\n      contacts=[]\n\n  while True:\n      command = BTCInput.read_int_ranged(prompt=menu, min_value=1, max_value=4)\n      if command == 1:\n          new_contact()\n      elif command == 2:\n          display_contact()\n      elif command == 3:\n          edit_contact()\n      elif command == 4:\n          save_contacts(file_name) #save contacts on exit\n          break\n      else:\n          raise ValueError(\"Unexpected value encountered\")\n\n\n\nConsider the following questions about the code above\n\nWhat happens if the load_contacts function raises an exception?\n\nload_contacts raises an exception if the contacts file can’t be found, or if the load function in pickle fails\nIn this case the exception is caught, an error message is printed and an empty contacts list is created\n\nWhy does the program not catch the exceptions raised by save_contacts?\n\nYou could add this if you wanted\nIf the program crashes, the user should probably expect the save failed\nSince they were trying to quit anyway they probably don’t care\nMy implementation adds try...except block that prints an error message if the save fails (as the book suggests you consider)\n\nWhy does the program use a variable for the file name of the pickled file?\n\nThe contacts are held in a file called* contacts.pickle\nThis file is used in two places* load_contacts and save_contacts\n\nWe could put the string literal in both places\nInstead use a variable\nMeans we can change the file name in one place and the program works\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nAvoiding Magic Constants\nA magic constant is a literal value that appears in multiple places in code without an apparent reason. For example if we just used contacts.pickle that would be a magic constant. The string is a constant but there is no context to explain what the value means. Magic constants are problematic because they are hard to find and if we want to change them we have to find all the places they’re used and then resolve the issue of does this 2 correspond to this magic constant or another magic constant\nIt is a good idea to instead put these constants in a variable so that we need only change the value in one place and we can clearly explain what the constant means\n\n\n\n\n\n\n\nTiny Contacts builds the Contact instance after we create one\n  new_contact = Contact()\n  new_contact.name = BTCInput.read_text(\"Enter the contact name: \")\n  new_contact.address = BTCInput.read_text(\"Enter the contact address: \")\n  new_contact.telephone = BTCInput.read_text(\"Enter the contact phone: \")\nThis makes the program fragile\n\nWe could misspell an attribute\nForget to set one\n\nIdeally want to create a Contact and ensure values are set as part of creation\nWe can do so with a Constructor, a special method called to create the object\n\nAlso sometimes called an initializer method\n\nA method attribute is like a data attribute but as an attached function\n\n\n\n\nHeld inside a python class\nNamed __init__\n\npython uses “dunder methods” marked __function_name__ to mark special functions defined by the language\n\n\n\n\nOpen the python interpreter and work through the following steps to create an understand an initializer, answering the questions\nType the below code in to define a class\n\nclass InitPrint:\n    def __init__(self):\n        print(\"you made an InitPrint instance\")\n\nThe above defines the class InitPrint it defines an initializer method that prints a method. Note the double underscore before and after the init are required, as is the parameter self. The last line of the class is an empty line\n\nThe initializer looks remarkably like a function why is that?\n\nAn initializer is a function that is called when a class instance is created.\nType in the code below, which creates an instance of InitPrint and assigns it to the variable x,observe that the __init__ method is called even without us explicitly putting it\n\n  x = InitPrint()\n\nyou made an InitPrint instance\n\n\n\nHow is the __init__ function made to run?\n\nIt is handled by the python interpreter and how objects are constructed\nIt will run each time an instance of the InitPrint class is created\n\n\n\nNow define the InitName class as below\n\n  class InitName:\n      def __init__(self, new_name):\n          self.name = new_name\n\n\nThe initializer can take arguments like any other function, here it takes new_name\nInitializer no longer prints a message but rather sets a name attribute on the variable self\nself is a reference to the object running the method\n\nIn the initializer this is the object being created\nself is always the first parameter of a method, and must be included\n\nNow replicate the code below to see how the new __init__ method works\n\n  x = InitName(\"Fred\")\n  print(x.name)\n\nFred\n\n\nWhen creating an InitName object we now have to pass the new_name parameter\nObserve we don’t explicitly pass self\n\nOnce an initializer is defined, it is the only way to create an instance\n\nAttempting otherwise leads to an error, e.g. if we exclude the new_name\n\n\n  y = InitName()\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[16], line 1\n----&gt; 1 y = InitName()\n\nTypeError: InitName.__init__() missing 1 required positional argument: 'new_name'\n\n\n\nThis is a way of enforcing that an object is created with a full set of attributes\nOur Contact class, should accept three parameters\n\n  class Contact:\n      def __init__(self, name, address, telephone):\n          \"\"\"\n          Create a new `Contact` instance\n\n          Parameters\n          ----------\n          name : str\n              Contact Name\n          address : str\n              Contact's postal or street address\n          telephone : str\n              Contact phone number (stored as a string)\n          \"\"\"\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n\n\n\n\n\nWork through the following questions to ensure you understand the __init__ method\n\nIt looks like you’ve written the assignments in the initializer so that a value is assigned to itself. What’s going on?\n\nConsider a statement\n  self.telephone = telephone\nThis looks like assigning telephone to telephone it, does not\nThe left is the telephone attribute on the self object\nThe right is the telephone parameter passed to the initializer\nPython variable names are namespaced\n\nnamespaces are regions in which names are uniquely identified\n\nOne namespace is the local namespace of the __init__ method\nThe other namespace is the attribute namespace of the self object\nnamespaces allow different contexts to use the same variable name distinct from each other\nGenerally it is convention to give initializer parameters the same name as their associated object attributes\n\nWhat happens if the user of the constructor supplies silly arguments to it?\n\nCurrently the constructor doesn’t validate the input\ne.g. we could pass name a number, empty string or even None\n\nStill generates a Contact\n\nYou can add error handling code to the constructor and raise exceptions if the provided values are invalid\n\nFor a more robust application this might be required\nFor a small toy program we can generally expect valid input\n\n\n\n\nIf we want to create a new Contact now we can just call,\n\n\n    rob = Contact(name = \"Rob Miles\", address=\"18 Pussycat Mews, London, NE1 410S\", telephone=\"+44(1234) 56789\")\n\n\nWe can integrate this into our Tiny Contacts implementation\n  def new_contact():\n      \"\"\"\n      Creates and adds a new contact to the contact book\n\n      Returns\n      -------\n      None\n\n      See Also\n      --------\n      Contact : class for storing contact information\n      \"\"\"\n      print(\"Create new contact\")\n      name = BTCInput.read_text(\"Enter the contact name: \")\n      address = BTCInput.read_text(\"Enter the contact address: \")\n      telephone = BTCInput.read_text(\"Enter the contact phone: \")\n      new_contact = Contact(name=name, address=address, telephone=telephone)\n      contacts.append(new_contact)\n\n\n\n\n\n\nThe __init__ method supports default arguments\nFor example if we don’t want to make the telephone mandatory we could write\n\n  class Contact:\n      def __init__(self, name, address, telephone=\"No Telephone\"):\n          \"\"\"\n          Create a new Contact instance\n\n          Parameters\n          ----------\n          name : str\n              Contact Name\n          address : str\n              Contact's postal or street address\n          telephone : str\n              Contact phone number (stored as a string)\n          \"\"\"\n          self.name = name\n          self.address = address\n          self.telephone = telephone\n\nWe could then create create a Contact as,\n\n  rob = Contact(name=\"Rob Miles\", address=\"18 Pussycat Mews, London, NE1 410S\")\n  print(rob.telephone)\n\nNo Telephone\n\n\n\nObserve that the telephone attribute still exists and has the default value \"No Telephone\"\n\n\n\n\n\n\n\n\nA Dictionary is another collection type like list and tuple\nDictionaries store data as key-value pairs\n\nA value is looked up by its key\nYou can think of a list as a dictionary where the key is the index\n\n\n\n\n\nLet’s consider creating a dictionary for a coffee shop\nWe want to key coffee products to their price (value)\nWe create an empty dictionary using {}\n\n  prices = {}\n\nItems can be added using the indexing operator to assign a value,\n\n  prices[\"latte\"] = 3.5\n  prices[\"latte\"]\n\n3.5\n\n\nWe can see prices has the key latte and the associated value of \\(3.5\\)\nWe can redefine dictionary values as for lists\n\n  prices[\"latte\"] = 3.6\n  prices[\"latte\"]\n\n3.6\n\n\nKeys are case-sensitive and must be spelled correctly, else a KeyError occurs,\n\n  prices[\"Latte\"]\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[24], line 1\n----&gt; 1 prices[\"Latte\"]\n\nKeyError: 'Latte'\n\n\n\nWe can search a dictionary for keys using the in operator\n\n  print('latte' in prices)\n  print('flat white' in prices)\n\nTrue\nFalse\n\n\nWe can print an entire dictionary just like with lists and tuples\n\n  prices[\"espresso\"] = 3.0\n  prices[\"tea\"] = 2.5\n  prices\n\n{'latte': 3.6, 'espresso': 3.0, 'tea': 2.5}\n\n\nObserve that the key-value pairs are printed with the format key : value\nWe can also create a dictionary with value using the same syntax like the printed output\n\n  prices = {'Latte' : 3.6, 'Espresso' : 3.0, \"Tea\" : 2.5, \"Americano\" : 2.5}\n\n\n\n\n\n\nDictionary elements use the \"key:item\" format\nKeys and values can be a mix of types, e.g. str, int, float e.g.,\n\n  access_control = {1234 : \"complete\", 1111 : \"limited\", 4342 : \"limited\"}\n\nValues can be duplicated\nBut keys must be unique\nConsider a dictionary that controls access to a burglar alarm\n\nUsers provide an access code\nCode keys a dictionary\nAccess is determined by the value in the dictionary\nA missing key (code) indicates no access permissions\n\n  # Example 9.9 Alarm Access Control\n  #\n  # Demonstrates the use of a dictionary as a lookup table to translate\n  # keys into associated values\n\n  import BTCInput\n\n  access_control = {1234: \"complete\", 1111: \"limited\", 4342: \"limited\"}\n\n  access_code = BTCInput.read_int(\"Enter your access code: \")\n  if access_code in access_control:\n      print(\"You have\", access_control[access_code], \"access\")\n  else:\n      print(\"You are not allowed access\")\nWe can delete dictionary entries using the del keyword, e.g.\n\n  del(access_control[1111])\n  print(access_control[1111])\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[29], line 2\n      1 del(access_control[1111])\n----&gt; 2 print(access_control[1111])\n\nKeyError: 1111\n\n\n\nThe KeyError above shows that the key-value has been eliminated\ndel can also be used to remove elements of a list\ndel will raise an exception if the object being deleted doesn’t exist\n\n\n\n\n\nWe’ve seen that programs can use dictionaries as lookup tables\nCan also return a dictionary from a function\n\ne.g. our Pirates Treasure map from Chapter 8 could use a dict instead\n\n\n  # Example 9.10: Pirate Treasure Dictionary\n  #\n  # Implementation of the Pirates Treasure map that uses a\n  # dictionary rather than a tuple to provide contextual\n  # key-value pairs\n\n\n  def get_treasure_location():\n      \"\"\"\n      Get the location of the treasure\n\n      Returns\n      -------\n      dict\n          Dictionary containing the location of the treasure, containing\n          the following keys\n\n          `\"start\"` : str\n\n              landmark to start at\n\n          `\"n\"` : int\n\n              number of paces to walk north relative to the\n              start\n\n          `\"e\"` : int\n\n              number of paces to walk east relative to the\n              start\n      \"\"\"\n      return {\"start\": \"The old oak tree\", \"n\": 20, \"e\": 30}\n\n\n  location = get_treasure_location()\n  print(\n      \"Start at\",\n      location[\"start\"],\n      \"walk\",\n      location[\"n\"],\n      \"paces north, and\",\n      location[\"e\"],\n      \"paces east\",\n  )\n\nStart at The old oak tree walk 20 paces north, and 30 paces east\n\n\nDictionaries let us assign contextual meaning to the returned parameters\nHarder to work with than tuple unpacking though\n\n\n\n\n\nWe could use dictionaries to store contacts in Tiny Contacts\n\nRather than use a class we could represent a contact with a dictionary like\n\n  rob_contact = {\"name\" : \"Rob Miles\", \"address\" : \"18 Pussycat Mews\", \"telephone\" : \"+44(1234) 56789\"}\n\n\nBut the we lost some of the nice class behaviours\n\nlike attributes being accessible via Contact.name etc. and we would instead have to use the string literal keys everywhere\n\n\nAnother option is storing the contacts themselves in a dictionary rather than a list\n\n contact_dictionary = {}\n rob = Contact(name = \"Rob Miles\", address = \"18 Pussycat Mews\", telephone = \"+44(1234) 56789\")\n contact_dictionary[rob.name] = rob\n print(contact_dictionary)\n\n{'Rob Miles': &lt;__main__.Contact object at 0x7f39c8e4d4f0&gt;}\n\n\nWe can then search for a contact by just querying the key\n\n  contact_dictionary[\"Rob Miles\"]\n\n&lt;__main__.Contact at 0x7f39c8e4d4f0&gt;\n\n\nHowever the user would have to type the correct full name\n\nAlso case sensitive\nWe could fix the case sensitivity by rather than using the name directly using a normalised key\n\nsuch as by using strip().lower() to strip excess whitespace and convert to lowercase\n\n\nOur current implementation uses startswith to provide more flexible matching\nIn general though, dictionaries provide fast queries for finding objects when we can easily use the key as a unique identifier\n\n\n\n\n\n\nThe Tiny contacts program is a useful template for any kind of program that stores data and lets a user work with it. You can even add some of the sorting and data-processing features from the ice-cream sales program to make applications that not only store data but let you do interesting things with it.\nExpand on the Tiny Contacts Program to implement the following,\n\nThe Tiny Contacts program will print all contacts if the find_contacts search string is blank, document this for the user\nAdd the sorting features from the ice-cream sales program to print contacts in alphabetical order\nIdentify more common between functions in Tiny Contacts and see what further refactors you can make\n\nThe first step is straightforward. We update the program is two places. First we document the behaviour in the responsible function, find_contacts\ndef find_contacts(search_name):\n    \"\"\"\n    Finds the contacts with the matching name\n\n    If the empty string is given, all contacts\n    are matched\n\n    Parameters\n    ----------\n    search_name : str\n        Name to search for (uses prefix matching)\n\n    Returns\n    -------\n    list[Contact]\n        list of contacts matching `search_name`, if no\n        matches exist the list is empty\n    \"\"\"\n    search_name = search_name.strip().lower()\n    results = []\n    for contact in contacts:\n        name = contact.name.strip().lower()\n        if name.startswith(search_name):\n            results.append(contact)\n    return results\nThis helps anyone who in the future has to edit or maintain our code. However it doesn’t provide much help to the user of the program. So we also document this in the user facing code (display_contacts)\ndef display_contacts():\n    \"\"\"\n    Prompts the user for a contact name and\n    displays all matching contacts\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_contact : displays a single contact\n    \"\"\"\n    print(\"Find contact\")\n    contacts = find_contacts(\n        BTCInput.read_text(\"Enter the contact name (Press enter to display all): \")\n    )\n    if len(contacts) &gt; 0:\n        for contact in contacts:\n            display_contact(contact)\n    else:\n        print(\"This name was not found\")\nThe relevant line being,\n    BTCInput.read_text(\"Enter the contact name (Press enter to display all): \")\nTo add the sorting functionality we first need to put the sorting code in,\ndef sort_contacts():\n    \"\"\"\n    sorts the contacts list into alphabetical order\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"Sort contacts\")\n    for sort_pass in range(0, len(contacts)):\n        done_swap = False\n        for count in range(0, len(contacts) - 1 - sort_pass):\n            if contacts[count].name &gt; contacts[count + 1].name:\n                temp = contacts[count]\n                contacts[count] = contacts[count + 1]\n                contacts[count + 1] = temp\n                done_swap = True\n        if not done_swap:\n            break\nThis code is basically the same as the sorting code in the ice-cream stand example except there might be something that looks odd. namely the line\ncontacts[count].name &gt; contacts[count + 1].name\nThis is because we want to sort the Contact objects alphabetical on the name field. So we have to compare against this field. contacts[count] is a reference to the Contact object stored at the index count so we can access the attributes on the underlying object\nWe then need to include the sorting option in the display menu\nmenu = \"\"\"Tiny Contacts\n\n1. New Contact\n2. Find Contact\n3. Edit Contact\n4. Sort Contacts\n5. Exit Program\n\nEnter your command: \"\"\"\n\nfile_name = \"contacts.pickle\"\ntry:\n    load_contacts(file_name)\nexcept:  # noqa: E722\n    print(\"Contacts file not found\")\n    contacts = []\n\nwhile True:\n    command = BTCInput.read_int_ranged(prompt=menu, min_value=1, max_value=5)\n    if command == 1:\n        new_contact()\n    elif command == 2:\n        display_contacts()\n    elif command == 3:\n        edit_contacts()\n    elif command == 4:\n        sort_contacts()\n    elif command == 5:\n        try:\n            save_contacts(file_name)\n        except:  # noqa: E722\n            print(\"Contacts failed to save\")\n        break\n    else:\n        raise ValueError(\"Unexpected command id found: \" + str(command))\nTo answer the final question of what functionality we can pull out we can see that both display_contacts and edit_contacts contain code for displaying an individual Contact. We can pull this code out into a distinct display_contact function responsible for displaying a single Contact. We can then update display_contacts and edit_contacts to defer the display functionality to display_contact\ndef display_contact(contact):\n    \"\"\"\n    Displays the Contact details for the supplied contact\n\n    Parameters\n    ----------\n    contact : Contact\n        contact to display\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_contacts : Displays all contacts matching a search name\n    \"\"\"\n    print(\"Name:\", contact.name)\n    print(\"Address:\", contact.address)\n    print(\"Telephone:\", contact.telephone, \"\\n\")\nThe new display_contacts now looks like,\ndef display_contacts():\n    \"\"\"\n    Prompts the user for a contact name and\n    displays all matching contacts\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_contact : displays a single contact\n    \"\"\"\n    print(\"Find contact\")\n    contacts = find_contacts(\n        BTCInput.read_text(\"Enter the contact name (Press enter to display all): \")\n    )\n    if len(contacts) &gt; 0:\n        for contact in contacts:\n            display_contact(contact)\n    else:\n        print(\"This name was not found\")\nand edit_contacts looks similar\n\n\n\nThis Chapter also contains two further examples which demonstrate building data storage applications that handle more functionality than tiny contacts.\nDue to the size of the discussion required for each exercise they are linked on a separate page\n\n\nFocuses on demonstrating adding additional functionality to a basic storage application for data interrogation\n\nDevelops an application that can store music tracks\nImplements searching and sorting based on length of the track\nSupports the ability to create and save playlists\nPlaylists can be interrogated for their total length\nThe program can suggest playlists that match the user’s target runtime\n\n\n\n\nDemonstrates working with larger more complicated objects in data storage\n\nDevelops and application for storing recipes\nUsers can search for recipes by their name or their ingredients\nSupports different mechanisms for viewing details about a recipe\n\nViewing the ingredients\nViewing the steps\nStepping through the recipe, step by step\n\n\nYou are encouraged to work through or examine these exercises",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 9: Use Classes to Store Data"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/09_UsingClasses/Chapter_09.html#summary",
    "href": "02_AdvancedProgramming/09_UsingClasses/Chapter_09.html#summary",
    "title": "Chapter 9: Use Classes to Store Data",
    "section": "Summary",
    "text": "Summary\n\nPython lets you define Classes\n\nClasses can have data attributes\ndata attributes can be defined at construction via a constructor\ndata attributes can be added dynamically at runtime\nclasses may define a constructor via __init__ to control how they are created\n\nPython variables are references to memory objects\n\nIf there are multiple references to one object then changing the object via one reference will be propagated to the other references\n\nSome fundamental python types int, str, float, are immutable\n\nAssigning a value to a variable holding an immutable type creates a new memory object with that value\n\nOther references to the original object are untouched\n\nThis allows them to be manipulated as simple values\n\npickle is a library for serialising python objects as binary data\nPython provides a dictionary data object that can be used to store a collection of key-value pairs",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 9: Use Classes to Store Data"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/09_UsingClasses/Chapter_09.html#questions-and-answers",
    "href": "02_AdvancedProgramming/09_UsingClasses/Chapter_09.html#questions-and-answers",
    "title": "Chapter 9: Use Classes to Store Data",
    "section": "Questions and Answers",
    "text": "Questions and Answers\n\nIf an object has name, address and telephone attributes can a program treat it as a Contact instance?\n\nYes, Python uses what is called duck-typing\n\n“If it walks like a duck, quacks like a duck, it is a duck”\nMeans that if it behaves like a Contact it can be used as a Contact\nIf the programmer makes a mistake however, a runtime exception is created\n\nThis means we could define a Customer with the same fields and treat it as a Contact\nPython does provide mechanisms for explicit type checking\n\nWe’ve seen one for example (type)\n\nOther languages have different rules\nJava, C# and C++ are “Strongly Typed”\n\nThe type of the variable is fixed and we can only work with objects, functions and operators that support that type\n\n“Strongly Typed” languages typically allow you catch mismatched type errors at compile-time before a program is run\n\nCan an object contain a reference to itself?\n\nYes, though this is usually not a good idea\nTypically objects are daisy-chained together\n\nObject A references Object B references Object C etc.\nThe most basic structure is called a linked list\nMore complex structures like trees have more complicated referential structures\n\n\nIs an object forced to have a constructor / initializer?\n\nNo, we saw this with the first Contact which was a simple blank class\n__init__ provides greater ability to ensure that objects are created properly though\n\nCan you stop a program from adding new attributes to an object?\n\nNo\nThis has the impact of allowing us to create incompatible and distinct instances of the same class where for some reason one has been augmented with an additional attribute\n\nCan you remove attributes from an object?\n\nYes, you can use the del operator to delete an attribute\n\n  del(rob.name)\n  print(rob.address)\n  rob.name\n\n18 Pussycat Mews\n\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[34], line 3\n      1 del(rob.name)\n      2 print(rob.address)\n----&gt; 3 rob.name\n\nAttributeError: 'Contact' object has no attribute 'name'\n\n\n\n\nWhat is immutable again?\n\nimmutable means an unchangeable object\nWhen we try to change an immutable object python instead creates a copy with the new values\nimmutability improves data storage especially for primitive types\ne.g. We might have a story of one million words\n\nThe story string itself consists of words stored as strings which are immutable\nA list of words uses references to refer to each word\nCertain words are probably referred to multiple times (e.g. the)\nSince the words are immutable we can reference one instance of the string \"the\" rather than having a distinct memory object for each instance (which we would need if they were mutable)\n\n\nHow does the operating system know its storing a binary file?\n\nIt doesn’t\nReally all files are binary\nFile system simply responsible for locating and retrieving files\nPrograms are the ones that impose meaning on a file\n\nfile extensions are there to help an operating system or user associate different file formats with their respective programs\n\n\nCan two items in a dictionary have the same key?\n\nStrictly no, if you wish to store multiple objects with the same key you would have to use a dictionary where the value was some form of collection e.g. a list or tuple.\nYou would then access the list via the dictionary key\n\nThen have to search through the list to get the specific value you were interested in",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 9: Use Classes to Store Data"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/07_UsingFunctions/Chapter_07.html",
    "href": "01_ProgrammingFundamentals/07_UsingFunctions/Chapter_07.html",
    "title": "Chapter 7: Using Functions to Simplify Programs",
    "section": "",
    "text": "A function is a named chunk of code\n\nCan be thought of as like a variable containing code rather than a value\nConsider the simple function\n\n\n  def greeter():\n      print(\"Hello\")\n\n\nPrint’s the message \"Hello\"\nCalled by the function name, then parentheses, e.g.\n\n\n  greeter()\n\nHello\n\n\n\nfunctions must be defined before they can be called\n\n\n\n\nUse a python interpreter to work through the following questions to understand python functions\nEnter the following program into the interpreter\ndef greeter():\n     print(\"Hello\")\n\nWhy did the interpreter not print \"Hello\"?\n\nBecause the print statement is stored as part of the greeter function\n\nHow do I tell Python that I’ve finished entering the greeter function?\n\nThe same way you close a loop or an if statement, by de-indenting and adding an empty line\n\nHow do I make a call to the greeter function?\n\n greeter()\n\nHello\n\n\n\nThe same way you call any other function. Write the function name and a parenthesised list of parameters. In this case the list is empty. Once called the function runs all the statements contained in its definition.\n\n\nNow consider the following code snippet\n\nx = greeter\nx()\n\nHello\n\n\nObserve that we can treat functions like variables. We can assign them to other labels/variables in this case x is set to the value of greeter. We can then call x as if it where greeter\nThe ability to treat functions as variables is a powerful feature we will explore more in Chapter 12\n\n\n\nExamine the following code block and and answer the following questions to understand how functions work. (You can run the code at Pathfinder.py)\n\n# Example 7.1: Pathfinder\n#\n# Sample Program to demonstrate function flow\n\n\ndef m2():\n    print(\"the\")\n\n\ndef m3():\n    print(\"sat on\")\n    m2()\n\n\ndef m1():\n    m2()\n    print(\"cat\")\n    m3()\n    print(\"mat\")\n\n\nm1()\n\nthe\ncat\nsat on\nthe\nmat\n\n\n\nWhat will the program display when it runs?\n\nStep through the program one statement at a time\nFirst m1 is called\n\nm1 calls m2\n\nm2 prints \"the\"\nm2 ends and control returns to m1\n\nm1’s next statement prints \"cat\"\nm1’s next statement calls m3\n\nm3 prints \"sat on\"\nm3 calls m2\n\nm2 prints \"the\"\nm2 ends and control returns to m3\n\nm3 ends and control returns to m1\n\nm1 prints \"mat\"\nm1 and thus the program ends\n\nThe final output is thus:\n\n the\n cat\n sat on\n the\n mat\nWhat happens if a function calls itself? For example what if m1 called m1\n\nLet’s try changing m1 to the following,\n\n  def m1():\n      m1()\n\n  m1()\n\n\n---------------------------------------------------------------------------\nRecursionError                            Traceback (most recent call last)\nCell In[6], line 4\n      1 def m1():\n      2     m1()\n----&gt; 4 m1()\n\nCell In[6], line 2, in m1()\n      1 def m1():\n----&gt; 2     m1()\n\nCell In[6], line 2, in m1()\n      1 def m1():\n----&gt; 2     m1()\n\n    [... skipping similar frames: m1 at line 2 (2975 times)]\n\nCell In[6], line 2, in m1()\n      1 def m1():\n----&gt; 2     m1()\n\nRecursionError: maximum recursion depth exceeded\n\n\n\nThe code generates a RecursionError!\n\nA function that calls itself is called a recursive function\nLike an infinite loop infinite recursion occurs when a function calls itself with no condition to stop\nEventually the computer cannot allocate more memory to track the function calls\n\nThis can be dangerous so Python prematurely limits the “depth” of recursive calls a function can make\n\n\nFormally with recursion:\n\nEach time a function is called Python stores the return address (where the code goes back to) on the “stack”\n\nThe stack is special memory responsible for managing the program\nWhen a function finishes the program grabs the return of the stack and looks at the address to to determine where to run\n\nCalling and exiting functions thus grows and shrinks the stack\n\nUp to a limit defined by Python at which point a recursion error occurs\n\n\nRecursive functions are a powerful and elegant technique in many cases\n\nHowever, often it is better to use simple loop structures\nRecursion more of interest for theory\n\n\n\n\n\n\n\n\n\n\n\nblock-beta\n    columns 7\n\n    classDef BG stroke:transparent, fill:transparent\n\n\n    space\n    space\n    title[\"Breakdown of a Function Definition\"]:3\n    space\n    space\n\n    class title BG\n\n    block:Def\n    columns 1\n        def[\"def\"]\n        defDescr[\"(start of function definition)\"]\n    end\n\n    class def BG\n    class defDescr BG\n\n\n    block:Name\n    columns 1\n        name[\"name\"]\n        nameDescr[\"(name of the function)\"]\n    end\n\n    class name BG\n    class nameDescr BG\n\n    block:LeftP\n    columns 1\n        leftP[\"(\"]\n        leftPDescr[\" \"]\n    end\n\n    class leftP BG\n    class leftPDescr BG\n\n    block:Parameters\n    columns 1\n        parameters[\"parameters\"]\n        parametersDescr[\"(items to feed into the function)\"]\n    end\n\n    class parameters BG\n    class parametersDescr BG\n\n    block:RightP\n    columns 1\n        rightP[\")\"]\n        rightPDescr[\" \"]\n    end\n\n    class rightP BG\n    class rightPDescr BG\n\n    block:Colon\n    columns 1\n        colon[\":\"]\n        colonDescr[\"colon\"]\n    end\n\n    class colon BG\n    class colonDescr BG\n\n    block:Suite\n    columns 1\n        suite[\"Statement block\"]\n        suiteDescr[\"(statements)\"]\n    end\n\n    class suite BG\n    class suiteDescr BG\n\n\n\n\n\n\n\ndef tells python we’re defining a function\n\nAs opposed to calling an existing one\n\nspace then name of the function\n\nSame naming rules as for variables\nfunctions do things, i.e. the are naturally associated with verbs\n\nUnlike variables with are things i.e. nouns\n\ne.g. display_menu names a function which takes the action to display a menu\n\nThen parameters in a parentheses-enclosed, comma-delimited list\n\nNo space between name and left parenthesis\nParameters feed extra information for the function to work on\nParameter list can be empty (as we’ve seen)\n\nThen colon\nFollowed by indented set of statements associated with the function\n\nCalled the function body\n\n\n\n\n\n\nFunctions can receive data to work on through parameters\nE.g. we can parameterise our times table code\n\n  def print_times_table(times_value):\n      count = 1\n      while count &lt;  13:\n          result = count * times_value\n          print(count, 'times', times_value, 'equals', result)\n          count = count + 1\n\nWe can then call with different times_value to print the respective times table\n\n\n    print_times_table(5)\n    print_times_table(99)\n\n1 times 5 equals 5\n2 times 5 equals 10\n3 times 5 equals 15\n4 times 5 equals 20\n5 times 5 equals 25\n6 times 5 equals 30\n7 times 5 equals 35\n8 times 5 equals 40\n9 times 5 equals 45\n10 times 5 equals 50\n11 times 5 equals 55\n12 times 5 equals 60\n1 times 99 equals 99\n2 times 99 equals 198\n3 times 99 equals 297\n4 times 99 equals 396\n5 times 99 equals 495\n6 times 99 equals 594\n7 times 99 equals 693\n8 times 99 equals 792\n9 times 99 equals 891\n10 times 99 equals 990\n11 times 99 equals 1089\n12 times 99 equals 1188\n\n\n\n\n\nA parameter is the name assigned to a value passed to a function\nAn argument is the specific value passed when a function is called\ne.g. in the above print_times_table function:\n\nThe parameter is times_value\nBut a specific argument is \\(5\\) or \\(99\\)\n\nConsider it as the phrase “we call the function passing the arguments to the parameters”\n\n\n\nFind out more about arguments and parameters by answering the following questions\n\nWhat would the following program do?\n\n # Example 7.2: Times Tables\n #\n # Demonstrates function parameters through a\n # Times Table function that takes in an argument to\n # determine which times table is printed\n\n def print_times_table(times_value):\n     count = 1\n     while count &lt; 13:\n         result = count * times_value\n         print(count, \"times\", times_value, \"equals\", result)\n         count = count + 1\n\n print_times_table(6)\n\n1 times 6 equals 6\n2 times 6 equals 12\n3 times 6 equals 18\n4 times 6 equals 24\n5 times 6 equals 30\n6 times 6 equals 36\n7 times 6 equals 42\n8 times 6 equals 48\n9 times 6 equals 54\n10 times 6 equals 60\n11 times 6 equals 66\n12 times 6 equals 72\n\n\n\nThe above should print out the times table for \\(6\\)\n\nWhat would happen if we changed the call of the print_times_table function to the one below that has a string as the argument? Would the program fail?\n\n print_times_table(\"six\")\n\n1 times six equals six\n2 times six equals sixsix\n3 times six equals sixsixsix\n4 times six equals sixsixsixsix\n5 times six equals sixsixsixsixsix\n6 times six equals sixsixsixsixsixsix\n7 times six equals sixsixsixsixsixsixsix\n8 times six equals sixsixsixsixsixsixsixsix\n9 times six equals sixsixsixsixsixsixsixsixsix\n10 times six equals sixsixsixsixsixsixsixsixsixsix\n11 times six equals sixsixsixsixsixsixsixsixsixsixsix\n12 times six equals sixsixsixsixsixsixsixsixsixsixsixsix\n\n\n\nRecall that multiplication between strings and numbers is defined in python as the repeated concatenation of the string with itself\nThe above thus prints a triangle of increasingly concatenated \"six\"\nThis behaviour while semantically correct by the python language is not logically correct. Really we would expect an error to occur\n\nHow do we make the print_times_table function work with integer parameters only?\n\nFirst: is it a problem?\n\nIf this function is wrapped in a higher level function that does the error handling we can probably forget it\n\nSecond: If it is a problem, what is the way to fix it?\n\nPrint a warning message?\nStop the program?\nHandle the error locally? (within the function)\n\nIn this case let’s throw an error if the type is not an integer\n\nThe isinstance function lets you type check an item\nAccepts two arguments, item to test, and the type to match\nReturns True if item is that type else False\n\n\n\n # Example 7.3: Safe Times Tables\n #\n # A version of Times Tables that uses isinstance\n # to ensure that argument is an integer\n\n\n def print_times_table(times_value):\n     if not isinstance(times_value, int):\n         raise Exception(\"print_times_table requires an integer argument\")\n     count = 1\n     while count &lt; 13:\n         result = count * times_value\n         print(count, \"times\", times_value, \"equals\", result)\n         count = count + 1\n\n\n print_times_table(\"six\")\n\n\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\nCell In[11], line 17\n     13         print(count, \"times\", times_value, \"equals\", result)\n     14         count = count + 1\n---&gt; 17 print_times_table(\"six\")\n\nCell In[11], line 9, in print_times_table(times_value)\n      7 def print_times_table(times_value):\n      8     if not isinstance(times_value, int):\n----&gt; 9         raise Exception(\"print_times_table requires an integer argument\")\n     10     count = 1\n     11     while count &lt; 13:\n\nException: print_times_table requires an integer argument\n\n\n\n\nSafeTimesTable.py shown above demonstrates using isinstance to raise an exception\nException can be thought of as an object that holds the error description\n\nstring argument describes the error\n\nraise creates and throws it\n\n\n\n\n\n\n\nfunctions can have multiple parameters\n\ne.g. what if we want to adjust the length of the times table\n\n\n  # Example 7.4: Two Parameter Times Table\n  #\n  # Demonstrates a multi-parameter function through a variable\n  # length times table program\n\n\n  def print_times_table(times_value, limit):\n      count = 1\n      while count &lt; limit + 1:\n          result = times_value * count\n          print(count, \"times\", times_value, \"equals\", result)\n          count = count + 1\n\n\nThe above uses times_value to control which times table is printed, and limit controls the length\n\nThe full code is given in TwoParameterTimesTable.py\n\nAn example call is then,\n\n\n  print_times_table(6,5)\n\n1 times 6 equals 6\n2 times 6 equals 12\n3 times 6 equals 18\n4 times 6 equals 24\n5 times 6 equals 30\n\n\n\nThe above prints the first \\(5\\) entries of the \\(6\\) times tables\n\n\n\n\n\n\nConsider the call,\n\n  print_times_table(12, 7)\n\n1 times 12 equals 12\n2 times 12 equals 24\n3 times 12 equals 36\n4 times 12 equals 48\n5 times 12 equals 60\n6 times 12 equals 72\n7 times 12 equals 84\n\n\nThe above, to the unfamiliar user makes it unclear if its a \\(12\\) times table of length \\(7\\) or a times table for \\(7\\) of length \\(12\\)\n\nThis is because the arguments are passed as positional parameters\n\ni.e. order the arguments go in, controls which parameter they are assigned too\n\n\nYou can also pass arguments to functions by specifying the parameter name, e.g.\n\n  print_times_table(times_value=12, limit=7)\n\n1 times 12 equals 12\n2 times 12 equals 24\n3 times 12 equals 36\n4 times 12 equals 48\n5 times 12 equals 60\n6 times 12 equals 72\n7 times 12 equals 84\n\n\n\nThis is called keyword arguments, because we specify the arguments associated parameter by its name\n\n\n\n\n\n\n\n\nWarning\n\n\n\nDon’t mix positional and keyword arguments\nPython lets you mix positional and keyword arguments in a call to a function. This can make it hard to work out what is assigned to what. You should either use all positional arguments (when obvious) or all keyword arguments\nBeware that positional arguments must precede all keyword arguments\n\n\n\n\n\n\nOur original implementation of print_times_table assumed the length was \\(12\\)\nThe second version allowed us to specify the length, but no longer assumes that it is \\(12\\)\nDefault parameters let us combine both behaviours\n\n  # Example 7.5: Default Parameters\n  #\n  # Demonstrates default arguments by capturing the single\n  # argument times table code in the two parameter version\n\n\n  def print_times_table(times_value, limit=12):\n      count = 1\n      while count &lt; 13:\n          result = times_value * count\n          print(count, \"times\", times_value, \"equals\", result)\n          count = count + 1\n\n\nIf an argument is not provided to a parameter with a default argument, the default is used, e.g. the below call implicitly uses limit = 12\n\n  print_times_table(times_value=7)\n\n1 times 7 equals 7\n2 times 7 equals 14\n3 times 7 equals 21\n4 times 7 equals 28\n5 times 7 equals 35\n6 times 7 equals 42\n7 times 7 equals 49\n8 times 7 equals 56\n9 times 7 equals 63\n10 times 7 equals 70\n11 times 7 equals 77\n12 times 7 equals 84\n\n\n\nMost modern python editors and tooling can read function definitions, and highlight and default arguments\n\n\n\n\n\n\n\nTip\n\n\n\nWhy use named arguments and default parameters?\nNamed arguments and default parameters help make functions clearer in intent. Reduce the possibility of getting arguments confused or mixed up. Makes it easy to define “standard” behaviour for a function\n\n\n\n\n\nWhat does it mean when we pass the value of an argument to a function parameter? Consider the following program\n\n# Example 7.6 Parameters as Values\n#\n# Demonstrates how python handles passing values to a function\n\n\ndef what_would_I_do(input_value):\n    input_value = 99  # noqa: F841\n\n\ntest = 0\nwhat_would_I_do(test)\nprint(\"The value of test is\", test)\n\nThe value of test is 0\n\n\nThe function accepts a single value and sets it to \\(99\\). We then call the function with the value of test which has been set to \\(0\\). We then print the value of test after the function call\nAnswer the following question,\n\nWhat would this program print when it runs?\n\nThe program follows this sequence\n\ntest is set to \\(0\\)\nwhat_would_I_do is called, being passed the value of test which is \\(0\\)\nIn what_would_I_do, input_value is initially set to \\(0\\)\ninput_value is set to \\(99\\)\nwhat_would_I_do then ends\nThe value of test is printed\n\nThe main observation here is that the value of test is passed to the function not test itself\n\ntest is unchanged outside the function\n\n\n\n\n\n\nWrite a function teletype_print that slowly writes out an input string. Use a for loop to loop over the contents of the string and the time library to delay the output. Use a default argument with a value of \\(0.1\\) to control the print speed. Use the random library to add a random amount of noise to the specified delay\nThe final function is given in the example TeletypePrinter.py, but we’ll work through the code in parts\n\nWe first import the modules we need\n\n# Exercise 7.1: Teletype Printer\n#\n# Emulates the slow speed of a teletype printer\n# by using a for loop and time to slowly loop over\n# an input string\n\nimport random\nimport time\n\nWe then define our function signature, text is left as something that must be supplied while delay is given a default value of \\(0.5\\) (purely to make the delay more obvious than the \\(0.1\\) suggested in the original book)\nWe then add a jitter to the delay from \\(1/10\\) through to the full size of the delay, by generating a random number\n\nWe then randomly generate a \\(0\\) or a \\(1\\) and use that to determine if the jitter is added or removed from the delay\n\n\ndef teletype_printer(text, delay=0.5):\n    jitter = delay / random.randint(1, 10)\n    if random.randint(0, 1):\n        delay = delay + jitter\n    else:\n        delay = delay - jitter\n\nWe then loop over the string, printing each character\n\nWe have to override the print default arguments\n\nend determines what is printed after each call to print, we set end to the empty string so that all the characters are printed on the same line\nSetting flush to False ensures the interpreter prints each character as it is called rather than waiting for the end of a line\n\n\nAfter the loop we now have to print an empty line to get the new line\n\n    for ch in text:\n        print(ch, end=\"\", flush=True)\n        time.sleep(delay)\n    print(\"\")\n\nLastly we demonstrate the function being called with it’s default values on the word \"hello\"\n\nteletype_printer(\"hello\")\n\n\nhello\n\n\n\n\n\nUse the function you wrote for a teletype output to add some style to the Fortune Teller Program\nOur solution is given in TeletypeFortuneTeller.py and repeated below\n# Exercise 7.2 Teletype Fortune Teller\n#\n# Version of the Fortune Teller Program that uses the teletype_printer function\n# to delay the output\n\nimport random\nimport time\n\n\ndef teletype_printer(text, delay=0.25):\n    jitter = delay / random.randint(1, 10)\n    if random.randint(0, 1):\n        delay = delay + jitter\n    else:\n        delay = delay - jitter\n\n    for ch in text:\n        print(ch, end=\"\", flush=True)\n        time.sleep(delay)\n    print(\"\")\n\n\nteletype_printer(\"...\", delay=0.5)\n# Meeting someone\nif random.randint(1, 6) &lt; 4:\n    teletype_printer(\"You will meet a tall, dark stranger\")\nelse:\n    teletype_printer(\"Nobody unexpected will enter your life\")\n\nteletype_printer(\"...\", delay=0.5)\n# Money\nresult = random.randint(1, 6)\nif result == 1:\n    teletype_printer(\"I see untold riches in your future\")\nelif result &lt;= 3:\n    teletype_printer(\"A life of comfort is coming\")\nelif result &lt; 6:\n    teletype_printer(\"You would do well to husband your wealth\")\nelse:\n    teletype_printer(\"I see a future lived on the streets...\")\n\nteletype_printer(\"...\", delay=0.5)\n# Advice\nresult = random.randint(1, 6)\nif result &lt;= 2:\n    teletype_printer(\"Sometimes the answers to our future, come from the past\")\nelif result &lt; 6:\n    teletype_printer(\"To define your future, avoid getting hung up on the past\")\nelse:\n    teletype_printer(\"You will soon face a decision that will redefine everything\")\nWe basically copy across the teletype_printer function from the previous exercise and replace the previous print statements with the new function. For fun we change the default delay to a lower number so the prints occur faster but between advice add a new\nteletype_printer(\"...\", delay=0.5)\ncall, with a longer delay that makes it look like the fortune teller is thinking between each piece of advice\n\n\n\n\n\nFunctions can return values, e.g.\n\nname = input('Enter your name please: ')\n\nHere name is assigned the value returned by the function input\nFunctions return values via the return keyword, e.g. the function below, returns the value \\(1\\)\n\n\ndef return_one():\n    return 1\n\nreturn_one()\n\n1\n\n\n\n\nTake a look look at the return in the following function and the attached program to answer the following questions\n\ndef get_value(prompt, value_min, value_max):\n    return 1\n    return 2\n\nride_number = get_value(prompt=\"Please enter the ride you want:\", value_min=1, value_max=5)\nprint(\"You have selected ride\", ride_number)\n\nYou have selected ride 1\n\n\n\nWhat would the above program print?\n\nThe function returns at the first return which in this case is \\(1\\), so the returned value is \\(1\\)\nThe second return is never reached\n\nWhat would the program below print? Would it run correctly?\n\n def get_value(prompt, value_min, value_max):\n     return\n\n ride_number = get_value(prompt=\"Please enter the ride number you want:\", value_min=1, value_max=5)\n print(\"You have selected ride:\", ride_number)\n\nYou have selected ride: None\n\n\n\nreturn ends the function without returning a value\nA distinct value None is returned\n\nRepresents the lack of a usable value\n\nNone is also returned when a function ends without hitting a return statement\n\nCan a function contain multiple return statements?\n\nYes! We already saw this with the first question\nA program exits from a function as soon as it reaches a return\n\n\n\nThe program below gives a generic function that asks the user for an integer with a client specified prompt between a range of value_min and value_max (inclusive)\n\n# Example 7.7: Get Value\n#\n# Demonstrates function returns through a program\n# that receives and validates an integer\n\n\ndef get_value(prompt, value_min, value_max):\n    while True:\n        number_text = input(prompt)\n        try:\n            number = int(number_text)\n        except ValueError:\n            print(\"Invalid number text. Please enter digits.\")\n            continue\n        if number &lt; value_min:\n            print(\"Value too small\")\n            print(\"The minimum value is\", value_min)\n            continue\n        elif number &gt; value_max:\n            print(\"Value too large\")\n            print(\"The maximum value is\", value_max)\n            continue\n        return number\n\n#Example usage\nride_number = get_value(\n    prompt=\"Please enter the ride number you want: \", value_min=1, value_max=5\n)\n\nprint(\"You have selected ride: \", ride_number)\n\nAn example interaction might proceed as follows\n\n\n\n\nPlease enter the ride number you want:  6 \n\nValue too large\n\nThe maximum value is 5\n\nPlease enter the ride number you want:  3 \n\nYou have selected ride: 3\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nDesigning Functions\nThinking about how to break a program down into functions is an important part of the design process. Functions are typically defined first in terms of their behaviour and then their header (i.e. name, parameters and return values).\nFunction reduce the amount of repeated code that needs to be written. Don’t start by creating too many functions but when you find yourself repeating yourself, it’s a good sign to start writing a function\n\nAny changes can now be made in one place - the function\nFunctions provide testable components for a larger piece of software\n\nThey are effectively mini-programs\nTests run the function for some input and check the output against some expected output\nTests are typically written alongside the code itself, and mean that as the code is developed and modified we can ensure it still works\n\n\n\n\n\n\n\n\n\nFunctions have what is called a local namespace\n\nIf we declare a variable i in one function we can declare another variable i in a second function, e.g. (LocalVariables.py)\n\n\n\n    # Example 7.8 Local Variables\n    #\n    # Demonstrates the local namespaces of functions\n\n\n    def func_2():\n        i = 99  # noqa: F841\n\n\n    def func_1():\n        i = 0\n        func_2()\n        print(\"The value of i is: \", i)\n\n\n    func_1()\n\nThe value of i is:  0\n\n\n\nHere func_1 sets its version of i to \\(0\\), the calls func_2 which defines its own version of i to \\(99\\)\nWhen we return to func_1 we are dealing with func_1’s version of i which still has the value \\(0\\)\n\n\n\n\n\nAny variable declared outside a function is a global variable\nCan be implicitly accessed by any function\n\nSee the program (GlobalVariables.py) below\n\n\n  # Example 7.9 Global Variables\n  #\n  # Demonstrates using global variables in functions\n\n  cheese = 99\n\n\n  def func():\n      print(\"Global cheese is:\", cheese)\n\n\n  func()\n\nGlobal cheese is: 99\n\n\nIf we define a new variable inside a function, with the same name as a global variable the global variable is hidden or shadowed\n\nSee the program (ShadowingGlobalVariables.py)\n\n\n  # Example 7.10 Shadowing Global Variables\n  #\n  # Demonstrates local variables shadowing a\n  # global variable\n\n  cheese = 99\n\n\n  def func():\n      cheese = 100\n      print(\"Local cheese is:\", cheese)\n\n\n  func()\n  print(\"Global cheese is:\", cheese)\n\nLocal cheese is: 100\nGlobal cheese is: 99\n\n\n\nWe can see in the above that inside func we can’t see the value of the global cheese\n\nBut what if we want to update a global variable inside a function?\n\nCan use the global keyword to connect the variable in a function to the global counterpart, see StoringGlobalVariables.py\n\n\n  # Example 7.11 Storing Global Variables\n  #\n  # Demonstrates storing a global variables in a\n  # variable in a function. Also shows updating a global\n  # variable\n\n  cheese = 99\n\n\n  def func():\n      global cheese  # use the global variable\n      print(\"Global cheese is:\", cheese)\n      cheese = 100\n\n\n  func()\n  print(\"Global cheese is:\", cheese)\n\nGlobal cheese is: 99\nGlobal cheese is: 100\n\n\nObserve in the above program we first connect func to the global variable cheese\n\nThe print shows that func’s cheese has the same value as the global cheese\n\nWe then change the value of cheese in func and can see that this is propagated back to the global context\nThe use of the global keyword makes it clear when we are intending to use global variables\n\nHowever shadowing can cause confusion\n\n\n\n\n\n\n\n\nWarning\n\n\n\nUse global data with care\nGlobal data, while useful can make programs hard to debug. Global variables connect all the functions that rely on them. Changes (and by extension error) can propagate through to all the functions that depend on the variable. You should therefore limit and be clear when you use global variables\n\n\n\n\n\n\n\nIt is useful to write functions to capture common, reusable functionality\nFor example: Collecting valid user data\n\n\n\n\nThe simplest case, is getting a string from the user\n\nSimply want to prevent the user interrupting the program\nAlso useful to provide a generic standard prompt if the user doesn’t want to provide one every time, i.e. default argument\n\nStart by defining the function header\n\nread_text(prompt=\"Please enter some text: \")\n\nThe implementation is then pretty similar to what we’ve developed before, (the full example in InputFunctions.py contains some additional lines of code to demonstrate the use of the function)\n\n\n# Read Text\n#\n# A simple function for getting validated strings from a user\n\n\ndef read_text(prompt=\"Please enter some text: \"):\n    while True:\n        try:\n            result = input(prompt)\n            break  # stop loop if no exception\n        except KeyboardInterrupt:\n            print(\"Please enter text\")\n    return result\n\n\n\nUse the read_text function to answer the following questions\n\nWhat is the result variable used to accomplish?\n\nLocal variable storing the user input to be returned\n\nWhat stops the function from repeating continuously?\n\nThe break statement ends the loop one a string has been entered\nOnce the loop finishes the rest of the function is linear and will end\n\nWhy does the text reading loop repeat after the exception has been handled?\n\nThe function reaches the end of the loop block (look at the indentation of the return)\nThe loop condition is while True so unless stopped by the break which requires the program to successfully read a string, the loop will run again\n\n\n\n\n\n\n\nPython has a convention for adding comments that describe a function\nThese can be automatically read and displayed by Python tooling\n\nEnables automatic documentation generation\n\nA string literal immediately after the function header but before any other code is interpreted as a functions docstring, e.g.\n\ndef read_line(prompt):\n    'Displays a prompt and reads in a string of text'\n\nThe above is single-line comment that provides a simple description of the function\nThe alternate below, is a multi-line comment which can provide more detail,\n\ndef read_text(prompt=\"Please enter some text: \"):\n    \"\"\"\n    Displays a prompt and reads in a string of text.\n    Keyboard Interrupts are ignored\n\n    prompt: str\n        prompt the user sees before entering text\n\n    return: str\n        returns a string containing the string input by the user\n    \"\"\"\n\nNote the use of triple quotes to write a string over multiple lines\nHere we describe the function, it’s parameters and the return in detail\n\nOur descriptions of parameters and returns explain both what they mean, and also the expected type\n\n\n\n\n\n\n\n\nTip\n\n\n\nUse a standard docstring convention\nThere are a number of standard formats used for docstrings. Two common ones being google and numpy\nThe advantage of using a common format is that it means that not only can we generate and display information about functions in code (see below for information about pydoc) but that there exists many tools for converting these standard formats into reference documentation that can be hosted or shared (e.g. on a website.)\nYou could of course define your own format, but then you might need to roll your own tooling if you ever wanted to publish your own reference documentation.\nIn these notes and the included code snippets we have generally stuck to using the numpy convention\n\n\n\n\n\nThe pydoc library is designed to read function docstrings\n\nFor example if we use it on the standard library function print\n\n\n  import pydoc\n\n  pydoc.help(print)\n\nHelp on built-in function print in module builtins:\n\nprint(*args, sep=' ', end='\\n', file=None, flush=False)\n    Prints the values to a stream, or to sys.stdout by default.\n\n    sep\n      string inserted between values, default a space.\n    end\n      string appended after the last value, default a newline.\n    file\n      a file-like object (stream); defaults to the current sys.stdout.\n    flush\n      whether to forcibly flush the stream.\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nForm a habit of documenting your code\nNowadays, programmers try to package the documentation with the code writing process. Sometimes this extends to the concept of documentation-as-code. Whenever you write a function, you should get into the habit of writing documentation.\n\n\n\n\n\n\n\nThe next function in our set of input functions is one to handle receiving a numbers\n\nMore specifically floating point numbers\n\nWe can break this down into steps\n\nFirst we get a valid string from the user\n\nWe can reuse read_text\n\nWe check that it’s a valid number\n\nWrap the extra functionality\n\n\n\n\ndef read_float(prompt):\n    \"\"\"\n    Displays a prompt and reads in a number\n\n    Keyboard interrupts are ignored\n    Invalid numbers are rejected\n\n    Parameters\n    ----------\n    prompt : str\n        Prompt the user sees before giving input\n\n    Returns\n    -------\n    float\n        The input value\n\n    See Also\n    --------\n    read_float_ranged : reads a float restricted to a closed interval\n    \"\"\"\n    while True:\n        try:\n            number_text = read_text(prompt)\n            result = float(number_text)\n            break\n        except ValueError:\n            print(\"Please enter a number\")\n    return result\n\n\nAn example usage is (mirrored in InputFunctions.py)\n\nage = read_float(\"Please enter your age: \")\nprint(age)\n\nWhich the user might see as,\n\n\nprint(\"Please enter your age: \\033[31m 32.7 \\033[0m\")\nprint(32.7)\n\n\nPlease enter your age:  32.7 \n\n32.7\n\n\n\n\n\nWe can then create a specialised version of read_float that uses it as a component to get a float restricted to a user specified range\n\n\ndef read_float_ranged(prompt, min_value, max_value):\n    \"\"\"\n    Displays a prompt and reads in a number between\n    min_value and max_value (inclusive)\n\n    Keyboard interrupts are ignored\n    Invalid numbers or out of range numbers are rejected\n\n    min_value: float minimum value (inclusive)\n    max_value: float maximum value (inclusive)\n\n    return: float\n    value input by user in the range [min_value, max_value]\n    \"\"\"\n    while True:\n        result = read_float(prompt)\n        if result &lt; min_value:\n            print(\"That number is too low\")\n            print(\"The minimum value is\", min_value)\n            continue\n        elif result &gt; max_value:\n            print(\"That value is too large\")\n            print(\"The maximum value is\", max_value)\n            continue\n        break  # if here have a valid number\n    return result\n\n\nLike with the read_float we use a previous function (here read_float) to capture existing error-handling and input handling code\n\nThen add in the extra functionality\nExample usage (again seen in the complete file InputFunctions.py)\n\n  age = read_float_ranged(\"Please enter your age\", min_value=5, max_value=90)\n  print(age)\nObserve how we have used each function as a reusable component in the next more specific function\n\nWe can do this because we cleanly define the responsibilities of each function\n\n\n\n\n\nLet’s examine the final function read_float_ranged in more detail to capture all the things we’ve built up. Answer the following questions\n\nWhy doesn’t this function have code to capture exceptions?\n\nNo, The two exception types we care about KeyboardInterrupt and ValueError are handled by read_text (via read_float) and read_float respectively\n\nWill chaining these functions together slow down the program?\n\nThere would probably be some slow down, since each time we have to call a function there is some setup and tear-down\nHowever, the slow down would be minuscule\nThe improved readability and compartmentalisation has advantages in readability and maintainability for the user\n\nThis practice of building higher-level functions out of smaller “lower level” functions is very common\n\n\nWhat would happen if a programmer reversed the minimum and maximum values?\n\nThe program would not work, it would require a number that is greater than what it thinks is the min (actually max) and less than what it thinks is the max (actually the min). These are incompatible conditions and the program would never be able to exit the function (or interrupt it)\nThere are three options\n\nFix the program so it swaps min and max if they are reversed\nDocuments that it’s not expected to work and leaves it to the user to ensure that the case doesn’t arise.\nRaises an exception for the caller to handle. (Our implementation in InputFunctions.py) uses the former technique\n if min_value &gt; max_value:\n     raise Exception(\"Min value is greater than max value\")\n\nIt is good etiquette to document exceptions raised in the function documentation\n\n\n\n\n\n\n\n\nIdeally we want to write our functions once and be able to reuse them\n\nThe most basic way would be to simply copy them into a new file each time we need them\n\nA more complete method is to write our own module\n\nWe create a file BTCInput.py\nSo long as we include this file in the same directory as our new project we can include the functions the same way we would use time or random via\n  import BTCInput\nWe then call the functions as for any other module e.g.\n  age = BTCInput.read_float_ranged(\"Enter your age: \", min_value=5, max_value=90)\n\nIf we want to avoid having to write the module name every time we call a function we can use the from keyword\n\nAllows us to import specific components into the global namespace\nAlternatively can import all components of a module using *\n\nTypically avoid this, it carries a high risk of name clashes between functions defined in different modules\n\n\n\n#option 1: import function\nfrom BTCInput import read_float_ranged\nage = read_float_ranged(\"Enter your age: \", min_value=5, max_value=90)\n\n#option 2: import all\nfrom BTCInput import *\nage = read_float_ranged(\"Enter your age: \", min_value=5, max_value=90)\n\n\nRewrite the following programs to use BTCInput for input\n\nGreeter\nUltra Precise Egg Timer\nPizza Order Calculator\nFahrenheit To Celsius\nRide Selector\nUser-Selected Times Table\n\n\n\n\n\n\n\nNote\n\n\n\nWe’ve linked to where each of these programs are first referenced, but we’ll generally try to update the most comprehensive version of the respective program. We use the version of BTCInput.py included in Chapter 8 of the original code (see samples in the repo) since it offers a more complete set of validation functions based on the discussion above.\nTo correctly setup BTCInput.py ensure the variable DEBUG_MODE = FALSE\n\n\n\nGreeter\n\nThis change is straight forward, we replace input with read_text\n\n # Exercise 7.2.1: Greeter\n # An implementation of Greeter than uses BTCInput for validation\n\n import BTCInput\n\n name = BTCInput.read_text(\"Enter your name please: \")\n print(\"Hello\", name)\nUltra Precise Egg Timer\n\nWe can combine the original code that reads in the egg boiling time and the float conversion to one call to the BTCInput function read_float. Note that we don’t change the second input which just asks the user to press enter, since really we’re looking for any input from the user\n\n # Exercise 7.2.2 Ultra-Precise Egg Timer\n #\n # Implementation of Ultra-Precise Egg Timer using BTCInput\n\n import time\n import BTCInput\n\n egg_time = BTCInput.read_float(\"Enter the cooking time in seconds: \")\n\n print(\"Put the egg in boiling water now\")\n input(\"Press enter to continue once the egg is in...\")\n\n time.sleep(egg_time)\n\n print(\"Take the egg out now\")\nPizza Order Calculator\n\nAgain we simply replace the int(input()) structure with the BTCInput equivalent, BTCInput.read_int\n\n # Exercise 7.2.3: Pizza Order Calculator\n #\n # Implementation of Pizza Order Calculator that uses BTCInput\n\n import BTCInput\n\n students_int = BTCInput.read_int(\"How many students are attending? \")\n\n pizza_count = int(students_int / 1.5) + 1  # perform division int -&gt; float\n print(\"You will need\", pizza_count, \"pizzas\")\nFahrenheit To Celsius\n\nAgain a simple replacement, here float(input(...)) becomes BTCInput.read_float()\n\n # Exercise 7.2.4: Fahrenheit to Celsius\n #\n # Version of Fahrenheit to Celsius that uses BTCInput\n\n import BTCInput\n\n temperature_fahrenheit = BTCInput.read_float(\"Enter a temperature in Fahrenheit: \")\n temperature_centigrade = (temperature_fahrenheit - 32) / 1.8\n print(\"The temperature is\", temperature_centigrade, \"degrees Celsius\")\nRide Selector\n\nThe implementation is based on the Full input validated version of Ride Selector in Chapter 6\nThere are two important changes, first to ensure the user selects a valid theme park ride option, we use BTCInput.read_int_ranged\n  ride_number = BTCInput.read_int_ranged(\n      \"Please enter the ride number you want: \", 0, 5\n  )\nRemember that \\(0\\) is a number we’ve chosen to represent quitting the program\nSecond the ensure the user adds an age, here even though we have a valid age range, this is for being able to ride\n\nWe still want to accept those ages, and then inform the user of the issue\nSo here we use BTCInput.read_int (note un-ranged)\n\n  age = BTCInput.read_int(\"Please enter your age: \")\n\nUser Selected Times Tables\n\nHere we can remove all the validation code we wrote and simply replace it with the BTCInput.read_int_ranged call\nThis highlights the advantage of functions, the final program is much cleaner and easier to read\n  # Exercise 7.2.6 Tables Tables\n  #\n  # Variant of the User Selected Times Tables Tutor that uses BTCInput for\n  # validation\n\n  import BTCInput\n\n  count = 1\n  times_value = BTCInput.read_int(\"Please enter a times table between 2-12 (inclusive): \")\n\n  while count &lt; 13:\n      result = count * times_value\n      print(count, \"times\", times_value, \"equals\", result)\n      count = count + 1\n\n\n\n\n\n\n\n\nMost python development environments support a debugger\nA debugger is a program designed to help you identify (and solve) bugs or problems in your program\nThis section will introduce concepts of a debugger\n\nThe book discusses the specifics of using the debugger packaged in IDLE\nThe notes here discuss generics\n\nA debugger runs code like normal, but supports extra tools and techniques for interrogating the internal state of a program\nA breakpoint causes the program being run in the debugger to pause when it reaches the line where the break occurs.\n\nbreakpoints allow the programmer to halt the program at a desired point (typically close to where a problem occurs) and inspect variable contents\n\n\n\n\n\n\n\n\nNote\n\n\n\nBreakpoints vs break\nA breakpoint is different to the break keyword\n\nbreak is used to immediately escape a loop structure in a running program\nA breakpoint is used to pause the execution of a program at a specific point when it is being debugged\n\n\n\n\n\nUse the following example, found in InvestigateTheDebugger.py as the basis to learn the debugger\n# Example 7.14 Investigate the Debugger\n#\n# A sample code for practising with the debugger\n\n\ndef increment_function(input_value):\n    result = input_value + 1\n    return result\n\n\nx = 99\ny = increment_function(x)\nprint(\"The answer is:\", y)\nUsing your debugger, set a breakpoint on the line x = 99\n\nIn VSCode for my setup with the python extensions I simply click on the line, left of the line number, a red circle appears indicating a breakpoint\n\nTo clear the breakpoint just click on it again\n\nThen run your program using the debugger\n\nIn VSCode I simply go to the Run and Debug tab, and click the Run and Debug button\n\nI then select from a dropdown menu, python debugger followed by debug the current file\n\nThe code starts running then stops at the breakpoint\nOn the left a panel shows the call stack\n\nThe call stack shows the sequence of function calls we are in\n\nAbove a panel shows the contents of variables\n\nBroken up into a tab for\n\nLocal variables\nGlobal variables\nThere are also tabs for special and function variables which can be ignored for now\n\n\nA control panel shows at the top of the program, the options are as follows,\n\nGo continues running the program\nStep Over goes to the next line in the program\n\nIf the line the program is on is a function, the program will calculate the results of the function and then go to the line after the program\n\nStep In goes to the next line in the program, if the program is on a function, the debugger will step into the function and go through it line by line\n\nThis includes opening any files where a function is defined in another file\n\nStep Out completes the current function and goes to the line after it\nRestart restarts the program\nStop immediately stops the program\n\n\nUse the step function to watch how python flows through this program, observe the call stack and the variable values when you step into increment_function\n\nObserve what happens when you step into print\n\nDepending on the debugger it may or may not step into the print function\nUse Step Out to leave print\nUse Step Out again, the program should end",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 7: Using Functions to Simplify Programs"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/07_UsingFunctions/Chapter_07.html#notes",
    "href": "01_ProgrammingFundamentals/07_UsingFunctions/Chapter_07.html#notes",
    "title": "Chapter 7: Using Functions to Simplify Programs",
    "section": "",
    "text": "A function is a named chunk of code\n\nCan be thought of as like a variable containing code rather than a value\nConsider the simple function\n\n\n  def greeter():\n      print(\"Hello\")\n\n\nPrint’s the message \"Hello\"\nCalled by the function name, then parentheses, e.g.\n\n\n  greeter()\n\nHello\n\n\n\nfunctions must be defined before they can be called\n\n\n\n\nUse a python interpreter to work through the following questions to understand python functions\nEnter the following program into the interpreter\ndef greeter():\n     print(\"Hello\")\n\nWhy did the interpreter not print \"Hello\"?\n\nBecause the print statement is stored as part of the greeter function\n\nHow do I tell Python that I’ve finished entering the greeter function?\n\nThe same way you close a loop or an if statement, by de-indenting and adding an empty line\n\nHow do I make a call to the greeter function?\n\n greeter()\n\nHello\n\n\n\nThe same way you call any other function. Write the function name and a parenthesised list of parameters. In this case the list is empty. Once called the function runs all the statements contained in its definition.\n\n\nNow consider the following code snippet\n\nx = greeter\nx()\n\nHello\n\n\nObserve that we can treat functions like variables. We can assign them to other labels/variables in this case x is set to the value of greeter. We can then call x as if it where greeter\nThe ability to treat functions as variables is a powerful feature we will explore more in Chapter 12\n\n\n\nExamine the following code block and and answer the following questions to understand how functions work. (You can run the code at Pathfinder.py)\n\n# Example 7.1: Pathfinder\n#\n# Sample Program to demonstrate function flow\n\n\ndef m2():\n    print(\"the\")\n\n\ndef m3():\n    print(\"sat on\")\n    m2()\n\n\ndef m1():\n    m2()\n    print(\"cat\")\n    m3()\n    print(\"mat\")\n\n\nm1()\n\nthe\ncat\nsat on\nthe\nmat\n\n\n\nWhat will the program display when it runs?\n\nStep through the program one statement at a time\nFirst m1 is called\n\nm1 calls m2\n\nm2 prints \"the\"\nm2 ends and control returns to m1\n\nm1’s next statement prints \"cat\"\nm1’s next statement calls m3\n\nm3 prints \"sat on\"\nm3 calls m2\n\nm2 prints \"the\"\nm2 ends and control returns to m3\n\nm3 ends and control returns to m1\n\nm1 prints \"mat\"\nm1 and thus the program ends\n\nThe final output is thus:\n\n the\n cat\n sat on\n the\n mat\nWhat happens if a function calls itself? For example what if m1 called m1\n\nLet’s try changing m1 to the following,\n\n  def m1():\n      m1()\n\n  m1()\n\n\n---------------------------------------------------------------------------\nRecursionError                            Traceback (most recent call last)\nCell In[6], line 4\n      1 def m1():\n      2     m1()\n----&gt; 4 m1()\n\nCell In[6], line 2, in m1()\n      1 def m1():\n----&gt; 2     m1()\n\nCell In[6], line 2, in m1()\n      1 def m1():\n----&gt; 2     m1()\n\n    [... skipping similar frames: m1 at line 2 (2975 times)]\n\nCell In[6], line 2, in m1()\n      1 def m1():\n----&gt; 2     m1()\n\nRecursionError: maximum recursion depth exceeded\n\n\n\nThe code generates a RecursionError!\n\nA function that calls itself is called a recursive function\nLike an infinite loop infinite recursion occurs when a function calls itself with no condition to stop\nEventually the computer cannot allocate more memory to track the function calls\n\nThis can be dangerous so Python prematurely limits the “depth” of recursive calls a function can make\n\n\nFormally with recursion:\n\nEach time a function is called Python stores the return address (where the code goes back to) on the “stack”\n\nThe stack is special memory responsible for managing the program\nWhen a function finishes the program grabs the return of the stack and looks at the address to to determine where to run\n\nCalling and exiting functions thus grows and shrinks the stack\n\nUp to a limit defined by Python at which point a recursion error occurs\n\n\nRecursive functions are a powerful and elegant technique in many cases\n\nHowever, often it is better to use simple loop structures\nRecursion more of interest for theory\n\n\n\n\n\n\n\n\n\n\n\nblock-beta\n    columns 7\n\n    classDef BG stroke:transparent, fill:transparent\n\n\n    space\n    space\n    title[\"Breakdown of a Function Definition\"]:3\n    space\n    space\n\n    class title BG\n\n    block:Def\n    columns 1\n        def[\"def\"]\n        defDescr[\"(start of function definition)\"]\n    end\n\n    class def BG\n    class defDescr BG\n\n\n    block:Name\n    columns 1\n        name[\"name\"]\n        nameDescr[\"(name of the function)\"]\n    end\n\n    class name BG\n    class nameDescr BG\n\n    block:LeftP\n    columns 1\n        leftP[\"(\"]\n        leftPDescr[\" \"]\n    end\n\n    class leftP BG\n    class leftPDescr BG\n\n    block:Parameters\n    columns 1\n        parameters[\"parameters\"]\n        parametersDescr[\"(items to feed into the function)\"]\n    end\n\n    class parameters BG\n    class parametersDescr BG\n\n    block:RightP\n    columns 1\n        rightP[\")\"]\n        rightPDescr[\" \"]\n    end\n\n    class rightP BG\n    class rightPDescr BG\n\n    block:Colon\n    columns 1\n        colon[\":\"]\n        colonDescr[\"colon\"]\n    end\n\n    class colon BG\n    class colonDescr BG\n\n    block:Suite\n    columns 1\n        suite[\"Statement block\"]\n        suiteDescr[\"(statements)\"]\n    end\n\n    class suite BG\n    class suiteDescr BG\n\n\n\n\n\n\n\ndef tells python we’re defining a function\n\nAs opposed to calling an existing one\n\nspace then name of the function\n\nSame naming rules as for variables\nfunctions do things, i.e. the are naturally associated with verbs\n\nUnlike variables with are things i.e. nouns\n\ne.g. display_menu names a function which takes the action to display a menu\n\nThen parameters in a parentheses-enclosed, comma-delimited list\n\nNo space between name and left parenthesis\nParameters feed extra information for the function to work on\nParameter list can be empty (as we’ve seen)\n\nThen colon\nFollowed by indented set of statements associated with the function\n\nCalled the function body\n\n\n\n\n\n\nFunctions can receive data to work on through parameters\nE.g. we can parameterise our times table code\n\n  def print_times_table(times_value):\n      count = 1\n      while count &lt;  13:\n          result = count * times_value\n          print(count, 'times', times_value, 'equals', result)\n          count = count + 1\n\nWe can then call with different times_value to print the respective times table\n\n\n    print_times_table(5)\n    print_times_table(99)\n\n1 times 5 equals 5\n2 times 5 equals 10\n3 times 5 equals 15\n4 times 5 equals 20\n5 times 5 equals 25\n6 times 5 equals 30\n7 times 5 equals 35\n8 times 5 equals 40\n9 times 5 equals 45\n10 times 5 equals 50\n11 times 5 equals 55\n12 times 5 equals 60\n1 times 99 equals 99\n2 times 99 equals 198\n3 times 99 equals 297\n4 times 99 equals 396\n5 times 99 equals 495\n6 times 99 equals 594\n7 times 99 equals 693\n8 times 99 equals 792\n9 times 99 equals 891\n10 times 99 equals 990\n11 times 99 equals 1089\n12 times 99 equals 1188\n\n\n\n\n\nA parameter is the name assigned to a value passed to a function\nAn argument is the specific value passed when a function is called\ne.g. in the above print_times_table function:\n\nThe parameter is times_value\nBut a specific argument is \\(5\\) or \\(99\\)\n\nConsider it as the phrase “we call the function passing the arguments to the parameters”\n\n\n\nFind out more about arguments and parameters by answering the following questions\n\nWhat would the following program do?\n\n # Example 7.2: Times Tables\n #\n # Demonstrates function parameters through a\n # Times Table function that takes in an argument to\n # determine which times table is printed\n\n def print_times_table(times_value):\n     count = 1\n     while count &lt; 13:\n         result = count * times_value\n         print(count, \"times\", times_value, \"equals\", result)\n         count = count + 1\n\n print_times_table(6)\n\n1 times 6 equals 6\n2 times 6 equals 12\n3 times 6 equals 18\n4 times 6 equals 24\n5 times 6 equals 30\n6 times 6 equals 36\n7 times 6 equals 42\n8 times 6 equals 48\n9 times 6 equals 54\n10 times 6 equals 60\n11 times 6 equals 66\n12 times 6 equals 72\n\n\n\nThe above should print out the times table for \\(6\\)\n\nWhat would happen if we changed the call of the print_times_table function to the one below that has a string as the argument? Would the program fail?\n\n print_times_table(\"six\")\n\n1 times six equals six\n2 times six equals sixsix\n3 times six equals sixsixsix\n4 times six equals sixsixsixsix\n5 times six equals sixsixsixsixsix\n6 times six equals sixsixsixsixsixsix\n7 times six equals sixsixsixsixsixsixsix\n8 times six equals sixsixsixsixsixsixsixsix\n9 times six equals sixsixsixsixsixsixsixsixsix\n10 times six equals sixsixsixsixsixsixsixsixsixsix\n11 times six equals sixsixsixsixsixsixsixsixsixsixsix\n12 times six equals sixsixsixsixsixsixsixsixsixsixsixsix\n\n\n\nRecall that multiplication between strings and numbers is defined in python as the repeated concatenation of the string with itself\nThe above thus prints a triangle of increasingly concatenated \"six\"\nThis behaviour while semantically correct by the python language is not logically correct. Really we would expect an error to occur\n\nHow do we make the print_times_table function work with integer parameters only?\n\nFirst: is it a problem?\n\nIf this function is wrapped in a higher level function that does the error handling we can probably forget it\n\nSecond: If it is a problem, what is the way to fix it?\n\nPrint a warning message?\nStop the program?\nHandle the error locally? (within the function)\n\nIn this case let’s throw an error if the type is not an integer\n\nThe isinstance function lets you type check an item\nAccepts two arguments, item to test, and the type to match\nReturns True if item is that type else False\n\n\n\n # Example 7.3: Safe Times Tables\n #\n # A version of Times Tables that uses isinstance\n # to ensure that argument is an integer\n\n\n def print_times_table(times_value):\n     if not isinstance(times_value, int):\n         raise Exception(\"print_times_table requires an integer argument\")\n     count = 1\n     while count &lt; 13:\n         result = count * times_value\n         print(count, \"times\", times_value, \"equals\", result)\n         count = count + 1\n\n\n print_times_table(\"six\")\n\n\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\nCell In[11], line 17\n     13         print(count, \"times\", times_value, \"equals\", result)\n     14         count = count + 1\n---&gt; 17 print_times_table(\"six\")\n\nCell In[11], line 9, in print_times_table(times_value)\n      7 def print_times_table(times_value):\n      8     if not isinstance(times_value, int):\n----&gt; 9         raise Exception(\"print_times_table requires an integer argument\")\n     10     count = 1\n     11     while count &lt; 13:\n\nException: print_times_table requires an integer argument\n\n\n\n\nSafeTimesTable.py shown above demonstrates using isinstance to raise an exception\nException can be thought of as an object that holds the error description\n\nstring argument describes the error\n\nraise creates and throws it\n\n\n\n\n\n\n\nfunctions can have multiple parameters\n\ne.g. what if we want to adjust the length of the times table\n\n\n  # Example 7.4: Two Parameter Times Table\n  #\n  # Demonstrates a multi-parameter function through a variable\n  # length times table program\n\n\n  def print_times_table(times_value, limit):\n      count = 1\n      while count &lt; limit + 1:\n          result = times_value * count\n          print(count, \"times\", times_value, \"equals\", result)\n          count = count + 1\n\n\nThe above uses times_value to control which times table is printed, and limit controls the length\n\nThe full code is given in TwoParameterTimesTable.py\n\nAn example call is then,\n\n\n  print_times_table(6,5)\n\n1 times 6 equals 6\n2 times 6 equals 12\n3 times 6 equals 18\n4 times 6 equals 24\n5 times 6 equals 30\n\n\n\nThe above prints the first \\(5\\) entries of the \\(6\\) times tables\n\n\n\n\n\n\nConsider the call,\n\n  print_times_table(12, 7)\n\n1 times 12 equals 12\n2 times 12 equals 24\n3 times 12 equals 36\n4 times 12 equals 48\n5 times 12 equals 60\n6 times 12 equals 72\n7 times 12 equals 84\n\n\nThe above, to the unfamiliar user makes it unclear if its a \\(12\\) times table of length \\(7\\) or a times table for \\(7\\) of length \\(12\\)\n\nThis is because the arguments are passed as positional parameters\n\ni.e. order the arguments go in, controls which parameter they are assigned too\n\n\nYou can also pass arguments to functions by specifying the parameter name, e.g.\n\n  print_times_table(times_value=12, limit=7)\n\n1 times 12 equals 12\n2 times 12 equals 24\n3 times 12 equals 36\n4 times 12 equals 48\n5 times 12 equals 60\n6 times 12 equals 72\n7 times 12 equals 84\n\n\n\nThis is called keyword arguments, because we specify the arguments associated parameter by its name\n\n\n\n\n\n\n\n\nWarning\n\n\n\nDon’t mix positional and keyword arguments\nPython lets you mix positional and keyword arguments in a call to a function. This can make it hard to work out what is assigned to what. You should either use all positional arguments (when obvious) or all keyword arguments\nBeware that positional arguments must precede all keyword arguments\n\n\n\n\n\n\nOur original implementation of print_times_table assumed the length was \\(12\\)\nThe second version allowed us to specify the length, but no longer assumes that it is \\(12\\)\nDefault parameters let us combine both behaviours\n\n  # Example 7.5: Default Parameters\n  #\n  # Demonstrates default arguments by capturing the single\n  # argument times table code in the two parameter version\n\n\n  def print_times_table(times_value, limit=12):\n      count = 1\n      while count &lt; 13:\n          result = times_value * count\n          print(count, \"times\", times_value, \"equals\", result)\n          count = count + 1\n\n\nIf an argument is not provided to a parameter with a default argument, the default is used, e.g. the below call implicitly uses limit = 12\n\n  print_times_table(times_value=7)\n\n1 times 7 equals 7\n2 times 7 equals 14\n3 times 7 equals 21\n4 times 7 equals 28\n5 times 7 equals 35\n6 times 7 equals 42\n7 times 7 equals 49\n8 times 7 equals 56\n9 times 7 equals 63\n10 times 7 equals 70\n11 times 7 equals 77\n12 times 7 equals 84\n\n\n\nMost modern python editors and tooling can read function definitions, and highlight and default arguments\n\n\n\n\n\n\n\nTip\n\n\n\nWhy use named arguments and default parameters?\nNamed arguments and default parameters help make functions clearer in intent. Reduce the possibility of getting arguments confused or mixed up. Makes it easy to define “standard” behaviour for a function\n\n\n\n\n\nWhat does it mean when we pass the value of an argument to a function parameter? Consider the following program\n\n# Example 7.6 Parameters as Values\n#\n# Demonstrates how python handles passing values to a function\n\n\ndef what_would_I_do(input_value):\n    input_value = 99  # noqa: F841\n\n\ntest = 0\nwhat_would_I_do(test)\nprint(\"The value of test is\", test)\n\nThe value of test is 0\n\n\nThe function accepts a single value and sets it to \\(99\\). We then call the function with the value of test which has been set to \\(0\\). We then print the value of test after the function call\nAnswer the following question,\n\nWhat would this program print when it runs?\n\nThe program follows this sequence\n\ntest is set to \\(0\\)\nwhat_would_I_do is called, being passed the value of test which is \\(0\\)\nIn what_would_I_do, input_value is initially set to \\(0\\)\ninput_value is set to \\(99\\)\nwhat_would_I_do then ends\nThe value of test is printed\n\nThe main observation here is that the value of test is passed to the function not test itself\n\ntest is unchanged outside the function\n\n\n\n\n\n\nWrite a function teletype_print that slowly writes out an input string. Use a for loop to loop over the contents of the string and the time library to delay the output. Use a default argument with a value of \\(0.1\\) to control the print speed. Use the random library to add a random amount of noise to the specified delay\nThe final function is given in the example TeletypePrinter.py, but we’ll work through the code in parts\n\nWe first import the modules we need\n\n# Exercise 7.1: Teletype Printer\n#\n# Emulates the slow speed of a teletype printer\n# by using a for loop and time to slowly loop over\n# an input string\n\nimport random\nimport time\n\nWe then define our function signature, text is left as something that must be supplied while delay is given a default value of \\(0.5\\) (purely to make the delay more obvious than the \\(0.1\\) suggested in the original book)\nWe then add a jitter to the delay from \\(1/10\\) through to the full size of the delay, by generating a random number\n\nWe then randomly generate a \\(0\\) or a \\(1\\) and use that to determine if the jitter is added or removed from the delay\n\n\ndef teletype_printer(text, delay=0.5):\n    jitter = delay / random.randint(1, 10)\n    if random.randint(0, 1):\n        delay = delay + jitter\n    else:\n        delay = delay - jitter\n\nWe then loop over the string, printing each character\n\nWe have to override the print default arguments\n\nend determines what is printed after each call to print, we set end to the empty string so that all the characters are printed on the same line\nSetting flush to False ensures the interpreter prints each character as it is called rather than waiting for the end of a line\n\n\nAfter the loop we now have to print an empty line to get the new line\n\n    for ch in text:\n        print(ch, end=\"\", flush=True)\n        time.sleep(delay)\n    print(\"\")\n\nLastly we demonstrate the function being called with it’s default values on the word \"hello\"\n\nteletype_printer(\"hello\")\n\n\nhello\n\n\n\n\n\nUse the function you wrote for a teletype output to add some style to the Fortune Teller Program\nOur solution is given in TeletypeFortuneTeller.py and repeated below\n# Exercise 7.2 Teletype Fortune Teller\n#\n# Version of the Fortune Teller Program that uses the teletype_printer function\n# to delay the output\n\nimport random\nimport time\n\n\ndef teletype_printer(text, delay=0.25):\n    jitter = delay / random.randint(1, 10)\n    if random.randint(0, 1):\n        delay = delay + jitter\n    else:\n        delay = delay - jitter\n\n    for ch in text:\n        print(ch, end=\"\", flush=True)\n        time.sleep(delay)\n    print(\"\")\n\n\nteletype_printer(\"...\", delay=0.5)\n# Meeting someone\nif random.randint(1, 6) &lt; 4:\n    teletype_printer(\"You will meet a tall, dark stranger\")\nelse:\n    teletype_printer(\"Nobody unexpected will enter your life\")\n\nteletype_printer(\"...\", delay=0.5)\n# Money\nresult = random.randint(1, 6)\nif result == 1:\n    teletype_printer(\"I see untold riches in your future\")\nelif result &lt;= 3:\n    teletype_printer(\"A life of comfort is coming\")\nelif result &lt; 6:\n    teletype_printer(\"You would do well to husband your wealth\")\nelse:\n    teletype_printer(\"I see a future lived on the streets...\")\n\nteletype_printer(\"...\", delay=0.5)\n# Advice\nresult = random.randint(1, 6)\nif result &lt;= 2:\n    teletype_printer(\"Sometimes the answers to our future, come from the past\")\nelif result &lt; 6:\n    teletype_printer(\"To define your future, avoid getting hung up on the past\")\nelse:\n    teletype_printer(\"You will soon face a decision that will redefine everything\")\nWe basically copy across the teletype_printer function from the previous exercise and replace the previous print statements with the new function. For fun we change the default delay to a lower number so the prints occur faster but between advice add a new\nteletype_printer(\"...\", delay=0.5)\ncall, with a longer delay that makes it look like the fortune teller is thinking between each piece of advice\n\n\n\n\n\nFunctions can return values, e.g.\n\nname = input('Enter your name please: ')\n\nHere name is assigned the value returned by the function input\nFunctions return values via the return keyword, e.g. the function below, returns the value \\(1\\)\n\n\ndef return_one():\n    return 1\n\nreturn_one()\n\n1\n\n\n\n\nTake a look look at the return in the following function and the attached program to answer the following questions\n\ndef get_value(prompt, value_min, value_max):\n    return 1\n    return 2\n\nride_number = get_value(prompt=\"Please enter the ride you want:\", value_min=1, value_max=5)\nprint(\"You have selected ride\", ride_number)\n\nYou have selected ride 1\n\n\n\nWhat would the above program print?\n\nThe function returns at the first return which in this case is \\(1\\), so the returned value is \\(1\\)\nThe second return is never reached\n\nWhat would the program below print? Would it run correctly?\n\n def get_value(prompt, value_min, value_max):\n     return\n\n ride_number = get_value(prompt=\"Please enter the ride number you want:\", value_min=1, value_max=5)\n print(\"You have selected ride:\", ride_number)\n\nYou have selected ride: None\n\n\n\nreturn ends the function without returning a value\nA distinct value None is returned\n\nRepresents the lack of a usable value\n\nNone is also returned when a function ends without hitting a return statement\n\nCan a function contain multiple return statements?\n\nYes! We already saw this with the first question\nA program exits from a function as soon as it reaches a return\n\n\n\nThe program below gives a generic function that asks the user for an integer with a client specified prompt between a range of value_min and value_max (inclusive)\n\n# Example 7.7: Get Value\n#\n# Demonstrates function returns through a program\n# that receives and validates an integer\n\n\ndef get_value(prompt, value_min, value_max):\n    while True:\n        number_text = input(prompt)\n        try:\n            number = int(number_text)\n        except ValueError:\n            print(\"Invalid number text. Please enter digits.\")\n            continue\n        if number &lt; value_min:\n            print(\"Value too small\")\n            print(\"The minimum value is\", value_min)\n            continue\n        elif number &gt; value_max:\n            print(\"Value too large\")\n            print(\"The maximum value is\", value_max)\n            continue\n        return number\n\n#Example usage\nride_number = get_value(\n    prompt=\"Please enter the ride number you want: \", value_min=1, value_max=5\n)\n\nprint(\"You have selected ride: \", ride_number)\n\nAn example interaction might proceed as follows\n\n\n\n\nPlease enter the ride number you want:  6 \n\nValue too large\n\nThe maximum value is 5\n\nPlease enter the ride number you want:  3 \n\nYou have selected ride: 3\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nDesigning Functions\nThinking about how to break a program down into functions is an important part of the design process. Functions are typically defined first in terms of their behaviour and then their header (i.e. name, parameters and return values).\nFunction reduce the amount of repeated code that needs to be written. Don’t start by creating too many functions but when you find yourself repeating yourself, it’s a good sign to start writing a function\n\nAny changes can now be made in one place - the function\nFunctions provide testable components for a larger piece of software\n\nThey are effectively mini-programs\nTests run the function for some input and check the output against some expected output\nTests are typically written alongside the code itself, and mean that as the code is developed and modified we can ensure it still works\n\n\n\n\n\n\n\n\n\nFunctions have what is called a local namespace\n\nIf we declare a variable i in one function we can declare another variable i in a second function, e.g. (LocalVariables.py)\n\n\n\n    # Example 7.8 Local Variables\n    #\n    # Demonstrates the local namespaces of functions\n\n\n    def func_2():\n        i = 99  # noqa: F841\n\n\n    def func_1():\n        i = 0\n        func_2()\n        print(\"The value of i is: \", i)\n\n\n    func_1()\n\nThe value of i is:  0\n\n\n\nHere func_1 sets its version of i to \\(0\\), the calls func_2 which defines its own version of i to \\(99\\)\nWhen we return to func_1 we are dealing with func_1’s version of i which still has the value \\(0\\)\n\n\n\n\n\nAny variable declared outside a function is a global variable\nCan be implicitly accessed by any function\n\nSee the program (GlobalVariables.py) below\n\n\n  # Example 7.9 Global Variables\n  #\n  # Demonstrates using global variables in functions\n\n  cheese = 99\n\n\n  def func():\n      print(\"Global cheese is:\", cheese)\n\n\n  func()\n\nGlobal cheese is: 99\n\n\nIf we define a new variable inside a function, with the same name as a global variable the global variable is hidden or shadowed\n\nSee the program (ShadowingGlobalVariables.py)\n\n\n  # Example 7.10 Shadowing Global Variables\n  #\n  # Demonstrates local variables shadowing a\n  # global variable\n\n  cheese = 99\n\n\n  def func():\n      cheese = 100\n      print(\"Local cheese is:\", cheese)\n\n\n  func()\n  print(\"Global cheese is:\", cheese)\n\nLocal cheese is: 100\nGlobal cheese is: 99\n\n\n\nWe can see in the above that inside func we can’t see the value of the global cheese\n\nBut what if we want to update a global variable inside a function?\n\nCan use the global keyword to connect the variable in a function to the global counterpart, see StoringGlobalVariables.py\n\n\n  # Example 7.11 Storing Global Variables\n  #\n  # Demonstrates storing a global variables in a\n  # variable in a function. Also shows updating a global\n  # variable\n\n  cheese = 99\n\n\n  def func():\n      global cheese  # use the global variable\n      print(\"Global cheese is:\", cheese)\n      cheese = 100\n\n\n  func()\n  print(\"Global cheese is:\", cheese)\n\nGlobal cheese is: 99\nGlobal cheese is: 100\n\n\nObserve in the above program we first connect func to the global variable cheese\n\nThe print shows that func’s cheese has the same value as the global cheese\n\nWe then change the value of cheese in func and can see that this is propagated back to the global context\nThe use of the global keyword makes it clear when we are intending to use global variables\n\nHowever shadowing can cause confusion\n\n\n\n\n\n\n\n\nWarning\n\n\n\nUse global data with care\nGlobal data, while useful can make programs hard to debug. Global variables connect all the functions that rely on them. Changes (and by extension error) can propagate through to all the functions that depend on the variable. You should therefore limit and be clear when you use global variables\n\n\n\n\n\n\n\nIt is useful to write functions to capture common, reusable functionality\nFor example: Collecting valid user data\n\n\n\n\nThe simplest case, is getting a string from the user\n\nSimply want to prevent the user interrupting the program\nAlso useful to provide a generic standard prompt if the user doesn’t want to provide one every time, i.e. default argument\n\nStart by defining the function header\n\nread_text(prompt=\"Please enter some text: \")\n\nThe implementation is then pretty similar to what we’ve developed before, (the full example in InputFunctions.py contains some additional lines of code to demonstrate the use of the function)\n\n\n# Read Text\n#\n# A simple function for getting validated strings from a user\n\n\ndef read_text(prompt=\"Please enter some text: \"):\n    while True:\n        try:\n            result = input(prompt)\n            break  # stop loop if no exception\n        except KeyboardInterrupt:\n            print(\"Please enter text\")\n    return result\n\n\n\nUse the read_text function to answer the following questions\n\nWhat is the result variable used to accomplish?\n\nLocal variable storing the user input to be returned\n\nWhat stops the function from repeating continuously?\n\nThe break statement ends the loop one a string has been entered\nOnce the loop finishes the rest of the function is linear and will end\n\nWhy does the text reading loop repeat after the exception has been handled?\n\nThe function reaches the end of the loop block (look at the indentation of the return)\nThe loop condition is while True so unless stopped by the break which requires the program to successfully read a string, the loop will run again\n\n\n\n\n\n\n\nPython has a convention for adding comments that describe a function\nThese can be automatically read and displayed by Python tooling\n\nEnables automatic documentation generation\n\nA string literal immediately after the function header but before any other code is interpreted as a functions docstring, e.g.\n\ndef read_line(prompt):\n    'Displays a prompt and reads in a string of text'\n\nThe above is single-line comment that provides a simple description of the function\nThe alternate below, is a multi-line comment which can provide more detail,\n\ndef read_text(prompt=\"Please enter some text: \"):\n    \"\"\"\n    Displays a prompt and reads in a string of text.\n    Keyboard Interrupts are ignored\n\n    prompt: str\n        prompt the user sees before entering text\n\n    return: str\n        returns a string containing the string input by the user\n    \"\"\"\n\nNote the use of triple quotes to write a string over multiple lines\nHere we describe the function, it’s parameters and the return in detail\n\nOur descriptions of parameters and returns explain both what they mean, and also the expected type\n\n\n\n\n\n\n\n\nTip\n\n\n\nUse a standard docstring convention\nThere are a number of standard formats used for docstrings. Two common ones being google and numpy\nThe advantage of using a common format is that it means that not only can we generate and display information about functions in code (see below for information about pydoc) but that there exists many tools for converting these standard formats into reference documentation that can be hosted or shared (e.g. on a website.)\nYou could of course define your own format, but then you might need to roll your own tooling if you ever wanted to publish your own reference documentation.\nIn these notes and the included code snippets we have generally stuck to using the numpy convention\n\n\n\n\n\nThe pydoc library is designed to read function docstrings\n\nFor example if we use it on the standard library function print\n\n\n  import pydoc\n\n  pydoc.help(print)\n\nHelp on built-in function print in module builtins:\n\nprint(*args, sep=' ', end='\\n', file=None, flush=False)\n    Prints the values to a stream, or to sys.stdout by default.\n\n    sep\n      string inserted between values, default a space.\n    end\n      string appended after the last value, default a newline.\n    file\n      a file-like object (stream); defaults to the current sys.stdout.\n    flush\n      whether to forcibly flush the stream.\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nForm a habit of documenting your code\nNowadays, programmers try to package the documentation with the code writing process. Sometimes this extends to the concept of documentation-as-code. Whenever you write a function, you should get into the habit of writing documentation.\n\n\n\n\n\n\n\nThe next function in our set of input functions is one to handle receiving a numbers\n\nMore specifically floating point numbers\n\nWe can break this down into steps\n\nFirst we get a valid string from the user\n\nWe can reuse read_text\n\nWe check that it’s a valid number\n\nWrap the extra functionality\n\n\n\n\ndef read_float(prompt):\n    \"\"\"\n    Displays a prompt and reads in a number\n\n    Keyboard interrupts are ignored\n    Invalid numbers are rejected\n\n    Parameters\n    ----------\n    prompt : str\n        Prompt the user sees before giving input\n\n    Returns\n    -------\n    float\n        The input value\n\n    See Also\n    --------\n    read_float_ranged : reads a float restricted to a closed interval\n    \"\"\"\n    while True:\n        try:\n            number_text = read_text(prompt)\n            result = float(number_text)\n            break\n        except ValueError:\n            print(\"Please enter a number\")\n    return result\n\n\nAn example usage is (mirrored in InputFunctions.py)\n\nage = read_float(\"Please enter your age: \")\nprint(age)\n\nWhich the user might see as,\n\n\nprint(\"Please enter your age: \\033[31m 32.7 \\033[0m\")\nprint(32.7)\n\n\nPlease enter your age:  32.7 \n\n32.7\n\n\n\n\n\nWe can then create a specialised version of read_float that uses it as a component to get a float restricted to a user specified range\n\n\ndef read_float_ranged(prompt, min_value, max_value):\n    \"\"\"\n    Displays a prompt and reads in a number between\n    min_value and max_value (inclusive)\n\n    Keyboard interrupts are ignored\n    Invalid numbers or out of range numbers are rejected\n\n    min_value: float minimum value (inclusive)\n    max_value: float maximum value (inclusive)\n\n    return: float\n    value input by user in the range [min_value, max_value]\n    \"\"\"\n    while True:\n        result = read_float(prompt)\n        if result &lt; min_value:\n            print(\"That number is too low\")\n            print(\"The minimum value is\", min_value)\n            continue\n        elif result &gt; max_value:\n            print(\"That value is too large\")\n            print(\"The maximum value is\", max_value)\n            continue\n        break  # if here have a valid number\n    return result\n\n\nLike with the read_float we use a previous function (here read_float) to capture existing error-handling and input handling code\n\nThen add in the extra functionality\nExample usage (again seen in the complete file InputFunctions.py)\n\n  age = read_float_ranged(\"Please enter your age\", min_value=5, max_value=90)\n  print(age)\nObserve how we have used each function as a reusable component in the next more specific function\n\nWe can do this because we cleanly define the responsibilities of each function\n\n\n\n\n\nLet’s examine the final function read_float_ranged in more detail to capture all the things we’ve built up. Answer the following questions\n\nWhy doesn’t this function have code to capture exceptions?\n\nNo, The two exception types we care about KeyboardInterrupt and ValueError are handled by read_text (via read_float) and read_float respectively\n\nWill chaining these functions together slow down the program?\n\nThere would probably be some slow down, since each time we have to call a function there is some setup and tear-down\nHowever, the slow down would be minuscule\nThe improved readability and compartmentalisation has advantages in readability and maintainability for the user\n\nThis practice of building higher-level functions out of smaller “lower level” functions is very common\n\n\nWhat would happen if a programmer reversed the minimum and maximum values?\n\nThe program would not work, it would require a number that is greater than what it thinks is the min (actually max) and less than what it thinks is the max (actually the min). These are incompatible conditions and the program would never be able to exit the function (or interrupt it)\nThere are three options\n\nFix the program so it swaps min and max if they are reversed\nDocuments that it’s not expected to work and leaves it to the user to ensure that the case doesn’t arise.\nRaises an exception for the caller to handle. (Our implementation in InputFunctions.py) uses the former technique\n if min_value &gt; max_value:\n     raise Exception(\"Min value is greater than max value\")\n\nIt is good etiquette to document exceptions raised in the function documentation\n\n\n\n\n\n\n\n\nIdeally we want to write our functions once and be able to reuse them\n\nThe most basic way would be to simply copy them into a new file each time we need them\n\nA more complete method is to write our own module\n\nWe create a file BTCInput.py\nSo long as we include this file in the same directory as our new project we can include the functions the same way we would use time or random via\n  import BTCInput\nWe then call the functions as for any other module e.g.\n  age = BTCInput.read_float_ranged(\"Enter your age: \", min_value=5, max_value=90)\n\nIf we want to avoid having to write the module name every time we call a function we can use the from keyword\n\nAllows us to import specific components into the global namespace\nAlternatively can import all components of a module using *\n\nTypically avoid this, it carries a high risk of name clashes between functions defined in different modules\n\n\n\n#option 1: import function\nfrom BTCInput import read_float_ranged\nage = read_float_ranged(\"Enter your age: \", min_value=5, max_value=90)\n\n#option 2: import all\nfrom BTCInput import *\nage = read_float_ranged(\"Enter your age: \", min_value=5, max_value=90)\n\n\nRewrite the following programs to use BTCInput for input\n\nGreeter\nUltra Precise Egg Timer\nPizza Order Calculator\nFahrenheit To Celsius\nRide Selector\nUser-Selected Times Table\n\n\n\n\n\n\n\nNote\n\n\n\nWe’ve linked to where each of these programs are first referenced, but we’ll generally try to update the most comprehensive version of the respective program. We use the version of BTCInput.py included in Chapter 8 of the original code (see samples in the repo) since it offers a more complete set of validation functions based on the discussion above.\nTo correctly setup BTCInput.py ensure the variable DEBUG_MODE = FALSE\n\n\n\nGreeter\n\nThis change is straight forward, we replace input with read_text\n\n # Exercise 7.2.1: Greeter\n # An implementation of Greeter than uses BTCInput for validation\n\n import BTCInput\n\n name = BTCInput.read_text(\"Enter your name please: \")\n print(\"Hello\", name)\nUltra Precise Egg Timer\n\nWe can combine the original code that reads in the egg boiling time and the float conversion to one call to the BTCInput function read_float. Note that we don’t change the second input which just asks the user to press enter, since really we’re looking for any input from the user\n\n # Exercise 7.2.2 Ultra-Precise Egg Timer\n #\n # Implementation of Ultra-Precise Egg Timer using BTCInput\n\n import time\n import BTCInput\n\n egg_time = BTCInput.read_float(\"Enter the cooking time in seconds: \")\n\n print(\"Put the egg in boiling water now\")\n input(\"Press enter to continue once the egg is in...\")\n\n time.sleep(egg_time)\n\n print(\"Take the egg out now\")\nPizza Order Calculator\n\nAgain we simply replace the int(input()) structure with the BTCInput equivalent, BTCInput.read_int\n\n # Exercise 7.2.3: Pizza Order Calculator\n #\n # Implementation of Pizza Order Calculator that uses BTCInput\n\n import BTCInput\n\n students_int = BTCInput.read_int(\"How many students are attending? \")\n\n pizza_count = int(students_int / 1.5) + 1  # perform division int -&gt; float\n print(\"You will need\", pizza_count, \"pizzas\")\nFahrenheit To Celsius\n\nAgain a simple replacement, here float(input(...)) becomes BTCInput.read_float()\n\n # Exercise 7.2.4: Fahrenheit to Celsius\n #\n # Version of Fahrenheit to Celsius that uses BTCInput\n\n import BTCInput\n\n temperature_fahrenheit = BTCInput.read_float(\"Enter a temperature in Fahrenheit: \")\n temperature_centigrade = (temperature_fahrenheit - 32) / 1.8\n print(\"The temperature is\", temperature_centigrade, \"degrees Celsius\")\nRide Selector\n\nThe implementation is based on the Full input validated version of Ride Selector in Chapter 6\nThere are two important changes, first to ensure the user selects a valid theme park ride option, we use BTCInput.read_int_ranged\n  ride_number = BTCInput.read_int_ranged(\n      \"Please enter the ride number you want: \", 0, 5\n  )\nRemember that \\(0\\) is a number we’ve chosen to represent quitting the program\nSecond the ensure the user adds an age, here even though we have a valid age range, this is for being able to ride\n\nWe still want to accept those ages, and then inform the user of the issue\nSo here we use BTCInput.read_int (note un-ranged)\n\n  age = BTCInput.read_int(\"Please enter your age: \")\n\nUser Selected Times Tables\n\nHere we can remove all the validation code we wrote and simply replace it with the BTCInput.read_int_ranged call\nThis highlights the advantage of functions, the final program is much cleaner and easier to read\n  # Exercise 7.2.6 Tables Tables\n  #\n  # Variant of the User Selected Times Tables Tutor that uses BTCInput for\n  # validation\n\n  import BTCInput\n\n  count = 1\n  times_value = BTCInput.read_int(\"Please enter a times table between 2-12 (inclusive): \")\n\n  while count &lt; 13:\n      result = count * times_value\n      print(count, \"times\", times_value, \"equals\", result)\n      count = count + 1\n\n\n\n\n\n\n\n\nMost python development environments support a debugger\nA debugger is a program designed to help you identify (and solve) bugs or problems in your program\nThis section will introduce concepts of a debugger\n\nThe book discusses the specifics of using the debugger packaged in IDLE\nThe notes here discuss generics\n\nA debugger runs code like normal, but supports extra tools and techniques for interrogating the internal state of a program\nA breakpoint causes the program being run in the debugger to pause when it reaches the line where the break occurs.\n\nbreakpoints allow the programmer to halt the program at a desired point (typically close to where a problem occurs) and inspect variable contents\n\n\n\n\n\n\n\n\nNote\n\n\n\nBreakpoints vs break\nA breakpoint is different to the break keyword\n\nbreak is used to immediately escape a loop structure in a running program\nA breakpoint is used to pause the execution of a program at a specific point when it is being debugged\n\n\n\n\n\nUse the following example, found in InvestigateTheDebugger.py as the basis to learn the debugger\n# Example 7.14 Investigate the Debugger\n#\n# A sample code for practising with the debugger\n\n\ndef increment_function(input_value):\n    result = input_value + 1\n    return result\n\n\nx = 99\ny = increment_function(x)\nprint(\"The answer is:\", y)\nUsing your debugger, set a breakpoint on the line x = 99\n\nIn VSCode for my setup with the python extensions I simply click on the line, left of the line number, a red circle appears indicating a breakpoint\n\nTo clear the breakpoint just click on it again\n\nThen run your program using the debugger\n\nIn VSCode I simply go to the Run and Debug tab, and click the Run and Debug button\n\nI then select from a dropdown menu, python debugger followed by debug the current file\n\nThe code starts running then stops at the breakpoint\nOn the left a panel shows the call stack\n\nThe call stack shows the sequence of function calls we are in\n\nAbove a panel shows the contents of variables\n\nBroken up into a tab for\n\nLocal variables\nGlobal variables\nThere are also tabs for special and function variables which can be ignored for now\n\n\nA control panel shows at the top of the program, the options are as follows,\n\nGo continues running the program\nStep Over goes to the next line in the program\n\nIf the line the program is on is a function, the program will calculate the results of the function and then go to the line after the program\n\nStep In goes to the next line in the program, if the program is on a function, the debugger will step into the function and go through it line by line\n\nThis includes opening any files where a function is defined in another file\n\nStep Out completes the current function and goes to the line after it\nRestart restarts the program\nStop immediately stops the program\n\n\nUse the step function to watch how python flows through this program, observe the call stack and the variable values when you step into increment_function\n\nObserve what happens when you step into print\n\nDepending on the debugger it may or may not step into the print function\nUse Step Out to leave print\nUse Step Out again, the program should end",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 7: Using Functions to Simplify Programs"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/07_UsingFunctions/Chapter_07.html#summary",
    "href": "01_ProgrammingFundamentals/07_UsingFunctions/Chapter_07.html#summary",
    "title": "Chapter 7: Using Functions to Simplify Programs",
    "section": "Summary",
    "text": "Summary\n\nFunctions allow us to reuse blocks of code\nFunctions consist of a header describing the function and the code\n\nHeader supplies function and parameter names (including their default values if specified)\n\nFunctions are called with arguments passed to the parameters\nParameters are value copied objects the function can work on\n\nThis means changes are local to the function\n\nFunctions can return a value via the return function\nNone is returned when a function finishes without an explicit return value\nVariables defined in a function are local to that function\n\nCannot be accessed outside the function\n\nVariables declared outside any function are called global variables\n\nCan be read by functions\nCan be modified by functions via the global keyword\n\nLocal variables can shadow global variables if they share the same name\nA function can contain a string as the first statement\n\nThis is called the docstring and documents the behaviour of the function\n\nFunctions can be imported into another python file that has access to the file they are defined in",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 7: Using Functions to Simplify Programs"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/07_UsingFunctions/Chapter_07.html#questions-and-answers",
    "href": "01_ProgrammingFundamentals/07_UsingFunctions/Chapter_07.html#questions-and-answers",
    "title": "Chapter 7: Using Functions to Simplify Programs",
    "section": "Questions and Answers",
    "text": "Questions and Answers\n\nDoes using functions in programs slow down the program?\n\nNot noticeably. The slight cost of setting up and tearing down functions is minimal\n\nCan I use functions to spread work around a group of programmers?\n\nYes, packaging functions into modules is a very common way for programmers to share code including functions\nAlternatively when building programs together, programmers may define the function headers together, and then each can work on implementing different functions separately\n\nHow do I come up with names for my functions?\n\nFunctions should typically be verbs that describe what action they do, e.g. read_string reads a string. Where reasonable also try to indicate what it returns\n\nCan functions in libraries use global variables?\n\nGlobal variables are those declared at file scope\nLibrary files can contain global variables\nThey can be used by the functions in those files\nBut they cannot be shared across files\n\nShould I put all my functions in modules/libraries?\n\nProbably not all of your functions\nGood for common utility functions that have quite broad use cases\nA common pattern in larger applications is to split functions into files that group together natural sets of logic",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 7: Using Functions to Simplify Programs"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/05_MakingDecisions/Chapter_05.html",
    "href": "01_ProgrammingFundamentals/05_MakingDecisions/Chapter_05.html",
    "title": "Chapter 5: Making Decisions",
    "section": "",
    "text": "Caution\n\n\n\nA number of the code examples in this use the file siren.wav, this can be found in the corresponding chapter in the samples submodule. For space reasons we haven’t uploaded it to the github\n\n\n\n\n\nBoolean values are a type that is used to distinguish between values that are True or False\nFor example, we could use an int to count the number of hairs on a person’s head, but a bool to indicate if they are bald\n\n\n\n\nSimply declare a variable with a value of True or False\n\nPython will infer the type\n\nFor example, to declare a true valued boolean,\n\nit_is_time_to_get_up = True\n\nwe can then set the value to false,\n\nit_is_time_to_get_up = False\n\nNote that True and False are python keywords, and are case-sensitive, e.g. true and false will not work as expected\n\n\n\n\nOpen up the python interpreter and work through the following questions to understand booleans\n\nWhat do you think would happen if you printed the contents of a boolean value?\n\nit_is_time_to_get_up = True\nprint(it_is_time_to_get_up)\n\nTrue\n\n\n\nPython will try to print out something meaningful, for a boolean this is either True or False\n\nWhat do you think would happen if you gave the word True to the input function?\nx = input(\"True or False: \")\nTrue or False: True\n\ninput returns it’s input as a string, so in this case x will not be a bool but rather a string with the value \"True\"\n\nIs there a python function called bool that will convert things into Boolean, just like there are int and float functions?\n\nYes there is, consistent behaviour with bool. Consider the following examples\n\n\nprint(bool(1))\nprint(bool(0))\nprint(bool(0.0))\nprint(bool(0.1))\nprint(bool(''))\nprint(bool('Hello'))\n\nTrue\nFalse\nFalse\nTrue\nFalse\nTrue\n\n\n\nWe can see that non-zero numbers evaluate True while zero, evaluates as False Similarly the empty string evaluates False while a non-empty string evaluates as True\n\nWhat happens if a program combines bool values with other values?\n\nWe should already expect that if we try to mix incompatible data that an error should be generated\n\n\n 'Hello' + True\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 'Hello' + True\n\nTypeError: can only concatenate str (not \"bool\") to str\n\n\n\n\nWe can see that we cannot concatenate a boolean value to a string\nThe behaviour can be a little less intuitive with numbers though,\n\n\n1 + True\n\n2\n\n\n\nTrue is implicitly converted to the integer value \\(1\\)\n\n\n1 + False\n\n1\n\n\n\nSimilarly, False is implicitly converted to the integer value \\(0\\)\nWe can see that numeric operations on bool thus have well-allowed behaviour\nString operations (i.e. textual data) are not compatible\n\n\n\n\n\n\nNormally we don’t declare a boolean with True or False explicitly but instead as the result of evaluating an expression\n\nSome expressions evaluate to True or False which naturally suits being stored in a boolean\n\nConsider a simple alarm clock,\n\nWe can get the time through the time library we’ve seen before\n  import time\n\n  current_time = time.localtime()\n\n  hour = current_time.tm_hour\ntime.localtime returns an object containing information about the current time.\n\nThis different blocks of information are called attributes, below is a list of the attributes contained in the object returned by localtime\n\n\n\n\n\n\n\n\n\n\nAttribute\nValue\n\n\n\n\ntm_year\nYear (for example, 2017)\n\n\ntm_mon\nMonth (in the range 1 … 12, 1 represents January)\n\n\ntm_mday\nDay in the Month (in the range 1 … month length)\n\n\ntm_hour\nHour in the Day (in the range 0 … 23)\n\n\ntm_min\nMinute in the Hour ( in the range 0 … 59)\n\n\ntm_sec\nSeconds in the Minute ( in the range 0 … 59)\n\n\ntm_wday\nDay of the Week (in the range 0 … 6 with Monday as 0)\n\n\ntm_yday\nDay in the Year (in the range 0 … 364 or 365 depending on if the year is a leap year)\n\n\n\n\nAn example of a localtime object might look like,\n\n\n\n\nAttribute\nValue\n\n\n\n\ntm_year\n2017\n\n\ntm_mon\n7\n\n\ntm_mday\n19\n\n\ntm_hour\n11\n\n\ntm_min\n40\n\n\ntm_sec\n30\n\n\ntm_wday\n2\n\n\ntm_yday\n200\n\n\n\n\n\nLets make a clock that displays only the hour value, using localtime. These one-handed clocks are supposed promote a more relaxed attitude. Create a new program (OneHandedClock.py) and copy the below text.\n\n    # Example 5.1: One Handed Clock\n    #\n    # Uses time to display the hour\n\n    import time\n\n    current_time = time.localtime()\n    hour = current_time.tm_hour\n\n    print(\"The hour is\", hour)\n\nThe hour is 11\n\n\nRun the program, it should print out the current hour\n\n\n\nImprove the previous example to produce a more fully featured clock that reports the time, and date when run\nWe can use the table above to grab the correct attributes. We then simply need to format the attribute as necessary. The final program is given below\n\n    # Exercise 5.1: Improved Clock\n    #\n    # An improved clock that displays the date and time when run\n\n    import time\n\n    current_datetime = time.localtime()\n\n    day = current_datetime.tm_mday\n    month = current_datetime.tm_mon\n    year = current_datetime.tm_year\n    print(\"The date is\", day, \"/\", month, \"/\", year)\n\n    seconds = current_datetime.tm_sec\n    minutes = current_datetime.tm_min\n    hours = current_datetime.tm_hour\n    print(\"The time is\", hours, \":\", minutes, \":\", seconds)\n\nThe date is 10 / 2 / 2026\nThe time is 11 : 22 : 37\n\n\n\n\n\n\n\nWe’ve seen expressions as being made of operators and operands\nOne type of operator is a comparison operator\n\nReturns a value that is True or False, e.g.\n\n\n\n\n\n\n\nblock-beta\n    columns 3\n    space\n    title[\"Breakdown of an Example Comparison Expression\"]\n    space\n\n    block:Input\n    columns 1\n        operand1[\"hour\"]\n        operand1Word[\"Operand\"]\n        operand1descr[\"(thing to work on)\"]\n    end\n\n    block:Middle\n    columns 1\n        operator[\"&gt;\"]\n        operatorWord[\"Operator\"]\n        operatorDescr[\"(thing to do)\"]\n    end\n\n    block:Output\n    columns 1\n        operand2[\"6\"]\n        operand2Word[\"Operand\"]\n        operand2descr[\"(thing to work on)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass operand2Word BG\nclass operand2descr BG\nclass operand1Word BG\nclass operand1descr BG\nclass operatorWord BG\nclass operatorDescr BG\n\n\n\n\n\n\n\n\n\nBelow is a table of the common comparison operators\n\n\n\n\n\n\n\n\n\nOperator\nName\nEffect\n\n\n\n\n\\(&gt;\\)\nGreater than\nTrue if the left argument is greater than the right, else False\n\n\n\\(&lt;\\)\nLess than\nTrue if the left argument less than the right, else False\n\n\n\\(&gt;=\\)\nGreater than or Equal\nAs for Greater than but also True if the left argument equals the right\n\n\n\\(&lt;=\\)\nLess than or Equal\nAs for Less than but also True if the left argument equals the right\n\n\n\\(==\\)\nEquals\nTrue if the left argument equals the right argument, else False\n\n\n\\(!=\\)\nNot Equals\nTrue if the left argument does not equal the right argument, else False\n\n\n\n\nA program can use a comparison operator to set a boolean variable, e.g. the below code fragment which sets the boolean variable it_is_time_to_get_up to True if the variable hour is greater than \\(6\\) else sets it to False\n\n    it_is_time_to_get_up = hour &gt; 6\n\n\nUse the python interpreter to work through the following questions in order to understand Comparison Operators\n\nHow does the equality operator work?\n\nThe equality operator evaluates to True if the two operands hold the same value\n\n\n1 == 1\n\nTrue\n\n\n\nThe equality operator can be used to compare strings and bools\n\n\n 'Rob' == 'Rob'\n\nTrue\n\n\n\n True == True\n\nTrue\n\n\nHow do I remember which relational operator to use?\n\nPractice, patience and muscle memory\n\nCan we apply relational operators between other types of expressions?\n\nYes. For example, the \\(&gt;\\) and \\(&lt;\\) operators when used to compare strings will use an alphabetic ordering, e.g.\n\n'Alice' &lt; 'Brian'\n\nTrue\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nEquality and Floating-point Values\nIn Chapter 4 we noted that floating points only approximate a specific real-value. These approximations can cause issues when using comparison operators, e.g.\n\nx = 0.3\ny = 0.1 + 0.2\nx == y\n\nFalse\n\n\n\nThe variables x and y should both notionally store \\(0.3\\), but the equality shows they are unequal. This is because the addition of \\(0.1\\) and \\(0.2\\) actually leads to y storing the slightly inaccurate \\(0.3000...4\\)\nIf comparing floating-point numbers for equality, the best approach is to check that the values are appropriately close\n\n\n\n\nPython provides the type function, type(x) returns the type of the variable x, especially useful for investigating the type of values returned by library functions you’ve never seen before\n\n\n\n\n\n\n\nWhat if we want to combine boolean expressions to create a new boolean expression\ne.g. An alarm might want to go off when the hour is after \\(7\\) and the minute is after \\(30\\)\nPython provides logic operators for combining boolean expressions\n\n\n\nUse the python interpreter to answer the following questions and investigate boolean operators\n\nWhat does the following expression evaluate too?\n\nnot True\n\nFalse\n\n\n\nnot inverts the value of a boolean, so True is converted to False\n\nHow about this expression?\n\nTrue and True\n\nTrue\n\n\n\nand is True iff both arguments are True as is the case above, so the result is True\n\nHow about this expression?\n\nTrue and False\n\nFalse\n\n\n\nSince one of the arguments is False and will evaluate to False\n\nHow about this expression?\n\nTrue or False\n\nTrue\n\n\n\nSince one of the arguments is True or will evaluate to True\n\nSo far, the examples have only used boolean values. What happens if we mix boolean and numeric values?\n\n True and 1\n\n1\n\n\n\nRecall that python can convert numeric expressions to boolean ones, this implicitly happens to the \\(1\\) in the above. So we would expect and to return True. However ,instead \\(1\\) is returned. This is due to some odd python behaviour\n\nPython sees True \\(\\rightarrow\\) result of and implied by second argument\n\nSo simply returns the second argument, since the truthfulness of \\(1\\), is equivalent to the original expression\n\nIf we flip the arguments, we should see this more clearly\n\n  1 and True\n\nTrue\n\n\n\nThis time the above expressions should return True\n\nThe same behaviour will also occur with or\n\n  1 or False\n\n1\n\n\n\nHere the or operator short-circuits on \\(1\\), so returns \\(1\\)\n\n\n  0 or True\n\nTrue\n\n\n\nHere the or evaluates the first argument as false, so cannot short-circuit, the second argument is returned, i.e True\n\n\n\n\n\nLet us now use and to try construct an expression that will correctly evaluate when the time is after \\(7:30\\), naively we might expect,\n\n    it_is_time_to_get_up = hour &gt; 6 and minute &gt; 29\n\nWe can use a truth table to check,\n\n\n\n\nHour\nMinute\nDesired\nOutput\n\n\n\n\n6\n0\nFalse\nFalse\n\n\n7\n29\nFalse\nFalse\n\n\n7\n30\nTrue\nTrue\n\n\n8\n0\nTrue\nFalse\n\n\n\n\nWe can see in the last case the result is not what we want!\n\nhour &gt; 7 is true, but minute &gt; 29 is false, so we need to be more precise,\n\n\n    it_is_time_to_get_up = (hour &gt; 7) or (hour == 7 and minute &gt; 29)\n\nWe use brackets to make the expression more readable\nHere we use short-circuiting, if the the hour is greater than \\(7\\) we don’t need to check the minutes value\n\n\n\n\n\n\n\nWarning\n\n\n\nBe Careful with Logic Operations\nWhen working with boolean operations you should always check that the logic matches what you expect!\n\n\n\n\n\n\n\n\nSuppose we want a program to tell me if it’s time to get out of bed\nNeed the ability to run code if a boolean condition is met\n\nCan do so using the aptly named if operator\n\n\n\n\n\nCreate a new python program (SimpleAlarmClock.py) with the following contents\n\n\n# Example 5.2: Simple Alarm Clock\n#\n# Demonstrates `if` using a simple alarm clock\n\nimport time\n\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminute = current_time.tm_sec\n\nit_is_time_to_get_up = (hour &gt; 7) or (hour == 7 and minute &gt; 29)\n\nif it_is_time_to_get_up:\n    print(\"IT IS TIME TO GET UP\")\n\nIT IS TIME TO GET UP\n\n\n\nThe program should print IT IS TIME TO GET UP only if the time is after \\(7:30\\)\nThe if construct starts with the word if, following by a boolean value called the condition, then a :\nAny statements we want to execute if the if is True are then written below the if and indented one level\n\n\n\n\n\nCondition is a term for the expression that controls which branch of the if is executed\nIf the condition evaluates True the indented branch is run\nIf the condition evaluates False the indented branch is skipped\nWe could simply the above code by including the check directly in the if rather than an intermediate variable\n\n\nif (hour &gt; 7) or (hour == 7 and minutes &gt; 29):\n    print(\"IT IS TIME TO GET UP\")\n\nIT IS TIME TO GET UP\n\n\n\n\n\n\nWhat if we want multiple statements to run after an if statement\nWe just write them as a sequence of indented statements\n\n\n\nLet us improve the previous example to also play a sound if it’s time to get up. Create a program (SirenAlarmClock.py) with the contents below\n# Example 5.3: Siren Alarm Clock\n#\n# Improves the Simple Alarm Clock to also play a sound\n\nimport time\n\nimport snaps\n\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminute = current_time.tm_min\n\nif (hour &gt; 7) or (hour == 7 and minute &gt; 29):\n    snaps.display_message(\"TIME TO GET UP\")\n    snaps.play_sound(\"siren.wav\")\n    # pause the program to give time for the sound to play\n    time.sleep(10)\nThis program now runs three statements in the if\n\nFirst a message is displayed\nSecond a sound is played\nThird the program sleeps so the sound has time to play\n\n\nIf we want something to run regardless of the if condition, we write it either before or after the if statement\n\n\n\n\nAdd to the simple Alarm Clock, by making it so the program will always print the current time regardless of if the alarm goes off. Create a new program (AlarmClockWithTimeDisplay.py). Enter the following contents,\n\n# Example 5.4: Alarm Clock with Time Display\n#\n# A variant of Alarm Clock to also always display the time\n\nimport time\n\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminute = current_time.tm_min\n\nif (hour &gt; 7) or (hour == 7 and minute &gt; 29):\n    print(\"TIME TO GET UP\")\n    print(\"RISE AND SHINE\")\n    print(\"THE EARLY BIRD GETS THE WORM\")\nprint(\"The time is\", hour, \":\", minute)\n\nTIME TO GET UP\nRISE AND SHINE\nTHE EARLY BIRD GETS THE WORM\nThe time is 11 : 22\n\n\n\nThe program above will always print the current time, regardless of if the alarm block is run\n\n\n\n\n\n\n\nCaution\n\n\n\nIndented Text can cause Big Problems\nAs seen above, python uses indentation for control flow, this has the advantage in that it follows normal code style practices, but has some pitfalls\n\nIf the indention is wrong the program won’t run\n\ni.e. if one line is indented four spaces, and the next three an error will be thrown\n\nimport time\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminutes = current_time.tm_min\n\nif (hour &gt; 7) or (hour == 7 and minute &gt; 29):\n  print(\"IT IS TIME TO GET UP\")\n      print(\"The early bird gets the worm...\")\n\n\n  Cell In[24], line 8\n    print(\"The early bird gets the worm...\")\n    ^\nIndentationError: unexpected indent\n\n\n\n\n\nA more insidious error, occurs if one mixes tabs and spaces in the indentation, since the code may appear to be fine until it attempts to run\n\n import time\n current_time = time.localtime()\n hour = current_time.tm_hour\n minutes = current_time.tm_min\n\n if (hour &gt; 7) or (hour == 7 and minute &gt; 29):\n     print(\"IT IS TIME TO GET UP\")\n     print(\"The early bird gets the worm...\")\n\nIT IS TIME TO GET UP\nThe early bird gets the worm...\n\n\n\nMost programmers and even text editors will automatically convert one style of indentation to the other (commonly tabs to spaces, but sometimes spaces to tabs) to avoid this issue\n\nIn the above code, my editor converted the second line which was indented with spaces to a tab to match the previous line\n\n\n\n\n\n\n\n\n\n\nFormally, an if has a structure like\n\n\n\n\n\n\nblock-beta\n    columns 4\n    space\n    title[\"Breakdown of an if statement\"]:2\n    space\n\n    block:Input\n    columns 1\n        if[\"if\"]\n        ifDescr[\"(start of the if construction)\"]\n    end\n\n    block:Condition\n    columns 1\n        condition[\"condition\"]\n        conditionDescr[\"(value that is true or false)\"]\n    end\n\n    block:Colon\n    columns 1\n        colon[\":\"]\n        colonDescr[\"colon\"]\n    end\n\n    block:Suite\n    columns 1\n        suite[\"suite\"]\n        suiteDescr[\"statements\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass condition BG\nclass conditionDescr BG\nclass colon BG\nclass colonDescr BG\nclass suite BG\nclass suiteDescr BG\nclass if BG\nclass ifDescr BG\n\n\n\n\n\n\n\nThere are two ways to write the suite\n\nA set of indented statements on the lines proceeding the if\nA set of statements on the same line as the if each seperated by a semicolon (;) e.g.\n if (hour &gt; 6): print('IT IS TIME TO GET UP'); print('THE EARLY BIRD GETS THE WORM')\n\n\n\n\n\n\n\n\nWarning\n\n\n\nYou can’t combine inline if statements, with indented if statements, e.g.\n\n    import time\n    current_time = time.localtime()\n    hour = current_time.tm_hour\n    minutes = current_time.tm_min\n\n    if (hour &gt; 7) or (hour == 7 and minute &gt; 29): print(\"IT IS TIME TO GET UP\"); print(\"RISE AND SHINE\")\n        print(\"The early bird gets the worm...\")\n\n\n  Cell In[26], line 7\n    print(\"The early bird gets the worm...\")\n    ^\nIndentationError: unexpected indent\n\n\n\n\n\n\n\n\nUse the python interpreter to answer the following questions to understand conditional statements\n\nCan we work with conditional statements using the python shell?\n\nYes you can, type the following into the shell,\n\nif True:\n\nThe shell may display ... instead of &gt;&gt;&gt; or, omit &gt;&gt;&gt; and indent\n\nIn the first case we can indent ourselves to write the suite\nIn the second we simply write the suite\n\nOnce done writing the if statement, simply deindent\nTry write the following in the shell, and verify the output\n\n  if True:\n      print('True')\n      print('Still True')\n\nTrue\nStill True\n\n\n\nHow many spaces must you indent a suite of Python statements controlled by an if statement?\n\nThere is no approved value, but it must be consistent\ni.e. if the first indentation is four, then all future indentations must also be four\n\nCommon choices are 4, 8 or 2\n\n\n\n\n\n\n\n\nSometimes we want conditional behaviour on both the True and False branches\nelse is a keyword that lets us add behaviour that executes when an if evaluates as False\n\n\n\nModify the Simple Alarm Clock to now print a message telling us to go back to bed if it before our alarm should go off. Write a new program (SimpleAlarmClockWithElse.py) with the following contents,\n\n# Example 5.5: Simple Alarm Clock\n#\n# Variant of the Simple Alarm Clock\n# that modifies the output depending on if its time to get up\n\nimport time\n\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminute = current_time.tm_min\n\nif (hour &gt; 7) or (hour == 7 and minute &gt; 29):\n    print(\"IT IS TIME TO GET UP\")\nelse:\n    print(\"Go back to bed\")\n\nIT IS TIME TO GET UP\n\n\n\nObserve that only one line of the paired if-else statements is printed\n\n\n\n\nWork through the following questions to understand if constructions\n\nMust an if construction have an else part?\n\nNo, we saw when first working with if that we could exclude the else in that case no additional code runs if the if evaluates False\n\nWhat happens if a condition is never True?\n\nIt simply never executes\n\n\n\n\n\n\n\nThe if statement can be used to compare strings, as seen with the comparison operators\n\n\n\nThe following program uses the equality operator and an if statement to greet a person if their name matches. What is a potential issue with this program?\n# Example 5.6: Broken Greeter\n#\n# A Greeter program using string matching\n# Identify the issues with this program\n\nname = input(\"Enter your name: \")\n\nif name == \"Rob\":\n    print(\"Hello, Oh great one\")\n\nThe equality operator checks against the string \"Rob\" exactly\ni.e. it is case sensitive, if we write \"ROB\", or \"rob\" or some variation thereof, the statement will not match.\n\nWe can fix this by using the string method upper, this converts all forms of the word \"rob\" to \"ROB\" which we can reliably check against. The new program looks like\n# Example 5.7: Uppercase Greeter\n#\n# A Greeter program using string matching\n# Fixes the issues with Example 5.6 by using\n# str.upper()\n\nname = input(\"Enter your name: \")\n\nif name.upper() == \"ROB\":\n    print(\"Hello, Oh great one\")\n\nWe could also use the string method lower to compare against an all lowercase word\n\n\n\n\nConsider the following questions to learn about methods and functions\n\nHow do lower() and upper() work?\n\nPython types are objects that provide methods.\nMethods are called like functions\n\nWhy do we have to write lower() and not lower?\n\nLeave the parentheses off, and see what happens\n\n  name = 'Rob'\n  name.upper\n\n&lt;function str.upper()&gt;\n\n\nWe are instead returned a description of the method itself\n\nWhat’s the difference between functions and methods?\n\nThey are used the same way, but they differ in where they are created\nFunctions are not associated any specific object\nMethods are bound as attributes of objects\n\n\n\n\n\n\n\nYou can nest conditions, e.g. if you want to perform sequential checks\n\n\n\nLet us demonstrate nested if through a greeter which requires a follow on code word to confirm the identity of the user. Create a program (CodedGreeter.py) with the following contents\n# Example 5.8: Coded Greeter\n#\n# Asks the user for a follow on code to confirm their ID\n# before the program greets them\n\nname = input(\"Enter your name: \")\n\nif name.upper() == \"ROB\":\n    code = input(\"Enter the codeword: \")\n    if code == \"secret\":\n        print(\"Hello, Oh great one\")\n    else:\n        print(\"Begone. Imposter\")\n\nPlay around with the above code to see what happens for various input combinations.\nYou should see if the first input is not a variant of \"rob\" the second prompt never occurs and the program ends.\nAdjust the above by writing a new program (CodedGreeterWithOuterElse.py)*\n\n# Example 5.9: Coded Greeter with Outer Else\n#\n# Asks the user for a follow on code to confirm their ID\n# before the program greets them\n# Has an additional outer else clause for the case that the nested\n# if does not run\n\nname = input(\"Enter your name: \")\n\nif name.upper() == \"ROB\":\n    code = input(\"Enter the codeword: \")\n    if code == \"secret\":\n        print(\"Hello, Oh great one\")\n    else:\n        print(\"Begone. Imposter\")\nelse:\n    print(\"You are not Rob. Shame.\")\n\nThe above code uses a second else clause, attached to the first outer, if condition\nThis means that it will run whenever the original name is not some variant of \"ROB\"\n\n\n\n\n\n\n\nImprove the Alarm Clock. Make the alarm display the date as well as the time, and let the user sleep in on the weekends.\nOur implementation is given below,\n# Exercise 4.2: Advanced Alarm Clock\n#\n# An Advanced Alarm Combining the Behaviour\n# of most increments of the alarm clock\n# and allowing you to sleep in on weekends\n\nimport time\n\nimport snaps\n\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminute = current_time.tm_min\nday = current_time.tm_mday\nmonth = current_time.tm_mon\nis_weekend = current_time.tm_wday &gt;= 5\n\ndate_message = \"The date is \" + str(day) + \"/\" + str(month)\ntime_message = \"The time is \" + str(hour) + \":\" + str(minute)\n\nmsg = \"\"\nup_hour = 7 + is_weekend  # get to sleep in an extra hour on weekends\n\nif (hour &gt; up_hour) or (hour == up_hour and minute &gt; 29):\n    msg = msg + \"TIME TO GET UP\"\n    snaps.play_sound(\"siren.wav\")\nelse:\n    msg = msg + \"Go back to bed!\"\nmsg = msg + \"\\n\" + date_message + \"\\n\" + time_message\nsnaps.display_message(msg, size=50)\ntime.sleep(10)  # leave time for the sound and to read\nMost of the text simply exists to correctly create the final message we will display on the screen. The most important parts are, is_weekend = current_time.tm_wday &gt;= 5 which uses the fact that Saturday and Sunday have the value \\(5\\) and \\(6\\) in the current_time.tm_wday attribute (A number representing the day in the week) to set a boolean flag. We then use the fact that True acts numerically as one, and False acts numerically as zero to let us sleep in an hour on the weekend using up_hour = 7 + is_weekend which is \\(8\\) on weekends and \\(7\\) on weekdays.\nWe then run through the code as we have for most of the alarm clock cases, using an else clause to ensure we always have a message for the user, and appending the date and time message to this output.\nLastly we pass the method to snaps for display\n\n\n\n\n\n\nIn this next section we’ll write our first semi-sophisticated program\n\n\nScenario:\nA local theme park wants you to write a program that will let users check if they meet the age requirements to go on a ride. They provide the following table covering the current rides\n\n\n\n\n\n\n\nRide\nRestrictions\n\n\n\n\nScenic River Cruise\nNone\n\n\nCarnival Carousel\nAt least 3 years old\n\n\nJungle Adventure Water Splash\nAt least 6 years old\n\n\nDownhill Mountain Run\nAt least 12 years old\n\n\nThe Regurgitator\nAt least 12 years old and less than 70\n\n\n\n\n\n\n\nWe will use a simple text interface\n\nWelcome to our Theme Park\n\nThese are the available rides\n\n1. Scenic River Cruise\n2. Carnival Carousel\n3. Jungle Adventure Water Splash\n4. Downhill Mountain Run\n5. The Regurgitator\n\nPlease enter the ride you want: 1\nYou have selected the Scenic River Cruise\nThere are no age limits for this ride\n\n\n\n\n\n\nImportant\n\n\n\nDesign the User Interface with the Customer\nThe UI can be the most important and most difficult part of design because it can be very subjective. Ultimately the Customer is the one paying and so they should be involved in the UI design throughout!\n\n\n\n\n\n\nWe have a UI design, now we need to implement it\nOur code starts as below,\n\n# Example 5.10: Ride Selector Start\n#\n# The basic shell of the Ride Selector UI\n\nprint(\"\"\"Welcome to our Theme Park\n      These are the available ride:\n\n      1. Scenic River Cruise\n      2. Carnival Carousel\n      3. Jungle Adventure Water Splash\n      4. Downhill Mountain Run\n      5. The Regurgitator\n      \"\"\")\n\nride_number_text = input(\"Please enter the ride number you want: \")\nride_number = int(ride_number_text)\n\nif ride_number == 1:\n    print(\"You have selected Scenic River Cruise\")\n    print(\"There are no age limits for this ride\")\n\nWe first print out our Menu, using a triple-delimited string so we can multiline it\nThen we implement the menu using a series of if statements.\n\nFor the first case (Scenci River Cruise) we don’t need the user’s age so we can output the result immediately\n\nFor other rides the user needs to supply their age, so we continue,\n\nelse:  # need to get the age of the user\n    age_text = input(\"Please enter your age: \")\n    age = int(age_text)\n\nWe have to get the age using another input pair\nThis should already be familiar to you\n\n\n\n\nOnce we have the age, we need to compare against the restrictions for the selected ride\nWe can do this with a nested series of if statements which\n\nFirst selects the appropriate ride\nChecks the age against the ride’s age requirements\n\n\n    if ride_number == 2:\n        print(\"You have selected the Carnival Carousel\")\n        if age &gt;= 3:\n            print(\"You can go on the ride\")\n        else:\n            print(\"Sorry, you are too young\")\n    if ride_number == 3:\n        print(\"You have selected Jungle Adventure Water Splash\")\n        if age &gt;= 6:\n            print(\"You can go on the ride\")\n        else:\n            print(\"Sorry, you are too young\")\n\nDownhill Mountain Splash (ride number 4) can be implemented exactly as above\n\n\n\n\n\n\n\nTip\n\n\n\nReduce duplicated Code\nYou may have noticed that the above statement appears to have a bunch of duplicated code. The rough structure is,\nselect ride\nif age of user is greater than or equal to the rides min age\n    Inform the user they can go on the ride\nelse:\n    Inform the user they cannot go on the ride\nProgrammers typically don’t like to repeat themselves as it increases the number of ways a program can go wrong. So ideally we would like a way were we could write something like the above once and have the appropriate checks be carried out, and the message printed without having to write it out for every case. We’ll look at some ways to do this later in the book.\n\n\n\n\n\n\nThe last ride introduces an additional check, we have a minimum and a maximum age.\n\nNeed to introduce another layer nested conditional to differentiate between the too old and too young case\n\n\n    if ride_number == 5:\n        print(\"You have selected The Regurgitator\")\n        if age &gt;= 12:\n            # first check age not too low\n            if age &gt; 70:\n                # Age is too old\n                print(\"Sorry, you are too old\")\n            else:\n                # In the valid range\n                print(\"You can go on the ride\")\n        else:\n            # Age is too young\n            print(\"Sorry, you are too young\")\n\nYou can see the final Program (Ride Selector)\n\n\n\n\n\n\nWe can add some extra quality to our implementation using snaps\nsnaps get_string method\n\n# Example 5.11: Snaps get_string function\n#\n# Demonstrates using the get_string function\n# in snaps to get user input via a graphical\n# interface\n\nimport time\n\nimport snaps\n\nname = snaps.get_string(\"Enter your name: \")\nsnaps.display_message(\"Hello \" + name)\n\ntime.sleep(5)\n\n\n\n\n\n\nImportant\n\n\n\nAs written, the snaps get_string method on my machine, did not work when running Pygame 2. I had to modify the method to the following,\ndef get_string(prompt, size=50, margin=20,\n               color=(255, 0, 0), horiz='left', vert='center',\n               max_line_length=20):\n    '''\n    Reads a string from the user\n    '''\n\n    setup()\n\n    result = ''\n    cursor_char = '*'\n    cursor = None\n\n    def redraw():\n        clear_display()\n\n        render_message(prompt+result, margin=margin, size=size,\n                       horiz=horiz, vert=vert, color=color, cursor=cursor)\n\n    def cursor_flip():\n        nonlocal cursor\n\n    # create a timer for the cursor\n\n    cursor_event = pygame.USEREVENT+1\n\n    pygame.time.set_timer(cursor_event,500)\n    pygame.key.start_text_input()\n\n    while True:\n        event = pygame.event.wait()\n\n        if event.type == cursor_event:\n            if cursor:\n                cursor = None\n            else:\n                cursor = cursor_char\n            redraw()\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_RETURN:\n                break\n            elif event.key == pygame.K_BACKSPACE:\n                if len(result) &gt; 0:\n                    result = result[:-1]\n                    redraw()\n        elif event.type == pygame.TEXTINPUT:\n            if len(result) &lt; max_line_length:\n                result += event.text\n                redraw()\n\n    # disable the timer for the cursor\n    pygame.time.set_timer(cursor_event,0)\n    return result\nI won’t go into detail on explaining the changes since it’s above the level we’ve currently been discussing but if you have issues with the running any of the snaps get_string programs in this book, I would recommend trying the above replacement to the function\n\n\n\nUsing the above and some optional arguments to play around with text placement we can create the start of a GUI implementation of the Ride Selector Program\n\n\n\nThe below program is the outline for an implementation of the Ride Selector Program using snaps to provide a GUI\n# Example 5.12: Theme Park Snaps Display\n#\n# Reimplments the shell of the Ride Selector Menu using Snaps\n\nimport time\nimport snaps\n\n\nsnaps.display_image(\"themepark.png\")\n\nprompt = \"\"\"Welcome to our Theme Park\n      These are the available ride:\n\n      1. Scenic River Cruise\n      2. Carnival Carousel\n      3. Jungle Adventure Water Splash\n      4. Downhill Mountain Run\n      5. The Regurgitator\n\n      Select your ride: \"\"\"\n\nride_number_text = snaps.get_string(prompt, vert=\"bottom\", max_line_length=3)\nconfirm = \"Ride \" + ride_number_text\n\nsnaps.display_message(confirm)\ntime.sleep(5) #gives user time to read the output\n\n\n\nUsing the previous example, complete the ride selector program. Extending its features where reasonable\nWe’ll reimplement all the features of the original text-based interface, but add in the siren sound effect if the user is unable to ride the ride. Otherwise this proceeds as with most of our conversions to snaps. We replace print with snaps.display_message and introduce some work to build the string that we want to send to snaps.display_message. In this case we create a string that is nicely formatted to output\n\nThe ride number the user selected\nThe name of the ride\nA message letting them know if they are allowed to ride\n\nOur final implementation can be found in the file ThemeParkSnapsDisplay.py, or read from down below, observe the usual use of the time.sleep function to prevent the window from immediately closing\n# Exercise 5.3: Snaps Ride Selector\n#\n# Reimplments the entirety of the Theme Park Ride Selector using\n# a snaps interface, and adds some audio ques to warn the user\n# when they are ineligable for ride\n\nimport time\nimport snaps\n\n\nsnaps.display_image(\"themepark.png\")\n\nprompt = \"\"\"Welcome to our Theme Park\n      These are the available ride:\n\n      1. Scenic River Cruise\n      2. Carnival Carousel\n      3. Jungle Adventure Water Splash\n      4. Downhill Mountain Run\n      5. The Regurgitator\n\n      Select your ride: \"\"\"\n\nride_number_text = snaps.get_string(prompt, vert=\"bottom\", max_line_length=3)\nconfirm = \"Ride \" + ride_number_text\n\nsnaps.display_message(confirm)\ntime.sleep(2)  # gives user time to read the output\n\nride_number = int(ride_number_text)\n\nif ride_number == 1:\n    msg = confirm + \"\\nScenic River Cruise\\n\\nThere are no age limits for this ride\"\n    snaps.display_message(msg, size=100)\nelse:  # need to get the age of the user\n    age_text = snaps.get_string(\n        \"Please enter your age: \", vert=\"bottom\", max_line_length=3\n    )\n    age = int(age_text)\n\n    if ride_number == 2:\n        msg = confirm + \"\\nCarnival Cruise\"\n        if age &gt;= 3:\n            msg = msg + \"\\n\\nYou can go on the ride\"\n            snaps.display_message(msg, size=100)\n        else:\n            snaps.play_sound(\"siren.wav\")\n            msg = msg + \"\\n\\nSorry, you are too young\"\n            snaps.display_message(msg, size=100)\n    if ride_number == 3:\n        msg = confirm + \"\\nJungle Adventure Water Splash\"\n        if age &gt;= 6:\n            msg = msg + \"\\n\\nYou can go on the ride\"\n            snaps.display_message(msg, size=100)\n        else:\n            msg = msg + \"\\n\\nSorry, you are too young\"\n            snaps.play_sound(\"siren.wav\")\n            snaps.display_message(msg, size=100)\n    if ride_number == 4:\n        msg = confirm + \"\\nDownhill Mountain Run\"\n        if age &gt;= 12:\n            msg = msg + \"\\n\\nYou can go on the ride\"\n            snaps.display_message(msg, size=100)\n        else:\n            msg = msg + \"\\n\\nSorry, you are too young\"\n            snaps.play_sound(\"siren.wav\")\n            snaps.display_message(msg, size=100)\n    if ride_number == 5:\n        msg = confirm + \"\\nThe Regurgitator\"\n        if age &gt;= 12:\n            # first check age not too lowe\n            if age &gt; 70:\n                # Age is too old\n                msg = msg + \"\\n\\nSorry, you are too old\"\n                snaps.play_sound(\"siren.wav\")\n                snaps.display_message(msg, size=100)\n            else:\n                msg = msg + \"\\n\\nYou can go on the ride\"\n                snaps.display_message(msg, size=100)\n        else:\n            msg = msg + \"\\n\\nSorry, you are too young\"\n            snaps.display_message(msg, size=100)\ntime.sleep(5)\n\n\n\nUsing snaps and the weather functions it includes, write a simple program to remind the user to wrap up warm, wear sunscreen etc.\nWe’ll use the basic outline of the solution in the book,\n#EG5-14 Weather Helper\n\nimport snaps\n\ntemp = snaps.get_weather_temp(latitude=47.61, longitude=-122.33)\nprint(\"The temperature is:\", temp)\n\nif temp &lt; 40:\n    print(\"Wear a coat - it is cold out there\")\nelif temp &gt; 70:\n    print(\"Remember to wear sunscreen\")\nThe first step is to convert the print statements to instead use the snaps, display_message function. This requires us to do the usual work of building the string before we display it. Next we also want to display an image, either a sun or a snowflake depending on if the weather is hot or cold. Since we’re grabbing some new images, we run into an issue that snaps doesn’t work to rescale the images out of the box. We can fix this by adding the line image = image.convert_alpha() before the image = pygame.transform.smoothscale(image, window_size) line in display_image in snaps. Our final program (Weather Helper) looks like,\n# Exercise 5.4 Weather Helper\n#\n# Simple Weather Program that reminds the user about\n# the weather conditions, with helpful text and\n# pictures\n\nimport time\nimport snaps\n\ntemp = snaps.get_weather_temp(latitude=47.61, longitude=-122.33)\nconditions = snaps.get_weather_desciption(latitude=47.61, longitude=-122.33)\n\nif temp is None or conditions is None:\n    msg = \"Could not retrieve Weather...\"\nelse:\n    msg = \"The temperature is: \" + str(temp)\n    if temp &lt; 40:\n        msg = msg + \"\\n\\nWear a coat - it is cold out there\"\n        snaps.display_image(\"snowflake.png\")\n    elif temp &gt; 70:\n        msg = msg + \"\\n\\nRemember to wear sunscreen\"\n        snaps.display_image(\"sun.png\")\n    msg = msg + \"\\n\\nThe weather is \" + conditions\n\nsnaps.display_message(msg, size=100, color=\"red\")\ntime.sleep(5)\nIgnore the line if temp is None or conditions is None, this is some error handling code we’ll look at in a latter chapter. Notice that since no matter which path we go through the if, elif chain we’ll post a message at the end. So we use the branch code in order to set up the appropriate message, while the call to display_message sits outside the loop, so we don’t have to call it on every path.\n\n\n\nUsing randint and if statements write a fortune teller program that gives random fortunes to the user\nWe’ll expand on the prototype given by providing two additional statements, one relating to the future and the other relating to the wealth. We’ll follow the structure of using random.randint(1, 6) to simulate rolling a six-sided die, but spice it up by using if-elif-else clauses to play with the relative weighting of different statements.\n\n# Exercise 5.5 Fortune Teller Program\n#\n# A simple program that uses random numbers to generate a sequence of\n# fortunes for the user\n\nimport random\n\n# Meeting someone\nif random.randint(1, 6) &lt; 4:\n    print(\"You will meet a tall, dark stranger\")\nelse:\n    print(\"Nobody unexpected will enter your life\")\n\n# Money\nresult = random.randint(1, 6)\nif result == 1:\n    print(\"I see untold riches in your future\")\nelif result &lt;= 3:\n    print(\"A life of comfort is coming\")\nelif result &lt; 6:\n    print(\"You would do well to husband your wealth\")\nelse:\n    print(\"I see a future lived on the streets...\")\n\n# Advice\nresult = random.randint(1, 6)\nif result &lt;= 2:\n    print(\"Sometimes the answers to our future, come from the past\")\nelif result &lt; 6:\n    print(\"To define your future, avoid getting hung up on the past\")\nelse:\n    print(\"You will soon face a decision that will redefine everything\")\n\nNobody unexpected will enter your life\nYou would do well to husband your wealth\nSometimes the answers to our future, come from the past\n\n\nWe use a mix of ==, &lt;= and &lt; operators to emphasise the clarity of the branching. This implementation is quite simple (because the exercise does not personally interest me that much) Feel free to expand on my solution",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 5: Making Decisions"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/05_MakingDecisions/Chapter_05.html#notes",
    "href": "01_ProgrammingFundamentals/05_MakingDecisions/Chapter_05.html#notes",
    "title": "Chapter 5: Making Decisions",
    "section": "",
    "text": "Caution\n\n\n\nA number of the code examples in this use the file siren.wav, this can be found in the corresponding chapter in the samples submodule. For space reasons we haven’t uploaded it to the github\n\n\n\n\n\nBoolean values are a type that is used to distinguish between values that are True or False\nFor example, we could use an int to count the number of hairs on a person’s head, but a bool to indicate if they are bald\n\n\n\n\nSimply declare a variable with a value of True or False\n\nPython will infer the type\n\nFor example, to declare a true valued boolean,\n\nit_is_time_to_get_up = True\n\nwe can then set the value to false,\n\nit_is_time_to_get_up = False\n\nNote that True and False are python keywords, and are case-sensitive, e.g. true and false will not work as expected\n\n\n\n\nOpen up the python interpreter and work through the following questions to understand booleans\n\nWhat do you think would happen if you printed the contents of a boolean value?\n\nit_is_time_to_get_up = True\nprint(it_is_time_to_get_up)\n\nTrue\n\n\n\nPython will try to print out something meaningful, for a boolean this is either True or False\n\nWhat do you think would happen if you gave the word True to the input function?\nx = input(\"True or False: \")\nTrue or False: True\n\ninput returns it’s input as a string, so in this case x will not be a bool but rather a string with the value \"True\"\n\nIs there a python function called bool that will convert things into Boolean, just like there are int and float functions?\n\nYes there is, consistent behaviour with bool. Consider the following examples\n\n\nprint(bool(1))\nprint(bool(0))\nprint(bool(0.0))\nprint(bool(0.1))\nprint(bool(''))\nprint(bool('Hello'))\n\nTrue\nFalse\nFalse\nTrue\nFalse\nTrue\n\n\n\nWe can see that non-zero numbers evaluate True while zero, evaluates as False Similarly the empty string evaluates False while a non-empty string evaluates as True\n\nWhat happens if a program combines bool values with other values?\n\nWe should already expect that if we try to mix incompatible data that an error should be generated\n\n\n 'Hello' + True\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 'Hello' + True\n\nTypeError: can only concatenate str (not \"bool\") to str\n\n\n\n\nWe can see that we cannot concatenate a boolean value to a string\nThe behaviour can be a little less intuitive with numbers though,\n\n\n1 + True\n\n2\n\n\n\nTrue is implicitly converted to the integer value \\(1\\)\n\n\n1 + False\n\n1\n\n\n\nSimilarly, False is implicitly converted to the integer value \\(0\\)\nWe can see that numeric operations on bool thus have well-allowed behaviour\nString operations (i.e. textual data) are not compatible\n\n\n\n\n\n\nNormally we don’t declare a boolean with True or False explicitly but instead as the result of evaluating an expression\n\nSome expressions evaluate to True or False which naturally suits being stored in a boolean\n\nConsider a simple alarm clock,\n\nWe can get the time through the time library we’ve seen before\n  import time\n\n  current_time = time.localtime()\n\n  hour = current_time.tm_hour\ntime.localtime returns an object containing information about the current time.\n\nThis different blocks of information are called attributes, below is a list of the attributes contained in the object returned by localtime\n\n\n\n\n\n\n\n\n\n\nAttribute\nValue\n\n\n\n\ntm_year\nYear (for example, 2017)\n\n\ntm_mon\nMonth (in the range 1 … 12, 1 represents January)\n\n\ntm_mday\nDay in the Month (in the range 1 … month length)\n\n\ntm_hour\nHour in the Day (in the range 0 … 23)\n\n\ntm_min\nMinute in the Hour ( in the range 0 … 59)\n\n\ntm_sec\nSeconds in the Minute ( in the range 0 … 59)\n\n\ntm_wday\nDay of the Week (in the range 0 … 6 with Monday as 0)\n\n\ntm_yday\nDay in the Year (in the range 0 … 364 or 365 depending on if the year is a leap year)\n\n\n\n\nAn example of a localtime object might look like,\n\n\n\n\nAttribute\nValue\n\n\n\n\ntm_year\n2017\n\n\ntm_mon\n7\n\n\ntm_mday\n19\n\n\ntm_hour\n11\n\n\ntm_min\n40\n\n\ntm_sec\n30\n\n\ntm_wday\n2\n\n\ntm_yday\n200\n\n\n\n\n\nLets make a clock that displays only the hour value, using localtime. These one-handed clocks are supposed promote a more relaxed attitude. Create a new program (OneHandedClock.py) and copy the below text.\n\n    # Example 5.1: One Handed Clock\n    #\n    # Uses time to display the hour\n\n    import time\n\n    current_time = time.localtime()\n    hour = current_time.tm_hour\n\n    print(\"The hour is\", hour)\n\nThe hour is 11\n\n\nRun the program, it should print out the current hour\n\n\n\nImprove the previous example to produce a more fully featured clock that reports the time, and date when run\nWe can use the table above to grab the correct attributes. We then simply need to format the attribute as necessary. The final program is given below\n\n    # Exercise 5.1: Improved Clock\n    #\n    # An improved clock that displays the date and time when run\n\n    import time\n\n    current_datetime = time.localtime()\n\n    day = current_datetime.tm_mday\n    month = current_datetime.tm_mon\n    year = current_datetime.tm_year\n    print(\"The date is\", day, \"/\", month, \"/\", year)\n\n    seconds = current_datetime.tm_sec\n    minutes = current_datetime.tm_min\n    hours = current_datetime.tm_hour\n    print(\"The time is\", hours, \":\", minutes, \":\", seconds)\n\nThe date is 10 / 2 / 2026\nThe time is 11 : 22 : 37\n\n\n\n\n\n\n\nWe’ve seen expressions as being made of operators and operands\nOne type of operator is a comparison operator\n\nReturns a value that is True or False, e.g.\n\n\n\n\n\n\n\nblock-beta\n    columns 3\n    space\n    title[\"Breakdown of an Example Comparison Expression\"]\n    space\n\n    block:Input\n    columns 1\n        operand1[\"hour\"]\n        operand1Word[\"Operand\"]\n        operand1descr[\"(thing to work on)\"]\n    end\n\n    block:Middle\n    columns 1\n        operator[\"&gt;\"]\n        operatorWord[\"Operator\"]\n        operatorDescr[\"(thing to do)\"]\n    end\n\n    block:Output\n    columns 1\n        operand2[\"6\"]\n        operand2Word[\"Operand\"]\n        operand2descr[\"(thing to work on)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass operand2Word BG\nclass operand2descr BG\nclass operand1Word BG\nclass operand1descr BG\nclass operatorWord BG\nclass operatorDescr BG\n\n\n\n\n\n\n\n\n\nBelow is a table of the common comparison operators\n\n\n\n\n\n\n\n\n\nOperator\nName\nEffect\n\n\n\n\n\\(&gt;\\)\nGreater than\nTrue if the left argument is greater than the right, else False\n\n\n\\(&lt;\\)\nLess than\nTrue if the left argument less than the right, else False\n\n\n\\(&gt;=\\)\nGreater than or Equal\nAs for Greater than but also True if the left argument equals the right\n\n\n\\(&lt;=\\)\nLess than or Equal\nAs for Less than but also True if the left argument equals the right\n\n\n\\(==\\)\nEquals\nTrue if the left argument equals the right argument, else False\n\n\n\\(!=\\)\nNot Equals\nTrue if the left argument does not equal the right argument, else False\n\n\n\n\nA program can use a comparison operator to set a boolean variable, e.g. the below code fragment which sets the boolean variable it_is_time_to_get_up to True if the variable hour is greater than \\(6\\) else sets it to False\n\n    it_is_time_to_get_up = hour &gt; 6\n\n\nUse the python interpreter to work through the following questions in order to understand Comparison Operators\n\nHow does the equality operator work?\n\nThe equality operator evaluates to True if the two operands hold the same value\n\n\n1 == 1\n\nTrue\n\n\n\nThe equality operator can be used to compare strings and bools\n\n\n 'Rob' == 'Rob'\n\nTrue\n\n\n\n True == True\n\nTrue\n\n\nHow do I remember which relational operator to use?\n\nPractice, patience and muscle memory\n\nCan we apply relational operators between other types of expressions?\n\nYes. For example, the \\(&gt;\\) and \\(&lt;\\) operators when used to compare strings will use an alphabetic ordering, e.g.\n\n'Alice' &lt; 'Brian'\n\nTrue\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nEquality and Floating-point Values\nIn Chapter 4 we noted that floating points only approximate a specific real-value. These approximations can cause issues when using comparison operators, e.g.\n\nx = 0.3\ny = 0.1 + 0.2\nx == y\n\nFalse\n\n\n\nThe variables x and y should both notionally store \\(0.3\\), but the equality shows they are unequal. This is because the addition of \\(0.1\\) and \\(0.2\\) actually leads to y storing the slightly inaccurate \\(0.3000...4\\)\nIf comparing floating-point numbers for equality, the best approach is to check that the values are appropriately close\n\n\n\n\nPython provides the type function, type(x) returns the type of the variable x, especially useful for investigating the type of values returned by library functions you’ve never seen before\n\n\n\n\n\n\n\nWhat if we want to combine boolean expressions to create a new boolean expression\ne.g. An alarm might want to go off when the hour is after \\(7\\) and the minute is after \\(30\\)\nPython provides logic operators for combining boolean expressions\n\n\n\nUse the python interpreter to answer the following questions and investigate boolean operators\n\nWhat does the following expression evaluate too?\n\nnot True\n\nFalse\n\n\n\nnot inverts the value of a boolean, so True is converted to False\n\nHow about this expression?\n\nTrue and True\n\nTrue\n\n\n\nand is True iff both arguments are True as is the case above, so the result is True\n\nHow about this expression?\n\nTrue and False\n\nFalse\n\n\n\nSince one of the arguments is False and will evaluate to False\n\nHow about this expression?\n\nTrue or False\n\nTrue\n\n\n\nSince one of the arguments is True or will evaluate to True\n\nSo far, the examples have only used boolean values. What happens if we mix boolean and numeric values?\n\n True and 1\n\n1\n\n\n\nRecall that python can convert numeric expressions to boolean ones, this implicitly happens to the \\(1\\) in the above. So we would expect and to return True. However ,instead \\(1\\) is returned. This is due to some odd python behaviour\n\nPython sees True \\(\\rightarrow\\) result of and implied by second argument\n\nSo simply returns the second argument, since the truthfulness of \\(1\\), is equivalent to the original expression\n\nIf we flip the arguments, we should see this more clearly\n\n  1 and True\n\nTrue\n\n\n\nThis time the above expressions should return True\n\nThe same behaviour will also occur with or\n\n  1 or False\n\n1\n\n\n\nHere the or operator short-circuits on \\(1\\), so returns \\(1\\)\n\n\n  0 or True\n\nTrue\n\n\n\nHere the or evaluates the first argument as false, so cannot short-circuit, the second argument is returned, i.e True\n\n\n\n\n\nLet us now use and to try construct an expression that will correctly evaluate when the time is after \\(7:30\\), naively we might expect,\n\n    it_is_time_to_get_up = hour &gt; 6 and minute &gt; 29\n\nWe can use a truth table to check,\n\n\n\n\nHour\nMinute\nDesired\nOutput\n\n\n\n\n6\n0\nFalse\nFalse\n\n\n7\n29\nFalse\nFalse\n\n\n7\n30\nTrue\nTrue\n\n\n8\n0\nTrue\nFalse\n\n\n\n\nWe can see in the last case the result is not what we want!\n\nhour &gt; 7 is true, but minute &gt; 29 is false, so we need to be more precise,\n\n\n    it_is_time_to_get_up = (hour &gt; 7) or (hour == 7 and minute &gt; 29)\n\nWe use brackets to make the expression more readable\nHere we use short-circuiting, if the the hour is greater than \\(7\\) we don’t need to check the minutes value\n\n\n\n\n\n\n\nWarning\n\n\n\nBe Careful with Logic Operations\nWhen working with boolean operations you should always check that the logic matches what you expect!\n\n\n\n\n\n\n\n\nSuppose we want a program to tell me if it’s time to get out of bed\nNeed the ability to run code if a boolean condition is met\n\nCan do so using the aptly named if operator\n\n\n\n\n\nCreate a new python program (SimpleAlarmClock.py) with the following contents\n\n\n# Example 5.2: Simple Alarm Clock\n#\n# Demonstrates `if` using a simple alarm clock\n\nimport time\n\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminute = current_time.tm_sec\n\nit_is_time_to_get_up = (hour &gt; 7) or (hour == 7 and minute &gt; 29)\n\nif it_is_time_to_get_up:\n    print(\"IT IS TIME TO GET UP\")\n\nIT IS TIME TO GET UP\n\n\n\nThe program should print IT IS TIME TO GET UP only if the time is after \\(7:30\\)\nThe if construct starts with the word if, following by a boolean value called the condition, then a :\nAny statements we want to execute if the if is True are then written below the if and indented one level\n\n\n\n\n\nCondition is a term for the expression that controls which branch of the if is executed\nIf the condition evaluates True the indented branch is run\nIf the condition evaluates False the indented branch is skipped\nWe could simply the above code by including the check directly in the if rather than an intermediate variable\n\n\nif (hour &gt; 7) or (hour == 7 and minutes &gt; 29):\n    print(\"IT IS TIME TO GET UP\")\n\nIT IS TIME TO GET UP\n\n\n\n\n\n\nWhat if we want multiple statements to run after an if statement\nWe just write them as a sequence of indented statements\n\n\n\nLet us improve the previous example to also play a sound if it’s time to get up. Create a program (SirenAlarmClock.py) with the contents below\n# Example 5.3: Siren Alarm Clock\n#\n# Improves the Simple Alarm Clock to also play a sound\n\nimport time\n\nimport snaps\n\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminute = current_time.tm_min\n\nif (hour &gt; 7) or (hour == 7 and minute &gt; 29):\n    snaps.display_message(\"TIME TO GET UP\")\n    snaps.play_sound(\"siren.wav\")\n    # pause the program to give time for the sound to play\n    time.sleep(10)\nThis program now runs three statements in the if\n\nFirst a message is displayed\nSecond a sound is played\nThird the program sleeps so the sound has time to play\n\n\nIf we want something to run regardless of the if condition, we write it either before or after the if statement\n\n\n\n\nAdd to the simple Alarm Clock, by making it so the program will always print the current time regardless of if the alarm goes off. Create a new program (AlarmClockWithTimeDisplay.py). Enter the following contents,\n\n# Example 5.4: Alarm Clock with Time Display\n#\n# A variant of Alarm Clock to also always display the time\n\nimport time\n\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminute = current_time.tm_min\n\nif (hour &gt; 7) or (hour == 7 and minute &gt; 29):\n    print(\"TIME TO GET UP\")\n    print(\"RISE AND SHINE\")\n    print(\"THE EARLY BIRD GETS THE WORM\")\nprint(\"The time is\", hour, \":\", minute)\n\nTIME TO GET UP\nRISE AND SHINE\nTHE EARLY BIRD GETS THE WORM\nThe time is 11 : 22\n\n\n\nThe program above will always print the current time, regardless of if the alarm block is run\n\n\n\n\n\n\n\nCaution\n\n\n\nIndented Text can cause Big Problems\nAs seen above, python uses indentation for control flow, this has the advantage in that it follows normal code style practices, but has some pitfalls\n\nIf the indention is wrong the program won’t run\n\ni.e. if one line is indented four spaces, and the next three an error will be thrown\n\nimport time\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminutes = current_time.tm_min\n\nif (hour &gt; 7) or (hour == 7 and minute &gt; 29):\n  print(\"IT IS TIME TO GET UP\")\n      print(\"The early bird gets the worm...\")\n\n\n  Cell In[24], line 8\n    print(\"The early bird gets the worm...\")\n    ^\nIndentationError: unexpected indent\n\n\n\n\n\nA more insidious error, occurs if one mixes tabs and spaces in the indentation, since the code may appear to be fine until it attempts to run\n\n import time\n current_time = time.localtime()\n hour = current_time.tm_hour\n minutes = current_time.tm_min\n\n if (hour &gt; 7) or (hour == 7 and minute &gt; 29):\n     print(\"IT IS TIME TO GET UP\")\n     print(\"The early bird gets the worm...\")\n\nIT IS TIME TO GET UP\nThe early bird gets the worm...\n\n\n\nMost programmers and even text editors will automatically convert one style of indentation to the other (commonly tabs to spaces, but sometimes spaces to tabs) to avoid this issue\n\nIn the above code, my editor converted the second line which was indented with spaces to a tab to match the previous line\n\n\n\n\n\n\n\n\n\n\nFormally, an if has a structure like\n\n\n\n\n\n\nblock-beta\n    columns 4\n    space\n    title[\"Breakdown of an if statement\"]:2\n    space\n\n    block:Input\n    columns 1\n        if[\"if\"]\n        ifDescr[\"(start of the if construction)\"]\n    end\n\n    block:Condition\n    columns 1\n        condition[\"condition\"]\n        conditionDescr[\"(value that is true or false)\"]\n    end\n\n    block:Colon\n    columns 1\n        colon[\":\"]\n        colonDescr[\"colon\"]\n    end\n\n    block:Suite\n    columns 1\n        suite[\"suite\"]\n        suiteDescr[\"statements\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass condition BG\nclass conditionDescr BG\nclass colon BG\nclass colonDescr BG\nclass suite BG\nclass suiteDescr BG\nclass if BG\nclass ifDescr BG\n\n\n\n\n\n\n\nThere are two ways to write the suite\n\nA set of indented statements on the lines proceeding the if\nA set of statements on the same line as the if each seperated by a semicolon (;) e.g.\n if (hour &gt; 6): print('IT IS TIME TO GET UP'); print('THE EARLY BIRD GETS THE WORM')\n\n\n\n\n\n\n\n\nWarning\n\n\n\nYou can’t combine inline if statements, with indented if statements, e.g.\n\n    import time\n    current_time = time.localtime()\n    hour = current_time.tm_hour\n    minutes = current_time.tm_min\n\n    if (hour &gt; 7) or (hour == 7 and minute &gt; 29): print(\"IT IS TIME TO GET UP\"); print(\"RISE AND SHINE\")\n        print(\"The early bird gets the worm...\")\n\n\n  Cell In[26], line 7\n    print(\"The early bird gets the worm...\")\n    ^\nIndentationError: unexpected indent\n\n\n\n\n\n\n\n\nUse the python interpreter to answer the following questions to understand conditional statements\n\nCan we work with conditional statements using the python shell?\n\nYes you can, type the following into the shell,\n\nif True:\n\nThe shell may display ... instead of &gt;&gt;&gt; or, omit &gt;&gt;&gt; and indent\n\nIn the first case we can indent ourselves to write the suite\nIn the second we simply write the suite\n\nOnce done writing the if statement, simply deindent\nTry write the following in the shell, and verify the output\n\n  if True:\n      print('True')\n      print('Still True')\n\nTrue\nStill True\n\n\n\nHow many spaces must you indent a suite of Python statements controlled by an if statement?\n\nThere is no approved value, but it must be consistent\ni.e. if the first indentation is four, then all future indentations must also be four\n\nCommon choices are 4, 8 or 2\n\n\n\n\n\n\n\n\nSometimes we want conditional behaviour on both the True and False branches\nelse is a keyword that lets us add behaviour that executes when an if evaluates as False\n\n\n\nModify the Simple Alarm Clock to now print a message telling us to go back to bed if it before our alarm should go off. Write a new program (SimpleAlarmClockWithElse.py) with the following contents,\n\n# Example 5.5: Simple Alarm Clock\n#\n# Variant of the Simple Alarm Clock\n# that modifies the output depending on if its time to get up\n\nimport time\n\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminute = current_time.tm_min\n\nif (hour &gt; 7) or (hour == 7 and minute &gt; 29):\n    print(\"IT IS TIME TO GET UP\")\nelse:\n    print(\"Go back to bed\")\n\nIT IS TIME TO GET UP\n\n\n\nObserve that only one line of the paired if-else statements is printed\n\n\n\n\nWork through the following questions to understand if constructions\n\nMust an if construction have an else part?\n\nNo, we saw when first working with if that we could exclude the else in that case no additional code runs if the if evaluates False\n\nWhat happens if a condition is never True?\n\nIt simply never executes\n\n\n\n\n\n\n\nThe if statement can be used to compare strings, as seen with the comparison operators\n\n\n\nThe following program uses the equality operator and an if statement to greet a person if their name matches. What is a potential issue with this program?\n# Example 5.6: Broken Greeter\n#\n# A Greeter program using string matching\n# Identify the issues with this program\n\nname = input(\"Enter your name: \")\n\nif name == \"Rob\":\n    print(\"Hello, Oh great one\")\n\nThe equality operator checks against the string \"Rob\" exactly\ni.e. it is case sensitive, if we write \"ROB\", or \"rob\" or some variation thereof, the statement will not match.\n\nWe can fix this by using the string method upper, this converts all forms of the word \"rob\" to \"ROB\" which we can reliably check against. The new program looks like\n# Example 5.7: Uppercase Greeter\n#\n# A Greeter program using string matching\n# Fixes the issues with Example 5.6 by using\n# str.upper()\n\nname = input(\"Enter your name: \")\n\nif name.upper() == \"ROB\":\n    print(\"Hello, Oh great one\")\n\nWe could also use the string method lower to compare against an all lowercase word\n\n\n\n\nConsider the following questions to learn about methods and functions\n\nHow do lower() and upper() work?\n\nPython types are objects that provide methods.\nMethods are called like functions\n\nWhy do we have to write lower() and not lower?\n\nLeave the parentheses off, and see what happens\n\n  name = 'Rob'\n  name.upper\n\n&lt;function str.upper()&gt;\n\n\nWe are instead returned a description of the method itself\n\nWhat’s the difference between functions and methods?\n\nThey are used the same way, but they differ in where they are created\nFunctions are not associated any specific object\nMethods are bound as attributes of objects\n\n\n\n\n\n\n\nYou can nest conditions, e.g. if you want to perform sequential checks\n\n\n\nLet us demonstrate nested if through a greeter which requires a follow on code word to confirm the identity of the user. Create a program (CodedGreeter.py) with the following contents\n# Example 5.8: Coded Greeter\n#\n# Asks the user for a follow on code to confirm their ID\n# before the program greets them\n\nname = input(\"Enter your name: \")\n\nif name.upper() == \"ROB\":\n    code = input(\"Enter the codeword: \")\n    if code == \"secret\":\n        print(\"Hello, Oh great one\")\n    else:\n        print(\"Begone. Imposter\")\n\nPlay around with the above code to see what happens for various input combinations.\nYou should see if the first input is not a variant of \"rob\" the second prompt never occurs and the program ends.\nAdjust the above by writing a new program (CodedGreeterWithOuterElse.py)*\n\n# Example 5.9: Coded Greeter with Outer Else\n#\n# Asks the user for a follow on code to confirm their ID\n# before the program greets them\n# Has an additional outer else clause for the case that the nested\n# if does not run\n\nname = input(\"Enter your name: \")\n\nif name.upper() == \"ROB\":\n    code = input(\"Enter the codeword: \")\n    if code == \"secret\":\n        print(\"Hello, Oh great one\")\n    else:\n        print(\"Begone. Imposter\")\nelse:\n    print(\"You are not Rob. Shame.\")\n\nThe above code uses a second else clause, attached to the first outer, if condition\nThis means that it will run whenever the original name is not some variant of \"ROB\"\n\n\n\n\n\n\n\nImprove the Alarm Clock. Make the alarm display the date as well as the time, and let the user sleep in on the weekends.\nOur implementation is given below,\n# Exercise 4.2: Advanced Alarm Clock\n#\n# An Advanced Alarm Combining the Behaviour\n# of most increments of the alarm clock\n# and allowing you to sleep in on weekends\n\nimport time\n\nimport snaps\n\ncurrent_time = time.localtime()\nhour = current_time.tm_hour\nminute = current_time.tm_min\nday = current_time.tm_mday\nmonth = current_time.tm_mon\nis_weekend = current_time.tm_wday &gt;= 5\n\ndate_message = \"The date is \" + str(day) + \"/\" + str(month)\ntime_message = \"The time is \" + str(hour) + \":\" + str(minute)\n\nmsg = \"\"\nup_hour = 7 + is_weekend  # get to sleep in an extra hour on weekends\n\nif (hour &gt; up_hour) or (hour == up_hour and minute &gt; 29):\n    msg = msg + \"TIME TO GET UP\"\n    snaps.play_sound(\"siren.wav\")\nelse:\n    msg = msg + \"Go back to bed!\"\nmsg = msg + \"\\n\" + date_message + \"\\n\" + time_message\nsnaps.display_message(msg, size=50)\ntime.sleep(10)  # leave time for the sound and to read\nMost of the text simply exists to correctly create the final message we will display on the screen. The most important parts are, is_weekend = current_time.tm_wday &gt;= 5 which uses the fact that Saturday and Sunday have the value \\(5\\) and \\(6\\) in the current_time.tm_wday attribute (A number representing the day in the week) to set a boolean flag. We then use the fact that True acts numerically as one, and False acts numerically as zero to let us sleep in an hour on the weekend using up_hour = 7 + is_weekend which is \\(8\\) on weekends and \\(7\\) on weekdays.\nWe then run through the code as we have for most of the alarm clock cases, using an else clause to ensure we always have a message for the user, and appending the date and time message to this output.\nLastly we pass the method to snaps for display\n\n\n\n\n\n\nIn this next section we’ll write our first semi-sophisticated program\n\n\nScenario:\nA local theme park wants you to write a program that will let users check if they meet the age requirements to go on a ride. They provide the following table covering the current rides\n\n\n\n\n\n\n\nRide\nRestrictions\n\n\n\n\nScenic River Cruise\nNone\n\n\nCarnival Carousel\nAt least 3 years old\n\n\nJungle Adventure Water Splash\nAt least 6 years old\n\n\nDownhill Mountain Run\nAt least 12 years old\n\n\nThe Regurgitator\nAt least 12 years old and less than 70\n\n\n\n\n\n\n\nWe will use a simple text interface\n\nWelcome to our Theme Park\n\nThese are the available rides\n\n1. Scenic River Cruise\n2. Carnival Carousel\n3. Jungle Adventure Water Splash\n4. Downhill Mountain Run\n5. The Regurgitator\n\nPlease enter the ride you want: 1\nYou have selected the Scenic River Cruise\nThere are no age limits for this ride\n\n\n\n\n\n\nImportant\n\n\n\nDesign the User Interface with the Customer\nThe UI can be the most important and most difficult part of design because it can be very subjective. Ultimately the Customer is the one paying and so they should be involved in the UI design throughout!\n\n\n\n\n\n\nWe have a UI design, now we need to implement it\nOur code starts as below,\n\n# Example 5.10: Ride Selector Start\n#\n# The basic shell of the Ride Selector UI\n\nprint(\"\"\"Welcome to our Theme Park\n      These are the available ride:\n\n      1. Scenic River Cruise\n      2. Carnival Carousel\n      3. Jungle Adventure Water Splash\n      4. Downhill Mountain Run\n      5. The Regurgitator\n      \"\"\")\n\nride_number_text = input(\"Please enter the ride number you want: \")\nride_number = int(ride_number_text)\n\nif ride_number == 1:\n    print(\"You have selected Scenic River Cruise\")\n    print(\"There are no age limits for this ride\")\n\nWe first print out our Menu, using a triple-delimited string so we can multiline it\nThen we implement the menu using a series of if statements.\n\nFor the first case (Scenci River Cruise) we don’t need the user’s age so we can output the result immediately\n\nFor other rides the user needs to supply their age, so we continue,\n\nelse:  # need to get the age of the user\n    age_text = input(\"Please enter your age: \")\n    age = int(age_text)\n\nWe have to get the age using another input pair\nThis should already be familiar to you\n\n\n\n\nOnce we have the age, we need to compare against the restrictions for the selected ride\nWe can do this with a nested series of if statements which\n\nFirst selects the appropriate ride\nChecks the age against the ride’s age requirements\n\n\n    if ride_number == 2:\n        print(\"You have selected the Carnival Carousel\")\n        if age &gt;= 3:\n            print(\"You can go on the ride\")\n        else:\n            print(\"Sorry, you are too young\")\n    if ride_number == 3:\n        print(\"You have selected Jungle Adventure Water Splash\")\n        if age &gt;= 6:\n            print(\"You can go on the ride\")\n        else:\n            print(\"Sorry, you are too young\")\n\nDownhill Mountain Splash (ride number 4) can be implemented exactly as above\n\n\n\n\n\n\n\nTip\n\n\n\nReduce duplicated Code\nYou may have noticed that the above statement appears to have a bunch of duplicated code. The rough structure is,\nselect ride\nif age of user is greater than or equal to the rides min age\n    Inform the user they can go on the ride\nelse:\n    Inform the user they cannot go on the ride\nProgrammers typically don’t like to repeat themselves as it increases the number of ways a program can go wrong. So ideally we would like a way were we could write something like the above once and have the appropriate checks be carried out, and the message printed without having to write it out for every case. We’ll look at some ways to do this later in the book.\n\n\n\n\n\n\nThe last ride introduces an additional check, we have a minimum and a maximum age.\n\nNeed to introduce another layer nested conditional to differentiate between the too old and too young case\n\n\n    if ride_number == 5:\n        print(\"You have selected The Regurgitator\")\n        if age &gt;= 12:\n            # first check age not too low\n            if age &gt; 70:\n                # Age is too old\n                print(\"Sorry, you are too old\")\n            else:\n                # In the valid range\n                print(\"You can go on the ride\")\n        else:\n            # Age is too young\n            print(\"Sorry, you are too young\")\n\nYou can see the final Program (Ride Selector)\n\n\n\n\n\n\nWe can add some extra quality to our implementation using snaps\nsnaps get_string method\n\n# Example 5.11: Snaps get_string function\n#\n# Demonstrates using the get_string function\n# in snaps to get user input via a graphical\n# interface\n\nimport time\n\nimport snaps\n\nname = snaps.get_string(\"Enter your name: \")\nsnaps.display_message(\"Hello \" + name)\n\ntime.sleep(5)\n\n\n\n\n\n\nImportant\n\n\n\nAs written, the snaps get_string method on my machine, did not work when running Pygame 2. I had to modify the method to the following,\ndef get_string(prompt, size=50, margin=20,\n               color=(255, 0, 0), horiz='left', vert='center',\n               max_line_length=20):\n    '''\n    Reads a string from the user\n    '''\n\n    setup()\n\n    result = ''\n    cursor_char = '*'\n    cursor = None\n\n    def redraw():\n        clear_display()\n\n        render_message(prompt+result, margin=margin, size=size,\n                       horiz=horiz, vert=vert, color=color, cursor=cursor)\n\n    def cursor_flip():\n        nonlocal cursor\n\n    # create a timer for the cursor\n\n    cursor_event = pygame.USEREVENT+1\n\n    pygame.time.set_timer(cursor_event,500)\n    pygame.key.start_text_input()\n\n    while True:\n        event = pygame.event.wait()\n\n        if event.type == cursor_event:\n            if cursor:\n                cursor = None\n            else:\n                cursor = cursor_char\n            redraw()\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_RETURN:\n                break\n            elif event.key == pygame.K_BACKSPACE:\n                if len(result) &gt; 0:\n                    result = result[:-1]\n                    redraw()\n        elif event.type == pygame.TEXTINPUT:\n            if len(result) &lt; max_line_length:\n                result += event.text\n                redraw()\n\n    # disable the timer for the cursor\n    pygame.time.set_timer(cursor_event,0)\n    return result\nI won’t go into detail on explaining the changes since it’s above the level we’ve currently been discussing but if you have issues with the running any of the snaps get_string programs in this book, I would recommend trying the above replacement to the function\n\n\n\nUsing the above and some optional arguments to play around with text placement we can create the start of a GUI implementation of the Ride Selector Program\n\n\n\nThe below program is the outline for an implementation of the Ride Selector Program using snaps to provide a GUI\n# Example 5.12: Theme Park Snaps Display\n#\n# Reimplments the shell of the Ride Selector Menu using Snaps\n\nimport time\nimport snaps\n\n\nsnaps.display_image(\"themepark.png\")\n\nprompt = \"\"\"Welcome to our Theme Park\n      These are the available ride:\n\n      1. Scenic River Cruise\n      2. Carnival Carousel\n      3. Jungle Adventure Water Splash\n      4. Downhill Mountain Run\n      5. The Regurgitator\n\n      Select your ride: \"\"\"\n\nride_number_text = snaps.get_string(prompt, vert=\"bottom\", max_line_length=3)\nconfirm = \"Ride \" + ride_number_text\n\nsnaps.display_message(confirm)\ntime.sleep(5) #gives user time to read the output\n\n\n\nUsing the previous example, complete the ride selector program. Extending its features where reasonable\nWe’ll reimplement all the features of the original text-based interface, but add in the siren sound effect if the user is unable to ride the ride. Otherwise this proceeds as with most of our conversions to snaps. We replace print with snaps.display_message and introduce some work to build the string that we want to send to snaps.display_message. In this case we create a string that is nicely formatted to output\n\nThe ride number the user selected\nThe name of the ride\nA message letting them know if they are allowed to ride\n\nOur final implementation can be found in the file ThemeParkSnapsDisplay.py, or read from down below, observe the usual use of the time.sleep function to prevent the window from immediately closing\n# Exercise 5.3: Snaps Ride Selector\n#\n# Reimplments the entirety of the Theme Park Ride Selector using\n# a snaps interface, and adds some audio ques to warn the user\n# when they are ineligable for ride\n\nimport time\nimport snaps\n\n\nsnaps.display_image(\"themepark.png\")\n\nprompt = \"\"\"Welcome to our Theme Park\n      These are the available ride:\n\n      1. Scenic River Cruise\n      2. Carnival Carousel\n      3. Jungle Adventure Water Splash\n      4. Downhill Mountain Run\n      5. The Regurgitator\n\n      Select your ride: \"\"\"\n\nride_number_text = snaps.get_string(prompt, vert=\"bottom\", max_line_length=3)\nconfirm = \"Ride \" + ride_number_text\n\nsnaps.display_message(confirm)\ntime.sleep(2)  # gives user time to read the output\n\nride_number = int(ride_number_text)\n\nif ride_number == 1:\n    msg = confirm + \"\\nScenic River Cruise\\n\\nThere are no age limits for this ride\"\n    snaps.display_message(msg, size=100)\nelse:  # need to get the age of the user\n    age_text = snaps.get_string(\n        \"Please enter your age: \", vert=\"bottom\", max_line_length=3\n    )\n    age = int(age_text)\n\n    if ride_number == 2:\n        msg = confirm + \"\\nCarnival Cruise\"\n        if age &gt;= 3:\n            msg = msg + \"\\n\\nYou can go on the ride\"\n            snaps.display_message(msg, size=100)\n        else:\n            snaps.play_sound(\"siren.wav\")\n            msg = msg + \"\\n\\nSorry, you are too young\"\n            snaps.display_message(msg, size=100)\n    if ride_number == 3:\n        msg = confirm + \"\\nJungle Adventure Water Splash\"\n        if age &gt;= 6:\n            msg = msg + \"\\n\\nYou can go on the ride\"\n            snaps.display_message(msg, size=100)\n        else:\n            msg = msg + \"\\n\\nSorry, you are too young\"\n            snaps.play_sound(\"siren.wav\")\n            snaps.display_message(msg, size=100)\n    if ride_number == 4:\n        msg = confirm + \"\\nDownhill Mountain Run\"\n        if age &gt;= 12:\n            msg = msg + \"\\n\\nYou can go on the ride\"\n            snaps.display_message(msg, size=100)\n        else:\n            msg = msg + \"\\n\\nSorry, you are too young\"\n            snaps.play_sound(\"siren.wav\")\n            snaps.display_message(msg, size=100)\n    if ride_number == 5:\n        msg = confirm + \"\\nThe Regurgitator\"\n        if age &gt;= 12:\n            # first check age not too lowe\n            if age &gt; 70:\n                # Age is too old\n                msg = msg + \"\\n\\nSorry, you are too old\"\n                snaps.play_sound(\"siren.wav\")\n                snaps.display_message(msg, size=100)\n            else:\n                msg = msg + \"\\n\\nYou can go on the ride\"\n                snaps.display_message(msg, size=100)\n        else:\n            msg = msg + \"\\n\\nSorry, you are too young\"\n            snaps.display_message(msg, size=100)\ntime.sleep(5)\n\n\n\nUsing snaps and the weather functions it includes, write a simple program to remind the user to wrap up warm, wear sunscreen etc.\nWe’ll use the basic outline of the solution in the book,\n#EG5-14 Weather Helper\n\nimport snaps\n\ntemp = snaps.get_weather_temp(latitude=47.61, longitude=-122.33)\nprint(\"The temperature is:\", temp)\n\nif temp &lt; 40:\n    print(\"Wear a coat - it is cold out there\")\nelif temp &gt; 70:\n    print(\"Remember to wear sunscreen\")\nThe first step is to convert the print statements to instead use the snaps, display_message function. This requires us to do the usual work of building the string before we display it. Next we also want to display an image, either a sun or a snowflake depending on if the weather is hot or cold. Since we’re grabbing some new images, we run into an issue that snaps doesn’t work to rescale the images out of the box. We can fix this by adding the line image = image.convert_alpha() before the image = pygame.transform.smoothscale(image, window_size) line in display_image in snaps. Our final program (Weather Helper) looks like,\n# Exercise 5.4 Weather Helper\n#\n# Simple Weather Program that reminds the user about\n# the weather conditions, with helpful text and\n# pictures\n\nimport time\nimport snaps\n\ntemp = snaps.get_weather_temp(latitude=47.61, longitude=-122.33)\nconditions = snaps.get_weather_desciption(latitude=47.61, longitude=-122.33)\n\nif temp is None or conditions is None:\n    msg = \"Could not retrieve Weather...\"\nelse:\n    msg = \"The temperature is: \" + str(temp)\n    if temp &lt; 40:\n        msg = msg + \"\\n\\nWear a coat - it is cold out there\"\n        snaps.display_image(\"snowflake.png\")\n    elif temp &gt; 70:\n        msg = msg + \"\\n\\nRemember to wear sunscreen\"\n        snaps.display_image(\"sun.png\")\n    msg = msg + \"\\n\\nThe weather is \" + conditions\n\nsnaps.display_message(msg, size=100, color=\"red\")\ntime.sleep(5)\nIgnore the line if temp is None or conditions is None, this is some error handling code we’ll look at in a latter chapter. Notice that since no matter which path we go through the if, elif chain we’ll post a message at the end. So we use the branch code in order to set up the appropriate message, while the call to display_message sits outside the loop, so we don’t have to call it on every path.\n\n\n\nUsing randint and if statements write a fortune teller program that gives random fortunes to the user\nWe’ll expand on the prototype given by providing two additional statements, one relating to the future and the other relating to the wealth. We’ll follow the structure of using random.randint(1, 6) to simulate rolling a six-sided die, but spice it up by using if-elif-else clauses to play with the relative weighting of different statements.\n\n# Exercise 5.5 Fortune Teller Program\n#\n# A simple program that uses random numbers to generate a sequence of\n# fortunes for the user\n\nimport random\n\n# Meeting someone\nif random.randint(1, 6) &lt; 4:\n    print(\"You will meet a tall, dark stranger\")\nelse:\n    print(\"Nobody unexpected will enter your life\")\n\n# Money\nresult = random.randint(1, 6)\nif result == 1:\n    print(\"I see untold riches in your future\")\nelif result &lt;= 3:\n    print(\"A life of comfort is coming\")\nelif result &lt; 6:\n    print(\"You would do well to husband your wealth\")\nelse:\n    print(\"I see a future lived on the streets...\")\n\n# Advice\nresult = random.randint(1, 6)\nif result &lt;= 2:\n    print(\"Sometimes the answers to our future, come from the past\")\nelif result &lt; 6:\n    print(\"To define your future, avoid getting hung up on the past\")\nelse:\n    print(\"You will soon face a decision that will redefine everything\")\n\nNobody unexpected will enter your life\nYou would do well to husband your wealth\nSometimes the answers to our future, come from the past\n\n\nWe use a mix of ==, &lt;= and &lt; operators to emphasise the clarity of the branching. This implementation is quite simple (because the exercise does not personally interest me that much) Feel free to expand on my solution",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 5: Making Decisions"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/05_MakingDecisions/Chapter_05.html#summary",
    "href": "01_ProgrammingFundamentals/05_MakingDecisions/Chapter_05.html#summary",
    "title": "Chapter 5: Making Decisions",
    "section": "Summary",
    "text": "Summary\n\nPython can work with boolean values\n\nBool values are either True or False\n\nComparison operators compare expressions to generate boolean values\nif is used to control program execution in response to boolean expressions\n\nif executes code if a condition is True\n\nLogic operators and, or and not are used to create new boolean expressions from existing ones\n\nand is True if both expressions are True else False\nor is True if either expression is True else False\nnot flips the truth of a boolean expression\n\ne.g. True \\(\\rightarrow\\) False\nFalse \\(\\rightarrow\\) True",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 5: Making Decisions"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/05_MakingDecisions/Chapter_05.html#questions-and-answers",
    "href": "01_ProgrammingFundamentals/05_MakingDecisions/Chapter_05.html#questions-and-answers",
    "title": "Chapter 5: Making Decisions",
    "section": "Questions and Answers",
    "text": "Questions and Answers\n\nDoes the use of Boolean values mean a program will always do the same thing given the same data inputs?\n\nIt is very important that given the same inputs (including any inputs from a source of randomness) a program behaves the same way\n\nWill the computer always do the right thing when we write programs that make decisions?\n\nA computer running a program is only as correct as the program that was written. Formally verifing anything but the most trivial program as being correct is very difficult (and the problem in general is not-computable (see The Halting Problem))\nIt is typically the responsibility of the programmer to to ensure a program behaves correctly (in conjuction with the customer.) Even in cases where a user inputs wrong data, the customer would probably expect the programmer to build into the program the appropriate checks to deal with these wrong data inputs\n\nIs there a limit to how many if conditions you can nest inside each other?\n\nNo, the python interpreter should be able to handle many many layers of nested if statements. Most people will emphasise that if you’re finding that you’re needing to write heavily nested code (the exact number of what constitutes heavy is debated but \\(3\\) is a rough guide) you should look at if there’s a better way to write",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 5: Making Decisions"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/03_PythonProgramStructure/Chapter_03.html",
    "href": "01_ProgrammingFundamentals/03_PythonProgramStructure/Chapter_03.html",
    "title": "Chapter 3: Python Program Structure",
    "section": "",
    "text": "A program is a sequence of actions performed in order\n\nA script is a type of program that often repeats a series of simple tasks\n\nPython programs are stored as text files, traditionally with a .py extension\n\n\n\n\nTo run a program, you first need to write it. Any text editor should do.\n\n\n\nOpen a text editor and enter the following into the file,\n2+2\nSave the file somewhere appropriate with a name and the .py extension. Then run the program, if you have IDLE you can run it through that. I personally use the command line as\npython path-to-file\nYou may need to use python3 or python3.X depending on how your environment is setup where X is the python subversion. The code should execute but produce no output\n\n\n\n\n\nWhy did the example produce an empty output when run as a program, but \\(4\\) when run through the interpreter?\n\nProgram returns \\(4\\) to the caller, which for the program, is the shell that executes it\nWhat we really want is to output to the user\n\n\n\n\n\n\n\n---\ntitle: Python Data Processing with I/O\nconfig:\n  flowchart:\n    htmlLabels: false\n---\nflowchart LR\n\ninput((\"Python\n        Commands\"))\ncomputer[\"Python Command Shell\"]\noutput((\"Results\"))\nuser[\"User\"]\n\ninput--&gt;computer\ncomputer--&gt;output\nuser &lt;--&gt; computer\n\n\n\n\n\n\n\nWe want the program to be able to interact with the user to provide output, and request input\n\nThe first such function we need is print\n\n\n\n\nWrite a python file (using_print.py) with the following contents\n\nprint(2+2)\n\n4\n\n\nNow run the program. It should produce the same output as above (\\(4\\)). On my machine, running the following in terminal, leads to the output \\(4\\) as expected\npython using_print.py\n4\nNow create a new file (using_print2.py) with the following contents\n\nprint('The answer is: ')\nprint(2 + 2)\n\nThe answer is: \n4\n\n\nSave and run this file. The output should match the above\nObserve here that the program automatically adds a new line, if we want to avoid that we can instead write\n\nprint('The answer is:', 2+2)\n\nThe answer is: 4\n\n\nWrite and run a new file (using_print3.py) containing the above line and check the output matches the above.\nHere we see that one of the ways to call print is to provide a comma separated list of values. By default print adds a space between these elements\n\n\n\n\n\n\nCaution\n\n\n\nThere are several ways a python program can fail, for example\n\nprint('The answer is: '}\n\n\n  Cell In[4], line 1\n    print('The answer is: '}\n                           ^\nSyntaxError: closing parenthesis '}' does not match opening parenthesis '('\n\n\n\n\nleads to a syntax error, because the wrong parentheses have been used. Or,\n\nPrint(2 + 2)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[5], line 1\n----&gt; 1 Print(2 + 2)\n\nNameError: name 'Print' is not defined\n\n\n\nleads to a NameError because function names are case sensitive, and we have put Print not print. Proper use of tooling can catch these syntax and other errors before you run the code, however sometimes errors slip through and you end up with errors occurring at run time!\n\n\n\n\n\n\n\n\nLibraries provide additional built in functions, like ord and chr already seen\nLibraries can be supplied built-in, i.e. supplied with the python install, or installed later\n\n\n\n\nProvides a source of random numbers\nTo add a library we use the import command, e.g. import random\n\ni.e. import then the name of the library\n\nWe can then use functions from the library with the format, module_name.function_name(arguments)\n\ne.g. for random we can use randint as random.randint(1,6) to generate a random number from \\(1\\) to \\(6\\)\n\n\n\n\nWrite and run a python program containing the following lines\n\nimport random\nprint('You have rolled:', random.randint(1,6))\n\nYou have rolled: 3\n\n\nTry running this program multiple times and see what the output is\n\n\n\n\n\n\nCaution\n\n\n\nModules and the Interpreter\nIf we try calling random.randint without importing random we will get a NameError since neither random or randint will be recognised by the interpreter.\nIf we get the name of the module wrong, e.g. import Random, then we should get a ModuleNotFoundError\n\n\n\nThe python shell and most modern text editors can access documentation about pythons functions to help you with using them\nTypically this is obtained by hovering over the function name. Try this in your setup, in mine I get the documentation:\n\ndef randint(a : int, b : int) -&gt; int\nReturn random integer in range [a,b], including both end points\n\n\n\n\n\nThe time function contains functions for managing dates and times\nThe sleep function lets a program for a given time period\n\nTells the operating system to pause execution of the program for a set time period\nOther programs continue running as normal\n\n\n\n\nWrite and execute the following program\n\nimport time\nprint('I will need to think about that...')\ntime.sleep(5)\nprint('The answer is: 42')\n\nI will need to think about that...\nThe answer is: 42\n\n\nYou should see the program print the first line, pause for about \\(5\\) seconds, then print the second line. The above cell should show the code after all lines have run\n\n\nMake an egg timer program. The program should allow the user to time a 5-minute boiled egg. You can do this by modifying the example sleep program which paused for \\(5\\) seconds. For extra style points, you could make the program print, “Nearly cooked, get your spoon ready,” \\(30\\) seconds before the \\(5\\)-minute deadline. You could even expand this into an interactive recipe program that describes the steps to be performed at each point in the recipe and then pauses until the next step is performed\nCurrently we haven’t been show a way to get input from the user so we can’t add that final step of interactivity. But the first two are fairly simple. There are \\(300\\) seconds in \\(5\\) minutes. So we want to tell the user to put the egg in, then sleep for \\(270\\) seconds, then print our message to get ready, sleep for another \\(30\\) seconds then tell the user to remove the egg.\nThe final code is then, (with sample output)\nimport time\n\nprint('Make sure the water is boiling!!!')\nprint('Drop the egg in...')\ntime.sleep(270)\nprint('Nearly cooked, get your spoon ready')\ntime.sleep(300)\nprint('Egg cooked, remove now.')\n\n\nMake sure the water is boiling!!!\nDrop the egg in...\nNearly cooked, get your spoon ready\nEgg cooked, remove now.\n\n\n\n\n\n\n\n\n\nComments are used to add metadata to code, i.e. extra information that does not impact how the code is run\ne.g. version numbers, authorship attribution, modification dates\nA comment is marked with a # and extends to the end of the line\n\n# Exercise 3.1 Egg Timer Program\n\nimport time\n\nprint(\"Make sure the water is boiling!!!\")\nprint(\"Drop the egg in...\")\ntime.sleep(270)\nprint(\"Nearly cooked, get your spoon ready\")\ntime.sleep(300)\nprint(\"Egg cooked, remove now.\")\n\nComments can be added at the end of statements, e.g.\n\ntime.sleep(300) #sleep while egg cooks (300 seconds or 5 minutes)\n\nThe above comment is good because it explains why the function is called\nA bad comment simply repeats the code\nComments have a maintenance overhead, you must keep them consistent with the surrounding code or they will generate confusion\n\n\n\n\n\nYou can use sleep to delay the end of a program. This can be useful in some environments where the calling window automatically closes after the program finishes execution, sleep lets you actually see the output\n\n\n\n\n\nsnaps is a library provided with the book code that provides simple functions for working with text, images and sound\nUses the pygame library\n\n\n\n\nPygame is a not packaged with python: we have to install it\nNormally this is done through a package manager, pip is a python package manager provided with python\nIn a terminal run one of the following lines,\n\npy -m pip install pygame --user #Windows\npython -m pip install pygame --user #Mac or Linux\n\nYou may need to use python3 instead of python\n\n\n\n\n\n\n\nTip\n\n\n\nInstalling and Managing Packages\nInstalling python packages and python package management is a whole issue. In general one should prefer virtual environments, user installations to isolate packages to the specific project. A program that I use that assists with all of this is called uv. In uv a package is added with the command uv add package-name. Package management and uv is a complicated topic, but to get started look at their homepage which is quite well documented.\n\n\n\n\n\n\nThe snaps library, is a python file contained in the provided book sample code, in each chapter folder with examples.\n\nIf you want to use snaps we could install it, but this is a bit more involved than where we are at right now\nInstead simply copy it into the same folder as any python file that wants to use it\n\n\n\n\n\nsnaps contains a display_message function that takes a string of text and displays it on the screen\nThe first example uses the most basic form of display_message\n\n# Example 3.5.1 Displaying Text via Snaps\n\nimport time\n\nfrom snaps import *\n\ndisplay_message(\"hello world\")\ntime.sleep(5)  # add a sleep so the window doesn't autoclose\n\nThe above creates a window with red text saying ‘Hello World’.\n\nWe’ve added the sleep so the window doesn’t automatically close - see discussion about Delaying the end of a program\n\nThe from snaps import * is an alternate import structure\n\nIt tells us from the module snaps import everything (*)\nThis means we don’t need to use the snaps prefix\nGenerally avoid doing this as it can mean that different packages with the same function names will cause naming clashes\n\nPython functions support optional arguments\n\nThese are arguments that have some default supplied value\nWe can customise these to change function behaviour\n\nThe second example uses these optional arguments to change the size, colour and alignment of the text\n\n# Example 3.5.2 Displaying Text via Snaps\n#\n# Extends the previous example by demonstrating\n# adding colour, size, text position\n\nimport time\n\nimport snaps\n\nsnaps.display_message(\n    \"This is smaller text in green on the top left\",\n    color=(0, 255, 0),\n    size=50,\n    horiz=\"left\",\n    vert=\"top\",\n)\ntime.sleep(5)  # add a sleep for 5 seconds so the window doesn't autoclose\n\n\n\n\nLike display_message, the display_image function in snaps can be used to display an image file.\nFunction takes the path to the image and can be an png or jpeg\nText can be overlaid on an image by calling display_message after display_image\nFor example: Displaying Images\nHere we use display_image to render a jpeg, with some overlaid text\n\n# Example 3.6 Display Image\n#\n# display an image using snaps library\n\nimport time\n\nimport snaps\n\nsnaps.display_image(\"Housemartins.jpg\")\nsnaps.display_message(\"Hull Rocks\", color=(255, 255, 255), vert=\"top\")\n\ntime.sleep(5)\n\nAgain note, that sleep is used to prevent the window from closing\nThe order of the display messages matters, try changing the order and seeing the result\n\n\n\n\n\nWe have text and images, the last we need is sound, snaps has the play_sound function for this purpose\nSee the example in Playing Sounds\nHere we use play_sound to play a .wav audio file\n\n# Example 3.7 Play Sound\n#\n# play an audio file using snaps\n\nimport time\n\nimport snaps\n\nsnaps.play_sound(\"ding.wav\")\ntime.sleep(5)\n\nAgain, note we need to use sleep to prevent the program immediately ending, which will make it seem like the sound doesn’t play!\nIf you want to work with audio files, a commonly used program is Audacity\n\n\n\n\n\n\nYou can use the snaps program to add visuals and sound to some of the previous examples\n\n\n\nLets use the snaps program to make a GUI version of our egg timer program\nOur implementation essentially replaces the print with snaps display_message\n# Exercise 3.2 Improved Egg Timer\n#\n# Reimplements the Egg Timer Exercise using the snaps library\n# to add a visual and audio component\n\nimport time\n\nimport snaps\n\nsnaps.display_image(\"egg_timer_background.png\")\nsnaps.display_message(\n    \"Drop the egg in boiling water\", color=(255, 0, 0), vert=\"top\", size=100\n)\ntime.sleep(270)\nsnaps.display_message(\n    \"Nearly cooked, get your spoon ready!\", color=(0, 0, 255), size=100\n)\ntime.sleep(30)\nsnaps.play_sound(\"ding.wav\")\nsnaps.display_message(\n    \"Egg cooked, remove now.\", color=(0, 255, 0), vert=\"bottom\", size=100\n)\ntime.sleep(30)\n\nWe first set the background using display_image\n\nThis means the text will appear over the top of the background image\n\nWe then display the initial message\n\nThis is displayed in red, at the top, we adjust the size of the text to \\(100\\) so the text fits on the window\n\nWe then sleep for the first \\(4.5\\) minutes\nWe then inform the user that there is \\(30\\) seconds to go, like in the original code.\n\nThis time the text is displayed in blue, and migrates to the middle of the screen\n\nWe then sleep again for the last \\(30\\) seconds\nFinally we first play a sound to alert the user\nWe then display the message that the egg is ready\n\nThis time at the bottom and in red\n\nWe then sleep for \\(30\\) seconds so the user has time to notice and hear the sound\n\n\n\n\nUse the random number generator and sleep to make a high-low party game. The game works like this,\n\nThe program displays a number between \\(1\\) and \\(10\\) inclusive\nThe program then sleeps for \\(20\\) seconds. While the program is asleep, the players are invited to decide if the next number is higher or lower than the number just printed. Players who chose high stand on the right. Players who chose low stand on the left\nThe program then displays a second number between \\(1\\) and \\(10\\), and anyone who was wrong is eliminated from the game. The program is then re-run with the players that are left until you have a winner\n\nFor fun we use snaps for our implementation to make this visual\n# Exercise 3.3 High-Low\n#\n# Implements the High-Low Party game\n# Generates a random number in the interval [1, 10]\n# Sleeps for a period of time\n# Shows another number\n# Players are asked to guess if this second number will be higher or lower\n\nimport random\nimport time\n\nimport snaps\n\nsnaps.display_message(\"The first number is...\")\ntime.sleep(5)  # sleep so people can read the first message\nsnaps.display_message(random.randint(1, 10))\ntime.sleep(3)  # leave time to read the number\nsnaps.display_message(\"Will the next be higher or lower?\")\n\n# sleep for 20 seconds total, with a message to raise the tension with 5s left\ntime.sleep(15)\nsnaps.display_message(\"The second number is...\")\ntime.sleep(5)\n\nsnaps.display_message(random.randint(1, 10))\ntime.sleep(10)  # leave time for the players to read\n\nObserve that we have to wrap the display_message calls with calls to sleep to ensure that there is time for the user to read the messages\nThe output of (a terminal implementation of the program) should look something like,\n\n\n\nThe first number is:  6\nWill the next be higher or lower?\nThe second number is:  6\n\n\n\n\n\nUse the random number generator and sleep to make a Nerves of Steel game. This game works like this\n\nThe program displays “Players Stand”\nThe program sleeps for a random time between \\(5\\) and \\(20\\) seconds. While the program is sleeping, players can sit down. Keep track of the last person to sit down\nThe program displays “Last to sit down wins.” Players still standing are eliminated, and the winner is the last person to sit down\n\nAgain for fun we’ll use snaps to make a basic window.\n# Exercise 3.4 Nerves of Steel\n#\n# Implements the Nerves of Steel Party Game\n# Players stand\n# Generates a random time interval\n# All players standing after the time interval expires lose\n# Last to sit down before the interval expires wins\n\nimport random\nimport time\n\nimport snaps\n\nsnaps.display_message(\"Players Stand\")\ntime.sleep(random.randint(5, 20))\nsnaps.display_message(\"Last to sit down wins\", color=(0, 255, 0))\n\ntime.sleep(5)  # so program doesn't immediately end\n\nWe add a sleep at the end so the players have time to read the text. We also switch the final text from the initial red to green to celebrate the winner\nThe output of a terminal-based implementation might look like,\n\n\n\nPlayers Stand\nLast to sit down wins",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 3: Python Program Structure"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/03_PythonProgramStructure/Chapter_03.html#notes",
    "href": "01_ProgrammingFundamentals/03_PythonProgramStructure/Chapter_03.html#notes",
    "title": "Chapter 3: Python Program Structure",
    "section": "",
    "text": "A program is a sequence of actions performed in order\n\nA script is a type of program that often repeats a series of simple tasks\n\nPython programs are stored as text files, traditionally with a .py extension\n\n\n\n\nTo run a program, you first need to write it. Any text editor should do.\n\n\n\nOpen a text editor and enter the following into the file,\n2+2\nSave the file somewhere appropriate with a name and the .py extension. Then run the program, if you have IDLE you can run it through that. I personally use the command line as\npython path-to-file\nYou may need to use python3 or python3.X depending on how your environment is setup where X is the python subversion. The code should execute but produce no output\n\n\n\n\n\nWhy did the example produce an empty output when run as a program, but \\(4\\) when run through the interpreter?\n\nProgram returns \\(4\\) to the caller, which for the program, is the shell that executes it\nWhat we really want is to output to the user\n\n\n\n\n\n\n\n---\ntitle: Python Data Processing with I/O\nconfig:\n  flowchart:\n    htmlLabels: false\n---\nflowchart LR\n\ninput((\"Python\n        Commands\"))\ncomputer[\"Python Command Shell\"]\noutput((\"Results\"))\nuser[\"User\"]\n\ninput--&gt;computer\ncomputer--&gt;output\nuser &lt;--&gt; computer\n\n\n\n\n\n\n\nWe want the program to be able to interact with the user to provide output, and request input\n\nThe first such function we need is print\n\n\n\n\nWrite a python file (using_print.py) with the following contents\n\nprint(2+2)\n\n4\n\n\nNow run the program. It should produce the same output as above (\\(4\\)). On my machine, running the following in terminal, leads to the output \\(4\\) as expected\npython using_print.py\n4\nNow create a new file (using_print2.py) with the following contents\n\nprint('The answer is: ')\nprint(2 + 2)\n\nThe answer is: \n4\n\n\nSave and run this file. The output should match the above\nObserve here that the program automatically adds a new line, if we want to avoid that we can instead write\n\nprint('The answer is:', 2+2)\n\nThe answer is: 4\n\n\nWrite and run a new file (using_print3.py) containing the above line and check the output matches the above.\nHere we see that one of the ways to call print is to provide a comma separated list of values. By default print adds a space between these elements\n\n\n\n\n\n\nCaution\n\n\n\nThere are several ways a python program can fail, for example\n\nprint('The answer is: '}\n\n\n  Cell In[4], line 1\n    print('The answer is: '}\n                           ^\nSyntaxError: closing parenthesis '}' does not match opening parenthesis '('\n\n\n\n\nleads to a syntax error, because the wrong parentheses have been used. Or,\n\nPrint(2 + 2)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[5], line 1\n----&gt; 1 Print(2 + 2)\n\nNameError: name 'Print' is not defined\n\n\n\nleads to a NameError because function names are case sensitive, and we have put Print not print. Proper use of tooling can catch these syntax and other errors before you run the code, however sometimes errors slip through and you end up with errors occurring at run time!\n\n\n\n\n\n\n\n\nLibraries provide additional built in functions, like ord and chr already seen\nLibraries can be supplied built-in, i.e. supplied with the python install, or installed later\n\n\n\n\nProvides a source of random numbers\nTo add a library we use the import command, e.g. import random\n\ni.e. import then the name of the library\n\nWe can then use functions from the library with the format, module_name.function_name(arguments)\n\ne.g. for random we can use randint as random.randint(1,6) to generate a random number from \\(1\\) to \\(6\\)\n\n\n\n\nWrite and run a python program containing the following lines\n\nimport random\nprint('You have rolled:', random.randint(1,6))\n\nYou have rolled: 3\n\n\nTry running this program multiple times and see what the output is\n\n\n\n\n\n\nCaution\n\n\n\nModules and the Interpreter\nIf we try calling random.randint without importing random we will get a NameError since neither random or randint will be recognised by the interpreter.\nIf we get the name of the module wrong, e.g. import Random, then we should get a ModuleNotFoundError\n\n\n\nThe python shell and most modern text editors can access documentation about pythons functions to help you with using them\nTypically this is obtained by hovering over the function name. Try this in your setup, in mine I get the documentation:\n\ndef randint(a : int, b : int) -&gt; int\nReturn random integer in range [a,b], including both end points\n\n\n\n\n\nThe time function contains functions for managing dates and times\nThe sleep function lets a program for a given time period\n\nTells the operating system to pause execution of the program for a set time period\nOther programs continue running as normal\n\n\n\n\nWrite and execute the following program\n\nimport time\nprint('I will need to think about that...')\ntime.sleep(5)\nprint('The answer is: 42')\n\nI will need to think about that...\nThe answer is: 42\n\n\nYou should see the program print the first line, pause for about \\(5\\) seconds, then print the second line. The above cell should show the code after all lines have run\n\n\nMake an egg timer program. The program should allow the user to time a 5-minute boiled egg. You can do this by modifying the example sleep program which paused for \\(5\\) seconds. For extra style points, you could make the program print, “Nearly cooked, get your spoon ready,” \\(30\\) seconds before the \\(5\\)-minute deadline. You could even expand this into an interactive recipe program that describes the steps to be performed at each point in the recipe and then pauses until the next step is performed\nCurrently we haven’t been show a way to get input from the user so we can’t add that final step of interactivity. But the first two are fairly simple. There are \\(300\\) seconds in \\(5\\) minutes. So we want to tell the user to put the egg in, then sleep for \\(270\\) seconds, then print our message to get ready, sleep for another \\(30\\) seconds then tell the user to remove the egg.\nThe final code is then, (with sample output)\nimport time\n\nprint('Make sure the water is boiling!!!')\nprint('Drop the egg in...')\ntime.sleep(270)\nprint('Nearly cooked, get your spoon ready')\ntime.sleep(300)\nprint('Egg cooked, remove now.')\n\n\nMake sure the water is boiling!!!\nDrop the egg in...\nNearly cooked, get your spoon ready\nEgg cooked, remove now.\n\n\n\n\n\n\n\n\n\nComments are used to add metadata to code, i.e. extra information that does not impact how the code is run\ne.g. version numbers, authorship attribution, modification dates\nA comment is marked with a # and extends to the end of the line\n\n# Exercise 3.1 Egg Timer Program\n\nimport time\n\nprint(\"Make sure the water is boiling!!!\")\nprint(\"Drop the egg in...\")\ntime.sleep(270)\nprint(\"Nearly cooked, get your spoon ready\")\ntime.sleep(300)\nprint(\"Egg cooked, remove now.\")\n\nComments can be added at the end of statements, e.g.\n\ntime.sleep(300) #sleep while egg cooks (300 seconds or 5 minutes)\n\nThe above comment is good because it explains why the function is called\nA bad comment simply repeats the code\nComments have a maintenance overhead, you must keep them consistent with the surrounding code or they will generate confusion\n\n\n\n\n\nYou can use sleep to delay the end of a program. This can be useful in some environments where the calling window automatically closes after the program finishes execution, sleep lets you actually see the output\n\n\n\n\n\nsnaps is a library provided with the book code that provides simple functions for working with text, images and sound\nUses the pygame library\n\n\n\n\nPygame is a not packaged with python: we have to install it\nNormally this is done through a package manager, pip is a python package manager provided with python\nIn a terminal run one of the following lines,\n\npy -m pip install pygame --user #Windows\npython -m pip install pygame --user #Mac or Linux\n\nYou may need to use python3 instead of python\n\n\n\n\n\n\n\nTip\n\n\n\nInstalling and Managing Packages\nInstalling python packages and python package management is a whole issue. In general one should prefer virtual environments, user installations to isolate packages to the specific project. A program that I use that assists with all of this is called uv. In uv a package is added with the command uv add package-name. Package management and uv is a complicated topic, but to get started look at their homepage which is quite well documented.\n\n\n\n\n\n\nThe snaps library, is a python file contained in the provided book sample code, in each chapter folder with examples.\n\nIf you want to use snaps we could install it, but this is a bit more involved than where we are at right now\nInstead simply copy it into the same folder as any python file that wants to use it\n\n\n\n\n\nsnaps contains a display_message function that takes a string of text and displays it on the screen\nThe first example uses the most basic form of display_message\n\n# Example 3.5.1 Displaying Text via Snaps\n\nimport time\n\nfrom snaps import *\n\ndisplay_message(\"hello world\")\ntime.sleep(5)  # add a sleep so the window doesn't autoclose\n\nThe above creates a window with red text saying ‘Hello World’.\n\nWe’ve added the sleep so the window doesn’t automatically close - see discussion about Delaying the end of a program\n\nThe from snaps import * is an alternate import structure\n\nIt tells us from the module snaps import everything (*)\nThis means we don’t need to use the snaps prefix\nGenerally avoid doing this as it can mean that different packages with the same function names will cause naming clashes\n\nPython functions support optional arguments\n\nThese are arguments that have some default supplied value\nWe can customise these to change function behaviour\n\nThe second example uses these optional arguments to change the size, colour and alignment of the text\n\n# Example 3.5.2 Displaying Text via Snaps\n#\n# Extends the previous example by demonstrating\n# adding colour, size, text position\n\nimport time\n\nimport snaps\n\nsnaps.display_message(\n    \"This is smaller text in green on the top left\",\n    color=(0, 255, 0),\n    size=50,\n    horiz=\"left\",\n    vert=\"top\",\n)\ntime.sleep(5)  # add a sleep for 5 seconds so the window doesn't autoclose\n\n\n\n\nLike display_message, the display_image function in snaps can be used to display an image file.\nFunction takes the path to the image and can be an png or jpeg\nText can be overlaid on an image by calling display_message after display_image\nFor example: Displaying Images\nHere we use display_image to render a jpeg, with some overlaid text\n\n# Example 3.6 Display Image\n#\n# display an image using snaps library\n\nimport time\n\nimport snaps\n\nsnaps.display_image(\"Housemartins.jpg\")\nsnaps.display_message(\"Hull Rocks\", color=(255, 255, 255), vert=\"top\")\n\ntime.sleep(5)\n\nAgain note, that sleep is used to prevent the window from closing\nThe order of the display messages matters, try changing the order and seeing the result\n\n\n\n\n\nWe have text and images, the last we need is sound, snaps has the play_sound function for this purpose\nSee the example in Playing Sounds\nHere we use play_sound to play a .wav audio file\n\n# Example 3.7 Play Sound\n#\n# play an audio file using snaps\n\nimport time\n\nimport snaps\n\nsnaps.play_sound(\"ding.wav\")\ntime.sleep(5)\n\nAgain, note we need to use sleep to prevent the program immediately ending, which will make it seem like the sound doesn’t play!\nIf you want to work with audio files, a commonly used program is Audacity\n\n\n\n\n\n\nYou can use the snaps program to add visuals and sound to some of the previous examples\n\n\n\nLets use the snaps program to make a GUI version of our egg timer program\nOur implementation essentially replaces the print with snaps display_message\n# Exercise 3.2 Improved Egg Timer\n#\n# Reimplements the Egg Timer Exercise using the snaps library\n# to add a visual and audio component\n\nimport time\n\nimport snaps\n\nsnaps.display_image(\"egg_timer_background.png\")\nsnaps.display_message(\n    \"Drop the egg in boiling water\", color=(255, 0, 0), vert=\"top\", size=100\n)\ntime.sleep(270)\nsnaps.display_message(\n    \"Nearly cooked, get your spoon ready!\", color=(0, 0, 255), size=100\n)\ntime.sleep(30)\nsnaps.play_sound(\"ding.wav\")\nsnaps.display_message(\n    \"Egg cooked, remove now.\", color=(0, 255, 0), vert=\"bottom\", size=100\n)\ntime.sleep(30)\n\nWe first set the background using display_image\n\nThis means the text will appear over the top of the background image\n\nWe then display the initial message\n\nThis is displayed in red, at the top, we adjust the size of the text to \\(100\\) so the text fits on the window\n\nWe then sleep for the first \\(4.5\\) minutes\nWe then inform the user that there is \\(30\\) seconds to go, like in the original code.\n\nThis time the text is displayed in blue, and migrates to the middle of the screen\n\nWe then sleep again for the last \\(30\\) seconds\nFinally we first play a sound to alert the user\nWe then display the message that the egg is ready\n\nThis time at the bottom and in red\n\nWe then sleep for \\(30\\) seconds so the user has time to notice and hear the sound\n\n\n\n\nUse the random number generator and sleep to make a high-low party game. The game works like this,\n\nThe program displays a number between \\(1\\) and \\(10\\) inclusive\nThe program then sleeps for \\(20\\) seconds. While the program is asleep, the players are invited to decide if the next number is higher or lower than the number just printed. Players who chose high stand on the right. Players who chose low stand on the left\nThe program then displays a second number between \\(1\\) and \\(10\\), and anyone who was wrong is eliminated from the game. The program is then re-run with the players that are left until you have a winner\n\nFor fun we use snaps for our implementation to make this visual\n# Exercise 3.3 High-Low\n#\n# Implements the High-Low Party game\n# Generates a random number in the interval [1, 10]\n# Sleeps for a period of time\n# Shows another number\n# Players are asked to guess if this second number will be higher or lower\n\nimport random\nimport time\n\nimport snaps\n\nsnaps.display_message(\"The first number is...\")\ntime.sleep(5)  # sleep so people can read the first message\nsnaps.display_message(random.randint(1, 10))\ntime.sleep(3)  # leave time to read the number\nsnaps.display_message(\"Will the next be higher or lower?\")\n\n# sleep for 20 seconds total, with a message to raise the tension with 5s left\ntime.sleep(15)\nsnaps.display_message(\"The second number is...\")\ntime.sleep(5)\n\nsnaps.display_message(random.randint(1, 10))\ntime.sleep(10)  # leave time for the players to read\n\nObserve that we have to wrap the display_message calls with calls to sleep to ensure that there is time for the user to read the messages\nThe output of (a terminal implementation of the program) should look something like,\n\n\n\nThe first number is:  6\nWill the next be higher or lower?\nThe second number is:  6\n\n\n\n\n\nUse the random number generator and sleep to make a Nerves of Steel game. This game works like this\n\nThe program displays “Players Stand”\nThe program sleeps for a random time between \\(5\\) and \\(20\\) seconds. While the program is sleeping, players can sit down. Keep track of the last person to sit down\nThe program displays “Last to sit down wins.” Players still standing are eliminated, and the winner is the last person to sit down\n\nAgain for fun we’ll use snaps to make a basic window.\n# Exercise 3.4 Nerves of Steel\n#\n# Implements the Nerves of Steel Party Game\n# Players stand\n# Generates a random time interval\n# All players standing after the time interval expires lose\n# Last to sit down before the interval expires wins\n\nimport random\nimport time\n\nimport snaps\n\nsnaps.display_message(\"Players Stand\")\ntime.sleep(random.randint(5, 20))\nsnaps.display_message(\"Last to sit down wins\", color=(0, 255, 0))\n\ntime.sleep(5)  # so program doesn't immediately end\n\nWe add a sleep at the end so the players have time to read the text. We also switch the final text from the initial red to green to celebrate the winner\nThe output of a terminal-based implementation might look like,\n\n\n\nPlayers Stand\nLast to sit down wins",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 3: Python Program Structure"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/03_PythonProgramStructure/Chapter_03.html#summary",
    "href": "01_ProgrammingFundamentals/03_PythonProgramStructure/Chapter_03.html#summary",
    "title": "Chapter 3: Python Program Structure",
    "section": "Summary",
    "text": "Summary\n\nPython code can be run line by line through a shell, or as a program\nA program is a sequence of statements stored in one or more files\nThe print functions lets a program display output to the user as text\nLibraries contain other useable functions\n\nThey are accessed via import\nrandom is library for random numbers\n\nrandint generates random integers over an interval\n\ntime manages dates and times\n\nsleep lets a program pause for a specified number of seconds\n\n\nPrograms can and should contain comments\n\nComments are ignored by the interpreter\nProvide valuable metadata to the reader\nComments start with # and continue to the end of the line",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 3: Python Program Structure"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/03_PythonProgramStructure/Chapter_03.html#question-and-answers",
    "href": "01_ProgrammingFundamentals/03_PythonProgramStructure/Chapter_03.html#question-and-answers",
    "title": "Chapter 3: Python Program Structure",
    "section": "Question and Answers",
    "text": "Question and Answers\n\nWould a user ever use the Python Command Shell?\n\nThe command shell is very useful for programmers. Programmers can toy with code to check the output. Typically a user won’t interact with the shell but a program instead\n\nWhat would happen if two libraries contain a function with the same name?\n\nIf we use the import library approach nothing. Since functions are namespaced by their library we would simply have library1.function and library2.function\ne.g. we might have user.menu and system.menu\nIf we use the from library import * function then we might have an issue as the names will clash\n\nCan I make comments more than one line long?\n\nSeveral languages support multi-line comments (e.g. Java, C, C#), these are comments that by default span multiple lines\nPython requires you to use multiple #, i.e. one for each line\n\nThis is referred to as only supporting single line comments\n\nLater we’ll see a syntax for adding multi-line strings that can be used for documentation in a similar way to multi-line comments\n\nCan a python program run on any computer?\n\nYes and No. If a computer has a python interpreter installed then code should be able to run on it. However, there are caveats, the computer might require the same version of python and any libraries used some of which may be hardware or software dependent, e.g. a library might be specifically written to utilise the Windows API\n\nIs the python language the same on every machine?\n\nAgain Yes and No. Every computer should have the same core language, however different computers may have different versions of the same language which have slightly different feature sets. In fact it is often common for the same computer to manage several different python versions in different virtual environments\nMore common is for different computers to rely on libraries, that may not be commonly shared and may rely on hardware or software specific features to run.\n\nCan I use Snaps in my program?\n\nYes, it is provided by the book author to be used",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 3: Python Program Structure"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/02_PythonAndProgramming/Chapter_02.html",
    "href": "01_ProgrammingFundamentals/02_PythonAndProgramming/Chapter_02.html",
    "title": "Chapter 2: Python and Programming",
    "section": "",
    "text": "The ability to solve a program yourself\nConvert that solution into something the computer understands\n\n\n\n\nProgramming is problem solving\nA key part of programming is properly defining the problem and scope\n\nIn real projects this may take the form of a functional design specification\n\nA well defined problem is easy to reason about\n\n\n\n\n\n\n\nTip\n\n\n\nSpecifications must always exist\nOne should never write a program without getting a solid specification first. Defining a specification is essential even(or perhaps especially) when I do a job for a friend\n\n\n\nModern design techniques emphasise prototyping\n\nThe use of successive versions to solicit customer feedback\n\n\n\n\n\n\nThe best programmers are also good communicators\nEffective communication extends to writing\n\nHelps write code that more clearly articulates your point\n\n\n\n\n\n\n\n\nTip\n\n\n\nCommunication leads to the most interesting work\nInteresting tasks go to developers who are good communicators. They can articulate their ideas and liaise with customers\n\n\n\n\n\n\n\n\n\nComputers automate instructions\n\nThey follow given instructions\nConvert input data into output data\n\nComputers are typically unaware of the veracity of their data\n\nNo innate ability to question, or error recover\n\n\n\n\n\n\n\nblock-beta\n    columns 3\n    space\n    title[\"Examples of Typical Data-Processing Applications\"]\n    space\n\n    block:Input\n    columns 1\n        Inputs\n        radio[\"Radio Signals and Touchpad\"]\n        car[\"Temperature, Pressures, Throttle\"]\n        game[\"Gamepad\"]\n    end\n\n    block:Middle\n    columns 1\n        space\n        phone[\"Mobile Phone\"]\n        carMiddle[\"Car\"]\n        console[\"Console\"]\n    end\n\n    block:Output\n    columns 1\n        Outputs\n        phoneOut[\"Sound, Pictures\"]\n        carOut[\"Fuel Injector, Ignition timings\"]\n        consoleOut[\"Gameplay\"]\n    end\n\n    radio--&gt;phone\n    phone--&gt;phoneOut\n    car--&gt;carMiddle\n    carMiddle--&gt;carOut\n    game--&gt;console\n    console--&gt;consoleOut\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass Inputs BG\nclass Outputs BG\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nSoftware might be a matter of life or death\nSeemingly innocent programs can have real consequences. E.g. a program that calculates drug dosages may be used by a doctor. Therac-25 is the classic example.\n\n\n\n\n\n\n\n\n\n\n---\ntitle: Computers as Data Processors\nconfig:\n  flowchart:\n    htmlLabels: false\n---\nflowchart LR\n\ninput((\"Input\"))\ncomputer[\"Computer\"]\noutput((\"Output\"))\n\ninput--&gt;computer\ncomputer--&gt;output\n\n\n\n\n\n\n\nAs discussed computers can be seen as data transformers\nWe can view this as similar to following a recipe\n\n\n\n\n\n\n---\ntitle: Recipes as Programs\nconfig:\n  flowchart:\n    htmlLabels: false\n---\nflowchart LR\n\nflour((\"Flour\"))\nsugar((\"Sugar\"))\nmilk((\"Milk\"))\neggs((\"Eggs\"))\n\nhuman[\"Human following\n     recipe\"]\n\ncake((\"Cake\"))\n\nflour--&gt;human\nsugar--&gt;human\nmilk--&gt;human\neggs--&gt;human\n\nhuman--&gt;cake\n\n\n\n\n\n\n\n\n\n\nPython is effectively one of the ways we can make a computer do things\n\n\n\n\n\n\n---\ntitle: Python as a Data Processor\nconfig:\n  flowchart:\n    htmlLabels: false\n---\nflowchart LR\n\ninput((\"Python\n        Commands\"))\ncomputer[\"Python Command Shell\"]\noutput((\"Results\"))\n\ninput--&gt;computer\ncomputer--&gt;output\n\n\n\n\n\n\n\nCommands are the input which are processed by the python command shell (the computer) and turned into results (output)\n\n\n\n\nStart up a python interpreter and run the following\n\nhello\n\nhello\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[1], line 1\n----&gt; 1 hello\n\nNameError: name 'hello' is not defined\n\n\n\n\nThe interpreter doesn’t recognise the arbitrary word hello and produces an error message\n\n2\n\n2\n\n2\n\n\n\nThe interpreter echoes a number back out!\n\n2 + 2\n\n2 + 2\n\n4\n\n\n\nThe interpreter evaluates and echoes out the arithmetic!\n\n\n2 + 2 in the previous example is a representation of an expression\nPython can be seen as an expression evaluator. An expression consists of operators that act on operands to produce new output\nWe can break down the 2+2 example from the previous example to\n\n\n\n\n\n\nblock-beta\n    columns 3\n    space\n    title[\"Breakdown of a Simple Expression\"]\n    space\n\n    block:Input\n    columns 1\n        operand1[\"2\"]\n        operand1Word[\"Operand\"]\n        operand1descr[\"(thing to work on)\"]\n    end\n\n    block:Middle\n    columns 1\n        operator[\"+\"]\n        operatorWord[\"Operator\"]\n        operatorDescr[\"(thing to do)\"]\n    end\n\n    block:Output\n    columns 1\n        operand2[\"2\"]\n        operand2Word[\"Operand\"]\n        operand2descr[\"(thing to work on)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass operand2Word BG\nclass operand2descr BG\nclass operand1Word BG\nclass operand1descr BG\nclass operatorWord BG\nclass operatorDescr BG\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAs seen in the previous example, when invalid code is entered into the shell, an error message occurs. The same happens for an incomplete expression. e.g. the following is a shell sequence,\n\n2+\n\n\n  Cell In[4], line 1\n    2+\n      ^\nSyntaxError: invalid syntax\n\n\n\n\n\n\n\n\n\n\nWhat do you think would happen if you tried to evaluate 2+3*4?\n\nWe would expect 14 from the basic mathematical order of operations. Plugging this into the shell,\n\n\n 2 + 3 * 4\n\n14\n\n\nWhat do you think would happen if you tried to evaluate (2+3)*4?\n\nWe would expect 20 from the basic mathematical order of operations. Plugging this into the shell,\n\n\n (2 + 3) * 4\n\n20\n\n\nWhat do you think would happen if you tried to evaluate (2+3*4?\n\nWe might expect a syntax error\nInstead the interpreter, simply goes to a new line, and waits for us to enter the matching parenthesis\nOne such sequence in the shell might be,\n\n\n (2 + 3 * 4\n )\n\n14\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThere a different implementations of the Python Interpreter\nThese notes use a slightly different version of a python interpreter called a Jupyter Notebook to render the inline code. In Jupyter Notebooks code is written in cells and executed cell-by cell. This means that the interpreter can’t wait for the user to provide the missing input, so instead we get the slightly different error message below,\n\n\n\n (2 + 3 * 4\n\n\n  Cell In[8], line 1\n    (2 + 3 * 4\n              ^\nSyntaxError: incomplete input\n\n\n\n\nWhat do you think would happen if you tried to evaluate )2+3*4?\n\nIf we see a right parenthesis before a left parenthesis there is no way to retroactively go back and fix the missing left, like in the previous case where the shell simply waited for us to add the parenthesis\nSo here we would expect a syntax error\n\n\n )2+3*4\n\n\n  Cell In[9], line 1\n    )2+3*4\n    ^\nSyntaxError: unmatched ')'\n\n\n\n\n\n\n\n\n\n\nWe can use the interpreter like this to work line by line because python is a “scripting” language\n\ni.e. The program reads a line and then interprets the output\n\n\n\n\n\n\n\n\nNote\n\n\n\nNot all languages are scripting languages\nNot all languages are scripting languages. Some are converted to low-level hardware instructions. This is called compilation, and in place of an interpreter it requires a compiler to convert the code. Compiled programs are typically faster, since they can be optimised\n\n\n\n\n\n\n\nComputers fundamentally represent data as \\(0\\) or \\(1\\) in binary\n\nWe build up layers of abstract that let us handle concepts like numbers, characters and strings of text\n\nData can be regarded as the stored values representing information\nInformation is thus the interpretation of data, to mean something\n\n\n\n\nPython scripts thus can be considered data processors\n\nThe script is interpreted and converted to output\n\n\n\n\nStart up the python interpreter and run the following\n\n'hello'\n\n 'hello'\n\n'hello'\n\n\n\nLike before with \\(2\\) the word is echoed.\n\n'hello' + ' world'\n\n 'hello' + 'world'\n\n'helloworld'\n\n\n\n“Adding” two words performs a string concatenation\nObserve we explicitly have to include the space character in one of the strings\nA cool observation is that + changes it’s behaviour in response to what it’s arguments are\n\n\n\n\n\n\nWhat do you think would happen if missed the closing quote of a string you were typing?\n\nWe would expect it, to either hang waiting for the closing quote like with the missing left parenthesis, or a syntax error like a right quote. We find,\n\n  'hello\n\n\n  Cell In[12], line 1\n    'hello\n    ^\nSyntaxError: unterminated string literal (detected at line 1)\n\n\n\n\nEOL stands for “End of Line”\nOperands like strings and numbers can’t span multiple lines\nA string literal is just a string there in the code\n\nWhat do you think would happen if you tried to subtract one string from another?\n\nWhile addition of strings can be easily seen as concatenation, there is no meaningful equivalent for subtraction.\nWe could think of it as substring removal, but that has a lot of nuance that is hard to capture in a single symbol. We expect an error.\n\n  'hello' - ' world'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[13], line 1\n----&gt; 1 'hello' - ' world'\n\nTypeError: unsupported operand type(s) for -: 'str' and 'str'\n\n\n\nThe error message is somewhat obtuse but simply means that for the operand (-) we can’t subtract a string from another string\nTypeError indicates that something has gone wrong with the type of the data (here the type is string)\n\nWhat do you think would happen if you tried to add a number to a string?\n\nThis one can vary. There a two valid interpretations,\n\nYou can’t add a number to a word\nTreat the number as word, and concatenate it\n\nMost languages, use the former choice and so we make the assumption that python does too\n\n\n 'hello' + 2\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[14], line 1\n----&gt; 1 'hello' + 2\n\nTypeError: can only concatenate str (not \"int\") to str\n\n\n\n\nThe result is as expected, the error tells we can only concatenate a string to another string\n\nWhat do you think would happen if you tried to multiply a string by a number?\n\nAgain there are two interpretations,\n\nYou can’t multiply a word by a number\nYou can consider word * 3 as adding word three lots of word, where adding is string concatenation\n\nLets see what choice python uses,\n\n  'hello' * 3\n\n'hellohellohello'\n\n\nThe moral? Python tries to do something sensible when it can\n\n\n\n\n\n\n\nPython separates numerical data (e.g. 2) from text data (e.g. '2')\n\nNumerics and text are stored differently\n\nBehaviour of operators depends on the data types fed into them as operands\n\n\n\n\n\n\nA function is behaviour with a distinct name\n\ne.g. “Move left” is name for a distinct behaviour\n\nPython comes bundled with a number of built-in functions\n\n\n\n\n\n\n\nImportant\n\n\n\nFunctions are a critical part of programming languages\nLearning a new language often involves learning the functions it naively supports.\n\n\n\n\n\nord is a short name for ordinal value\n\nBuilt-in function, mean’s “give me the number representing this character”\nLet’s examine the use,\n\nord('W')\n\n87\n\n\n\n\n\n\nStart up a python interpreter, and run the following,\n\nord('W')\n\n ord('W')\n\n87\n\n\n\nThis matches our first example\n\nord(W)\n\n ord(W)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[18], line 1\n----&gt; 1 ord(W)\n\nNameError: name 'W' is not defined\n\n\n\n\nHere we get an error\nord is quite pedantic, requiring it’s argument to be a single character string\n\n\n\nObserve a function is called with the structure (using ord as an example),\n\n\n\n\n\n\nblock-beta\n    columns 4\n    space\n    title[\"Function Call Structure\"]:2\n    space\n\n    block:name\n    columns 1\n        ord[\"ord\"]\n        functionName[\"function name\"]\n        fndescr[\"(thing we want done)\"]\n    end\n\n    block:leftParenthesis\n    columns 1\n        leftP[\"(\"]\n        leftPname[\"Parenthesis\"]\n        space\n    end\n\n    block:argumentblock\n    columns 1\n        argument[\"'W'\"]\n        argumentName[\"argument\"]\n        argumentDescr[\"(thing to give function)\"]\n    end\n\n    block:rightParenthesis\n    columns 1\n        rightP[\")\"]\n        rightPname[\"Parenthesis\"]\n        space\n    end\n\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass ord BG\nclass functionName BG\nclass fndescr BG\nclass leftP BG\nclass leftPname BG\nclass argument BG\nclass argumentName BG\nclass argumentDescr BG\nclass rightP BG\nclass rightPname BG\n\n\n\n\n\n\n\n\n\n\n\nThe chr function is the counterpart to ord\n\nConverts numbers to text\n\n\n  chr(87)\n\n'W'\n\n\n\n\n\nStart up a python interpreter, and run the following,\n\nchr(87)\n\n chr(87)\n\n'W'\n\n\n\nExactly what we saw before, and what we would expect from ord\n\nchr(88)\n\n chr(88)\n\n'X'\n\n\n\nObserve that there is some logical progression.\nX comes after W in the alphabet, and does so in numerical representation\n\n\n\nInternational standards govern text representation\n\nHowever, older languages, software or hardware that predates these standards may not follow them\n\n\n\n\n\n\n\nAs mentioned before, computers store data in binary\nEach \\(0\\) or \\(1\\) is called a bit, a byte is typically a collection of \\(8\\) bits, and the smallest addressable unit of memory\nBytes can be grouped together to represent larger blocks of data\nbin converts a number to a string containing it’s binary representation\n\n\n\nUse the bin function to investigate how data is stored in a computer, start by running,\n\nbin(87)\n\n'0b1010111'\n\n\n\nbin returns a string giving the binary representation\n\ni.e. a string of 1’s and 0’s\n\nThe prefix 0b indicates that the remaining suffix is the binary representation of a number\n\n\n\n\nAnswer the following questions about binary representations\n\nWhat does the binary value of \\(0\\) look like?\n\nWould expect this to also be \\(0\\)\n\n\n bin(0)\n\n'0b0'\n\n\nWhat does the binary value of \\(1\\) look like?\n\nWould also expect this to be \\(1\\)\n\n\n bin(1)\n\n'0b1'\n\n\nWhat does the binary value of \\(2\\) look like?\n\nIn binary, digits are in columns of powers of \\(2\\) i.e. \\(1\\) like before is viewed as \\(1 \\times 2^{0}\\)\n\\(2\\) can be viewed as \\(1 \\times 2^{1} + 0 \\times 2^{0}\\), so we would expect the representation to be \\(10\\)\n\n\n bin(2)\n\n'0b10'\n\n\nWhat do you think the binary value of \\(11\\) means?\n\nIf we consider the above discussion, we expect this to be decimal \\(3\\)\n\n\n 3\n\n3\n\n\nHow does the binary value \\(86\\) differ from the binary value of \\(87\\)?\n\nLets look at 87 first.\n\n\n bin(87)\n\n'0b1010111'\n\n\n\n\\(86\\) differs by one, so we would expect \\(86\\) to be \\(1010110\\)\n\n\n bin(86)\n\n'0b1010110'",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 2: Python and Programming"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/02_PythonAndProgramming/Chapter_02.html#notes",
    "href": "01_ProgrammingFundamentals/02_PythonAndProgramming/Chapter_02.html#notes",
    "title": "Chapter 2: Python and Programming",
    "section": "",
    "text": "The ability to solve a program yourself\nConvert that solution into something the computer understands\n\n\n\n\nProgramming is problem solving\nA key part of programming is properly defining the problem and scope\n\nIn real projects this may take the form of a functional design specification\n\nA well defined problem is easy to reason about\n\n\n\n\n\n\n\nTip\n\n\n\nSpecifications must always exist\nOne should never write a program without getting a solid specification first. Defining a specification is essential even(or perhaps especially) when I do a job for a friend\n\n\n\nModern design techniques emphasise prototyping\n\nThe use of successive versions to solicit customer feedback\n\n\n\n\n\n\nThe best programmers are also good communicators\nEffective communication extends to writing\n\nHelps write code that more clearly articulates your point\n\n\n\n\n\n\n\n\nTip\n\n\n\nCommunication leads to the most interesting work\nInteresting tasks go to developers who are good communicators. They can articulate their ideas and liaise with customers\n\n\n\n\n\n\n\n\n\nComputers automate instructions\n\nThey follow given instructions\nConvert input data into output data\n\nComputers are typically unaware of the veracity of their data\n\nNo innate ability to question, or error recover\n\n\n\n\n\n\n\nblock-beta\n    columns 3\n    space\n    title[\"Examples of Typical Data-Processing Applications\"]\n    space\n\n    block:Input\n    columns 1\n        Inputs\n        radio[\"Radio Signals and Touchpad\"]\n        car[\"Temperature, Pressures, Throttle\"]\n        game[\"Gamepad\"]\n    end\n\n    block:Middle\n    columns 1\n        space\n        phone[\"Mobile Phone\"]\n        carMiddle[\"Car\"]\n        console[\"Console\"]\n    end\n\n    block:Output\n    columns 1\n        Outputs\n        phoneOut[\"Sound, Pictures\"]\n        carOut[\"Fuel Injector, Ignition timings\"]\n        consoleOut[\"Gameplay\"]\n    end\n\n    radio--&gt;phone\n    phone--&gt;phoneOut\n    car--&gt;carMiddle\n    carMiddle--&gt;carOut\n    game--&gt;console\n    console--&gt;consoleOut\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass Inputs BG\nclass Outputs BG\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nSoftware might be a matter of life or death\nSeemingly innocent programs can have real consequences. E.g. a program that calculates drug dosages may be used by a doctor. Therac-25 is the classic example.\n\n\n\n\n\n\n\n\n\n\n---\ntitle: Computers as Data Processors\nconfig:\n  flowchart:\n    htmlLabels: false\n---\nflowchart LR\n\ninput((\"Input\"))\ncomputer[\"Computer\"]\noutput((\"Output\"))\n\ninput--&gt;computer\ncomputer--&gt;output\n\n\n\n\n\n\n\nAs discussed computers can be seen as data transformers\nWe can view this as similar to following a recipe\n\n\n\n\n\n\n---\ntitle: Recipes as Programs\nconfig:\n  flowchart:\n    htmlLabels: false\n---\nflowchart LR\n\nflour((\"Flour\"))\nsugar((\"Sugar\"))\nmilk((\"Milk\"))\neggs((\"Eggs\"))\n\nhuman[\"Human following\n     recipe\"]\n\ncake((\"Cake\"))\n\nflour--&gt;human\nsugar--&gt;human\nmilk--&gt;human\neggs--&gt;human\n\nhuman--&gt;cake\n\n\n\n\n\n\n\n\n\n\nPython is effectively one of the ways we can make a computer do things\n\n\n\n\n\n\n---\ntitle: Python as a Data Processor\nconfig:\n  flowchart:\n    htmlLabels: false\n---\nflowchart LR\n\ninput((\"Python\n        Commands\"))\ncomputer[\"Python Command Shell\"]\noutput((\"Results\"))\n\ninput--&gt;computer\ncomputer--&gt;output\n\n\n\n\n\n\n\nCommands are the input which are processed by the python command shell (the computer) and turned into results (output)\n\n\n\n\nStart up a python interpreter and run the following\n\nhello\n\nhello\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[1], line 1\n----&gt; 1 hello\n\nNameError: name 'hello' is not defined\n\n\n\n\nThe interpreter doesn’t recognise the arbitrary word hello and produces an error message\n\n2\n\n2\n\n2\n\n\n\nThe interpreter echoes a number back out!\n\n2 + 2\n\n2 + 2\n\n4\n\n\n\nThe interpreter evaluates and echoes out the arithmetic!\n\n\n2 + 2 in the previous example is a representation of an expression\nPython can be seen as an expression evaluator. An expression consists of operators that act on operands to produce new output\nWe can break down the 2+2 example from the previous example to\n\n\n\n\n\n\nblock-beta\n    columns 3\n    space\n    title[\"Breakdown of a Simple Expression\"]\n    space\n\n    block:Input\n    columns 1\n        operand1[\"2\"]\n        operand1Word[\"Operand\"]\n        operand1descr[\"(thing to work on)\"]\n    end\n\n    block:Middle\n    columns 1\n        operator[\"+\"]\n        operatorWord[\"Operator\"]\n        operatorDescr[\"(thing to do)\"]\n    end\n\n    block:Output\n    columns 1\n        operand2[\"2\"]\n        operand2Word[\"Operand\"]\n        operand2descr[\"(thing to work on)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass operand2Word BG\nclass operand2descr BG\nclass operand1Word BG\nclass operand1descr BG\nclass operatorWord BG\nclass operatorDescr BG\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAs seen in the previous example, when invalid code is entered into the shell, an error message occurs. The same happens for an incomplete expression. e.g. the following is a shell sequence,\n\n2+\n\n\n  Cell In[4], line 1\n    2+\n      ^\nSyntaxError: invalid syntax\n\n\n\n\n\n\n\n\n\n\nWhat do you think would happen if you tried to evaluate 2+3*4?\n\nWe would expect 14 from the basic mathematical order of operations. Plugging this into the shell,\n\n\n 2 + 3 * 4\n\n14\n\n\nWhat do you think would happen if you tried to evaluate (2+3)*4?\n\nWe would expect 20 from the basic mathematical order of operations. Plugging this into the shell,\n\n\n (2 + 3) * 4\n\n20\n\n\nWhat do you think would happen if you tried to evaluate (2+3*4?\n\nWe might expect a syntax error\nInstead the interpreter, simply goes to a new line, and waits for us to enter the matching parenthesis\nOne such sequence in the shell might be,\n\n\n (2 + 3 * 4\n )\n\n14\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThere a different implementations of the Python Interpreter\nThese notes use a slightly different version of a python interpreter called a Jupyter Notebook to render the inline code. In Jupyter Notebooks code is written in cells and executed cell-by cell. This means that the interpreter can’t wait for the user to provide the missing input, so instead we get the slightly different error message below,\n\n\n\n (2 + 3 * 4\n\n\n  Cell In[8], line 1\n    (2 + 3 * 4\n              ^\nSyntaxError: incomplete input\n\n\n\n\nWhat do you think would happen if you tried to evaluate )2+3*4?\n\nIf we see a right parenthesis before a left parenthesis there is no way to retroactively go back and fix the missing left, like in the previous case where the shell simply waited for us to add the parenthesis\nSo here we would expect a syntax error\n\n\n )2+3*4\n\n\n  Cell In[9], line 1\n    )2+3*4\n    ^\nSyntaxError: unmatched ')'\n\n\n\n\n\n\n\n\n\n\nWe can use the interpreter like this to work line by line because python is a “scripting” language\n\ni.e. The program reads a line and then interprets the output\n\n\n\n\n\n\n\n\nNote\n\n\n\nNot all languages are scripting languages\nNot all languages are scripting languages. Some are converted to low-level hardware instructions. This is called compilation, and in place of an interpreter it requires a compiler to convert the code. Compiled programs are typically faster, since they can be optimised\n\n\n\n\n\n\n\nComputers fundamentally represent data as \\(0\\) or \\(1\\) in binary\n\nWe build up layers of abstract that let us handle concepts like numbers, characters and strings of text\n\nData can be regarded as the stored values representing information\nInformation is thus the interpretation of data, to mean something\n\n\n\n\nPython scripts thus can be considered data processors\n\nThe script is interpreted and converted to output\n\n\n\n\nStart up the python interpreter and run the following\n\n'hello'\n\n 'hello'\n\n'hello'\n\n\n\nLike before with \\(2\\) the word is echoed.\n\n'hello' + ' world'\n\n 'hello' + 'world'\n\n'helloworld'\n\n\n\n“Adding” two words performs a string concatenation\nObserve we explicitly have to include the space character in one of the strings\nA cool observation is that + changes it’s behaviour in response to what it’s arguments are\n\n\n\n\n\n\nWhat do you think would happen if missed the closing quote of a string you were typing?\n\nWe would expect it, to either hang waiting for the closing quote like with the missing left parenthesis, or a syntax error like a right quote. We find,\n\n  'hello\n\n\n  Cell In[12], line 1\n    'hello\n    ^\nSyntaxError: unterminated string literal (detected at line 1)\n\n\n\n\nEOL stands for “End of Line”\nOperands like strings and numbers can’t span multiple lines\nA string literal is just a string there in the code\n\nWhat do you think would happen if you tried to subtract one string from another?\n\nWhile addition of strings can be easily seen as concatenation, there is no meaningful equivalent for subtraction.\nWe could think of it as substring removal, but that has a lot of nuance that is hard to capture in a single symbol. We expect an error.\n\n  'hello' - ' world'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[13], line 1\n----&gt; 1 'hello' - ' world'\n\nTypeError: unsupported operand type(s) for -: 'str' and 'str'\n\n\n\nThe error message is somewhat obtuse but simply means that for the operand (-) we can’t subtract a string from another string\nTypeError indicates that something has gone wrong with the type of the data (here the type is string)\n\nWhat do you think would happen if you tried to add a number to a string?\n\nThis one can vary. There a two valid interpretations,\n\nYou can’t add a number to a word\nTreat the number as word, and concatenate it\n\nMost languages, use the former choice and so we make the assumption that python does too\n\n\n 'hello' + 2\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[14], line 1\n----&gt; 1 'hello' + 2\n\nTypeError: can only concatenate str (not \"int\") to str\n\n\n\n\nThe result is as expected, the error tells we can only concatenate a string to another string\n\nWhat do you think would happen if you tried to multiply a string by a number?\n\nAgain there are two interpretations,\n\nYou can’t multiply a word by a number\nYou can consider word * 3 as adding word three lots of word, where adding is string concatenation\n\nLets see what choice python uses,\n\n  'hello' * 3\n\n'hellohellohello'\n\n\nThe moral? Python tries to do something sensible when it can\n\n\n\n\n\n\n\nPython separates numerical data (e.g. 2) from text data (e.g. '2')\n\nNumerics and text are stored differently\n\nBehaviour of operators depends on the data types fed into them as operands\n\n\n\n\n\n\nA function is behaviour with a distinct name\n\ne.g. “Move left” is name for a distinct behaviour\n\nPython comes bundled with a number of built-in functions\n\n\n\n\n\n\n\nImportant\n\n\n\nFunctions are a critical part of programming languages\nLearning a new language often involves learning the functions it naively supports.\n\n\n\n\n\nord is a short name for ordinal value\n\nBuilt-in function, mean’s “give me the number representing this character”\nLet’s examine the use,\n\nord('W')\n\n87\n\n\n\n\n\n\nStart up a python interpreter, and run the following,\n\nord('W')\n\n ord('W')\n\n87\n\n\n\nThis matches our first example\n\nord(W)\n\n ord(W)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[18], line 1\n----&gt; 1 ord(W)\n\nNameError: name 'W' is not defined\n\n\n\n\nHere we get an error\nord is quite pedantic, requiring it’s argument to be a single character string\n\n\n\nObserve a function is called with the structure (using ord as an example),\n\n\n\n\n\n\nblock-beta\n    columns 4\n    space\n    title[\"Function Call Structure\"]:2\n    space\n\n    block:name\n    columns 1\n        ord[\"ord\"]\n        functionName[\"function name\"]\n        fndescr[\"(thing we want done)\"]\n    end\n\n    block:leftParenthesis\n    columns 1\n        leftP[\"(\"]\n        leftPname[\"Parenthesis\"]\n        space\n    end\n\n    block:argumentblock\n    columns 1\n        argument[\"'W'\"]\n        argumentName[\"argument\"]\n        argumentDescr[\"(thing to give function)\"]\n    end\n\n    block:rightParenthesis\n    columns 1\n        rightP[\")\"]\n        rightPname[\"Parenthesis\"]\n        space\n    end\n\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass ord BG\nclass functionName BG\nclass fndescr BG\nclass leftP BG\nclass leftPname BG\nclass argument BG\nclass argumentName BG\nclass argumentDescr BG\nclass rightP BG\nclass rightPname BG\n\n\n\n\n\n\n\n\n\n\n\nThe chr function is the counterpart to ord\n\nConverts numbers to text\n\n\n  chr(87)\n\n'W'\n\n\n\n\n\nStart up a python interpreter, and run the following,\n\nchr(87)\n\n chr(87)\n\n'W'\n\n\n\nExactly what we saw before, and what we would expect from ord\n\nchr(88)\n\n chr(88)\n\n'X'\n\n\n\nObserve that there is some logical progression.\nX comes after W in the alphabet, and does so in numerical representation\n\n\n\nInternational standards govern text representation\n\nHowever, older languages, software or hardware that predates these standards may not follow them\n\n\n\n\n\n\n\nAs mentioned before, computers store data in binary\nEach \\(0\\) or \\(1\\) is called a bit, a byte is typically a collection of \\(8\\) bits, and the smallest addressable unit of memory\nBytes can be grouped together to represent larger blocks of data\nbin converts a number to a string containing it’s binary representation\n\n\n\nUse the bin function to investigate how data is stored in a computer, start by running,\n\nbin(87)\n\n'0b1010111'\n\n\n\nbin returns a string giving the binary representation\n\ni.e. a string of 1’s and 0’s\n\nThe prefix 0b indicates that the remaining suffix is the binary representation of a number\n\n\n\n\nAnswer the following questions about binary representations\n\nWhat does the binary value of \\(0\\) look like?\n\nWould expect this to also be \\(0\\)\n\n\n bin(0)\n\n'0b0'\n\n\nWhat does the binary value of \\(1\\) look like?\n\nWould also expect this to be \\(1\\)\n\n\n bin(1)\n\n'0b1'\n\n\nWhat does the binary value of \\(2\\) look like?\n\nIn binary, digits are in columns of powers of \\(2\\) i.e. \\(1\\) like before is viewed as \\(1 \\times 2^{0}\\)\n\\(2\\) can be viewed as \\(1 \\times 2^{1} + 0 \\times 2^{0}\\), so we would expect the representation to be \\(10\\)\n\n\n bin(2)\n\n'0b10'\n\n\nWhat do you think the binary value of \\(11\\) means?\n\nIf we consider the above discussion, we expect this to be decimal \\(3\\)\n\n\n 3\n\n3\n\n\nHow does the binary value \\(86\\) differ from the binary value of \\(87\\)?\n\nLets look at 87 first.\n\n\n bin(87)\n\n'0b1010111'\n\n\n\n\\(86\\) differs by one, so we would expect \\(86\\) to be \\(1010110\\)\n\n\n bin(86)\n\n'0b1010110'",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 2: Python and Programming"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/02_PythonAndProgramming/Chapter_02.html#summary",
    "href": "01_ProgrammingFundamentals/02_PythonAndProgramming/Chapter_02.html#summary",
    "title": "Chapter 2: Python and Programming",
    "section": "Summary",
    "text": "Summary\n\nComputers view data as binary\nComputers process input data into output data\nHumans interpret data as information\nComputers do not naturally understand meaningful or nonsense input or output\nA program is the process of telling a computer how to convert input data into output data\n\nProgramming languages are a way to write these programs that the computer understands\n\nPython is one such language\n\nIt can also be viewed as a program that takes language statements, and then converts them to orders for the computer to carry out\n\nProgrammers create sequences of instructions to describe the task a computer needs to carry out\n\nGood code means knowing what the code needs to do\nFormal requirements solicitation and communication skills are key for programmers",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 2: Python and Programming"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/02_PythonAndProgramming/Chapter_02.html#question-and-answers",
    "href": "01_ProgrammingFundamentals/02_PythonAndProgramming/Chapter_02.html#question-and-answers",
    "title": "Chapter 2: Python and Programming",
    "section": "Question and Answers",
    "text": "Question and Answers\n\nWould a computer “know” that its stupid for someone to have an age of \\(-20\\)?\n\nNo. As far as the computer is concerned, the age value is just a pattern of bits that represents a number. If we want a computer to reject negative ages, we must actually build that understanding into the program\n\nIf the output from a program is settings for the fuel-injection system on a car, is the output data or information?\n\nAs soon as something starts acting on data, it becomes information. A human being is not doing anything with these values, but they will cause the speed of the engine to change, which might affect humans, so this makes the output information rather than data by the authors opinion\n\nIs the computer stupid because it can’t understand English?\n\nNo, english can be a quite ambiguous language. The legal profession is an example of somewhere were debate over the semantics of language is tricky\n\nIf I don’t know how to solve a problem, can I write a program to do it?\n\nNo, you need to understand the solution before you can write it and make sure that it does exactly what you want it to do\n\nIs it sensible to assume the customer measures everything in inches?\n\nIt’s never sensible to assume anything about a project. Every assumption increases the chance of a potential disaster\n\nIf the program does the wrong thing, is it my fault or the customer’s fault?\n\n\n\n\nSpecification?\nProgram?\nWhose Fault?\n\n\n\n\nRight\nWrong\nProgrammer\n\n\nWrong\nRight\nCustomer\n\n\nWrong\nWrong\nEveryone",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 2: Python and Programming"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/04_WorkingWithVariables/Chapter_04.html",
    "href": "01_ProgrammingFundamentals/04_WorkingWithVariables/Chapter_04.html",
    "title": "Chapter 4: Working With Variables",
    "section": "",
    "text": "Variables let us add memory to python\n\nCan be viewed as an alias for a storage location\n\nVariables in python are created by defining a name, and providing a value, e.g. the below defines a variable total and assigns it the value \\(0\\)\n\n\ntotal = 0\n\n\n\n\n\n\nblock-beta\n    columns 3\n    space\n    title[\"Anatomy of Variable Assignment\"]\n    space\n\n    block:variable\n    columns 1\n        varName[\"total\"]\n        variablebody[\"variable\"]\n        variableDescr[\"(thing to which value assigned)\"]\n    end\n\n    block:equals\n    columns 1\n        equalsSymbol[\"=\"]\n        equalsName[\"equals\"]\n        equalsDescr[\"(means assign)\"]\n    end\n\n    block:argumentblock\n    columns 1\n        zero[\"0\"]\n        zeroName[\"expression\"]\n        zeroDescr[\"(value to assign)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass variablebody BG\nclass variableDescr BG\nclass equalsName BG\nclass equalsDescr BG\nclass zeroName BG\nclass zeroDescr BG\n\n\n\n\n\n\n\nThe above diagrammatically breaks down variable assignment. On the left we have the variable, then = which means assignment, followed by the expression to assign\nThe assignment expression does not need to be made of simple primitives, e.g. total = us_sales + world_wide_sales defines the variable total to be equal to the sum of the variables us_sales and world_wide_sales\n\n\n\nStart up a python interpreter, then run the following commands in sequence\n\ntotal = 0\n\n total = 0\n\n\nNo output is generated, the assignment is performed silently\n\ntotal\n\n total\n\n0\n\n\n\n0 output\ntotal has been assigned 0, putting the variable name into the terminal returns the value associated with this value\n\ntotal = total + 10\n\n total = total + 10\n\n\nNo output\nLike with the first statement, variable assignment generates no output\nHere we assign total the value given by the current value of total plus \\(10\\)\n\ntotal\n\n total\n\n10\n\n\n\n10 output\nThe new value of total is printed\n\n\n\n\n\n\nVariables require names\nPython variable names must obey a number of rules\n\nMust start with a letter or _\nCan contain letters, numbers or _ characters\n\nSome valid names are\n\ntotal\nxyz\nt0tal\n\nSome invalid names are\n\n2_be_or_not_to_be\n\nStarts with a number which is not allowed\n\ntot@l\n\n@ is not a valid character for a variable name\n\n\nPython names are case sensitive, i.e. FRED and fred are distinct variables\n\n\n\n\n\n\n\nTip\n\n\n\nCreate Meaningful Names\nDon’t use silly or meaningless names like hello_mom. Use meaningful names that convey information about what they represent like length or length_in_centimetres. The PEP8 style guide, sets out how to write and format python programs. This includes a section on naming conventions\nSome languages recommend using camel case for variable naming. In this format words in a variable are distinguished by capital letters, but the first letter of the variable is lower case, e.g. lengthInCentimetres. Camel case is called this because the capital letters look like the humps of a camel. Either standard works, but when writing python it is best to stick to the python style guides\n\n\n\nPython does not limit the length of variable names\n\nThere should be no performance cost associated with long variable names\nLonger names can be hard to read\nNames should be no longer than they need to convey clear meaning\n\n\n\n\n\nYou’ve already seen that python can generate errors when it is unable to interpret an input. Answer the following questions to investigate how errors can arise in using variables. Assume that total has already been defined\n\nCan you identify an error in the statement below, which is supposed to add \\(10\\) to the variable total?\n\n # clearing saved variables in the notebook\n %reset\n\n\n total = 0\n Total = total + 10\n\n\nVariable names are case-sensitive. Therefore Total and total are distinct variables. So this declares a new variable Total and assigns it the value of total + 10. The value of total itself is unchanged.\nThis is a logic error, it is a legal statement in python that generates the wrong behaviour\n\nLogic errors are some of the hardest errors to deal with since they (typically) don’t stop a program running, they just produce incorrect behaviour\nPython typically cannot warn you about them ahead of time\n\nThis variable mis-assignment is why python style guides recommend the use of all lowercase letters for variable names\n\n\n\n\n\n\n\nNote\n\n\n\nIdentifying Errors\nOther languages with more strict type systems and variable declarations, may be able to identify logic errors like the one above.\n\n\nHow do we prevent logic errors?\n\nTesting\n\ni.e checking that the actual behaviour of a program matches the expected behaviour\nRun a program with input that will generate a known output when running correctly\n\nVerify the program generates this output\n\n\nTesting doesn’t guarantee a program is correct\n\nTypically hard to check all inputs and use cases\nDoes however give confidence and can provide that a program isn’t correct\n\nTypically tests should be written as the program is created or if using test-driven development the tests are written before the program itself is written\n\nThe statement below also contains a misspelling of the variable total. However, this time the name on the right-hand side of the equals is misspelled. What will happen when this program runs?\n\n # Again clear the notebook variables\n %reset\n\n\n total = 0\n total = Total + 10\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 2\n      1 total = 0\n----&gt; 2 total = Total + 10\n\nNameError: name 'Total' is not defined\n\n\n\n\nIn this case, Total is not defined as a variable, so there is no meaningful way to interpret a value. Hence we would expect an error. Since the error is that Total doesn’t exist, we see a NameError.\n\n\n\n\n\nConsider the Nerves of Steel exercise from Chapter 3. In the game, players must remain standing right up to the moment before they think a random timer will expire\nOne suggestion is that the game might provide more skill if the program told the players how long they had to stand. The game now functions as a “Self-Timer”, the winner is now arguably the person who can best keep track of the time\nThe “game” sequence is\n\nSet the time to remain standing to a random number\nDisplay time to remain standing\nSleep for the time to remain standing\nDisplay a message for the winner\n\nObserve that the time is required to be used in two places, displaying the time remaining and then sleeping for that period of time. This means we need to use a variable to store the value of the time remaining\n# Example 4.1: Self Timer\n#\n# Extends the Nerves of Steel Game from Chapter 3, by adding a skill element\n# with the players being informed of how long they have to stand for\n\nimport random\nimport time\n\nprint(\"Welcome to Self Timer\")\nprint()  # just prints a newline\nprint(\"Everybody stand up\")\nprint(\"Stay standing until you think the time has ended\")\nprint(\"Then sit down\")\nprint(\"Anyone still standing when the time expires loses\")\nprint(\"The last person to sit down before the time ended will win\")\n\nstand_time = random.randint(5, 20)  # generate the time to stand for\n\nprint(\"Stay standing for\", stand_time, \"seconds.\")  # display standing time\ntime.sleep(stand_time)  # sleep for the standing time\nprint(\"****TIMES UP, LAST TO SIT WINS!****\")\n\n\nWelcome to Self Timer\n\nEverybody stand up\nStay standing until you think the time has ended\nThen sit down\nAnyone still standing when the time expires loses\nThe last person to sit down before the time ended will win\nStay standing for 9 seconds.\n****TIMES UP, LAST TO SIT WINS!****\n\n\nMost of the code is just text, but the key takeaway is the line stand_time = random.randint(5, 20) which assigns stand_time the result of random.randint(5, 20), i.e a random number from 5 to 20 inclusive. We then call stand_time is our call to print to display the time, and then sleep for the same amount of time. Observe we couldn’t just write the number into both functions explicitly since it’s randomly generated, we would need to know ahead of time what the value will be\n\n\n\n\n\nVariables can also hold text, e.g. customer_name = 'fred' assigns the string 'fred' to customer_name\nCan use a string variable anywhere we would use a string literal, e.g. message = 'the name is ' + customer_name performs the string concatenation of 'the name is' and the value of customer_name and assigns the result to message, which we can confirm below,\n\n\n  customer_name = \"fred\"\n  message = \"the name is \" + customer_name\n  print(message)\n\nthe name is fred\n\n\n\n\nPython tracks the contents of each variable and only allows operations that make sense. Using the python interpreter experiment with the following combinations of string and number variables.\n\ncustomer_age_in_years = 25\ncustomer_name = 'fred'\n\nAfter entering the above two lines in the interpreter, run the following line\n\ncustomer_age_in_years + customer_name\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[13], line 1\n----&gt; 1 customer_age_in_years + customer_name\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\n\nHere we are trying to add a number and a string, which we saw previously shouldn’t work. The terminal should provide some error output like the below\nNow try the below line\n\ncustomer_age_in_years = 'Fred'\n\nOne might expect the above to generate an error, after all we assign text to a variable that was just storing a number. Instead python simply discards the old numeric value of the variable, and now stores text in customer_age_in_years. You should generally avoid doing this, being able to reason about the type of a variable is typically an important part of safe and effective programming, and the weak typing of python is typically disliked outside of quick prototyping\n\n\n\n\n\n\nNote\n\n\n\nWeak vs Strong Typing\nThe above behaviour is an example of python as a what’s called a weakly typed language. Types are a quite developed part of programming theory that can be discussed later. In some languages, types are enforced to greater degrees of strictness. In some languages (like C) you can assign variables compatible types, i.e. ones that can be converted to the variable’s innate type. In other stricter languages a variable can only hold the exact specified type\nThe more strictly a language enforces its typing system typically the harder it is to generate errors at runtime, however they are often correspondingly more painful to actually write the code in the first place\n\n\n\n\n\n\nPython lets you use either single-quotes (’) or double-quotes (“)\n\nLets us include ’ or ” in a string, by using the alternate delimiter\n\nFor example, compare the two quote snippets,\n\n\nprint(\"It's a trap\")\n\nIt's a trap\n\n\n\nWhereas if we tried to just use single quotes,\n\n\nprint('It's a trap')\n\n\n  Cell In[16], line 1\n    print('It's a trap')\n                      ^\nSyntaxError: unterminated string literal (detected at line 1)\n\n\n\n\n\nThe single quote in It's ends the string, and we get a syntax error detecting what should be the closing single quote as opening a new string literal\nHow do we handle the case where we have mixed quotes in a string?\n\nWe use triple quotes, a series of three single or double quotes in a row, see the example below\n\n\n\nprint('''...and then Luke said \"It's a trap\"''')\n\n...and then Luke said \"It's a trap\"\n\n\n\nTriple quoted strings have the added advantage of capturing newlines. To see this, we could rewrite the intro string in Nerves of Steel as\n\n\nprint('''Welcome to Nerves of Steel\n\nEverybody stand up\nStay standing as long as you dare.\nSit down just before you think the time will end. ''')\n\nWelcome to Nerves of Steel\n\nEverybody stand up\nStay standing as long as you dare.\nSit down just before you think the time will end. \n\n\n\n\n\n\n\n\nCaution\n\n\n\nString Delimiters must Match\nYou must using matching delimiters, if we try to mix them we’ll get an error\n\nprint('hello\")\n\n\n  Cell In[19], line 1\n    print('hello\")\n          ^\nSyntaxError: unterminated string literal (detected at line 1)\n\n\n\n\n\n\n\n\n\n\nEscape sequences are another way to include quote characters\nExtends to other symbols with meaning other than their literal character glyph in a string\nDenoted by the \\ character\n\n\n\n\n\n\n\n\n\nEscape Sequence\nMeaning\nEffect\n\n\n\n\n\\\\\nBackslash character (\\)\nEnter a backslash into a string\n\n\n\\'\nSingle Quote (')\nEnter a single quote into the string\n\n\n\\\"\nDouble Quote (\")\nEnter a double quote into the string\n\n\n\\n\nASCII Line Feed/New Line\nEnd this line and take a new one\n\n\n\\t\nASCII Tab\nMove to the right to the next tab stop\n\n\n\\r\nASCII Carriage Return\nReturn the printing position to the start of the line\n\n\n\\a\nASCII Bell\nSound the bell on the terminal\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nASCII\nASCII (short for American Standard Code for Information Interchange) is an old format for character encoding that covers a small range of symbols including the latin alphabet and digits.\nASCII itself is less used today since it only covers around \\(100\\) characters, which is nowhere near enough to cover all modern languages, before you start adding in characters like emojis. However modern text encoding like unicode are typically backwards compatible with ASCII.\nNot all ASCII escape sequences may work on a modern computer. \\a was designed to ring a mechanical bell on old computers. Some modern computers may play a beep while others may do nothing. Similarly \\r is supposed to return the print head of a computer back to the start of the line. This has very limited use cases, and may not be implemented on all systems.\nThe most common escape characters are newline \\n and escaping quotes\n\n\n\n\n\n\n\n\nImportant\n\n\n\nNewline in Python\nPython uses \\n as the newline character. Technically this is known as a line feed and means “go to the next line”. In Linux and similar operating systems this is equivalent to starting a new line, but in windows going to the start of a new line is achieved via \\r\\n, i.e. return to the start of the line, and then feed to the next. Luckily python handles the conversion between the conventions automatically and we can just use \\n regardless of the operating system we are actually running on\n\n\n\n\nStart a python interpreter and answer the following questions\n\nWhat do you think the following quote would print?\nprint('hello\\nworld')\n\nWe would expect this print hello on one line, then world on the next\n\n\n\nhello\nworld\n\n\nWhat do you think the following would print?\n print('Item\\tSales\\ncar\\t50\\nboat\\t10')\n\nWe can see this prints a series of tab separated lines. So this is essentially a tab separated table (a similar format to the more familiar comma-separated table)\n\n\n\nItem Sales\ncar  50\nboat 10\n\n\n\nThe exact spacing of tab characters can depend on the computer system, and it is quite common for text editors to convert tabs to spaces, so this format isn’t the best. We’ll see other ways to format strings later\n\nHow could I use Python escape sequences to print out this message?\n\nand then Luke said “It’s a trap”\n\n\nWe saw how to do this with triple-delimited strings before. Instead we just have to remember to instead use a single-delimiter string and then escape the quotes that actually form the string contents. See,\n\n\n print('and then Luke said \"It\\'s a trap\"')\n\nand then Luke said \"It's a trap\"\n\n\n\n\nSince the string is delimited by single quotes we only have to delimit the one single quote in It's rather than the two double quotes\n\n\n\n\n\n\nWe’ve seen how to output data with print\nWe can also input data with the appropriately named input\nThe code snippet below, takes input from the user and stores it in name\n\n  name = input()\n\nThe program will pause until the user supplies the input, (Try it yourself in the interpreter!)\nWe can add a display prompt to the input statement\n\n  name = input('Enter your name please: ')\n\nThe above should output something like the below when run\n\n\n\nEnter your name please: \n\n\n\nAs mentioned input passes what it receives into the receiving variable.\n\nIf we just immediately press enter this is the empty string i.e. a string containing no characters\n\ninput is another technique for delaying the end of a program, e.g. the below prints a prompt and then holds the program until some input is received\n\ninput('Press enter to continue...')\n\n\nUse python to create a simple program that will issue a personalised greeting. Create a new program (greeter.py) with the following contents\nname = input('Enter your name please: ')\nprint('Hello', name)\nSave the program and execute it to see the output. For me the program would output,\n\n\n\nEnter your name please: Felix\n\nHello Felix\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nI’ve used colour to emphases what is my input, versus the program’s output\n\n\n\n\n\n\n\n\n\n\ninput returns a string\n\nFine if we want that, but what if we want to handle numbers?\ne.g. if we wanted to have a user-specified egg timer\n\nint is a function that converts the argument to a whole number e.g.\n\ntime_text = input('Enter the cooking time in seconds: ') #receive time in seconds\ntime_int = int(time_next) #perform conversion to number\n\n\n\nThe complete program would then look like,\n  # Example 4.3: Configurable Egg Timer\n  #\n  # Reads in a user specified time to set the timer for\n\n  import time\n\n  time_text = input(\"Enter the cooking time in seconds: \")\n  time_int = int(time_text)\n\n  print(\"Put the egg in boiling water now\")\n  input(\"Press enter to continue once the egg is in...\")\n\n  time.sleep(time_int)\n\n  print(\"Take the egg out now\")\nThis basic pattern works just as well for an alarm as it does for a configurable timer\n\n\n\n\nConsider the previous example, and answer the following questions\n\nHow many variables are used in the program above?\n\ntwo, the first time_text stores the initial text input, while the second time_int contains the converted numeric representation\n\nCould you write the program without the time_text variable?\n\nYes, we could immediately pass the input result to int, e.g.\n\n time_int = int(input('Enter the cooking time in seconds: '))\n\nIt’s an open debate which format is clearer. In the second there’s more to grok on one line, but the whole workflow is there\n\nWhat do you think will happen if the user enters something other than a number?\n\nLet us find out,\n\n\n x = int('kaboom')\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[25], line 1\n----&gt; 1 x = int('kaboom')\n\nValueError: invalid literal for int() with base 10: 'kaboom'\n\n\n\n\nWe get an error, int tries to convert the string 'kaboom' to an integer, which it clearly cant\nThe art of programming to handle invalid input like the above is called error-handling, we’ll see that later\n\n\n\n\n\n\n\nThere are two types of numbers\n\nWhole numbers or integers\n\nAre always held accurately by the computer\n\nReal numbers (or representations of) or floating point\n\nContain a fractional component\nMust be truncated to be stored in memory, so cannot always be stored accurately\n\n\n\n\n\nLearn about the differences between whole numbers and real numbers through the following questions\n\nI’m building a device that can count the number of hairs on your head. Should this be stored as a whole or real number?\n\nInteger, we generally wouldn’t count fractions of a hair\nAlternatively, given how many hairs there are, and that we might not care about being precise, we might instead want to use a real number to store the approximate magnitude\n\nI want to use my hair-counting machine on \\(100\\) people and determine the average number of hairs on all their heads. Should I use this value as a whole or real number?\n\nWe expect that the average will not be a whole number, so we should store it as a real number\nAlternatively, we may not care about getting the number exact down to the fraction, so we could use a whole number to round to the nearest number\n\nI want to keep track of the price of a product in my program. Should I use whole numbers or real numbers?\n\nNaively we would a real number, however as we mentioned real numbers have some uncertainty stored in them\nWhen dealing with financial values we need to maintain that precision\n\nInstead we might then use whole cents\n\nWorks straightforward if we only care about the total\nIf we care about averages, or fractions of a total then we might have to reconsider\n\nThere are techniques used to control the error in a real number calculation\n\n\n\n\nAs you can see the argument of what numerical type to use, requires understanding both the nature of the value itself, and what you want to do with it. You can then consider the properties of the numeric representation and choose the most appropriate one\n\n\n\n\n\n\n\nImportant\n\n\n\nThe way you store a variable depends on what you want to do with it\nAs the discussion above highlights, sometimes the answer to how we want to store data is not the immediate first answer. It’s important to consider not just what the natural representation of a value is, but what it’s purpose in the code is.\nFor example as we discussed above, money is naturally expressed as real numbers. However due to the it’s use case, which requires high precision and also generally a limited range (values of even a trillion are rare, and we typically only consider down to whole cents) compared to the full range of a floating point number we might want to look at alternative representations\n\n\n\n\n\n\n\nReal numbers have a fractional part\n\nTheir representation may not align 1:1 with what was originally input\n\nThe most common way to store real numbers is called floating point\n\nThe floating means that the decimal point moves around in the representation, as opposed to a fixed point representation which has a set number of digits after the decimal point\nUsing more memory to store a float lets us store it with greater precision, but we can never accurately represent all floating point numbers\n\nReal numbers can be defined by range and precision\n\nPrecision governs how precisely a number is stored e.g. a float may be able to store \\(123456789.0\\) or \\(0.123456789\\) but not \\(123456789.987654321\\) because the precision required is too great\nRange determines how much we can slide the decimal point to represent large or small numbers e.g. we could store \\(123456700\\) or \\(0.0001234567\\)\nIn Python floats have \\(15-16\\) digits of precision and can range from \\(10^{308}\\) and \\(10^{-324}\\)\n\nA quirk of floating point is that some apparently simple numbers like \\(0.1\\) can’t be stored exactly\n\n\n\nConduct the following experiments in the python shell to learn about floating points\n\nWhat happens if we try to store a value that can’t be held accurately as a floating-point value?\n\n0.1\n\n0.1\n\n\n\nAbove we said that \\(0.1\\) couldn’t be exactly represented, but that doesn’t match with what we just saw. The answer is because the error in the representation is very small, and print rounds off the answer\n\nDoes the rounding really happen? Run the following and comment on the result\n\n 0.1 + 0.2\n\n0.30000000000000004\n\n\n\nWe expected the answer to be \\(0.3\\) but instead we see a slight error. This is because there is an error accumulation from adding \\(0.1\\) to \\(0.2\\) and the underlying floating point representations\n\n\n\nThese issues are not python specific. They are an innate challenge of trying to represent real numbers on hardware. Modern floating-point numbers are also an internationally recognised standard which lets different programs and hardware talk to each other.\nPython differs from some languages in only providing a single floating point type that is \\(8\\) bytes. In many languages this is referred to as a double-precision floating point or just a double and is one of several floating point types\n\n\n\n\n\n\n\nWarning\n\n\n\nDon’t confuse precision with accuracy\nNumbers don’t become more accurate when they are stored with more precision. Scientists often measure values with a measure of uncertainty which captures how sure they are in the accuracy of their number. There is no point storing a value to \\(15\\) decimal places of precision, if the accuracy of a measurement is only to \\(1-2\\) places, e.g. if we measure with a ruler\nUsing higher precision can result in slower programs that use more memory\n\n\n\nPython automatically creates variables for use in programs\nThe type of a variable is determined by what is stored in it\n\nname = 'Rob'\nage = 25\n\nThe above creates two variables\n\nOne name is a string type\nThe other age is an int or integer type\n\n\n\n\n\nWork through the following following questions to understand how floating-point variables work?\n\nHow do you create a floating point variable?\n\nYou can create a floating point variable by assigning a floating point number e.g. the below creates a variable* x *and assigns it the floating point value \\(1.5\\)\n\n\n x = 1.5\n x\n\n1.5\n\n\nWhat happens if you assign an integer to a floating point variable?\n\nThe below assigns the integer value \\(1.0\\) to a variable y\nIf we print the value back we can see it keeps the decimal, indicating it is a floating point value\n\n\n y = 1.0\n y\n\n1.0\n\n\n\ni.e. by writing the decimal point we coerce the type of y to be floating point\n\nWhat happens when we mix floating point and integers in calculations?\n\nIf we compare the two additions below, we can see that when we add floating points, the addition stays a floating point even if the result is integral\n\n\n 2 + 2\n\n4\n\n\n\n 2.0 + 2.0\n\n4.0\n\n\n\nIf we mix a floating point and integer type we can also see that the result is returned as a floating point (even when the final result is integral)\n\n\n 2 + 2.0\n\n4.0\n\n\n\nLastly what happens if we divide two coprime integers?\nWe see that the result gives the appropriate floating point fraction\n\n\n 1/2\n\n0.5\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nInteger Division\nWhile the last point about division behaviour may seem obvious if you haven’t programmed before you would do well to be careful. In many common languages, division of two integers is treated as integer division. In this case the result is always an integer with the result being rounded according to some scheme. Three common schemes are towards zero, in which the result is always rounded towards the number \\(0\\); towards the nearest, where the result is rounded to the nearest whole number and floored division in which the number is rounded towards negative infinity.\n\n\n\n\n\n\n\n\nDivision\nExample\nInterpretation\n\n\n\n\ntowards zero\n\\(-1/2 = 0\\)\nDiscard decimal digits\n\n\ntowards nearest\n\\(3.2/2 = 2\\)\nMinimise the difference between “true” division and result\n\n\nfloored division\n\\(-1/2 = -1\\)\nRound “down”\n\n\n\nPython lets you perform integer division using floored division behaviour with the // operator e.g.\n\n-1//2\n\n-1\n\n\n\n\n\n\n\n\n\nConverting string to float, works identically to as for int but we use float instead\n\ne.g. We could rewrite the configurable egg timer with floats as,\n\n\ntime_text = input('Enter the cooking time in seconds: ')\ntime_float = float(time_text)\n\n\n\nThe complete program would then look like\n\n# Example 4.4 Ultra-Precise Egg Timer\n#\n# A version of the Configurable Egg Timer using floating point for the input time\n\nimport time\n\ntime_text = input(\"Enter the cooking time in seconds: \")\ntime_float = float(time_text)\n\nprint(\"Put the egg in boiling water now\")\ninput(\"Press enter to continue once the egg is in...\")\n\ntime.sleep(time_float)\n\nprint(\"Take the egg out now\")\n\nThe code is the same except we make the substitution int \\(\\to\\) float\n\n\n\n\n\n\nAs mentioned before python is an expression evaluator\nAn expression consists of operators and operands\nPython evaluates an expression left to right, and carries out operations according to their order of operations\n\nAnalogous to mathematical order of operations (and includes them) but must extend for programming specific syntax\nAs in maths, parentheses are used to enforce an evaluation order\n\n\n\n\n\nOperator\nUse case\n\n\n\n\n-\nUnary minus, denotes a negative number\n\n\n*\nMultiplication (in-lieu of \\(\\times\\))\n\n\n/\nDivision\n\n\n+\nAddition\n\n\n-\nbinary minus or subtraction\n\n\n\n\nBasic operators and their precedence\n\n\n\nSee if you can work out the values of a, b and c when the following statements are evaluated,\n    a = 1\n    b = 2\n    c = a + b\n\n    c = c * (a + b)\n    b = a + b + c\nThe first three lines give a = \\(1\\), b = \\(2\\) and c = \\(3\\). Substituting those into the second evaluation for c,\n\na = 1\nb = 2\nc = a + b\nc = 3 * (1 + 2)\nc\n\n9\n\n\nSo c is assigned \\(9\\). We then repeat for the second assignment to b to get,\n\nb = 1 + 2 + 9\n\nSo the final values are, a = \\(1\\), b = \\(12\\), c = \\(9\\). If we execute the original cell we can confirm this\n\na = 1\nb = 2\nc = a + b\n\nc = c * (a + b)\nb = a + b + c\n\nprint('a: ', a)\nprint('b: ', b)\nprint('c: ', c)\n\na:  1\nb:  12\nc:  9\n\n\n\n\n\n\n\n\nCaution\n\n\n\nDumb Calculations\nPython won’t try and stop you if you do something that mathematically makes no sense like dividing a number by zero, instead an error is raised, but this won’t occur until your program runs! Therefore when using division you should always take care to make sure you either handling division by zero cases appropriately or preventing them from occurring\n\n1/0\n\n\n---------------------------------------------------------------------------\nZeroDivisionError                         Traceback (most recent call last)\nCell In[38], line 1\n----&gt; 1 1/0\n\nZeroDivisionError: division by zero\n\n\n\nWhen using other languages, they may not raise and error, instead unexpected behaviour may occur including your program crashing.\n\n\n\n\n\n\n\nWe saw floatcan be used to convert a string to a float.\n\nIt can also be used to convert an integer value to a floating point value, e.g.\n\n\n\nz = float(1)\nz\n\n1.0\n\n\n\nIf we want to go the other way we can use int to convert a float to an int.\n\nThe number is rounded towards zero, i.e. fractional components are truncated (see the callout-box above about integer division)\n\n\n\ni = int(2.9)\ni\n\n2\n\n\n\n\nConsider the following program which is designed to calculate the number of pizzas needed for a hackathon with \\(x\\) number of participants using the heuristic that \\(1\\) pizza can satisfy \\(1.5\\) people\n# Example 4.5: Pizza Order Calculator\n#\n# A basic pizza order calculator based on the heuristic that 1 pizza = 1.5 people fed\n\nstudents_int = int(\n    input(\"How many students are attending? \")\n)  # read in string, convert to int and store\npizza_count = students_int / 1.5  # perform division int -&gt; float\nprint(\"You will need\", pizza_count, \"pizzas\")\nNote, that I’ve modified the code to directly pass the input to int and then to a variable, to demonstrate that it’s possible.\nThe above program has the problem that for any number not divisible by \\(1.5\\), the program recommends ordering a fractional number of pizzas. This is generally not possible, so we need to convert the output to an integer.\n\nModify the program to return an int by calling int directly during the calculation of pizza_count. What potential problems does this solution have?\n # Exercise 4.1.1: Pizza Order Calculator\n #\n # A basic pizza order calculator based on the heuristic that 1 pizza = 1.5 people fed\n\n students_int = int(\n     input(\"How many students are attending? \")\n )  # read in string, convert to int and store\n pizza_count = students_int / 1.5  # perform division int -&gt; float\n print(\"You will need\", pizza_count, \"pizzas\")\n\nThis method has the disadvantage that it will tend to underestimate the number of pizzas needed.\nFor example if we needed to feed \\(40\\) people, the program would give us \\(26\\), which can satisfy, \\(39\\) people, meaning someone goes hungry\n\nModify the program to return an int by calling int to convert the division to an int then adding \\(1\\). Explain how this changes the behaviour\n # Exercise 4.1.2: Pizza Order Calculator\n #\n # A basic pizza order calculator based on the heuristic that 1 pizza = 1.5 people fed\n # Converts the result to an integer using int on pizza_count then adding one\n # has the disadvantage it will tend to overestimate the number of pizzas needed\n\n students_int = int(\n     input(\"How many students are attending? \")\n )  # read in string, convert to int and store\n pizza_count = int(students_int / 1.5) + 1  # perform division int -&gt; float\n print(\"You will need\", pizza_count, \"pizzas\")\n\nThis method will tend to add an additional spare pizza or overestimate the number of pizzas needed.\nSince it’s generally better for there to be a little left over than someone go hungry, this behaviour is probably preferred.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nNever assume you know what a program is supposed to do\nWhen faced with a choice like the above for the pizza order calculator for a product being made by a client, you should not decide what the expected behaviour is yourself. For example, in the above the customer may prefer to round down the number of pizzas to reduce cost.\nNever assume you know what the program should do, ask the client\n\n\n\n\n\nWrite a program to convert from Fahrenheit to Centigrade. The formula for this is\n\\[\n\\begin{align}\n\\text{Centigrade} &= \\frac{\\text{Fahrenheit} - 32}{1.8}\n\\end{align}\n\\]\nOur solution is very similar to the Pizza Calculator, but with some of the text changed. The other major difference is that we want to be able to accept a float value, and output a float value.\n    # Exercise 4.2: Fahrenheit to Celsius\n    #\n    # Converts Fahrenheit to Celsius\n\n    temperature_fahrenheit = float(\n        input(\"Enter a temperature in Fahrenheit: \")\n    )  # read in string, convert to float\n    temperature_centigrade = (temperature_fahrenheit - 32) / 1.8\n    print(\"The temperature is\", temperature_centigrade, \"degrees Celsius\")\nA sample output may look like,\n\n\n\nEnter a temperature in Fahrenheit: 0\n\nThe temperature is -17.77777777777778 degrees Celsius\n\n\n\n\n\nLater we’ll see how we can format the output to be a bit more presentable\n\n\n\n\n\n\n\nSnaps contains a function get_weather_temp for to return the temperature of a location in the United States\n\nData is scraped from the US National Weather Service website\nFunction takes the latitude and longitude as an argument\n\n\n\n\n\nThe following program can be used to get the current temperature reading from Seattle using snaps\n\n  # Example 4.6: Seattle Temperature\n  #\n  # Get the current temperature in Seattle\n\n  import snaps\n\n  temp = snaps.get_weather_temp(latitude=47.61, longitude=-122.33)\n\n  print(\"The temperature in Seattle is:\", temp)\n\npygame 2.6.1 (SDL 2.28.4, Python 3.12.3)\nHello from the pygame community. https://www.pygame.org/contribute.html\n\n\n/home/runner/work/BeginToCodeWithPython/BeginToCodeWithPython/.venv/lib/python3.12/site-packages/pygame/pkgdata.py:25: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools&lt;81.\n  from pkg_resources import resource_stream, resource_exists\n\n\nThe temperature in Seattle is: 43\n\n\n\n\n\n\n\nWe can also use snaps to get a short description of the current weather\n\n  # Example 4.7: Seattle Weather\n  #\n  # Uses snaps to get a description of the weather in Seattle\n\n  import snaps\n\n  desc = snaps.get_weather_description(latitude=47.61, longitude=-122.33)\n  print(\"The conditions are:\", desc)\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[43], line 7\n      1 # Example 4.7: Seattle Weather\n      2 #\n      3 # Uses snaps to get a description of the weather in Seattle\n      5 import snaps\n----&gt; 7 desc = snaps.get_weather_description(latitude=47.61, longitude=-122.33)\n      8 print(\"The conditions are:\", desc)\n\nAttributeError: module 'snaps' has no attribute 'get_weather_description'\n\n\n\n\n\n\n\nWrite a program that displays the current weather conditions. If you use the display_text function from snaps, your program can display the current weather and description\nOur solution is written below,\n# Exercise 4.3: Weather Display\n#\n# Displays the Weather in Seattle\n\nimport snaps\n\ntemperature_fahrenheit = snaps.get_weather_temp(latitude=47.61, longitude=-122.33)\ntemperature_string = \"The temperature in Seattle is: \" + str(temperature_fahrenheit)\n\nweather_descr = snaps.get_weather_description(latitude=47.61, longitude=-122.33)\nweather_descr_string = \"The conditions are: \" + str(weather_descr)\n\nweather_string = temperature_string + \"\\n\" + weather_descr_string\n\nsnaps.display_message(weather_string, size=100)\n\ninput(\"Press enter to continue...\")\nAs we can see most the actual getting of the temperature and weather data is the same as for the Seattle Temperature and Weather programs. The rest of the work is done to construct the appropriate strings and merge them together so they can be passed to the display_message function for output",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 4: Working With Variables"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/04_WorkingWithVariables/Chapter_04.html#notes",
    "href": "01_ProgrammingFundamentals/04_WorkingWithVariables/Chapter_04.html#notes",
    "title": "Chapter 4: Working With Variables",
    "section": "",
    "text": "Variables let us add memory to python\n\nCan be viewed as an alias for a storage location\n\nVariables in python are created by defining a name, and providing a value, e.g. the below defines a variable total and assigns it the value \\(0\\)\n\n\ntotal = 0\n\n\n\n\n\n\nblock-beta\n    columns 3\n    space\n    title[\"Anatomy of Variable Assignment\"]\n    space\n\n    block:variable\n    columns 1\n        varName[\"total\"]\n        variablebody[\"variable\"]\n        variableDescr[\"(thing to which value assigned)\"]\n    end\n\n    block:equals\n    columns 1\n        equalsSymbol[\"=\"]\n        equalsName[\"equals\"]\n        equalsDescr[\"(means assign)\"]\n    end\n\n    block:argumentblock\n    columns 1\n        zero[\"0\"]\n        zeroName[\"expression\"]\n        zeroDescr[\"(value to assign)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass variablebody BG\nclass variableDescr BG\nclass equalsName BG\nclass equalsDescr BG\nclass zeroName BG\nclass zeroDescr BG\n\n\n\n\n\n\n\nThe above diagrammatically breaks down variable assignment. On the left we have the variable, then = which means assignment, followed by the expression to assign\nThe assignment expression does not need to be made of simple primitives, e.g. total = us_sales + world_wide_sales defines the variable total to be equal to the sum of the variables us_sales and world_wide_sales\n\n\n\nStart up a python interpreter, then run the following commands in sequence\n\ntotal = 0\n\n total = 0\n\n\nNo output is generated, the assignment is performed silently\n\ntotal\n\n total\n\n0\n\n\n\n0 output\ntotal has been assigned 0, putting the variable name into the terminal returns the value associated with this value\n\ntotal = total + 10\n\n total = total + 10\n\n\nNo output\nLike with the first statement, variable assignment generates no output\nHere we assign total the value given by the current value of total plus \\(10\\)\n\ntotal\n\n total\n\n10\n\n\n\n10 output\nThe new value of total is printed\n\n\n\n\n\n\nVariables require names\nPython variable names must obey a number of rules\n\nMust start with a letter or _\nCan contain letters, numbers or _ characters\n\nSome valid names are\n\ntotal\nxyz\nt0tal\n\nSome invalid names are\n\n2_be_or_not_to_be\n\nStarts with a number which is not allowed\n\ntot@l\n\n@ is not a valid character for a variable name\n\n\nPython names are case sensitive, i.e. FRED and fred are distinct variables\n\n\n\n\n\n\n\nTip\n\n\n\nCreate Meaningful Names\nDon’t use silly or meaningless names like hello_mom. Use meaningful names that convey information about what they represent like length or length_in_centimetres. The PEP8 style guide, sets out how to write and format python programs. This includes a section on naming conventions\nSome languages recommend using camel case for variable naming. In this format words in a variable are distinguished by capital letters, but the first letter of the variable is lower case, e.g. lengthInCentimetres. Camel case is called this because the capital letters look like the humps of a camel. Either standard works, but when writing python it is best to stick to the python style guides\n\n\n\nPython does not limit the length of variable names\n\nThere should be no performance cost associated with long variable names\nLonger names can be hard to read\nNames should be no longer than they need to convey clear meaning\n\n\n\n\n\nYou’ve already seen that python can generate errors when it is unable to interpret an input. Answer the following questions to investigate how errors can arise in using variables. Assume that total has already been defined\n\nCan you identify an error in the statement below, which is supposed to add \\(10\\) to the variable total?\n\n # clearing saved variables in the notebook\n %reset\n\n\n total = 0\n Total = total + 10\n\n\nVariable names are case-sensitive. Therefore Total and total are distinct variables. So this declares a new variable Total and assigns it the value of total + 10. The value of total itself is unchanged.\nThis is a logic error, it is a legal statement in python that generates the wrong behaviour\n\nLogic errors are some of the hardest errors to deal with since they (typically) don’t stop a program running, they just produce incorrect behaviour\nPython typically cannot warn you about them ahead of time\n\nThis variable mis-assignment is why python style guides recommend the use of all lowercase letters for variable names\n\n\n\n\n\n\n\nNote\n\n\n\nIdentifying Errors\nOther languages with more strict type systems and variable declarations, may be able to identify logic errors like the one above.\n\n\nHow do we prevent logic errors?\n\nTesting\n\ni.e checking that the actual behaviour of a program matches the expected behaviour\nRun a program with input that will generate a known output when running correctly\n\nVerify the program generates this output\n\n\nTesting doesn’t guarantee a program is correct\n\nTypically hard to check all inputs and use cases\nDoes however give confidence and can provide that a program isn’t correct\n\nTypically tests should be written as the program is created or if using test-driven development the tests are written before the program itself is written\n\nThe statement below also contains a misspelling of the variable total. However, this time the name on the right-hand side of the equals is misspelled. What will happen when this program runs?\n\n # Again clear the notebook variables\n %reset\n\n\n total = 0\n total = Total + 10\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 2\n      1 total = 0\n----&gt; 2 total = Total + 10\n\nNameError: name 'Total' is not defined\n\n\n\n\nIn this case, Total is not defined as a variable, so there is no meaningful way to interpret a value. Hence we would expect an error. Since the error is that Total doesn’t exist, we see a NameError.\n\n\n\n\n\nConsider the Nerves of Steel exercise from Chapter 3. In the game, players must remain standing right up to the moment before they think a random timer will expire\nOne suggestion is that the game might provide more skill if the program told the players how long they had to stand. The game now functions as a “Self-Timer”, the winner is now arguably the person who can best keep track of the time\nThe “game” sequence is\n\nSet the time to remain standing to a random number\nDisplay time to remain standing\nSleep for the time to remain standing\nDisplay a message for the winner\n\nObserve that the time is required to be used in two places, displaying the time remaining and then sleeping for that period of time. This means we need to use a variable to store the value of the time remaining\n# Example 4.1: Self Timer\n#\n# Extends the Nerves of Steel Game from Chapter 3, by adding a skill element\n# with the players being informed of how long they have to stand for\n\nimport random\nimport time\n\nprint(\"Welcome to Self Timer\")\nprint()  # just prints a newline\nprint(\"Everybody stand up\")\nprint(\"Stay standing until you think the time has ended\")\nprint(\"Then sit down\")\nprint(\"Anyone still standing when the time expires loses\")\nprint(\"The last person to sit down before the time ended will win\")\n\nstand_time = random.randint(5, 20)  # generate the time to stand for\n\nprint(\"Stay standing for\", stand_time, \"seconds.\")  # display standing time\ntime.sleep(stand_time)  # sleep for the standing time\nprint(\"****TIMES UP, LAST TO SIT WINS!****\")\n\n\nWelcome to Self Timer\n\nEverybody stand up\nStay standing until you think the time has ended\nThen sit down\nAnyone still standing when the time expires loses\nThe last person to sit down before the time ended will win\nStay standing for 9 seconds.\n****TIMES UP, LAST TO SIT WINS!****\n\n\nMost of the code is just text, but the key takeaway is the line stand_time = random.randint(5, 20) which assigns stand_time the result of random.randint(5, 20), i.e a random number from 5 to 20 inclusive. We then call stand_time is our call to print to display the time, and then sleep for the same amount of time. Observe we couldn’t just write the number into both functions explicitly since it’s randomly generated, we would need to know ahead of time what the value will be\n\n\n\n\n\nVariables can also hold text, e.g. customer_name = 'fred' assigns the string 'fred' to customer_name\nCan use a string variable anywhere we would use a string literal, e.g. message = 'the name is ' + customer_name performs the string concatenation of 'the name is' and the value of customer_name and assigns the result to message, which we can confirm below,\n\n\n  customer_name = \"fred\"\n  message = \"the name is \" + customer_name\n  print(message)\n\nthe name is fred\n\n\n\n\nPython tracks the contents of each variable and only allows operations that make sense. Using the python interpreter experiment with the following combinations of string and number variables.\n\ncustomer_age_in_years = 25\ncustomer_name = 'fred'\n\nAfter entering the above two lines in the interpreter, run the following line\n\ncustomer_age_in_years + customer_name\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[13], line 1\n----&gt; 1 customer_age_in_years + customer_name\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\n\nHere we are trying to add a number and a string, which we saw previously shouldn’t work. The terminal should provide some error output like the below\nNow try the below line\n\ncustomer_age_in_years = 'Fred'\n\nOne might expect the above to generate an error, after all we assign text to a variable that was just storing a number. Instead python simply discards the old numeric value of the variable, and now stores text in customer_age_in_years. You should generally avoid doing this, being able to reason about the type of a variable is typically an important part of safe and effective programming, and the weak typing of python is typically disliked outside of quick prototyping\n\n\n\n\n\n\nNote\n\n\n\nWeak vs Strong Typing\nThe above behaviour is an example of python as a what’s called a weakly typed language. Types are a quite developed part of programming theory that can be discussed later. In some languages, types are enforced to greater degrees of strictness. In some languages (like C) you can assign variables compatible types, i.e. ones that can be converted to the variable’s innate type. In other stricter languages a variable can only hold the exact specified type\nThe more strictly a language enforces its typing system typically the harder it is to generate errors at runtime, however they are often correspondingly more painful to actually write the code in the first place\n\n\n\n\n\n\nPython lets you use either single-quotes (’) or double-quotes (“)\n\nLets us include ’ or ” in a string, by using the alternate delimiter\n\nFor example, compare the two quote snippets,\n\n\nprint(\"It's a trap\")\n\nIt's a trap\n\n\n\nWhereas if we tried to just use single quotes,\n\n\nprint('It's a trap')\n\n\n  Cell In[16], line 1\n    print('It's a trap')\n                      ^\nSyntaxError: unterminated string literal (detected at line 1)\n\n\n\n\n\nThe single quote in It's ends the string, and we get a syntax error detecting what should be the closing single quote as opening a new string literal\nHow do we handle the case where we have mixed quotes in a string?\n\nWe use triple quotes, a series of three single or double quotes in a row, see the example below\n\n\n\nprint('''...and then Luke said \"It's a trap\"''')\n\n...and then Luke said \"It's a trap\"\n\n\n\nTriple quoted strings have the added advantage of capturing newlines. To see this, we could rewrite the intro string in Nerves of Steel as\n\n\nprint('''Welcome to Nerves of Steel\n\nEverybody stand up\nStay standing as long as you dare.\nSit down just before you think the time will end. ''')\n\nWelcome to Nerves of Steel\n\nEverybody stand up\nStay standing as long as you dare.\nSit down just before you think the time will end. \n\n\n\n\n\n\n\n\nCaution\n\n\n\nString Delimiters must Match\nYou must using matching delimiters, if we try to mix them we’ll get an error\n\nprint('hello\")\n\n\n  Cell In[19], line 1\n    print('hello\")\n          ^\nSyntaxError: unterminated string literal (detected at line 1)\n\n\n\n\n\n\n\n\n\n\nEscape sequences are another way to include quote characters\nExtends to other symbols with meaning other than their literal character glyph in a string\nDenoted by the \\ character\n\n\n\n\n\n\n\n\n\nEscape Sequence\nMeaning\nEffect\n\n\n\n\n\\\\\nBackslash character (\\)\nEnter a backslash into a string\n\n\n\\'\nSingle Quote (')\nEnter a single quote into the string\n\n\n\\\"\nDouble Quote (\")\nEnter a double quote into the string\n\n\n\\n\nASCII Line Feed/New Line\nEnd this line and take a new one\n\n\n\\t\nASCII Tab\nMove to the right to the next tab stop\n\n\n\\r\nASCII Carriage Return\nReturn the printing position to the start of the line\n\n\n\\a\nASCII Bell\nSound the bell on the terminal\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nASCII\nASCII (short for American Standard Code for Information Interchange) is an old format for character encoding that covers a small range of symbols including the latin alphabet and digits.\nASCII itself is less used today since it only covers around \\(100\\) characters, which is nowhere near enough to cover all modern languages, before you start adding in characters like emojis. However modern text encoding like unicode are typically backwards compatible with ASCII.\nNot all ASCII escape sequences may work on a modern computer. \\a was designed to ring a mechanical bell on old computers. Some modern computers may play a beep while others may do nothing. Similarly \\r is supposed to return the print head of a computer back to the start of the line. This has very limited use cases, and may not be implemented on all systems.\nThe most common escape characters are newline \\n and escaping quotes\n\n\n\n\n\n\n\n\nImportant\n\n\n\nNewline in Python\nPython uses \\n as the newline character. Technically this is known as a line feed and means “go to the next line”. In Linux and similar operating systems this is equivalent to starting a new line, but in windows going to the start of a new line is achieved via \\r\\n, i.e. return to the start of the line, and then feed to the next. Luckily python handles the conversion between the conventions automatically and we can just use \\n regardless of the operating system we are actually running on\n\n\n\n\nStart a python interpreter and answer the following questions\n\nWhat do you think the following quote would print?\nprint('hello\\nworld')\n\nWe would expect this print hello on one line, then world on the next\n\n\n\nhello\nworld\n\n\nWhat do you think the following would print?\n print('Item\\tSales\\ncar\\t50\\nboat\\t10')\n\nWe can see this prints a series of tab separated lines. So this is essentially a tab separated table (a similar format to the more familiar comma-separated table)\n\n\n\nItem Sales\ncar  50\nboat 10\n\n\n\nThe exact spacing of tab characters can depend on the computer system, and it is quite common for text editors to convert tabs to spaces, so this format isn’t the best. We’ll see other ways to format strings later\n\nHow could I use Python escape sequences to print out this message?\n\nand then Luke said “It’s a trap”\n\n\nWe saw how to do this with triple-delimited strings before. Instead we just have to remember to instead use a single-delimiter string and then escape the quotes that actually form the string contents. See,\n\n\n print('and then Luke said \"It\\'s a trap\"')\n\nand then Luke said \"It's a trap\"\n\n\n\n\nSince the string is delimited by single quotes we only have to delimit the one single quote in It's rather than the two double quotes\n\n\n\n\n\n\nWe’ve seen how to output data with print\nWe can also input data with the appropriately named input\nThe code snippet below, takes input from the user and stores it in name\n\n  name = input()\n\nThe program will pause until the user supplies the input, (Try it yourself in the interpreter!)\nWe can add a display prompt to the input statement\n\n  name = input('Enter your name please: ')\n\nThe above should output something like the below when run\n\n\n\nEnter your name please: \n\n\n\nAs mentioned input passes what it receives into the receiving variable.\n\nIf we just immediately press enter this is the empty string i.e. a string containing no characters\n\ninput is another technique for delaying the end of a program, e.g. the below prints a prompt and then holds the program until some input is received\n\ninput('Press enter to continue...')\n\n\nUse python to create a simple program that will issue a personalised greeting. Create a new program (greeter.py) with the following contents\nname = input('Enter your name please: ')\nprint('Hello', name)\nSave the program and execute it to see the output. For me the program would output,\n\n\n\nEnter your name please: Felix\n\nHello Felix\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nI’ve used colour to emphases what is my input, versus the program’s output\n\n\n\n\n\n\n\n\n\n\ninput returns a string\n\nFine if we want that, but what if we want to handle numbers?\ne.g. if we wanted to have a user-specified egg timer\n\nint is a function that converts the argument to a whole number e.g.\n\ntime_text = input('Enter the cooking time in seconds: ') #receive time in seconds\ntime_int = int(time_next) #perform conversion to number\n\n\n\nThe complete program would then look like,\n  # Example 4.3: Configurable Egg Timer\n  #\n  # Reads in a user specified time to set the timer for\n\n  import time\n\n  time_text = input(\"Enter the cooking time in seconds: \")\n  time_int = int(time_text)\n\n  print(\"Put the egg in boiling water now\")\n  input(\"Press enter to continue once the egg is in...\")\n\n  time.sleep(time_int)\n\n  print(\"Take the egg out now\")\nThis basic pattern works just as well for an alarm as it does for a configurable timer\n\n\n\n\nConsider the previous example, and answer the following questions\n\nHow many variables are used in the program above?\n\ntwo, the first time_text stores the initial text input, while the second time_int contains the converted numeric representation\n\nCould you write the program without the time_text variable?\n\nYes, we could immediately pass the input result to int, e.g.\n\n time_int = int(input('Enter the cooking time in seconds: '))\n\nIt’s an open debate which format is clearer. In the second there’s more to grok on one line, but the whole workflow is there\n\nWhat do you think will happen if the user enters something other than a number?\n\nLet us find out,\n\n\n x = int('kaboom')\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[25], line 1\n----&gt; 1 x = int('kaboom')\n\nValueError: invalid literal for int() with base 10: 'kaboom'\n\n\n\n\nWe get an error, int tries to convert the string 'kaboom' to an integer, which it clearly cant\nThe art of programming to handle invalid input like the above is called error-handling, we’ll see that later\n\n\n\n\n\n\n\nThere are two types of numbers\n\nWhole numbers or integers\n\nAre always held accurately by the computer\n\nReal numbers (or representations of) or floating point\n\nContain a fractional component\nMust be truncated to be stored in memory, so cannot always be stored accurately\n\n\n\n\n\nLearn about the differences between whole numbers and real numbers through the following questions\n\nI’m building a device that can count the number of hairs on your head. Should this be stored as a whole or real number?\n\nInteger, we generally wouldn’t count fractions of a hair\nAlternatively, given how many hairs there are, and that we might not care about being precise, we might instead want to use a real number to store the approximate magnitude\n\nI want to use my hair-counting machine on \\(100\\) people and determine the average number of hairs on all their heads. Should I use this value as a whole or real number?\n\nWe expect that the average will not be a whole number, so we should store it as a real number\nAlternatively, we may not care about getting the number exact down to the fraction, so we could use a whole number to round to the nearest number\n\nI want to keep track of the price of a product in my program. Should I use whole numbers or real numbers?\n\nNaively we would a real number, however as we mentioned real numbers have some uncertainty stored in them\nWhen dealing with financial values we need to maintain that precision\n\nInstead we might then use whole cents\n\nWorks straightforward if we only care about the total\nIf we care about averages, or fractions of a total then we might have to reconsider\n\nThere are techniques used to control the error in a real number calculation\n\n\n\n\nAs you can see the argument of what numerical type to use, requires understanding both the nature of the value itself, and what you want to do with it. You can then consider the properties of the numeric representation and choose the most appropriate one\n\n\n\n\n\n\n\nImportant\n\n\n\nThe way you store a variable depends on what you want to do with it\nAs the discussion above highlights, sometimes the answer to how we want to store data is not the immediate first answer. It’s important to consider not just what the natural representation of a value is, but what it’s purpose in the code is.\nFor example as we discussed above, money is naturally expressed as real numbers. However due to the it’s use case, which requires high precision and also generally a limited range (values of even a trillion are rare, and we typically only consider down to whole cents) compared to the full range of a floating point number we might want to look at alternative representations\n\n\n\n\n\n\n\nReal numbers have a fractional part\n\nTheir representation may not align 1:1 with what was originally input\n\nThe most common way to store real numbers is called floating point\n\nThe floating means that the decimal point moves around in the representation, as opposed to a fixed point representation which has a set number of digits after the decimal point\nUsing more memory to store a float lets us store it with greater precision, but we can never accurately represent all floating point numbers\n\nReal numbers can be defined by range and precision\n\nPrecision governs how precisely a number is stored e.g. a float may be able to store \\(123456789.0\\) or \\(0.123456789\\) but not \\(123456789.987654321\\) because the precision required is too great\nRange determines how much we can slide the decimal point to represent large or small numbers e.g. we could store \\(123456700\\) or \\(0.0001234567\\)\nIn Python floats have \\(15-16\\) digits of precision and can range from \\(10^{308}\\) and \\(10^{-324}\\)\n\nA quirk of floating point is that some apparently simple numbers like \\(0.1\\) can’t be stored exactly\n\n\n\nConduct the following experiments in the python shell to learn about floating points\n\nWhat happens if we try to store a value that can’t be held accurately as a floating-point value?\n\n0.1\n\n0.1\n\n\n\nAbove we said that \\(0.1\\) couldn’t be exactly represented, but that doesn’t match with what we just saw. The answer is because the error in the representation is very small, and print rounds off the answer\n\nDoes the rounding really happen? Run the following and comment on the result\n\n 0.1 + 0.2\n\n0.30000000000000004\n\n\n\nWe expected the answer to be \\(0.3\\) but instead we see a slight error. This is because there is an error accumulation from adding \\(0.1\\) to \\(0.2\\) and the underlying floating point representations\n\n\n\nThese issues are not python specific. They are an innate challenge of trying to represent real numbers on hardware. Modern floating-point numbers are also an internationally recognised standard which lets different programs and hardware talk to each other.\nPython differs from some languages in only providing a single floating point type that is \\(8\\) bytes. In many languages this is referred to as a double-precision floating point or just a double and is one of several floating point types\n\n\n\n\n\n\n\nWarning\n\n\n\nDon’t confuse precision with accuracy\nNumbers don’t become more accurate when they are stored with more precision. Scientists often measure values with a measure of uncertainty which captures how sure they are in the accuracy of their number. There is no point storing a value to \\(15\\) decimal places of precision, if the accuracy of a measurement is only to \\(1-2\\) places, e.g. if we measure with a ruler\nUsing higher precision can result in slower programs that use more memory\n\n\n\nPython automatically creates variables for use in programs\nThe type of a variable is determined by what is stored in it\n\nname = 'Rob'\nage = 25\n\nThe above creates two variables\n\nOne name is a string type\nThe other age is an int or integer type\n\n\n\n\n\nWork through the following following questions to understand how floating-point variables work?\n\nHow do you create a floating point variable?\n\nYou can create a floating point variable by assigning a floating point number e.g. the below creates a variable* x *and assigns it the floating point value \\(1.5\\)\n\n\n x = 1.5\n x\n\n1.5\n\n\nWhat happens if you assign an integer to a floating point variable?\n\nThe below assigns the integer value \\(1.0\\) to a variable y\nIf we print the value back we can see it keeps the decimal, indicating it is a floating point value\n\n\n y = 1.0\n y\n\n1.0\n\n\n\ni.e. by writing the decimal point we coerce the type of y to be floating point\n\nWhat happens when we mix floating point and integers in calculations?\n\nIf we compare the two additions below, we can see that when we add floating points, the addition stays a floating point even if the result is integral\n\n\n 2 + 2\n\n4\n\n\n\n 2.0 + 2.0\n\n4.0\n\n\n\nIf we mix a floating point and integer type we can also see that the result is returned as a floating point (even when the final result is integral)\n\n\n 2 + 2.0\n\n4.0\n\n\n\nLastly what happens if we divide two coprime integers?\nWe see that the result gives the appropriate floating point fraction\n\n\n 1/2\n\n0.5\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nInteger Division\nWhile the last point about division behaviour may seem obvious if you haven’t programmed before you would do well to be careful. In many common languages, division of two integers is treated as integer division. In this case the result is always an integer with the result being rounded according to some scheme. Three common schemes are towards zero, in which the result is always rounded towards the number \\(0\\); towards the nearest, where the result is rounded to the nearest whole number and floored division in which the number is rounded towards negative infinity.\n\n\n\n\n\n\n\n\nDivision\nExample\nInterpretation\n\n\n\n\ntowards zero\n\\(-1/2 = 0\\)\nDiscard decimal digits\n\n\ntowards nearest\n\\(3.2/2 = 2\\)\nMinimise the difference between “true” division and result\n\n\nfloored division\n\\(-1/2 = -1\\)\nRound “down”\n\n\n\nPython lets you perform integer division using floored division behaviour with the // operator e.g.\n\n-1//2\n\n-1\n\n\n\n\n\n\n\n\n\nConverting string to float, works identically to as for int but we use float instead\n\ne.g. We could rewrite the configurable egg timer with floats as,\n\n\ntime_text = input('Enter the cooking time in seconds: ')\ntime_float = float(time_text)\n\n\n\nThe complete program would then look like\n\n# Example 4.4 Ultra-Precise Egg Timer\n#\n# A version of the Configurable Egg Timer using floating point for the input time\n\nimport time\n\ntime_text = input(\"Enter the cooking time in seconds: \")\ntime_float = float(time_text)\n\nprint(\"Put the egg in boiling water now\")\ninput(\"Press enter to continue once the egg is in...\")\n\ntime.sleep(time_float)\n\nprint(\"Take the egg out now\")\n\nThe code is the same except we make the substitution int \\(\\to\\) float\n\n\n\n\n\n\nAs mentioned before python is an expression evaluator\nAn expression consists of operators and operands\nPython evaluates an expression left to right, and carries out operations according to their order of operations\n\nAnalogous to mathematical order of operations (and includes them) but must extend for programming specific syntax\nAs in maths, parentheses are used to enforce an evaluation order\n\n\n\n\n\nOperator\nUse case\n\n\n\n\n-\nUnary minus, denotes a negative number\n\n\n*\nMultiplication (in-lieu of \\(\\times\\))\n\n\n/\nDivision\n\n\n+\nAddition\n\n\n-\nbinary minus or subtraction\n\n\n\n\nBasic operators and their precedence\n\n\n\nSee if you can work out the values of a, b and c when the following statements are evaluated,\n    a = 1\n    b = 2\n    c = a + b\n\n    c = c * (a + b)\n    b = a + b + c\nThe first three lines give a = \\(1\\), b = \\(2\\) and c = \\(3\\). Substituting those into the second evaluation for c,\n\na = 1\nb = 2\nc = a + b\nc = 3 * (1 + 2)\nc\n\n9\n\n\nSo c is assigned \\(9\\). We then repeat for the second assignment to b to get,\n\nb = 1 + 2 + 9\n\nSo the final values are, a = \\(1\\), b = \\(12\\), c = \\(9\\). If we execute the original cell we can confirm this\n\na = 1\nb = 2\nc = a + b\n\nc = c * (a + b)\nb = a + b + c\n\nprint('a: ', a)\nprint('b: ', b)\nprint('c: ', c)\n\na:  1\nb:  12\nc:  9\n\n\n\n\n\n\n\n\nCaution\n\n\n\nDumb Calculations\nPython won’t try and stop you if you do something that mathematically makes no sense like dividing a number by zero, instead an error is raised, but this won’t occur until your program runs! Therefore when using division you should always take care to make sure you either handling division by zero cases appropriately or preventing them from occurring\n\n1/0\n\n\n---------------------------------------------------------------------------\nZeroDivisionError                         Traceback (most recent call last)\nCell In[38], line 1\n----&gt; 1 1/0\n\nZeroDivisionError: division by zero\n\n\n\nWhen using other languages, they may not raise and error, instead unexpected behaviour may occur including your program crashing.\n\n\n\n\n\n\n\nWe saw floatcan be used to convert a string to a float.\n\nIt can also be used to convert an integer value to a floating point value, e.g.\n\n\n\nz = float(1)\nz\n\n1.0\n\n\n\nIf we want to go the other way we can use int to convert a float to an int.\n\nThe number is rounded towards zero, i.e. fractional components are truncated (see the callout-box above about integer division)\n\n\n\ni = int(2.9)\ni\n\n2\n\n\n\n\nConsider the following program which is designed to calculate the number of pizzas needed for a hackathon with \\(x\\) number of participants using the heuristic that \\(1\\) pizza can satisfy \\(1.5\\) people\n# Example 4.5: Pizza Order Calculator\n#\n# A basic pizza order calculator based on the heuristic that 1 pizza = 1.5 people fed\n\nstudents_int = int(\n    input(\"How many students are attending? \")\n)  # read in string, convert to int and store\npizza_count = students_int / 1.5  # perform division int -&gt; float\nprint(\"You will need\", pizza_count, \"pizzas\")\nNote, that I’ve modified the code to directly pass the input to int and then to a variable, to demonstrate that it’s possible.\nThe above program has the problem that for any number not divisible by \\(1.5\\), the program recommends ordering a fractional number of pizzas. This is generally not possible, so we need to convert the output to an integer.\n\nModify the program to return an int by calling int directly during the calculation of pizza_count. What potential problems does this solution have?\n # Exercise 4.1.1: Pizza Order Calculator\n #\n # A basic pizza order calculator based on the heuristic that 1 pizza = 1.5 people fed\n\n students_int = int(\n     input(\"How many students are attending? \")\n )  # read in string, convert to int and store\n pizza_count = students_int / 1.5  # perform division int -&gt; float\n print(\"You will need\", pizza_count, \"pizzas\")\n\nThis method has the disadvantage that it will tend to underestimate the number of pizzas needed.\nFor example if we needed to feed \\(40\\) people, the program would give us \\(26\\), which can satisfy, \\(39\\) people, meaning someone goes hungry\n\nModify the program to return an int by calling int to convert the division to an int then adding \\(1\\). Explain how this changes the behaviour\n # Exercise 4.1.2: Pizza Order Calculator\n #\n # A basic pizza order calculator based on the heuristic that 1 pizza = 1.5 people fed\n # Converts the result to an integer using int on pizza_count then adding one\n # has the disadvantage it will tend to overestimate the number of pizzas needed\n\n students_int = int(\n     input(\"How many students are attending? \")\n )  # read in string, convert to int and store\n pizza_count = int(students_int / 1.5) + 1  # perform division int -&gt; float\n print(\"You will need\", pizza_count, \"pizzas\")\n\nThis method will tend to add an additional spare pizza or overestimate the number of pizzas needed.\nSince it’s generally better for there to be a little left over than someone go hungry, this behaviour is probably preferred.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nNever assume you know what a program is supposed to do\nWhen faced with a choice like the above for the pizza order calculator for a product being made by a client, you should not decide what the expected behaviour is yourself. For example, in the above the customer may prefer to round down the number of pizzas to reduce cost.\nNever assume you know what the program should do, ask the client\n\n\n\n\n\nWrite a program to convert from Fahrenheit to Centigrade. The formula for this is\n\\[\n\\begin{align}\n\\text{Centigrade} &= \\frac{\\text{Fahrenheit} - 32}{1.8}\n\\end{align}\n\\]\nOur solution is very similar to the Pizza Calculator, but with some of the text changed. The other major difference is that we want to be able to accept a float value, and output a float value.\n    # Exercise 4.2: Fahrenheit to Celsius\n    #\n    # Converts Fahrenheit to Celsius\n\n    temperature_fahrenheit = float(\n        input(\"Enter a temperature in Fahrenheit: \")\n    )  # read in string, convert to float\n    temperature_centigrade = (temperature_fahrenheit - 32) / 1.8\n    print(\"The temperature is\", temperature_centigrade, \"degrees Celsius\")\nA sample output may look like,\n\n\n\nEnter a temperature in Fahrenheit: 0\n\nThe temperature is -17.77777777777778 degrees Celsius\n\n\n\n\n\nLater we’ll see how we can format the output to be a bit more presentable\n\n\n\n\n\n\n\nSnaps contains a function get_weather_temp for to return the temperature of a location in the United States\n\nData is scraped from the US National Weather Service website\nFunction takes the latitude and longitude as an argument\n\n\n\n\n\nThe following program can be used to get the current temperature reading from Seattle using snaps\n\n  # Example 4.6: Seattle Temperature\n  #\n  # Get the current temperature in Seattle\n\n  import snaps\n\n  temp = snaps.get_weather_temp(latitude=47.61, longitude=-122.33)\n\n  print(\"The temperature in Seattle is:\", temp)\n\npygame 2.6.1 (SDL 2.28.4, Python 3.12.3)\nHello from the pygame community. https://www.pygame.org/contribute.html\n\n\n/home/runner/work/BeginToCodeWithPython/BeginToCodeWithPython/.venv/lib/python3.12/site-packages/pygame/pkgdata.py:25: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools&lt;81.\n  from pkg_resources import resource_stream, resource_exists\n\n\nThe temperature in Seattle is: 43\n\n\n\n\n\n\n\nWe can also use snaps to get a short description of the current weather\n\n  # Example 4.7: Seattle Weather\n  #\n  # Uses snaps to get a description of the weather in Seattle\n\n  import snaps\n\n  desc = snaps.get_weather_description(latitude=47.61, longitude=-122.33)\n  print(\"The conditions are:\", desc)\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[43], line 7\n      1 # Example 4.7: Seattle Weather\n      2 #\n      3 # Uses snaps to get a description of the weather in Seattle\n      5 import snaps\n----&gt; 7 desc = snaps.get_weather_description(latitude=47.61, longitude=-122.33)\n      8 print(\"The conditions are:\", desc)\n\nAttributeError: module 'snaps' has no attribute 'get_weather_description'\n\n\n\n\n\n\n\nWrite a program that displays the current weather conditions. If you use the display_text function from snaps, your program can display the current weather and description\nOur solution is written below,\n# Exercise 4.3: Weather Display\n#\n# Displays the Weather in Seattle\n\nimport snaps\n\ntemperature_fahrenheit = snaps.get_weather_temp(latitude=47.61, longitude=-122.33)\ntemperature_string = \"The temperature in Seattle is: \" + str(temperature_fahrenheit)\n\nweather_descr = snaps.get_weather_description(latitude=47.61, longitude=-122.33)\nweather_descr_string = \"The conditions are: \" + str(weather_descr)\n\nweather_string = temperature_string + \"\\n\" + weather_descr_string\n\nsnaps.display_message(weather_string, size=100)\n\ninput(\"Press enter to continue...\")\nAs we can see most the actual getting of the temperature and weather data is the same as for the Seattle Temperature and Weather programs. The rest of the work is done to construct the appropriate strings and merge them together so they can be passed to the display_message function for output",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 4: Working With Variables"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/04_WorkingWithVariables/Chapter_04.html#summary",
    "href": "01_ProgrammingFundamentals/04_WorkingWithVariables/Chapter_04.html#summary",
    "title": "Chapter 4: Working With Variables",
    "section": "Summary",
    "text": "Summary\n\nVariables can be created\n\nVariables are effectively named regions of memory\nVariables must start with a letter or underscore and can only consist of alphanumeric characters or underscores\n\nData can be viewed as two fundamental types, text or numeric\n\nstring is a type for holding text\n\ninput can be used to get strings from the user\nint and float can convert a string to an integer or floating point number respectively\n\nNumeric values have two forms\n\nint for whole numbers with no fractional part\nfloat for real numbers with a fractional part\n\nfloat only approximate real numbers and can be subject to some errors",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 4: Working With Variables"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/04_WorkingWithVariables/Chapter_04.html#questions-and-answers",
    "href": "01_ProgrammingFundamentals/04_WorkingWithVariables/Chapter_04.html#questions-and-answers",
    "title": "Chapter 4: Working With Variables",
    "section": "Questions and Answers",
    "text": "Questions and Answers\n\nWhat happens if I “overwrite” a variable of one type with a value of another type?\n\nPython replaces the old variable with a new one of the same name but the new type\n\nDoes using a long variable name slow the program down?\n\nIf it does it is insignificant, it’s much more important to use a name that clearly conveys meaning\n\nCan we write all our programs using floating point numbers?\n\nYou could, but you should use int where appropriate because float representation is inexact and subject to errors\n\nThese errors mean that it is often hard to compare for exact equality e.g. 1.0 might actually have the representation 1.0000...4\n\n\nCan I stop my program from crashing if someone types in an invalid input?\n\nYes, this is called error handling. This will be covered later in Chapter 6",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 4: Working With Variables"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/06_RepeatingActionsWithLoops/Chapter_06.html",
    "href": "01_ProgrammingFundamentals/06_RepeatingActionsWithLoops/Chapter_06.html",
    "title": "Chapter 6: Repeating Actions with Loops",
    "section": "",
    "text": "while allows a program to repeat blocks of statements\nstructure is similar to an if\n\n\n\n\n\n\nblock-beta\n    columns 4\n    space\n    title[\"Breakdown of a While\"]:2\n    space\n\n    block:Input\n    columns 1\n        while[\"while\"]\n        whileDescr[\"(start of the while construction)\"]\n    end\n\n    block:MiddleOne\n    columns 1\n        condition[\"condition\"]\n        conditionDescr[\"(value that is True or False)\"]\n    end\n\n    block:MiddleTwo\n    columns 1\n        colon[\":\"]\n        colonDescr[\"Colon\"]\n    end\n\n    block:Suite\n    columns 1\n        suite[\"Statement block\"]\n        suiteDescr[\"(statements)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass condition BG\nclass conditionDescr BG\nclass colon BG\nclass colonDescr BG\nclass while BG\nclass whileDescr BG\nclass suite BG\nclass suiteDescr BG\n\n\n\n\n\n\n\nif the condition evaluates True then the block of statements is run\n\nAfter the statements are run, control returns to the start of the while loop\nIf the condition is still True then the loop runs again\n\n\n\n\nUse the python interpreter to run the following to understand the while loop\n\nCan we use a boolean value to control a while construction?\n\nYes, for example the block of statements in the while here shouldn’t run\n\n\n while False:\n     print(\"Loop\")\n print(\"Outside the Loop\")\n\nOutside the Loop\n\n\nCan a loop go on forever?\n\nYes, an control expression for a while that always evaluates True will cause the loop to run infinitely\n\n while True:\n     print(\"Loop\")\n print(\"Outside the Loop\")\n\nThe above should only print \"Loop\" when executed\nIf you accidentally do this you may need to use CTRL+C, CTRL+Z or an interrupt execution feature of your live environment to stop the execution\n\nWill the following program ever print out the message, \"Outside loop\"?\n while True:\n     print(\"Inside Loop\")\n print(\"Outside Loop\")\n\nNo, the above is a quintessential infinite loop\n\nWill the following program ever print out the message, \"Inside Loop\"? How about \"Outside loop\"?\n\n while False:\n     print(\"Inside Loop\")\n print(\"Outside Loop\")\n\nOutside Loop\n\n\n\nThe while never executes the statements inside so \"Inside Loop\" is never printed, but \"Outside Loop\" is.\n\nWhat will the following program print?\n\n # Example 6.1 Loop with Flag\n #\n # Demonstrates control of a loop with a boolean flag\n\n flag = True\n while flag:\n     print(\"Inside Loop\")\n     flag = False\n print(\"Outside Loop\")\n\nInside Loop\nOutside Loop\n\n\n\nWhen we first enter the loop flag is True so the loop executes and*\"Inside Loop\" is printed\nflag is then set False so on the next iteration of the loop, the loop doesn’t execute.\nWe move to the next statement outside of the loop and print out \"Outside Loop\"\nThe pattern of using a control variable that is updated in the loop body in a while loop is very common\n\nWhat will the following program print?\n flag = True\n while flag:\n     print(\"Inside Loop\")\n     Flag = False\n print(\"Outside Loop\")\n\nThis looks similar to the previous, but note the typo, we refer to Flag not flag inside the loop\nThis which defines a new variable, instead of modifying the loop control.\nWe thus get an infinite series of \"Inside Loop\" being printed.\n\nWhat will the following program print?\n\n # Example 6.2 Loop with Counter\n #\n # Demonstrates use control of a while loop\n # using a conditional expression\n\n count = 0\n while count &lt; 5:\n     print(\"Inside Loop\")\n     count = count + 1\n print(\"Outside Loop\")\n\nInside Loop\nInside Loop\nInside Loop\nInside Loop\nInside Loop\nOutside Loop\n\n\n\ncount is initially set to \\(0\\)\nAt each iteration we print \"Inside Loop\" * and increase the value of count by \\(1\\)\nThe loop stops once count reaches \\(5\\)\nThis means that \"Inside Loop\" should be printed \\(5\\) times, followed by \"Outside Loop\"\n\n\n\n\n\nUse a while loop, to make a theme park selector that runs continuously. All you need to do is put all of the statements that implement the theme park behaviour into a while True construction\nFor usability our program won’t loop endlessly. We’ll say that any number that it is not a valid ride number is code for quitting the program. The relevant changes to the Ride Selector are then,\n# Exercise 6.1 Looping Ride Selector\n#\n# Wraps the Ride Selector Program in a while\n# loop to allow the user to look at multiple rides\n\nrun_program = True\n\nwhile run_program:\n    print(\"\"\"Welcome to our Theme Park\n        These are the available ride:\n\n        1. Scenic River Cruise\n        2. Carnival Carousel\n        3. Jungle Adventure Water Splash\n        4. Downhill Mountain Run\n        5. The Regurgitator\n        Any other number to quit...\n        \"\"\")\n\n    ride_number_text = input(\"Please enter the ride number you want: \")\n    ride_number = int(ride_number_text)\n\n    if ride_number &lt; 1 or ride_number &gt; 5:\n        run_program = False\n    elif ride_number == 1:\nObserve that first we wrap all of the code in a while loop, and introduce a boolean flag run_program initially set to True to flag if the program continues to run at each loop iteration. When a user enters a number we first check if it corresponds to a ride number and if not, we set the program to quit on the next loop iteration by setting run_program to False. We now change the original if ride_number == 1 to and elif so it is only checked if we know the ride_number is valid. (The full code is in LoopingRideSelector.py)\n\n\n\nOne of the examples in the above question set involved a countup to \\(5\\). Implement a program that counts down from \\(10\\) to \\(0\\) over \\(10\\) seconds\n# Exercise 6.2: Countdown\n#\n# Performs a 10-second countdown\n\nimport time\n\ntime_left = 10\n\nwhile time_left &gt;= 0:\n    print(time_left)\n    time_left = time_left - 1\n    time.sleep(1)\n\n\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\n\n\nThis is a straightforward exercise (see Countdown.py), we set up our counter value to \\(10\\) and use the appropriate loop expression (here time_left &gt;= 0) to ensure that \\(0\\) is included in the countdown.\nIn the loop we print the current value of time_left, then decrement time_left by \\(1\\), and sleep for the required time. Observe that after the program prints \\(0\\), time_left becomes \\(-1\\) and the next iteration of the loop won’t run.\n\n\n\n\nRide Selector doesn’t account for invalid user entry\n\nBlindly assumes a number outside the range \\(1\\) to \\(5\\) represents quitting the program\n\nIdeally we would like to have a distinct number that represents quitting and a way to capture and handle any invalid inputs\n\n\n\n\n\n\n\nTip\n\n\n\nGreat Programmers Think Defensively\nDefensive programming is a programming technique in which a programmer attempts to defend their code against possible errors that might occur in a code e.g. receiving a word when expecting a number\nIt is good practice to think about, typically a user expects a computer to do something reasonable even when provided unreasonable input.\nData validation does have the downside in that it can make programs significantly bigger, and in compiled languages knowing that data is valid can make them much faster. A good skill is learning the correct layers or boundaries of a program to perform the defensive data validation so the core can run without concern\n\n\n\nIgnoring the question of quitting for now, data validation for the ride selector might look like,\n  if ride_number &lt; 1 or ride_number &gt; 5:\n      print('Invalid ride number')\n\n\n\n\nAbove acknowledges the error, but if we want to use this in our loop control we will need to use while\n  ride_number_text = input(\"Please enter the ride number you want: \")\n  ride_number = int(ride_number_text)\n\n  while ride_number &lt; 1 or ride_number &gt; 5:\n      print(\"There is no ride with that number\")\n      ride_number_text = input(\"Please enter the ride number you want: \")\n      ride_number = int(ride_number_text)\n  print(\"You have selected ride number: \", ride_number)\n\nwhile means program repeats until it receives valid input\nObserve the downside\n\nWe have to repeat the code asking for the ride number and converting to an integer\nSome languages have a do ... while statement which performs its test after executing the loop body for the first time\n\nWould allow us to write the above as one construct\n\n\n\n\n\n\nAdd ride number validation to the Looping Ride Selector implementation. Remember that the while construction must be added after the ride_number value has been read by the program\nWe can basically add the validation in immediately after the first attempt to read the ride number from the user. We also have to adjust the code to now use \\(0\\) as the explicit value for quitting rather than inferring any non-ride-number as a quit value. The main changes are,\n# Exercise 6.3 Ride Selector with Ride Number Validation\n#\n# Adds Ride Number validation to the Ride Selector\n# The program will query the user until a valid ride number or\n# the quit number is given\n\nwhile run_program:\n    print(\"\"\"Welcome to our Theme Park\n        These are the available ride:\n\n        1. Scenic River Cruise\n        2. Carnival Carousel\n        3. Jungle Adventure Water Splash\n        4. Downhill Mountain Run\n        5. The Regurgitator\n        Press 0 to quit the program\n        \"\"\")\n\n    ride_number_text = input(\"Please enter the ride number you want: \")\n    ride_number = int(ride_number_text)\n\n    while ride_number &lt; 0 or ride_number &gt; 5:\n        print(\"There is no ride with that number\")\n        ride_number_text = input(\"Please enter the ride number you want: \")\n        ride_number = int(ride_number_text)\n\n    if ride_number == 0:\n        run_program = False\nThe complete code is given in RideNumberValidation.py\n\n\n\nWhen creating composite conditions for loops, making sure the logic is correct is incredibly important. Examine the following program to understand more complicated loop control\nage_text = input(\"Please enter your age: \")\nage = int(age_text)\nwhile age &lt; 1 and age &gt; 95:\n    #repeat this code while the age is invalid\n    print(\"This age is not valid\")\n    age_text = input(\"Please enter your age: \")\n    age = int(age_text)\n#when we are here, we have a valid age value\nprint(\"Thank you for entering your age\")\n\nWhat is the fault in this program?\n\nThe condition age &lt; 1 and age &gt; 95 requires age to be both less than \\(1\\) and greater than \\(95\\), this is impossible, so the loop never runs\n\nWhat will the fault cause the program to do?\n\nSince the loop body can never run, every entered age will be considered valid\n\nHow do you fix this?\n\nThe desired logic is that age should be between \\(1\\) and \\(95\\) inclusive. This logic is captured by the or operator.\nThe corrected expression is*\n  while age &lt; 1 or age &gt; 95\n\n\n\n\n\n\n\n\nImportant\n\n\n\nAlways test failure behaviours along with successful ones\nIt’s very important when testing software to test both the successful path (the so-called “happy path”) and any possible error states.\nA good programmer proactively looks for potential points of failure, writes code to handle the errors and importantly checks that the code to handle the errors does what it’s supposed to do\nA good heuristic for starting to do this with simple programs is called boundary-value testing. Boundaries are the points between different expected behaviours. For example with the ride selector, we expect different behaviour for numbers \\(&lt; 1\\) or \\(&gt; 5\\) to those in the range \\(1\\) to \\(5\\). So a good set of tests might be \\(0\\), \\(1\\), \\(2\\), \\(4\\), \\(5\\), \\(6\\). i.e. we test either side of the boundary, and on the boundary\n\n\n\n\n\nAdd age validation to the Ride Selection Program. The theme park owner has told you that the minimum age for anyone going on a ride at the theme park is \\(1\\) year, and the maximum age is \\(95\\). Use these values in your program\nObserve that in this case if the user provides an age outside the accepted range, we don’t want to prompt them to put in a new age, since this could legitimately be their age. Instead we want to tell them regardless of the ride they chose they can’t ride. In this case we should use an if style validation technique\nThe change is applied at our age reading section of the program, we use an if...elif...else construct to tell the user they are either too young, too old, or to continue on to the standard ride selection code\nage_text = input(\"Please enter your age: \")\nage = int(age_text)\nif age &lt; 1:\n    print(\"You are too young to go on any rides\")\nelif age &gt; 95:\n    print(\"You are too old to go on any rides\")\nelse:\n    #continue on to normal ride selection code...\nThe full code is given in AgeValidation.py\n\n\n\n\n\n\n\nProblem: We can easily write a loop that checks if a value is invalid but how do we deal with the type being invalid?\n\ne.g. in the ride selector how do we deal with the user typing in a word rather than a number?\nConsider the snippet below, emulating the ride selector given a string input, we get an error, before we even get a chance to validate the value\n\n\n  ride_number_text = \"three\"\n  ride_number = int(ride_number_text)\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[6], line 2\n      1 ride_number_text = \"three\"\n----&gt; 2 ride_number = int(ride_number_text)\n\nValueError: invalid literal for int() with base 10: 'three'\n\n\n\n\nThis occurs because int requires it’s input to be convertible to a number\n\nUnfortunately this does not extend to human-language written versions of a number\nIn this case int throws an error, it is better to end the program than continue in an erroneous state\n\nIn general, when a program encounters an error state, it should aim to fail fast, rather than continue and generate unexpected outcomes\n\nExceptions are a mechanism by which elements of a program can inform other parts about errors that have occurred\n\nExceptions combine a description of what the error that occurred was, with where the error occurred\nIn the example above e.g. we are told that we got a ValueError\ni.e. an invalid value was found, we are given the additional detail “invalid literal for int() with base 10: ‘three’”\nIn plain english, the program did not know how to convert ‘three’ to an integer\nWe are also told where, in this case the second line, in the function int\n\nTo recover from an exception we have to handle it, i.e. do something\n\nThe first step is to catch the exception\nWe wrap code that might throw an exception in a try... except block\n\n# Example 6.3: Catching Exceptions\n#\n# Demonstrates how to catch and handle\n# an exception\n\n  try:\n      ride_number_text = input(\"Please enter a ride number: \")\n      ride_number = int(ride_number_text) #statement that might raise exception\n      print(\"You have entered\", ride_number)\n  except ValueError: # Start of an exception handler\n      print(\"Invalid number\") # Performed if exception raised\nWe wrap the code that may throw an exception in a try\nWe then use except to define statements we want to run if an exception is thrown\n\nIf an exception is thrown, control immediately jumps to the except block\ne.g. In the above example if int throws a ValueError then the line print(\"You have entered\", ride_number) won’t run\n\nInstead print(\"Invalid number\") runs\n\n\nAs observed except is followed by the exception type we want to catch (in this case ValueError)\nThe full example is given in CatchingExceptions\n\n\n\n\n\n\nblock-beta\n    columns 4\n    space\n    title[\"Breakdown of a Try-Except Block\"]:2\n    space\n\n    block:Try:2\n    columns 1\n        try[\"try\"]\n        tryDescr[\"(start of the try construction)\"]\n    end\n\n    block:TryColon\n    columns 1\n        Trycolon[\":\"]\n        TryColonDescr[\"colon\"]\n    end\n\n    block:TrySuite\n    columns 1\n        Trysuite[\"Statements\"]\n        TrysuiteDescr[(\"statements to execute normally\")]\n    end\n\n\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass try BG\nclass tryDescr BG\nclass Trycolon BG\nclass TryColonDescr BG\nclass Trysuite BG\nclass TrysuiteDescr BG\n\n    block:ExceptOne\n    columns 1\n        exceptOne[\"except\"]\n        exceptOneDescr[\"(start of an exception construction)\"]\n    end\n\n    block:ExceptNameOne\n    columns 1\n        exceptOneName[\"Name\"]\n        exceptOneNameDescr[\"(exception name)\"]\n    end\n\n    block:ExceptOneColon\n    columns 1\n        exceptOneColon[\":\"]\n        exceptOneColonDescr[\"colon\"]\n    end\n\n    block:ExceptOneStatements\n    columns 1\n        exceptOneStatements[\"statements\"]\n        exceptOneStatementsDescr[(\"statements to execute if exception caught\")]\n    end\n\nclass exceptOne BG\nclass exceptOneDescr BG\nclass exceptOneName BG\nclass exceptOneNameDescr BG\nclass exceptOneColon BG\nclass exceptOneColonDescr BG\nclass exceptOneStatements BG\nclass exceptOneStatementsDescr BG\n\n    block:ExceptTwo\n    columns 1\n        exceptTwo[\"except\"]\n        exceptTwoDescr[\"(start of an exception construction)\"]\n    end\n\n    block:ExceptNameTwo\n    columns 1\n        exceptTwoName[\"Name\"]\n        exceptTwoNameDescr[\"(exception name)\"]\n    end\n\n    block:ExceptTwoColon\n    columns 1\n        exceptTwoColon[\":\"]\n        exceptTwoColonDescr[\"colon\"]\n    end\n\n    block:ExceptTwoStatements\n    columns 1\n        exceptTwoStatements[\"statements\"]\n        exceptTwoStatementsDescr[(\"statements to execute if exception caught\")]\n    end\n\nclass exceptTwo BG\nclass exceptTwoDescr BG\nclass exceptTwoName BG\nclass exceptTwoNameDescr BG\nclass exceptTwoColon BG\nclass exceptTwoColonDescr BG\nclass exceptTwoStatements BG\nclass exceptTwoStatementsDescr BG\n\n\n\n\n\n\n\nAs demonstrated above a try...except block may contain multiple except statements designed to handle different exception types\n\n\n\n\nWe’ve seen how to use loops to handle invalid values\nWe’ve seen how to use exceptions to handle invalid types\nNow let’s put that together to write a loop to handle exceptions\n\n\n\nWe want to make a program that will perform a while construction as long as the user keeps typing in text that cannot be converted into a number. Look at the example code below, (see HandlingInvalidText.py) and answer the questions\n# Example 6.4: Handling Invalid Text\n#\n# Combines loops and exception handling to prompt a user\n# for a valid number and repeat until a number is provided\n\nride_number_valid = False  # create and set a flag to False\nwhile not ride_number_valid:  # repeats while flag is False\n    try:\n        ride_number_text = input(\"Please enter the ride number you want: \")\n        ride_number = int(ride_number_text)  # can throw a ValueError\n        ride_number_valid = True  # successfully read a number\n    except ValueError:  # catch the ValueError\n        print(\"Invalid number. Please enter a number in digits\")\n# Once outside the loop we have a valid number\nprint(\"You have selected ride\", ride_number)\n\nWhat is the purpose of the variable, ride_number_valid?\n\nIt is a flag\nTracks the state of a program, in this case a valid number been read\nStarts False once successfully received an int flips to True\n\nHow many times would you expect the while construction to loop when the program is used?\n\nIdeally we would expect it to run once\n\ni.e. The user enters a number straight away\n\nIn the next best case we would expect it run twice\n\nThe user experiences an error, reads the message and corrects their input the next time\n\n\nWhy don’t we have to test ride_number_valid at line \\(10\\), to make sure that the ride number is valid?\n\nThe while loop stops when it’s condition is False\nThis corresponds to ride_number_valid = True\nSo we know that once we leave the loop ride_number_valid must be True\n\n\n\n\n\n\n\nSometimes there a multiple exception types we wish to handle\ne.g. a KeyboardInterrupt allows a user to issue an exception which could stop a program\n\nIf the user is interacting with somebody else’s external facing program, we might not want them to be able to do this\n\nSimultaneously we might need to ensure that the user inputs valid data like numbers\nWe can just add an additional except block\n\nWhen an exception is thrown, the appropriate handler takes control\n\nThe improved exception handling code is given in HandlingInvalidTextMultipleExceptions\n\n# Example 6.5: Improved Handling Invalid Text\n#\n# Extends Example 6.4 by preventing the user from issuing a\n# keyboard interrupt to stop the program\n\nride_number_valid = False  # create and set a flag to False\nwhile not ride_number_valid:  # repeats while flag is False\n    try:\n        ride_number_text = input(\"Please enter the ride number you want: \")\n        ride_number = int(ride_number_text)  # can throw a ValueError\n        ride_number_valid = True  # successfully read a number\n    except ValueError:  # catch the ValueError\n        print(\"Invalid number. Please enter a number in digits\")\n    except KeyboardInterrupt:  # catches the interrupt\n        print(\"You do not have permission to interrupt this program\")\n# Once outside the loop we have a valid number\nprint(\"You have selected ride\", ride_number)  # type: ignore\n\n\n\n\n\n\nImportant\n\n\n\nPlan for Failure\nWhen writing a program you should always be thinking about how it could fail and the appropriate response. Any point that asks for user input is a major potential point of failure and should be handled correctly.\nYou should never catch exceptions to hide errors. You could all statements in a try...except block, but then you can’t identify any errors that occur.\n\n\n\n\n\n\n\nbreak statements allow you to exit a loop from inside\nAs soon as a break is encountered control immediately jumps to the next statement after the loop\nThe example code is given in UsingBreakToExitLoops.py\n\n# Example 6.6 Using Break to Exit Loops\n#\n# Demonstrates using a break statement to exit\n# a while loop from inside the loop\n\nwhile True:  # use break rather than a condition to exit\n    try:\n        ride_number_text = input(\"Please enter the ride number you want: \")\n        ride_number = int(ride_number_text)\n        break\n    except ValueError:\n        print(\"Invalid number text. Please enter digits\")\n    except KeyboardInterrupt:\n        print(\"You do not have permission to interrupt this program\")\n# Once outside the loop we have a valid number\nprint(\"You have selected ride\", ride_number)  # type: ignore\n\nThe above follows the previous example, but uses break rather than a flag to control the loop\nbreak statements can be paired with conditionals like if, as demonstrated in EarlyExitLoop.py\n\n\n# Example 6.7 Loop with condition ending early\n#\n# Demonstrates the pairing of break and conditional\n# statements to end a program early\n\ncount = 0\nwhile count &lt; 5:\n    print(\"Inside Loop\")\n    count = count + 1\n    if count == 3:\n        break\nprint(\"Outside loop\")\n\nInside Loop\nInside Loop\nInside Loop\nOutside loop\n\n\n\n\n\n\n\n\nTip\n\n\n\nDon’t use too many break statements\nA loop can theoretically only use many break statements to control flow. However break statements make it harder to reason about the flow of a loop. Sometimes they are the cleanest way to do something, but often they just make the code less readable.\nIn general prefer to use conditions to control loops, they are easier to reason about the state at the end of the loop\n\n\n\n\n\n\ncontinue causes control to immediately jump to the start of the next loop iteration\nFor example consider the Ride Selector example. If a ride is temporarily down we might push a patch to skip any selection of the ride, e.g. IgnoreRide.py given below\n\n# Example 6.8: Ignore Ride\n#\n# Demonstrates the use of continue to move\n# to the next loop iteration, skipping remaining\n# loop logic\n\nwhile True:\n    ride_number_text = input(\"Please enter the ride number you want: \")\n    ride_number = int(ride_number_text)\n    if ride_number == 3:\n        print(\"sorry, this ride is unavailable\")\n        continue\n    print(\"you have selected ride number: \", ride_number)\n\n\n\n\n\n\nNote\n\n\n\nYou wont use continue as often as you use break\nbreak can be useful in quite a few use cases. continue tends to be much more niche and isn’t used often\n\n\n\n\n\n\nYou can use a variable to make a loop repeat a specified number of times, e.g. in the below Times Tables Program\n\n\n# Example 6.9 Times Tables Tutor\n#\n# Uses Times Tables to demonstrate use of a counter\n# variable to control a loop\n\ncount = 1\ntimes_value = 2\nwhile count &lt; 13:\n    result = count * times_value\n    print(count, \"times\", times_value, \"equals\", result)\n    count = count + 1\n\n1 times 2 equals 2\n2 times 2 equals 4\n3 times 2 equals 6\n4 times 2 equals 8\n5 times 2 equals 10\n6 times 2 equals 12\n7 times 2 equals 14\n8 times 2 equals 16\n9 times 2 equals 18\n10 times 2 equals 20\n11 times 2 equals 22\n12 times 2 equals 24\n\n\n\nThe combination of while count &lt; 13 and count = count + 1 means that after \\(12\\) loop iterations the loop condition evaluates False and the loop ends\n\n\n\n\nConsider the previous example and answer the following questions\n\n\nWhat statement would you change if you wanted to generate the times table for three instead of two?\n\nWe would change times_value\n\nWhich statement would you change if you wanted to generate up to the \\(24\\) times table?\n\nWe would change the loop condition to count &lt; 25\n\nWhat would happen to the program if we changed the line count = count + 1 to count = count - 1\n\nThe loop would produce negative times tables, and never stop since count will be decreased every iteration and thus is always less than \\(13\\)\n\n\n\n\n\nWrite a version of the previous example that asks the user for the value of the times table they want. Add validation so that the user must enter a number between \\(2\\) and \\(12\\) inclusive\nOur solution (given in UserSelectedTimesTableTutor.py) prompts the user to enter a number between \\(2\\) - \\(12\\) inclusive, and then validates that the input is in the range.\nA try, except block is used to catch any invalid input type, and the whole thing is wrapped in a while True block that only ends once a valid integer in the range \\(2\\) - \\(12\\) is received through the use of a break statement. - The actual times tables code is then identical\n# Exercise 6.5 User SelectedTimes Tables Tutor\n#\n# Version of the times table tutor that allows the user to select the\n# times table in the range 2 - 12 they are interested in\n\ncount = 1\nwhile True:\n    try:\n        times_value_text = input(\n            \"Please enter a times table between 2-12 (inclusive): \"\n        )\n        times_value = int(times_value_text)\n        if times_value &lt; 2 or times_value &gt; 12:\n            print(\"Sorry, that is not between 2-12 (inclusive)\")\n        else:\n            break\n    except ValueError:\n        print(\"Please enter an integer\")\n\nwhile count &lt; 13:\n    result = count * times_value\n    print(count, \"times\", times_value, \"equals\", result)\n    count = count + 1\n\n\n\n\n\nFor loops operate similar to while loops, but are designed for when the number of iterations are known\n\n\n\n\n\n\nblock-beta\n    columns 6\n    space\n    space\n    title[\"Breakdown of a For\"]:2\n    space\n    space\n\n    block:Input\n    columns 1\n        while[\"for\"]\n        whileDescr[\"(start of the for construction)\"]\n    end\n\n    block:MiddleOne\n    columns 1\n        condition[\"variable\"]\n        conditionName[\"function name\"]\n        conditionDescr[\"(variable controlled in the for)\"]\n    end\n\n    block:In\n    columns 1\n        in[\"in\"]\n    end\n\n    block:Items\n    columns 1\n        items[\"items\"]\n        itemsDescr[\"(items to work through)\"]\n    end\n\n    block:MiddleTwo\n    columns 1\n        colon[\":\"]\n        colonDescr[\"Colon\"]\n    end\n\n    block:Suite\n    columns 1\n        suite[\"Statement block\"]\n        suiteDescr[\"(statements)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass condition BG\nclass conditionName BG\nclass conditionDescr BG\nclass colon BG\nclass colonDescr BG\nclass while BG\nclass whileDescr BG\nclass items BG\nclass itemsDescr BG\nclass suite BG\nclass suiteDescr BG\nclass in BG\n\n\n\n\n\n\n\nfor loops over a collection of items, acting on each item in turn\nEach iteration acts on next item in the collection\nAn example of a collection is a tuple, e.g.\n\nnames = ('Rob', 'Mary', 'David', 'Jenny', 'Chris', 'Imogen')\nnames is a tuple (denoted by the () containing the above names)\nWe’ll discuss Tuples in more detail in Chapter 8\n\nWe can pair the above tuple with a for loop e.g.\n\n\n# Example 6.10 Name Printer\n#\n# Prints a collection of names\n\nnames = (\"Rob\", \"Mary\", \"David\", \"Jenny\", \"Chris\", \"Imogen\")\nfor name in names:\n    print(name)\n\nRob\nMary\nDavid\nJenny\nChris\nImogen\n\n\n\nrange is a python function for generating a collection of numbers\n\nsyntax is range(start, stop) where start is included, but stop is excluded\ne.g. We could rewrite ours times table program as using range (see [RangeBasedTimeTables.py])\n\n\n\n# Example 6.11 Range Based Times Tables\n#\n# Demonstrates Python's range function using a for\n# loop to generate a times table\n\ntimes_value = 2\nfor count in range(1, 13):\n    result = count * times_value\n    print(count, \"times\", times_value, \"equals\", result)\n\n1 times 2 equals 2\n2 times 2 equals 4\n3 times 2 equals 6\n4 times 2 equals 8\n5 times 2 equals 10\n6 times 2 equals 12\n7 times 2 equals 14\n8 times 2 equals 16\n9 times 2 equals 18\n10 times 2 equals 20\n11 times 2 equals 22\n12 times 2 equals 24\n\n\n\nbreak and continue also work with for loops\n\ncontinue causes the loop to proceed to the next item in the collection\n\n\n\n\nLook at the following simple programs, and answer the corresponding questions about break and continue\n\nWhat would the following code print?\n\n for count in range(1, 13):\n     if count == 5:\n         break\n     print(count)\n print('Finished')\n\n1\n2\n3\n4\nFinished\n\n\n\nIt would print 1, 2, 3, 4 then \"finished\"\nSince when count is \\(5\\) the loop breaks before the print statement and then the print outside the loop is called\n\nWhat would the following code print?\n\n for count in range(1, 13):\n     if count == 5:\n         continue\n     print(count)\n print('Finished')\n\n1\n2\n3\n4\n6\n7\n8\n9\n10\n11\n12\nFinished\n\n\n\nThis program is similar to the above, except it would print 1 through to 12 but skip 5, before printing \"Finished\".\nThis is because the continue causes the loop iteration for count = 5 to skip the print statement in the loop and go to the next loop iteration\n\nWhat would the following code print?\n\n for count in range(1, 13):\n     count = 13\n     print(count)\n print('Finished')\n\n13\n13\n13\n13\n13\n13\n13\n13\n13\n13\n13\n13\nFinished\n\n\n\nThis will print \\(13\\) twelve times, because each time count starts a loop iteration it is set to the next value in the range(1, 13)\n\nThen inside the loop count is set to 13 and that value is printed\n\nOf course \"Finished\" is printed after the loop is down\n\nWould the following program run forever?\n\n while True:\n     break\n print('Finished')\n\nFinished\n\n\n\nNo, it will immediately end because break exits the loop\n\nWould the following program print the message “Looping”?\n while True:\n     continue\n     print('Looping')\n\nNo, the loop will hit the continue keyword and the go back to the start\nThis happens forever\n\nWhat would the following program do? Is it legal?\n\n for letter in 'hello world':\n     print(letter)\n\nh\ne\nl\nl\no\n\nw\no\nr\nl\nd\n\n\n\nStrings are collections of letters\nThe above program works, it loops over and prints each letter in the string\n\n\n\n\n\nReverse the behaviour of the times-table program so that rather than printing out the times-table your program instead asks questions like, “What is \\(6\\) times \\(4\\)?” The user could enter their answer, and the program could compare it with the correct answer and keep score of how many correct answers are given. You could use a loop to make the program produce \\(12\\) “times-table” questions, and you could use random numbers so that the quiz is different every time\nOur solution given in TimesTableQuiz.py is relatively complete. We use first print a header message, then we set up a variable to track the number of correct answers total and a second variable to track the number of questions to ask. We then go into our for loop, looping over range(0, NumberOfQuestions), this makes the loop run NumberOfQuestions times.\nThe actual quiz then proceeds, we randomly generate the two numbers, the times_value from the range [2, 12] and the count from the range [1, 12]. We then calculate the correct answer, and prompt the user for an answer, using the standard ValueError exception handling. If the user’s answer is correct we congratulate them and increment the score, else we tell them what the correct answer is. After they’ve answered all the questions we give them the final score\n# Exercise 6.6: Times Table Quiz\n#\n# Generates a times table quiz\n\nimport random\n\nprint(\"===Times table Quiz===\")\nscore = 0\nNumberOfQuestions = 12\n\nfor question in range(0, NumberOfQuestions):\n    times_value = random.randint(2, 12)\n    count = random.randint(1, 12)\n    correct_answer = times_value * count\n    while True:\n        try:\n            answer_text = input(\n                \"What is \" + str(count) + \" x \" + str(times_value) + \": \"\n            )\n            answer = int(answer_text)\n            break\n        except ValueError:\n            print(\"Please enter an integer\")\n    if answer == correct_answer:\n        score = score + 1\n        print(\"Correct!\")\n    else:\n        print(\"Sorry that's wrong!\")\n        print(\"The correct answer is\", correct_answer, \"you gave\", answer)\n\nprint(\"You got\", score, \"/\", NumberOfQuestions, \"correct\")\n\n\n\n\n\nPutting together what we’ve covered, we can make a digital clock using snaps (see DigitalClock.py)\n\n# Example 6.12: Digital Clock\n#\n# Uses a combination of loops and snaps to create a digital clock\n\nimport time\nimport snaps\n\nwhile True:\n    current_time = time.localtime()\n    hour_string = str(current_time.tm_hour)\n    minute_string = str(current_time.tm_min)\n    second_string = str(current_time.tm_sec)\n\n    time_string = hour_string + \":\" + minute_string + \":\" + second_string\n    snaps.display_message(time_string)\n    time.sleep(1)\n\n\nCombine the digital clock display from the previous example with the alarm clock from Chapter 5. Make the background image depend on the time of day\nOur final program is a bit complicated so we’ll analyse it in parts. The full file can be read in DigitalAlarmClock.py\nWe start by extracting the relevant date and time information from the current time, and perform a boolean check if it’s a weekend.\nWe first then check if the time is night (defined heuristically as from \\(7\\) pm through to \\(6\\) am) or day (\\(6\\) am to \\(7\\) pm). We then display a moon as the background in the former case, or a sun in the later.\nRemember we have to display the image first so that we can overlay the text on top.\n# Exercise 6.7: Digital Alarm Clock\n#\n# Integrates the Alarm Clock Functionality of\n# Chapter 5, with the Digital Clock Display of Chapter 6\n\nimport time\n\nimport snaps\n\nwhile True:\n    current_time = time.localtime()\n\n    hour = current_time.tm_hour\n    minute = current_time.tm_min\n    second = current_time.tm_sec\n    day = current_time.tm_mday\n    month = current_time.tm_mon\n    year = current_time.tm_year\n    is_weekend = current_time.tm_wday &gt;= 5\n\n    # draw the background\n    # define day as 6am - 7pm\n    if hour &gt;= 6 and hour &lt;= 19:\n        snaps.display_image(\"sun.png\")\n    else:\n        snaps.display_image(\"moon.png\")\nNow we prepare our datetime strings\n    # set up normal time and day clock behaviour\n    date_message = \"The date is \" + str(day) + \"/\" + str(month) + \"/\" + str(year)\n    time_message = \"The time is \" + str(hour) + \":\" + str(minute) + \":\" + str(second)\n    message = date_message + \"\\n\" + time_message\nNext we want to play a wake alarm at \\(7:30\\) giving as extra hour to sleep in on weekends. We also want to define a bed time. When the time hits \\(7:30\\) we want to play the alarm, then before bed time (\\(22:00\\))the clock should display a message telling us to get up, while after bed time it should tell us to go to sleep.\nThe if...else construct here is a bit more complicated. We only want to play the alarm sound at \\(7:30:00\\) rather than just if the user runs the clock after the wake up time. This is because the clock will then continuously play the sound every second it updates!\nOur first if statement thus checks if we are exactly on the alarm time, and if we are plays the alarm sound and updates the message\nWe then have to consider now when we check if the time is after the alarm has gone off that it is also not before it is time to go back to bed. It’s cleaner to split this into two cases (our elif statements)\nIn the first case if the hour is equal to the hour to get up and greater than the minute to get up then it must be time to get up and we don’t need to play the alarm (since the first if statement catches this case). Note this makes the assumption that we don’t wake up at a time like \\(8:30\\) and then go to bed at \\(8:59\\) which is reasonable.\nThe second case is when the hour is greater than the hour to get up. Here we have to check that either the hour is less than the hour we go to bed at or if it is the same, that the minutes are less than the minutes we go to bed at. (Effectively the reverse of our old alarm condition.) In either of the previous cases we only then need to update the final printed message with the statement that we should be up\nThe last case (the else) is our default case for when none of the previous cases are matched. By exhaustion of cases this has to be when it is time for us to be in bed by default. So we don’t need to do extra checks and can just update the message to tell us to go to sleep\n    # Play alarm and optionally append a wake up message\n    hour_to_get_up = 7 + is_weekend\n    hour_to_sleep = 22\n    minute_to_get_up = 30\n    minute_to_sleep = 0\n\n    wake_up_message = \"TIME TO GET UP!\"\n    sleep_message = \"TIME FOR BED!\"\n\n    # case 1: On the alarm\n    if hour == hour_to_get_up and minute == minute_to_get_up and second == 0:\n        snaps.play_sound(\"siren.wav\")\n        message = message + \"\\n\" + wake_up_message\n    # Past the alarm\n    elif hour == hour_to_get_up and minute &gt;= minute_to_get_up:\n        message = message + \"\\n\" + wake_up_message\n    # past the alarm but before bed\n    elif hour &gt; hour_to_get_up and (\n        hour &lt; hour_to_sleep or (hour == hour_to_sleep and minute &lt; minute_to_sleep)\n    ):\n        message = message + \"\\n\" + wake_up_message\n    # time for bed\n    else:\n        message = message + \"\\n\" + sleep_message\nFinally we display the message and then sleep for a second before updating the clock again\n    # display the message and then sleep\n    snaps.display_message(message, size=100)\n    time.sleep(1)",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 6: Repeating Actions with Loops"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/06_RepeatingActionsWithLoops/Chapter_06.html#notes",
    "href": "01_ProgrammingFundamentals/06_RepeatingActionsWithLoops/Chapter_06.html#notes",
    "title": "Chapter 6: Repeating Actions with Loops",
    "section": "",
    "text": "while allows a program to repeat blocks of statements\nstructure is similar to an if\n\n\n\n\n\n\nblock-beta\n    columns 4\n    space\n    title[\"Breakdown of a While\"]:2\n    space\n\n    block:Input\n    columns 1\n        while[\"while\"]\n        whileDescr[\"(start of the while construction)\"]\n    end\n\n    block:MiddleOne\n    columns 1\n        condition[\"condition\"]\n        conditionDescr[\"(value that is True or False)\"]\n    end\n\n    block:MiddleTwo\n    columns 1\n        colon[\":\"]\n        colonDescr[\"Colon\"]\n    end\n\n    block:Suite\n    columns 1\n        suite[\"Statement block\"]\n        suiteDescr[\"(statements)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass condition BG\nclass conditionDescr BG\nclass colon BG\nclass colonDescr BG\nclass while BG\nclass whileDescr BG\nclass suite BG\nclass suiteDescr BG\n\n\n\n\n\n\n\nif the condition evaluates True then the block of statements is run\n\nAfter the statements are run, control returns to the start of the while loop\nIf the condition is still True then the loop runs again\n\n\n\n\nUse the python interpreter to run the following to understand the while loop\n\nCan we use a boolean value to control a while construction?\n\nYes, for example the block of statements in the while here shouldn’t run\n\n\n while False:\n     print(\"Loop\")\n print(\"Outside the Loop\")\n\nOutside the Loop\n\n\nCan a loop go on forever?\n\nYes, an control expression for a while that always evaluates True will cause the loop to run infinitely\n\n while True:\n     print(\"Loop\")\n print(\"Outside the Loop\")\n\nThe above should only print \"Loop\" when executed\nIf you accidentally do this you may need to use CTRL+C, CTRL+Z or an interrupt execution feature of your live environment to stop the execution\n\nWill the following program ever print out the message, \"Outside loop\"?\n while True:\n     print(\"Inside Loop\")\n print(\"Outside Loop\")\n\nNo, the above is a quintessential infinite loop\n\nWill the following program ever print out the message, \"Inside Loop\"? How about \"Outside loop\"?\n\n while False:\n     print(\"Inside Loop\")\n print(\"Outside Loop\")\n\nOutside Loop\n\n\n\nThe while never executes the statements inside so \"Inside Loop\" is never printed, but \"Outside Loop\" is.\n\nWhat will the following program print?\n\n # Example 6.1 Loop with Flag\n #\n # Demonstrates control of a loop with a boolean flag\n\n flag = True\n while flag:\n     print(\"Inside Loop\")\n     flag = False\n print(\"Outside Loop\")\n\nInside Loop\nOutside Loop\n\n\n\nWhen we first enter the loop flag is True so the loop executes and*\"Inside Loop\" is printed\nflag is then set False so on the next iteration of the loop, the loop doesn’t execute.\nWe move to the next statement outside of the loop and print out \"Outside Loop\"\nThe pattern of using a control variable that is updated in the loop body in a while loop is very common\n\nWhat will the following program print?\n flag = True\n while flag:\n     print(\"Inside Loop\")\n     Flag = False\n print(\"Outside Loop\")\n\nThis looks similar to the previous, but note the typo, we refer to Flag not flag inside the loop\nThis which defines a new variable, instead of modifying the loop control.\nWe thus get an infinite series of \"Inside Loop\" being printed.\n\nWhat will the following program print?\n\n # Example 6.2 Loop with Counter\n #\n # Demonstrates use control of a while loop\n # using a conditional expression\n\n count = 0\n while count &lt; 5:\n     print(\"Inside Loop\")\n     count = count + 1\n print(\"Outside Loop\")\n\nInside Loop\nInside Loop\nInside Loop\nInside Loop\nInside Loop\nOutside Loop\n\n\n\ncount is initially set to \\(0\\)\nAt each iteration we print \"Inside Loop\" * and increase the value of count by \\(1\\)\nThe loop stops once count reaches \\(5\\)\nThis means that \"Inside Loop\" should be printed \\(5\\) times, followed by \"Outside Loop\"\n\n\n\n\n\nUse a while loop, to make a theme park selector that runs continuously. All you need to do is put all of the statements that implement the theme park behaviour into a while True construction\nFor usability our program won’t loop endlessly. We’ll say that any number that it is not a valid ride number is code for quitting the program. The relevant changes to the Ride Selector are then,\n# Exercise 6.1 Looping Ride Selector\n#\n# Wraps the Ride Selector Program in a while\n# loop to allow the user to look at multiple rides\n\nrun_program = True\n\nwhile run_program:\n    print(\"\"\"Welcome to our Theme Park\n        These are the available ride:\n\n        1. Scenic River Cruise\n        2. Carnival Carousel\n        3. Jungle Adventure Water Splash\n        4. Downhill Mountain Run\n        5. The Regurgitator\n        Any other number to quit...\n        \"\"\")\n\n    ride_number_text = input(\"Please enter the ride number you want: \")\n    ride_number = int(ride_number_text)\n\n    if ride_number &lt; 1 or ride_number &gt; 5:\n        run_program = False\n    elif ride_number == 1:\nObserve that first we wrap all of the code in a while loop, and introduce a boolean flag run_program initially set to True to flag if the program continues to run at each loop iteration. When a user enters a number we first check if it corresponds to a ride number and if not, we set the program to quit on the next loop iteration by setting run_program to False. We now change the original if ride_number == 1 to and elif so it is only checked if we know the ride_number is valid. (The full code is in LoopingRideSelector.py)\n\n\n\nOne of the examples in the above question set involved a countup to \\(5\\). Implement a program that counts down from \\(10\\) to \\(0\\) over \\(10\\) seconds\n# Exercise 6.2: Countdown\n#\n# Performs a 10-second countdown\n\nimport time\n\ntime_left = 10\n\nwhile time_left &gt;= 0:\n    print(time_left)\n    time_left = time_left - 1\n    time.sleep(1)\n\n\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\n\n\nThis is a straightforward exercise (see Countdown.py), we set up our counter value to \\(10\\) and use the appropriate loop expression (here time_left &gt;= 0) to ensure that \\(0\\) is included in the countdown.\nIn the loop we print the current value of time_left, then decrement time_left by \\(1\\), and sleep for the required time. Observe that after the program prints \\(0\\), time_left becomes \\(-1\\) and the next iteration of the loop won’t run.\n\n\n\n\nRide Selector doesn’t account for invalid user entry\n\nBlindly assumes a number outside the range \\(1\\) to \\(5\\) represents quitting the program\n\nIdeally we would like to have a distinct number that represents quitting and a way to capture and handle any invalid inputs\n\n\n\n\n\n\n\nTip\n\n\n\nGreat Programmers Think Defensively\nDefensive programming is a programming technique in which a programmer attempts to defend their code against possible errors that might occur in a code e.g. receiving a word when expecting a number\nIt is good practice to think about, typically a user expects a computer to do something reasonable even when provided unreasonable input.\nData validation does have the downside in that it can make programs significantly bigger, and in compiled languages knowing that data is valid can make them much faster. A good skill is learning the correct layers or boundaries of a program to perform the defensive data validation so the core can run without concern\n\n\n\nIgnoring the question of quitting for now, data validation for the ride selector might look like,\n  if ride_number &lt; 1 or ride_number &gt; 5:\n      print('Invalid ride number')\n\n\n\n\nAbove acknowledges the error, but if we want to use this in our loop control we will need to use while\n  ride_number_text = input(\"Please enter the ride number you want: \")\n  ride_number = int(ride_number_text)\n\n  while ride_number &lt; 1 or ride_number &gt; 5:\n      print(\"There is no ride with that number\")\n      ride_number_text = input(\"Please enter the ride number you want: \")\n      ride_number = int(ride_number_text)\n  print(\"You have selected ride number: \", ride_number)\n\nwhile means program repeats until it receives valid input\nObserve the downside\n\nWe have to repeat the code asking for the ride number and converting to an integer\nSome languages have a do ... while statement which performs its test after executing the loop body for the first time\n\nWould allow us to write the above as one construct\n\n\n\n\n\n\nAdd ride number validation to the Looping Ride Selector implementation. Remember that the while construction must be added after the ride_number value has been read by the program\nWe can basically add the validation in immediately after the first attempt to read the ride number from the user. We also have to adjust the code to now use \\(0\\) as the explicit value for quitting rather than inferring any non-ride-number as a quit value. The main changes are,\n# Exercise 6.3 Ride Selector with Ride Number Validation\n#\n# Adds Ride Number validation to the Ride Selector\n# The program will query the user until a valid ride number or\n# the quit number is given\n\nwhile run_program:\n    print(\"\"\"Welcome to our Theme Park\n        These are the available ride:\n\n        1. Scenic River Cruise\n        2. Carnival Carousel\n        3. Jungle Adventure Water Splash\n        4. Downhill Mountain Run\n        5. The Regurgitator\n        Press 0 to quit the program\n        \"\"\")\n\n    ride_number_text = input(\"Please enter the ride number you want: \")\n    ride_number = int(ride_number_text)\n\n    while ride_number &lt; 0 or ride_number &gt; 5:\n        print(\"There is no ride with that number\")\n        ride_number_text = input(\"Please enter the ride number you want: \")\n        ride_number = int(ride_number_text)\n\n    if ride_number == 0:\n        run_program = False\nThe complete code is given in RideNumberValidation.py\n\n\n\nWhen creating composite conditions for loops, making sure the logic is correct is incredibly important. Examine the following program to understand more complicated loop control\nage_text = input(\"Please enter your age: \")\nage = int(age_text)\nwhile age &lt; 1 and age &gt; 95:\n    #repeat this code while the age is invalid\n    print(\"This age is not valid\")\n    age_text = input(\"Please enter your age: \")\n    age = int(age_text)\n#when we are here, we have a valid age value\nprint(\"Thank you for entering your age\")\n\nWhat is the fault in this program?\n\nThe condition age &lt; 1 and age &gt; 95 requires age to be both less than \\(1\\) and greater than \\(95\\), this is impossible, so the loop never runs\n\nWhat will the fault cause the program to do?\n\nSince the loop body can never run, every entered age will be considered valid\n\nHow do you fix this?\n\nThe desired logic is that age should be between \\(1\\) and \\(95\\) inclusive. This logic is captured by the or operator.\nThe corrected expression is*\n  while age &lt; 1 or age &gt; 95\n\n\n\n\n\n\n\n\nImportant\n\n\n\nAlways test failure behaviours along with successful ones\nIt’s very important when testing software to test both the successful path (the so-called “happy path”) and any possible error states.\nA good programmer proactively looks for potential points of failure, writes code to handle the errors and importantly checks that the code to handle the errors does what it’s supposed to do\nA good heuristic for starting to do this with simple programs is called boundary-value testing. Boundaries are the points between different expected behaviours. For example with the ride selector, we expect different behaviour for numbers \\(&lt; 1\\) or \\(&gt; 5\\) to those in the range \\(1\\) to \\(5\\). So a good set of tests might be \\(0\\), \\(1\\), \\(2\\), \\(4\\), \\(5\\), \\(6\\). i.e. we test either side of the boundary, and on the boundary\n\n\n\n\n\nAdd age validation to the Ride Selection Program. The theme park owner has told you that the minimum age for anyone going on a ride at the theme park is \\(1\\) year, and the maximum age is \\(95\\). Use these values in your program\nObserve that in this case if the user provides an age outside the accepted range, we don’t want to prompt them to put in a new age, since this could legitimately be their age. Instead we want to tell them regardless of the ride they chose they can’t ride. In this case we should use an if style validation technique\nThe change is applied at our age reading section of the program, we use an if...elif...else construct to tell the user they are either too young, too old, or to continue on to the standard ride selection code\nage_text = input(\"Please enter your age: \")\nage = int(age_text)\nif age &lt; 1:\n    print(\"You are too young to go on any rides\")\nelif age &gt; 95:\n    print(\"You are too old to go on any rides\")\nelse:\n    #continue on to normal ride selection code...\nThe full code is given in AgeValidation.py\n\n\n\n\n\n\n\nProblem: We can easily write a loop that checks if a value is invalid but how do we deal with the type being invalid?\n\ne.g. in the ride selector how do we deal with the user typing in a word rather than a number?\nConsider the snippet below, emulating the ride selector given a string input, we get an error, before we even get a chance to validate the value\n\n\n  ride_number_text = \"three\"\n  ride_number = int(ride_number_text)\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[6], line 2\n      1 ride_number_text = \"three\"\n----&gt; 2 ride_number = int(ride_number_text)\n\nValueError: invalid literal for int() with base 10: 'three'\n\n\n\n\nThis occurs because int requires it’s input to be convertible to a number\n\nUnfortunately this does not extend to human-language written versions of a number\nIn this case int throws an error, it is better to end the program than continue in an erroneous state\n\nIn general, when a program encounters an error state, it should aim to fail fast, rather than continue and generate unexpected outcomes\n\nExceptions are a mechanism by which elements of a program can inform other parts about errors that have occurred\n\nExceptions combine a description of what the error that occurred was, with where the error occurred\nIn the example above e.g. we are told that we got a ValueError\ni.e. an invalid value was found, we are given the additional detail “invalid literal for int() with base 10: ‘three’”\nIn plain english, the program did not know how to convert ‘three’ to an integer\nWe are also told where, in this case the second line, in the function int\n\nTo recover from an exception we have to handle it, i.e. do something\n\nThe first step is to catch the exception\nWe wrap code that might throw an exception in a try... except block\n\n# Example 6.3: Catching Exceptions\n#\n# Demonstrates how to catch and handle\n# an exception\n\n  try:\n      ride_number_text = input(\"Please enter a ride number: \")\n      ride_number = int(ride_number_text) #statement that might raise exception\n      print(\"You have entered\", ride_number)\n  except ValueError: # Start of an exception handler\n      print(\"Invalid number\") # Performed if exception raised\nWe wrap the code that may throw an exception in a try\nWe then use except to define statements we want to run if an exception is thrown\n\nIf an exception is thrown, control immediately jumps to the except block\ne.g. In the above example if int throws a ValueError then the line print(\"You have entered\", ride_number) won’t run\n\nInstead print(\"Invalid number\") runs\n\n\nAs observed except is followed by the exception type we want to catch (in this case ValueError)\nThe full example is given in CatchingExceptions\n\n\n\n\n\n\nblock-beta\n    columns 4\n    space\n    title[\"Breakdown of a Try-Except Block\"]:2\n    space\n\n    block:Try:2\n    columns 1\n        try[\"try\"]\n        tryDescr[\"(start of the try construction)\"]\n    end\n\n    block:TryColon\n    columns 1\n        Trycolon[\":\"]\n        TryColonDescr[\"colon\"]\n    end\n\n    block:TrySuite\n    columns 1\n        Trysuite[\"Statements\"]\n        TrysuiteDescr[(\"statements to execute normally\")]\n    end\n\n\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass try BG\nclass tryDescr BG\nclass Trycolon BG\nclass TryColonDescr BG\nclass Trysuite BG\nclass TrysuiteDescr BG\n\n    block:ExceptOne\n    columns 1\n        exceptOne[\"except\"]\n        exceptOneDescr[\"(start of an exception construction)\"]\n    end\n\n    block:ExceptNameOne\n    columns 1\n        exceptOneName[\"Name\"]\n        exceptOneNameDescr[\"(exception name)\"]\n    end\n\n    block:ExceptOneColon\n    columns 1\n        exceptOneColon[\":\"]\n        exceptOneColonDescr[\"colon\"]\n    end\n\n    block:ExceptOneStatements\n    columns 1\n        exceptOneStatements[\"statements\"]\n        exceptOneStatementsDescr[(\"statements to execute if exception caught\")]\n    end\n\nclass exceptOne BG\nclass exceptOneDescr BG\nclass exceptOneName BG\nclass exceptOneNameDescr BG\nclass exceptOneColon BG\nclass exceptOneColonDescr BG\nclass exceptOneStatements BG\nclass exceptOneStatementsDescr BG\n\n    block:ExceptTwo\n    columns 1\n        exceptTwo[\"except\"]\n        exceptTwoDescr[\"(start of an exception construction)\"]\n    end\n\n    block:ExceptNameTwo\n    columns 1\n        exceptTwoName[\"Name\"]\n        exceptTwoNameDescr[\"(exception name)\"]\n    end\n\n    block:ExceptTwoColon\n    columns 1\n        exceptTwoColon[\":\"]\n        exceptTwoColonDescr[\"colon\"]\n    end\n\n    block:ExceptTwoStatements\n    columns 1\n        exceptTwoStatements[\"statements\"]\n        exceptTwoStatementsDescr[(\"statements to execute if exception caught\")]\n    end\n\nclass exceptTwo BG\nclass exceptTwoDescr BG\nclass exceptTwoName BG\nclass exceptTwoNameDescr BG\nclass exceptTwoColon BG\nclass exceptTwoColonDescr BG\nclass exceptTwoStatements BG\nclass exceptTwoStatementsDescr BG\n\n\n\n\n\n\n\nAs demonstrated above a try...except block may contain multiple except statements designed to handle different exception types\n\n\n\n\nWe’ve seen how to use loops to handle invalid values\nWe’ve seen how to use exceptions to handle invalid types\nNow let’s put that together to write a loop to handle exceptions\n\n\n\nWe want to make a program that will perform a while construction as long as the user keeps typing in text that cannot be converted into a number. Look at the example code below, (see HandlingInvalidText.py) and answer the questions\n# Example 6.4: Handling Invalid Text\n#\n# Combines loops and exception handling to prompt a user\n# for a valid number and repeat until a number is provided\n\nride_number_valid = False  # create and set a flag to False\nwhile not ride_number_valid:  # repeats while flag is False\n    try:\n        ride_number_text = input(\"Please enter the ride number you want: \")\n        ride_number = int(ride_number_text)  # can throw a ValueError\n        ride_number_valid = True  # successfully read a number\n    except ValueError:  # catch the ValueError\n        print(\"Invalid number. Please enter a number in digits\")\n# Once outside the loop we have a valid number\nprint(\"You have selected ride\", ride_number)\n\nWhat is the purpose of the variable, ride_number_valid?\n\nIt is a flag\nTracks the state of a program, in this case a valid number been read\nStarts False once successfully received an int flips to True\n\nHow many times would you expect the while construction to loop when the program is used?\n\nIdeally we would expect it to run once\n\ni.e. The user enters a number straight away\n\nIn the next best case we would expect it run twice\n\nThe user experiences an error, reads the message and corrects their input the next time\n\n\nWhy don’t we have to test ride_number_valid at line \\(10\\), to make sure that the ride number is valid?\n\nThe while loop stops when it’s condition is False\nThis corresponds to ride_number_valid = True\nSo we know that once we leave the loop ride_number_valid must be True\n\n\n\n\n\n\n\nSometimes there a multiple exception types we wish to handle\ne.g. a KeyboardInterrupt allows a user to issue an exception which could stop a program\n\nIf the user is interacting with somebody else’s external facing program, we might not want them to be able to do this\n\nSimultaneously we might need to ensure that the user inputs valid data like numbers\nWe can just add an additional except block\n\nWhen an exception is thrown, the appropriate handler takes control\n\nThe improved exception handling code is given in HandlingInvalidTextMultipleExceptions\n\n# Example 6.5: Improved Handling Invalid Text\n#\n# Extends Example 6.4 by preventing the user from issuing a\n# keyboard interrupt to stop the program\n\nride_number_valid = False  # create and set a flag to False\nwhile not ride_number_valid:  # repeats while flag is False\n    try:\n        ride_number_text = input(\"Please enter the ride number you want: \")\n        ride_number = int(ride_number_text)  # can throw a ValueError\n        ride_number_valid = True  # successfully read a number\n    except ValueError:  # catch the ValueError\n        print(\"Invalid number. Please enter a number in digits\")\n    except KeyboardInterrupt:  # catches the interrupt\n        print(\"You do not have permission to interrupt this program\")\n# Once outside the loop we have a valid number\nprint(\"You have selected ride\", ride_number)  # type: ignore\n\n\n\n\n\n\nImportant\n\n\n\nPlan for Failure\nWhen writing a program you should always be thinking about how it could fail and the appropriate response. Any point that asks for user input is a major potential point of failure and should be handled correctly.\nYou should never catch exceptions to hide errors. You could all statements in a try...except block, but then you can’t identify any errors that occur.\n\n\n\n\n\n\n\nbreak statements allow you to exit a loop from inside\nAs soon as a break is encountered control immediately jumps to the next statement after the loop\nThe example code is given in UsingBreakToExitLoops.py\n\n# Example 6.6 Using Break to Exit Loops\n#\n# Demonstrates using a break statement to exit\n# a while loop from inside the loop\n\nwhile True:  # use break rather than a condition to exit\n    try:\n        ride_number_text = input(\"Please enter the ride number you want: \")\n        ride_number = int(ride_number_text)\n        break\n    except ValueError:\n        print(\"Invalid number text. Please enter digits\")\n    except KeyboardInterrupt:\n        print(\"You do not have permission to interrupt this program\")\n# Once outside the loop we have a valid number\nprint(\"You have selected ride\", ride_number)  # type: ignore\n\nThe above follows the previous example, but uses break rather than a flag to control the loop\nbreak statements can be paired with conditionals like if, as demonstrated in EarlyExitLoop.py\n\n\n# Example 6.7 Loop with condition ending early\n#\n# Demonstrates the pairing of break and conditional\n# statements to end a program early\n\ncount = 0\nwhile count &lt; 5:\n    print(\"Inside Loop\")\n    count = count + 1\n    if count == 3:\n        break\nprint(\"Outside loop\")\n\nInside Loop\nInside Loop\nInside Loop\nOutside loop\n\n\n\n\n\n\n\n\nTip\n\n\n\nDon’t use too many break statements\nA loop can theoretically only use many break statements to control flow. However break statements make it harder to reason about the flow of a loop. Sometimes they are the cleanest way to do something, but often they just make the code less readable.\nIn general prefer to use conditions to control loops, they are easier to reason about the state at the end of the loop\n\n\n\n\n\n\ncontinue causes control to immediately jump to the start of the next loop iteration\nFor example consider the Ride Selector example. If a ride is temporarily down we might push a patch to skip any selection of the ride, e.g. IgnoreRide.py given below\n\n# Example 6.8: Ignore Ride\n#\n# Demonstrates the use of continue to move\n# to the next loop iteration, skipping remaining\n# loop logic\n\nwhile True:\n    ride_number_text = input(\"Please enter the ride number you want: \")\n    ride_number = int(ride_number_text)\n    if ride_number == 3:\n        print(\"sorry, this ride is unavailable\")\n        continue\n    print(\"you have selected ride number: \", ride_number)\n\n\n\n\n\n\nNote\n\n\n\nYou wont use continue as often as you use break\nbreak can be useful in quite a few use cases. continue tends to be much more niche and isn’t used often\n\n\n\n\n\n\nYou can use a variable to make a loop repeat a specified number of times, e.g. in the below Times Tables Program\n\n\n# Example 6.9 Times Tables Tutor\n#\n# Uses Times Tables to demonstrate use of a counter\n# variable to control a loop\n\ncount = 1\ntimes_value = 2\nwhile count &lt; 13:\n    result = count * times_value\n    print(count, \"times\", times_value, \"equals\", result)\n    count = count + 1\n\n1 times 2 equals 2\n2 times 2 equals 4\n3 times 2 equals 6\n4 times 2 equals 8\n5 times 2 equals 10\n6 times 2 equals 12\n7 times 2 equals 14\n8 times 2 equals 16\n9 times 2 equals 18\n10 times 2 equals 20\n11 times 2 equals 22\n12 times 2 equals 24\n\n\n\nThe combination of while count &lt; 13 and count = count + 1 means that after \\(12\\) loop iterations the loop condition evaluates False and the loop ends\n\n\n\n\nConsider the previous example and answer the following questions\n\n\nWhat statement would you change if you wanted to generate the times table for three instead of two?\n\nWe would change times_value\n\nWhich statement would you change if you wanted to generate up to the \\(24\\) times table?\n\nWe would change the loop condition to count &lt; 25\n\nWhat would happen to the program if we changed the line count = count + 1 to count = count - 1\n\nThe loop would produce negative times tables, and never stop since count will be decreased every iteration and thus is always less than \\(13\\)\n\n\n\n\n\nWrite a version of the previous example that asks the user for the value of the times table they want. Add validation so that the user must enter a number between \\(2\\) and \\(12\\) inclusive\nOur solution (given in UserSelectedTimesTableTutor.py) prompts the user to enter a number between \\(2\\) - \\(12\\) inclusive, and then validates that the input is in the range.\nA try, except block is used to catch any invalid input type, and the whole thing is wrapped in a while True block that only ends once a valid integer in the range \\(2\\) - \\(12\\) is received through the use of a break statement. - The actual times tables code is then identical\n# Exercise 6.5 User SelectedTimes Tables Tutor\n#\n# Version of the times table tutor that allows the user to select the\n# times table in the range 2 - 12 they are interested in\n\ncount = 1\nwhile True:\n    try:\n        times_value_text = input(\n            \"Please enter a times table between 2-12 (inclusive): \"\n        )\n        times_value = int(times_value_text)\n        if times_value &lt; 2 or times_value &gt; 12:\n            print(\"Sorry, that is not between 2-12 (inclusive)\")\n        else:\n            break\n    except ValueError:\n        print(\"Please enter an integer\")\n\nwhile count &lt; 13:\n    result = count * times_value\n    print(count, \"times\", times_value, \"equals\", result)\n    count = count + 1\n\n\n\n\n\nFor loops operate similar to while loops, but are designed for when the number of iterations are known\n\n\n\n\n\n\nblock-beta\n    columns 6\n    space\n    space\n    title[\"Breakdown of a For\"]:2\n    space\n    space\n\n    block:Input\n    columns 1\n        while[\"for\"]\n        whileDescr[\"(start of the for construction)\"]\n    end\n\n    block:MiddleOne\n    columns 1\n        condition[\"variable\"]\n        conditionName[\"function name\"]\n        conditionDescr[\"(variable controlled in the for)\"]\n    end\n\n    block:In\n    columns 1\n        in[\"in\"]\n    end\n\n    block:Items\n    columns 1\n        items[\"items\"]\n        itemsDescr[\"(items to work through)\"]\n    end\n\n    block:MiddleTwo\n    columns 1\n        colon[\":\"]\n        colonDescr[\"Colon\"]\n    end\n\n    block:Suite\n    columns 1\n        suite[\"Statement block\"]\n        suiteDescr[\"(statements)\"]\n    end\n\nclassDef BG stroke:transparent, fill:transparent\nclass title BG\nclass condition BG\nclass conditionName BG\nclass conditionDescr BG\nclass colon BG\nclass colonDescr BG\nclass while BG\nclass whileDescr BG\nclass items BG\nclass itemsDescr BG\nclass suite BG\nclass suiteDescr BG\nclass in BG\n\n\n\n\n\n\n\nfor loops over a collection of items, acting on each item in turn\nEach iteration acts on next item in the collection\nAn example of a collection is a tuple, e.g.\n\nnames = ('Rob', 'Mary', 'David', 'Jenny', 'Chris', 'Imogen')\nnames is a tuple (denoted by the () containing the above names)\nWe’ll discuss Tuples in more detail in Chapter 8\n\nWe can pair the above tuple with a for loop e.g.\n\n\n# Example 6.10 Name Printer\n#\n# Prints a collection of names\n\nnames = (\"Rob\", \"Mary\", \"David\", \"Jenny\", \"Chris\", \"Imogen\")\nfor name in names:\n    print(name)\n\nRob\nMary\nDavid\nJenny\nChris\nImogen\n\n\n\nrange is a python function for generating a collection of numbers\n\nsyntax is range(start, stop) where start is included, but stop is excluded\ne.g. We could rewrite ours times table program as using range (see [RangeBasedTimeTables.py])\n\n\n\n# Example 6.11 Range Based Times Tables\n#\n# Demonstrates Python's range function using a for\n# loop to generate a times table\n\ntimes_value = 2\nfor count in range(1, 13):\n    result = count * times_value\n    print(count, \"times\", times_value, \"equals\", result)\n\n1 times 2 equals 2\n2 times 2 equals 4\n3 times 2 equals 6\n4 times 2 equals 8\n5 times 2 equals 10\n6 times 2 equals 12\n7 times 2 equals 14\n8 times 2 equals 16\n9 times 2 equals 18\n10 times 2 equals 20\n11 times 2 equals 22\n12 times 2 equals 24\n\n\n\nbreak and continue also work with for loops\n\ncontinue causes the loop to proceed to the next item in the collection\n\n\n\n\nLook at the following simple programs, and answer the corresponding questions about break and continue\n\nWhat would the following code print?\n\n for count in range(1, 13):\n     if count == 5:\n         break\n     print(count)\n print('Finished')\n\n1\n2\n3\n4\nFinished\n\n\n\nIt would print 1, 2, 3, 4 then \"finished\"\nSince when count is \\(5\\) the loop breaks before the print statement and then the print outside the loop is called\n\nWhat would the following code print?\n\n for count in range(1, 13):\n     if count == 5:\n         continue\n     print(count)\n print('Finished')\n\n1\n2\n3\n4\n6\n7\n8\n9\n10\n11\n12\nFinished\n\n\n\nThis program is similar to the above, except it would print 1 through to 12 but skip 5, before printing \"Finished\".\nThis is because the continue causes the loop iteration for count = 5 to skip the print statement in the loop and go to the next loop iteration\n\nWhat would the following code print?\n\n for count in range(1, 13):\n     count = 13\n     print(count)\n print('Finished')\n\n13\n13\n13\n13\n13\n13\n13\n13\n13\n13\n13\n13\nFinished\n\n\n\nThis will print \\(13\\) twelve times, because each time count starts a loop iteration it is set to the next value in the range(1, 13)\n\nThen inside the loop count is set to 13 and that value is printed\n\nOf course \"Finished\" is printed after the loop is down\n\nWould the following program run forever?\n\n while True:\n     break\n print('Finished')\n\nFinished\n\n\n\nNo, it will immediately end because break exits the loop\n\nWould the following program print the message “Looping”?\n while True:\n     continue\n     print('Looping')\n\nNo, the loop will hit the continue keyword and the go back to the start\nThis happens forever\n\nWhat would the following program do? Is it legal?\n\n for letter in 'hello world':\n     print(letter)\n\nh\ne\nl\nl\no\n\nw\no\nr\nl\nd\n\n\n\nStrings are collections of letters\nThe above program works, it loops over and prints each letter in the string\n\n\n\n\n\nReverse the behaviour of the times-table program so that rather than printing out the times-table your program instead asks questions like, “What is \\(6\\) times \\(4\\)?” The user could enter their answer, and the program could compare it with the correct answer and keep score of how many correct answers are given. You could use a loop to make the program produce \\(12\\) “times-table” questions, and you could use random numbers so that the quiz is different every time\nOur solution given in TimesTableQuiz.py is relatively complete. We use first print a header message, then we set up a variable to track the number of correct answers total and a second variable to track the number of questions to ask. We then go into our for loop, looping over range(0, NumberOfQuestions), this makes the loop run NumberOfQuestions times.\nThe actual quiz then proceeds, we randomly generate the two numbers, the times_value from the range [2, 12] and the count from the range [1, 12]. We then calculate the correct answer, and prompt the user for an answer, using the standard ValueError exception handling. If the user’s answer is correct we congratulate them and increment the score, else we tell them what the correct answer is. After they’ve answered all the questions we give them the final score\n# Exercise 6.6: Times Table Quiz\n#\n# Generates a times table quiz\n\nimport random\n\nprint(\"===Times table Quiz===\")\nscore = 0\nNumberOfQuestions = 12\n\nfor question in range(0, NumberOfQuestions):\n    times_value = random.randint(2, 12)\n    count = random.randint(1, 12)\n    correct_answer = times_value * count\n    while True:\n        try:\n            answer_text = input(\n                \"What is \" + str(count) + \" x \" + str(times_value) + \": \"\n            )\n            answer = int(answer_text)\n            break\n        except ValueError:\n            print(\"Please enter an integer\")\n    if answer == correct_answer:\n        score = score + 1\n        print(\"Correct!\")\n    else:\n        print(\"Sorry that's wrong!\")\n        print(\"The correct answer is\", correct_answer, \"you gave\", answer)\n\nprint(\"You got\", score, \"/\", NumberOfQuestions, \"correct\")\n\n\n\n\n\nPutting together what we’ve covered, we can make a digital clock using snaps (see DigitalClock.py)\n\n# Example 6.12: Digital Clock\n#\n# Uses a combination of loops and snaps to create a digital clock\n\nimport time\nimport snaps\n\nwhile True:\n    current_time = time.localtime()\n    hour_string = str(current_time.tm_hour)\n    minute_string = str(current_time.tm_min)\n    second_string = str(current_time.tm_sec)\n\n    time_string = hour_string + \":\" + minute_string + \":\" + second_string\n    snaps.display_message(time_string)\n    time.sleep(1)\n\n\nCombine the digital clock display from the previous example with the alarm clock from Chapter 5. Make the background image depend on the time of day\nOur final program is a bit complicated so we’ll analyse it in parts. The full file can be read in DigitalAlarmClock.py\nWe start by extracting the relevant date and time information from the current time, and perform a boolean check if it’s a weekend.\nWe first then check if the time is night (defined heuristically as from \\(7\\) pm through to \\(6\\) am) or day (\\(6\\) am to \\(7\\) pm). We then display a moon as the background in the former case, or a sun in the later.\nRemember we have to display the image first so that we can overlay the text on top.\n# Exercise 6.7: Digital Alarm Clock\n#\n# Integrates the Alarm Clock Functionality of\n# Chapter 5, with the Digital Clock Display of Chapter 6\n\nimport time\n\nimport snaps\n\nwhile True:\n    current_time = time.localtime()\n\n    hour = current_time.tm_hour\n    minute = current_time.tm_min\n    second = current_time.tm_sec\n    day = current_time.tm_mday\n    month = current_time.tm_mon\n    year = current_time.tm_year\n    is_weekend = current_time.tm_wday &gt;= 5\n\n    # draw the background\n    # define day as 6am - 7pm\n    if hour &gt;= 6 and hour &lt;= 19:\n        snaps.display_image(\"sun.png\")\n    else:\n        snaps.display_image(\"moon.png\")\nNow we prepare our datetime strings\n    # set up normal time and day clock behaviour\n    date_message = \"The date is \" + str(day) + \"/\" + str(month) + \"/\" + str(year)\n    time_message = \"The time is \" + str(hour) + \":\" + str(minute) + \":\" + str(second)\n    message = date_message + \"\\n\" + time_message\nNext we want to play a wake alarm at \\(7:30\\) giving as extra hour to sleep in on weekends. We also want to define a bed time. When the time hits \\(7:30\\) we want to play the alarm, then before bed time (\\(22:00\\))the clock should display a message telling us to get up, while after bed time it should tell us to go to sleep.\nThe if...else construct here is a bit more complicated. We only want to play the alarm sound at \\(7:30:00\\) rather than just if the user runs the clock after the wake up time. This is because the clock will then continuously play the sound every second it updates!\nOur first if statement thus checks if we are exactly on the alarm time, and if we are plays the alarm sound and updates the message\nWe then have to consider now when we check if the time is after the alarm has gone off that it is also not before it is time to go back to bed. It’s cleaner to split this into two cases (our elif statements)\nIn the first case if the hour is equal to the hour to get up and greater than the minute to get up then it must be time to get up and we don’t need to play the alarm (since the first if statement catches this case). Note this makes the assumption that we don’t wake up at a time like \\(8:30\\) and then go to bed at \\(8:59\\) which is reasonable.\nThe second case is when the hour is greater than the hour to get up. Here we have to check that either the hour is less than the hour we go to bed at or if it is the same, that the minutes are less than the minutes we go to bed at. (Effectively the reverse of our old alarm condition.) In either of the previous cases we only then need to update the final printed message with the statement that we should be up\nThe last case (the else) is our default case for when none of the previous cases are matched. By exhaustion of cases this has to be when it is time for us to be in bed by default. So we don’t need to do extra checks and can just update the message to tell us to go to sleep\n    # Play alarm and optionally append a wake up message\n    hour_to_get_up = 7 + is_weekend\n    hour_to_sleep = 22\n    minute_to_get_up = 30\n    minute_to_sleep = 0\n\n    wake_up_message = \"TIME TO GET UP!\"\n    sleep_message = \"TIME FOR BED!\"\n\n    # case 1: On the alarm\n    if hour == hour_to_get_up and minute == minute_to_get_up and second == 0:\n        snaps.play_sound(\"siren.wav\")\n        message = message + \"\\n\" + wake_up_message\n    # Past the alarm\n    elif hour == hour_to_get_up and minute &gt;= minute_to_get_up:\n        message = message + \"\\n\" + wake_up_message\n    # past the alarm but before bed\n    elif hour &gt; hour_to_get_up and (\n        hour &lt; hour_to_sleep or (hour == hour_to_sleep and minute &lt; minute_to_sleep)\n    ):\n        message = message + \"\\n\" + wake_up_message\n    # time for bed\n    else:\n        message = message + \"\\n\" + sleep_message\nFinally we display the message and then sleep for a second before updating the clock again\n    # display the message and then sleep\n    snaps.display_message(message, size=100)\n    time.sleep(1)",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 6: Repeating Actions with Loops"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/06_RepeatingActionsWithLoops/Chapter_06.html#summary",
    "href": "01_ProgrammingFundamentals/06_RepeatingActionsWithLoops/Chapter_06.html#summary",
    "title": "Chapter 6: Repeating Actions with Loops",
    "section": "Summary",
    "text": "Summary\n\nwhile repeats statements as long as a logical expression is True\n\na while True loop runs forever\n\nfor is designed for looping through items in a collection of values one-by-one\nbreak and continue are two methods for controlling loop execution inside a loop\n\nbreak immediately terminates a loop\ncontinue immediately moves to the next loop iteration\n\nTuples are a basic form of container for storing values\n\ndeclared as a comma separated list of values surrounded by parentheses\n\nrange(start, stop) creates a collection of integers from start (inclusive) to stop (exclusive)",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 6: Repeating Actions with Loops"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/06_RepeatingActionsWithLoops/Chapter_06.html#questions-and-answers",
    "href": "01_ProgrammingFundamentals/06_RepeatingActionsWithLoops/Chapter_06.html#questions-and-answers",
    "title": "Chapter 6: Repeating Actions with Loops",
    "section": "Questions and Answers",
    "text": "Questions and Answers\n\nDo we really need loops?\n\nIn theory no, you could unroll a loop into repeated code, however this can be clunky to do for arbitrary length loops or complicated control expressions\n\nAre loops dangerous?\n\nThey can be. A poorly phrased loop may never execute, or potentially never stop executing.\nSome safety-critical applications may opt to exclude loops entirely to avoid these risks",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 6: Repeating Actions with Loops"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/08_StoringCollectionsOfData/Chapter_08.html",
    "href": "01_ProgrammingFundamentals/08_StoringCollectionsOfData/Chapter_08.html",
    "title": "Chapter 8: Storing Collections of Data",
    "section": "",
    "text": "Consider the following vignette\nThe owner of an ice-cream stand wants a program to track sales\n\nThere are ten stands, each selling multiple items\nThe program should take sales data as input and then provide the following views on the data\n\nSorted from lowest to highest\nSorted from highest to lowest\nShow just the highest and the lowest\nShow the total number of sales\nShow the average number of sales\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nGetting the specification right: Storyboarding\nAgreeing on the specification with your client is important. A technique is called storyboarding, best done by sitting down with a paper and pen (or a whiteboard)\nA storyboard shows how the program should flow in response to various user inputs. E.g. depicting the menus the user might use, with a storyboard for each menu choice. The storyboard should also show how the program will work\nFor bigger programs you can break different components out into their own storyboards, much in the same way we built up functions. Storyboards depict what needs to happen, but not how to do it.\n\n\n\nGiven the spec for the ice cream stand we can now outline the program\n\nStore the sales data in variables\nImplement a way to sort the data\nA way to print the output\nStore the data globally and pass it to functions to handle the work\n\nWe can construct the prototype interface, similar to the Ride Selector Program\n  Ice-Cream Sales\n\n  1: Print the Sales\n  2: Sort Low to High\n  3: Sort High to Low\n  4: Highest and Lowest\n  5: Total Sales\n  6: Average Sales\n  7: Enter Figures\n\n  Enter your command: 3\n\n\n\n\nWe first need to store the sales\n\nFor ten stores, we could theoretically use ten variables, one for each store\nBut this method becomes clunky when we want to start analysing the variables\nE.g. the following code (FindingLargestSales.py), only handles finding if the first stand is the one with the greatest sales\n  # Example 8.1 Finding the Largest Sales\n  #\n  # Checks if sales1 has the largest sales. Demonstrates the difficulty of using\n  # individual named variables to deal with aggregate data\n\n  import BTCInput\n\n  sales1 = BTCInput.read_int(\"Enter the sales for stand 1: \")\n  sales2 = BTCInput.read_int(\"Enter the sales for stand 2: \")\n  sales3 = BTCInput.read_int(\"Enter the sales for stand 3: \")\n  sales4 = BTCInput.read_int(\"Enter the sales for stand 4: \")\n  sales5 = BTCInput.read_int(\"Enter the sales for stand 5: \")\n  sales6 = BTCInput.read_int(\"Enter the sales for stand 6: \")\n  sales7 = BTCInput.read_int(\"Enter the sales for stand 7: \")\n  sales8 = BTCInput.read_int(\"Enter the sales for stand 8: \")\n  sales9 = BTCInput.read_int(\"Enter the sales for stand 9: \")\n  sales10 = BTCInput.read_int(\"Enter the sales for stand 10: \")\n\n  if (\n      sales1 &gt; sales2\n      and sales1 &gt; sales3\n      and sales1 &gt; sales4\n      and sales1 &gt; sales5\n      and sales1 &gt; sales6\n      and sales1 &gt; sales7\n      and sales1 &gt; sales8\n      and sales1 &gt; sales9\n      and sales1 &gt; sales10\n  ):\n      print(\"Stand 1 had the best sales\")\nProblem: We would have to repeat the code each time for each individual sales variable\nIf we add more stands, we have add another named variable and another big if statement\n\nAND modify all the previous if statements\n\n\nClearly this approach is not very maintainable\n\n\n\n\n\nA collection is a composite type\n\nIt stores multiple elements of another type\n\nWe’ve already (briefly) seen one type of collection the tuple\nThe most common form of collection is the list\n\nWhat it sounds like, a list of items\n\n\n\n\nOpen a python interpreter and work through the following steps to learn about list\n\nA list is created using brackets around the contents [], e.g.\n\n sales = []\n\n\nThe above defines sales as an empty list\n\nItems can be appended to a list using the append function\n\n sales.append(99)\n sales\n\n[99]\n\n\n\nAs we can see from above sales now contains the value 99\n\nCalling append again, adds the new item to the end of the list\n\n sales.append(100)\n sales\n\n[99, 100]\n\n\nObserve from above you can see the contents of a list, by simply typing the variable name in the interpreter\n\nIn scripts we can also use the explicit print call\n\n  print(sales)\n\n[99, 100]\n\n\n\nYou can access individual items of the list, using the indexing operator []\n\n sales[0]\n\n99\n\n\n\nSyntax is list_name[index] where index is an integer giving the index of the item\nPython lists are zero-indexed. i.e. the first value is stored at index \\(0\\)\n\nThe indexing operator can be used to change the value of an item at a given index\n\n sales[1] = 101\n sales\n\n[99, 101]\n\n\n\nThe above changes the value of the second item in sales to \\(101\\)\n\n\n\n\n\n\n\nWarning\n\n\n\nIndexed elements must exist\nWhenever we use the indexing operator the index must exist! For example if we tried to view the (non-existent) third item, we would get an error, e.g.\n\n example_list = [1, 2]\n print(example_list[2])\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[7], line 2\n      1 example_list = [1, 2]\n----&gt; 2 print(example_list[2])\n\nIndexError: list index out of range\n\n\n\nThe above illustrates the common off-by-one error where we access the last index past the list rather than the last element of the list. Here the type of exception thrown is called an IndexError\n\n\nA single list can store values of different types, and can replace items with new items of a different type\n\n sales.append(\"Rob\")\n sales[0] = \"Python\"\n sales\n\n['Python', 101, 'Rob']\n\n\n\nThe above appends a new string \"Rob\", converts sales[0] from an int to the string \"Python\" and leaves the number \\(101\\) in sales[1] untouched\nOverall list thus mixes string and integer types*\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAvoid Mixing Types in Lists\nust because you can* mix types in lists, doesn’t mean you should. Typically lists and list processing is much easier when a list stores all items of the same type*\n\n\n\n\n\n\n\nYou can use loops to populate a list (see ReadAndDisplay.py)\n  # Example 8.2.1 Read and Display\n  #\n  # Demonstrates using a loop to populate a list\n\n  import BTCInput\n\n  # create an empty list to populate\n  sales = []\n\n  for count in range(1, 11):\n      prompt = \"Enter the sales for stand \" + str(count) + \": \"\n      sales.append(BTCInput.read_int(prompt))\n\n  print(sales)\n\n\n\nExamine the code given above and consider the following questions to understand how the list is processed\n\nWhat is the purpose of the count variable?\n\ncount tracks the value of the current index in the loop. This is used to print the id for the sales stand we are collecting the data from\n\nWhy does the range of count go from \\(1\\) to \\(11\\)?\n\nThe range function returns a collection with the start included but the stop excluded. Since we have stores \\(1\\) through \\(10\\), we want the range to go from \\(1\\) to \\(11\\) so the generated numbers are \\(1\\) through to \\(10\\)\n\nWhich item in the list would hold the sales for stand number \\(1\\)?\n\nThe first item in the list, or the zeroth indexed, i.e. sales[0]\n\nWhat part of the code would have to be changed if we instead had \\(100\\) stands?\n\nWe simply change range(1,11) through to range(1,101)\nThe program below (ReadAndDisplay2.py) is a variant in which the user specifies the number of stands\n  # Example 8.2.2 Read and Display 2\n  #\n  # Improved version of Read and Display which allows the user to specify\n  # the number of stands\n\n  import BTCInput\n\n  # create an empty list to populate\n  sales = []\n\n  number_of_stands = BTCInput.read_int(\"Enter the number of stands: \")\n  for count in range(1, number_of_stands + 1):\n      prompt = \"Enter the sales for stand \" + str(count) + \": \"\n      sales.append(BTCInput.read_int(prompt))\n\n  print(sales)\nThe above is more flexible, but as a result it is more complicated, the trade off between flexibility and ease of use is one that should be considered with the input of the users\n\nIf I got one sales value wrong, would it be possible to edit the list to put in a corrected version?\n\nThis is not implemented in the current program, but we have already seen that you can reassign the value of list at a given index, so we could implement this in a more complete program\n\n\n\n\n\n\n\nWe’ve already seen that print has a default way of displaying a list\nWe can use a for loop for if we want custom printing for each item\n  # Example 8.3 Read and Display Loop\n  #\n  # Uses a for loop to provide custom list printing\n\n  import BTCInput\n\n  sales = []\n\n  for count in range(1, 11):\n      prompt = \"Enter the sales for stand \" + str(count) + \": \"\n      sales.append(BTCInput.read_int(prompt))\n\n  # print a heading\n  print(\"Sales Figures\")\n  count = 1\n  for sales_value in sales:\n      print(\"Sales for stand\", count, \"are\", sales_value)\n      count = count + 1\n\n\n\nLists can hold any type of data that you need to store, including strings. You can change the ice-cream sales program to read and store the names of guests for a party or an event you’re planning. Make a modified version of the sales program that reads in some guest names and then displays them. Make your program handle between \\(5\\) and \\(15\\) guests\n\nWe basically just copy the previous program with the following changes\n\nsales \\(\\rightarrow\\) guests\nsales_value \\(\\rightarrow\\) guest\nWe change the prompts to appropriately refer to guests rather than sales\n\nThe two main changes are\n\nWe add an initial prompt for the number of guests\n\nWe use BTCInput.read_int_ranged to ensure the value is from \\(5\\) to \\(15\\)\n\nWe use BTCInput.read_text instead of BTCInput.read_int to get the guest names\n\n\n    # Exercise 8.1 Party Guests\n    #\n    # A program that receives and then prints a list of party guests\n    # Works for between 5 and 15 guests\n\n    import BTCInput\n\n    guests = []\n    number_of_guests = BTCInput.read_int_ranged(\n        \"Enter the number of guests (5-15): \", 5, 15\n    )\n\n    for count in range(1, number_of_guests + 1):\n        prompt = \"Enter the name of guest \" + str(count) + \": \"\n        guests.append(BTCInput.read_text(prompt))\n\n    # print a heading\n    print(\"\\nGuests attending:\")\n    count = 1\n    for guest in guests:\n        print(\"- \", guest)\n        count = count + 1\n\n\n\n\n\n\nThe previous examples build up our program as one long chain of events\nHowever, if we think about our program this isn’t strictly the cleanest\n\nThere are two distinct responsibilities occuring\n\nFirst we read in the data\nSecond we display the data\n\nThese are natural candidates to be converted into functions\n\nBy pairing these behaviours the program locks us into one way of processing data\n\nWhat happens if we want to read in a second set of data?\nWhat if we want to print the data multiple times?\n\nRefactoring is the process of modifying existing code\n\nSpecifically changing how factors interact\n\nRefactoring avoids the problem of overcomplicating the design at the start of the process\n\nInstead we write the program the most simple way we can\nThen once a structure emerges, or we need to add functionality we can refactor the design\n\nLet us factor out the two key components identified above into a new implementation (Functions.py)\n  # Example 8.4 Functions\n  #\n  # Demonstrates refactoring a program into component functions\n\n  import BTCInput\n\n  sales = []\n\n\n  def read_sales(number_of_sales):\n      \"\"\"\n      Reads in the sales values and stores them in the sales list\n\n      Parameters\n      ----------\n      number_of_sales : int\n          Number of Stores to record sales values for\n\n      Returns\n      -------\n      None\n          Results are read into the sales list\n      \"\"\"\n      sales.clear()  # remove existing sales values\n      for count in range(1, number_of_sales + 1):\n          prompt = \"Enter the sales for stand \" + str(count) + \": \"\n          sales.append(BTCInput.read_int(prompt))\n\n\n  def print_sales():\n      \"\"\"\n      Prints the sales figures on the screen with a heading.\n\n      Each figure is numbered in sequence\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Sales Figures\")\n      count = 1\n      for sales_value in sales:\n          print(\"Sales for stand\", count, \"are\", sales_value)\n          count = count + 1\n\n\n  read_sales(10)\n  print_sales()\n\n\n\nOur sales analysis program now consists of two functions, read_sales and print_sales\n\nWhat does the parameter for the read_sales function do?\n\nWe hinted at in the previous section that we might want to account for the potential for the number of stands to change in a future implementation. To support this behaviour read_sales reads in the number of sales value that it should reads\n\nWhat does clear do?\n\nWe want to start with a fresh list every time we read the sales values\nclear is a method on list objects that clears its contents\n\nWhy don’t we need to tell the print_sales function how many sales figures to print?\n\nThe for loop goes through the contents of the sales list\nA list tracks its own size\nIn some languages like C, containers do not naturally track their sizes and we would need to specify them\n\nWhy didn’t we have to write global sales in the read_sales function?\n\nPython variable names are references to memory\nThese are distinct from the objects that live in that memory\nAssignments change what object a reference (variable) refers to\n\ne.g. sales=[]\n\nHowever, calling methods on a variable, is not changing the reference e.g. sales.append(99) (They change the object contents)\n\nSo we don’t need to use global because by calling methods its clear what reference we’re using\n\n\n\n\n\n\n\nA development technique called stubs is where we write placeholder functions before we can provide a complete implementation for a given behaviour\nThe placeholders are sometimes called stub functions e.g. the two below\n\ndef sort_high_to_low():\n    \"\"\"\n    Print out a sales list from highest to lowest\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    sort_low_to_high : sorts from lowest to highest\n    \"\"\"\n    pass\n\n\ndef sort_low_to_high():\n    \"\"\"\n    Print out a sales list from lowest to highest\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    sort_high_to_low : sorts from highest to lowest\n    \"\"\"\n    pass\n\nPlaceholders let us model the flow of program before we have all the behaviours specified\n\nObviously does not model the complete program since the functions are incomplete\n\npass is a keyword for a statement that does nothing\n\nIt is effectively a placeholder statement\n\n\n\n\n\n\nAt the start of the Chapter we defined a user interface\n\nBy using the previous discussion on stubbing, and our initial functions we can implement this menu (see the full implementation in FunctionsAndMenu.py)\n\n  menu = \"\"\"\n  Ice Cream Sales\n\n  1. Print the Sales\n  2. Sort High to Low\n  3. Sort Low to High\n  4. Highest and Lowest\n  5. Total Sales\n  6. Average Sales\n  7. Enter Figures\n\n  Enter your command: \"\"\"\n\n  command = BTCInput.read_int_ranged(menu, 1, 7)\n\n  if command == 1:\n      print_sales()\n  elif command == 2:\n      sort_high_to_low()\n  elif command == 3:\n      sort_low_to_high()\n  elif command == 4:\n      highest_and_lowest()\n  elif command == 5:\n      total_sales()\n  elif command == 6:\n      average_sales()\n  elif command == 7:\n      read_sales(10)\n  else:\n      raise ValueError(\"Unexpected value \" + str(command) + \" found\")\nWe use stub functions for the unimplemented behaviour\n\n\n\n\n\n\n\nTip\n\n\n\nUsing Else Clauses to Guard Against Modification\nIn the example above the final else clause should never trip because we expect the result of BTCInput.read_int_ranged(menu, 1, 7) to be between \\(1\\) and \\(7\\) (inclusive) which is captured by the if..elif chain\nWhy then do we include the else clause? The reason is to protect against modification. This could include,\n\nThe author of BTCInput introduces a bug in read_int_ranged that allows invalid input to leak through\nSomeone editing the sales program changes the allowed range of input for read_int_ranged (perhaps to introduce new functions) but forgets to include them in the elif chain\n\nIn either case, the else clause trips, and rather than a silent error which may have occured if we expected the else to catch a \\(7\\), or if there was no else an exception is raised, which immediately notifies us that there’s a problem in the code\nThis technique of guarding against potential modifications is a simple technique for catching sources of errors and making sure you’re confirming your assumptions\n\n\n\n\n\nIn many of the examples and exercises I’ve used elif to simplify cases where we would otherwise have a bunch of nested if...else conditions.\nelif is short for else if and is effectively a next condition to check if the first if (or all preceding elif) statement is False\n\nAll elif conditions must come before the else\n\n\n\n\n\n\n\n\nSorting is a common task for computing programs\nIt can be time-intensive\nThere are often multiple ways that we may wish to sort things, e.g.\n\nAlphabetically vs Numerically\nIncreasing vs Decreasing\nCase-sensitive vs Case-insensitive\n\nTraditional sorts are down, one item (or pair of items) at a time\nAlgorithms, are a sequence of steps that solve a problem\n\nSorting Algorithms are algorithms that sort collections\nProgramming is really the implementation of an algorithm\n\nBubble Sort is a simple sorting algorithm\n\nEasy to follow and understand\nNot scalable to larger data sets\n\n\n\n\n\nOften when implementing an algorithm we want to use a fixed set of test data\n\ni.e. Data for which we can easily know the desired final state or output\nAllows us to check our algorithm is not incorrect\n\nWe can define a list in python with some contents,\n\nsales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n\n\n\n\n\n\nblock-beta\n    columns 6\n\n    classDef BG stroke:transparent, fill:transparent\n\n    index[\"Index\"]:1\n    class index BG\n\n    block:Indices:5\n    columns 10\n        0\n        1\n        2\n        3\n        4\n        5\n        6\n        7\n        8\n        9\n    end\n\n    value[\"Value\"]:1\n    class value BG\n\n    block:Values:5\n    columns 10\n        50\n        54_1[\"54\"]\n        29\n        33\n        22\n        100\n        45\n        54_2[\"54\"]\n        89\n        75\n    end\n\n\n\n\n\n\n\n\nThe above shows how the test data looks in a python list\nFor a highest to lowest sort we want the largest value to be in index \\(0\\) and the lowest in index \\(9\\)\nThe basic idea of Bubble sort is to compare neighbouring values, if the right value is larger we want to swap them so the larger value is on the left\n\nThus closer to the top of the list\n\n\n\n\n\n\n\n\nImportant\n\n\n\nSwap Two Values in a Variable\nThe following code to swap two variables is broken,\nif sales[0] &lt; sales[1]:\n    # the two items are in the wrong order and must be swapped\n    sales[0] = sales[1]\n    sales[1] = sales[0]\nWhy? Lets work through what happens\n\nsales[0] is set to the value of sales[1]\nsales[1] is set to the current value of sales[0]\nBut, sales[0] has already been set to sales[1]\n\nSo sales[1] is set to the same value it already has\n\n\nThe net result is that we only copy sales[1] to sales[0]\nThe correct implementation is given below,\nif sales[0] &lt; sales[1]:\n    temp = sales[0]\n    sales[0] = sales[1]\n    sales[1] = temp\ntemp is used to store the value of sales[0] before it was overwritten\n\n\nObviously, we don’t want to write the code with explicit reference to indices. However we can write this generically with a for loop as below\nfor count in range(0, len(sales) - 1):\n    if sales[count] &lt; sales[count - 1]:\n        temp = sales[count]\n        sales[count] = sales[count + 1]\n        sales[count + 1] = temp\n\n\nThe above code uses some new python features. Work through the following questions to understand what’s going on\n\nWhy have you used a for loop, rather than a while loop?\n\nWe could use either, the for loop is slightly smaller since we don’t have to manually increment count\nAdditionally range technically returns what is called a generator,\nThis is more memory efficient\n\nRather than creating a full list of numbers in memory, it just returns the next number each time the for loop requests it\n\n\nWhat does the len function do on line \\(1\\)?\n\nlen returns the length of a collection, i.e. the number of items in the collection\nThis lets you write code that is insensitive to the size of the collection being worked with\nMeans our sorting code could work on any length list\n\nWhy is the limit of count the length of the list minus 1?\n\nThis is because bubble sort compares the current item to the item to its right, i.e. at the next index\nIf the range goes to the last index, then program will try an access an element one past the end of the list which doesn’t exist\n\nThis will cause an error. e.g.\n\n\n\n a_list = [1,2]\n for count in range(0, len(a_list)):\n     if a_list[count] &lt; a_list[count + 1]:\n         temp = a_list[count]\n         a_list[count] = a_list[count + 1]\n         a_list[count + 1] = temp\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[9], line 3\n      1 a_list = [1,2]\n      2 for count in range(0, len(a_list)):\n----&gt; 3     if a_list[count] &lt; a_list[count + 1]:\n      4         temp = a_list[count]\n      5         a_list[count] = a_list[count + 1]\n\nIndexError: list index out of range\n\n\n\n\n\nThe complete implementation of the above discussion below performs one pass through the list\n\n\n# Example 8.6 Bubble Sort First Pass\n#\n# Implements the first pass of bubble sort and shows the impact on the list\n\n# test data\nsales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\ndef sort_high_to_low():\n    \"\"\"\n    Print out a sales list from highest to lowest\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    for count in range(0, len(sales) - 1):\n        if sales[count] &lt; sales[count + 1]:\n            temp = sales[count]\n            sales[count] = sales[count + 1]\n            sales[count + 1] = temp\n\n\nprint(\"Input list:\", sales)\n\nsort_high_to_low()\n\nprint(\"Output list:\", sales)\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nOutput list: [54, 50, 33, 29, 100, 45, 54, 89, 75, 22]\n\n\nafter which the test data looks like this\n\n\n\n\n\nblock-beta\n    columns 6\n\n    classDef BG stroke:transparent, fill:transparent\n\n    index[\"Index\"]:1\n    class index BG\n\n    block:Indices:5\n    columns 10\n        0\n        1\n        2\n        3\n        4\n        5\n        6\n        7\n        8\n        9\n    end\n\n    value[\"Value\"]:1\n    class value BG\n\n    block:Values:5\n    columns 10\n        54_1[\"54\"]\n        50\n        33\n        29\n        100\n        45\n        54_2[\"54\"]\n        89\n        75\n        22\n    end\n\n\n\n\n\n\n\nNotice that the list has been partially sorted\n\nAlso notice that the smallest value \\(22\\) has been moved to the correct index (the end)\nThe high numbers effectively bubble left past one of the values smaller than them\n\nSince we can see that after sorting the smallest value has been moved to the end we expect on the second loop through the second smallest value will have been moved to the correct spot\n\nSo we want to loop through len(sales) times\n\nThe working bubble sort implemention is then,\n\n\n# Example 8.7 Bubble Sort Multiple Pass\n#\n# Implements a complete working version of bubble sort\n\n# test data\nsales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\ndef sort_high_to_low():\n    \"\"\"\n    Print out a sales list from highest to lowest\n\n    Returns\n    -------\n    None\n    \"\"\"\n    for sort_pass in range(0, len(sales)):\n        for count in range(0, len(sales) - 1):\n            if sales[count] &lt; sales[count + 1]:\n                temp = sales[count]\n                sales[count] = sales[count + 1]\n                sales[count + 1] = temp\n\n\nprint(\"Input list:\", sales)\n\nsort_high_to_low()\n\nprint(\"Output list:\", sales)\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nOutput list: [100, 89, 75, 54, 54, 50, 45, 33, 29, 22]\n\n\n\n\n\nAs seen above, the sorting program now works correctly. Once you have a working implementation its worth investigating if there are changes you can make to improve the efficiency. Work through the following questions to get the idea\n\nIs the program making more comparisons than necessary?\n\nYes, as we mentioned before, after one pass the smallest item will always be at the end of the collection\nThis means we don’t need to check any swaps against it any more for the inner loop\nAfter each pass the size of this sorted section increases by at least one\nAn implementation taking this into account is,\n  for sort_pass in range(0, len(sales)):\n      for count in range(0, len(sales) - 1 - sort_pass):\n          if sales[count] &lt; sales[count + 1]:\n              temp = sales[count]\n              sales[count] = sales[count + 1]\n              sales[count + 1] = temp\n\nIs the program performing more passes through the list than nessecary?\n\nProbably, unless the largest value is at the end of the list all values should be bubbled to their correct spot in less than len(sales) passes\nWe can stop doing additional passes if we work out the list is already sorted\nHow?\n\nWe use a flag to track if any swaps occur in a pass\nIf none do then the list is already sorted and we can stop\n\n\n  # Example 8.8 Efficient Bubble Sort\n  #\n  # A bubble sort implementation incorporating efficiency savings to the number\n  # of comparisons and passes through the list\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def sort_high_to_low():\n      \"\"\"\n      Print out a sales list from highest to lowest\n\n      Returns\n      -------\n      None\n      \"\"\"\n      for sort_pass in range(0, len(sales)):\n          done_swap = False\n          for count in range(0, len(sales) - 1 - sort_pass):\n              if sales[count] &lt; sales[count + 1]:\n                  temp = sales[count]\n                  sales[count] = sales[count + 1]\n                  sales[count + 1] = temp\n                  done_swap = True\n          if not done_swap:\n              break\n\n  print(\"Input list:\", sales)\n\n  sort_high_to_low()\n\n  print(\"Output list:\", sales)\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nOutput list: [100, 89, 75, 54, 54, 50, 45, 33, 29, 22]\n\n\n\n\n\n\n\nBubble sort works for strings as well as integers. We saw that in Chapter 5 the python relational operators also work for strings. See if you can modify the Party Guest Program to display the names in alphabetical order\nWe can basically just reuse our sort code, but renamed for the guest program.\ndef sort_alphabetical():\n    \"\"\"\n    Sorts a list alphabetically\n\n    Returns\n    -------\n    None\n    \"\"\"\n    for sort_pass in range(0, len(guests)):\n        done_swap = False\n        for count in range(0, len(guests) - 1 - sort_pass):\n            if guests[count] &gt; guests[count + 1]:\n                temp = guests[count]\n                guests[count] = guests[count + 1]\n                guests[count + 1] = temp\n                done_swap = True\n        if not done_swap:\n            break\nThere is a second modification above, which is changing the sign of the relational operator, e.g.\nguests[count] &lt; guests[count + 1]\nhas been changed to,\nguests[count] &gt; guests[count + 1]\nThis is because as written the program tries to put the smallest strings last, but for strings; where the relational operator is alphabetically ordered this puts strings starting with a for example, after those starting with z etc. So we need to swap the sign so that the list is printed a, b, … , z etc.\nWhy don’t we have to make more modifications? Well the code as written only requires that the items being sorted are stored in a list, and that the items in the list can be compared with a relational operator. Both of these properties are satisfied by a collection of strings so the code effectively works out of the box\nThe complete code, including the integration with reading and printing the guest list is given in SortAlphabetically.py\n\n\n\n\n\nTo flip the direction of the sort, we just need the condition that determines what is out of order or not\n\nWe do this by changing \\(&lt;\\) to \\(&gt;\\), i.e.\n\n  # Example 8.9 Bubble Sort Low to High\n  #\n  # Implementation of Bubble Sort that sorts from low to high\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def sort_low_to_high():\n      \"\"\"\n      Print out a sales list from highest to lowest\n\n      Returns\n      -------\n      None\n      \"\"\"\n      for sort_pass in range(0, len(sales)):\n          done_swap = False\n          for count in range(0, len(sales) - 1 - sort_pass):\n              if sales[count] &gt; sales[count + 1]:\n                  temp = sales[count]\n                  sales[count] = sales[count + 1]\n                  sales[count + 1] = temp\n                  done_swap = True\n          if not done_swap:\n              break\n\n\n  print(\"Input list:\", sales)\n\n  sort_low_to_high()\n\n  print(\"Output list:\", sales)\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nOutput list: [22, 29, 33, 45, 50, 54, 54, 75, 89, 100]\n\n\n\nThe code above is given in BubbleSortLowToHigh.py\n\n\n\n\n\nIn comparison to sorting, finding a value is much easier\nThe basic outline for finding the highest is,\n  for values in collection\n      if(new value &gt; highest seen so far)\n          highest = new value\nWe can write the code for the highest and lowest in python then as,\n  highest = sales[0]\n  for sales_value in sales:\n      if sales_value &gt; highest:\n          highest = sales_value\n\n  lowest = sales[0]\n  for sales_value in sales:\n      if sales_value &lt; lowest:\n          lowest = sales_value\nIf we want to find both at the same time, then we can combine the code above, which means we only have to do one pass through the collection\n\n  # Example 8.10 Highest and Lowest\n  #\n  # Function that finds the highest and lowest value in a collection\n\n  # Example 8.9 Bubble Sort Low to High\n  #\n  # Implementation of Bubble Sort that sorts from low to high\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def highest_and_lowest():\n      \"\"\"\n      Print out the highest and lowest elements of a sales list\n\n      Returns\n      -------\n      None\n      \"\"\"\n      highest = sales[0]\n      lowest = sales[0]\n\n      for sales_value in sales:\n          if sales_value &gt; highest:\n              highest = sales_value\n          elif sales_value &lt; lowest:\n              lowest = sales_value\n      print(\"The highest is:\", highest)\n      print(\"The lowest is\", lowest)\n\n\n  print(\"Input list:\", sales)\n\n  highest_and_lowest()\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nThe highest is: 100\nThe lowest is 22\n\n\n\nThe code above is given in HighestAndLowest.py\n\n\n\n\n\n\nTo evaluate the total we have to sum the contents of a list, simple using the for loops we’ve looked at, (implementation in TotalSales.py)\n\n  # Example 8.11 Total Sales\n  #\n  # Calculate the Total Sales\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def total_sales():\n      \"\"\"\n      Print out the total sales of a sales list\n\n      Returns\n      -------\n      None\n      \"\"\"\n      total = 0\n      for sales_value in sales:\n          total = total + sales_value\n      print(\"Total sales are:\", total)\n\n\n  print(\"Input list:\", sales)\n\n  total_sales()\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nTotal sales are: 551\n\n\nIt is a simple extra step to them calculate the average, (divide the total by the number of elements in the collection)\n\n  # Example 8.12 Average Sales\n  #\n  # Calculate the Average Sales\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def average_sales():\n      \"\"\"\n      Print out the average sales of a sales list\n\n      Returns\n      -------\n      None\n      \"\"\"\n      total = 0\n      for sales_value in sales:\n          total = total + sales_value\n      average_sales = total / len(sales)\n      print(\"Average sales are:\", average_sales)\n\n\n  print(\"Input list:\", sales)\n\n  average_sales()\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nAverage sales are: 55.1\n\n\n\n\n\n\n\nThe previous Exercises have given us all the parts, now we want to put it together\nThe crux of our program should be a loop around the menu through which the user selects different functions\nWe first however need to read in the data from the user\nFor useability we should add the ability to quit the program\nThe final program implements this\n\n# Example 8.13 Complete Program\n#\n# A Complete implementation of the Sales Program combining all the individual\n# programs that we have implemented\n\nimport BTCInput\n\nsales = []\n\n\ndef read_sales(number_of_sales):\n    \"\"\"\n    Reads in the sales values and stores them in the sales list\n\n    Parameters\n    ----------\n    number_of_sales : int\n        Number of Stores to record sales values for\n\n    Returns\n    -------\n    None\n        Results are read into the sales list\n    \"\"\"\n    sales.clear()  # remove existing sales values\n    for count in range(1, number_of_sales + 1):\n        prompt = \"Enter the sales for stand \" + str(count) + \": \"\n        sales.append(BTCInput.read_int(prompt))\n\n\ndef print_sales():\n    \"\"\"\n    Prints the sales figures on the screen with a heading. Each figure is\n    numbered in sequence\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"Sales Figures\")\n    count = 1\n    for sales_value in sales:\n        print(\"Sales for stand\", count, \"are\", sales_value)\n        count = count + 1\n\n\ndef sort_high_to_low():\n    \"\"\"\n    Print out a sales list from highest to lowest\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    sort_low_to_high : sorts from lowest to highest\n    \"\"\"\n    for sort_pass in range(0, len(sales)):\n        done_swap = False\n        for count in range(0, len(sales) - 1 - sort_pass):\n            if sales[count] &lt; sales[count + 1]:\n                temp = sales[count]\n                sales[count] = sales[count + 1]\n                sales[count + 1] = temp\n                done_swap = True\n        if not done_swap:\n            break\n\n\ndef sort_low_to_high():\n    \"\"\"\n    Print out a sales list from lowest to highest\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    sort_high_to_low : sorts from highest to lowest\n    \"\"\"\n    for sort_pass in range(0, len(sales)):\n        done_swap = False\n        for count in range(0, len(sales) - 1 - sort_pass):\n            if sales[count] &gt; sales[count + 1]:\n                temp = sales[count]\n                sales[count] = sales[count + 1]\n                sales[count + 1] = temp\n                done_swap = True\n        if not done_swap:\n            break\n\n\ndef highest_and_lowest():\n    \"\"\"\n    Print out the highest and lowest elements of a sales list\n\n    Returns\n    -------\n    None\n    \"\"\"\n    highest = sales[0]\n    lowest = sales[0]\n\n    for sales_value in sales:\n        if sales_value &gt; highest:\n            highest = sales_value\n        elif sales_value &lt; lowest:\n            lowest = sales_value\n    print(\"The highest is:\", highest)\n    print(\"The lowest is\", lowest)\n\n\ndef total_sales():\n    \"\"\"\n    Print out the total sales of a sales list\n\n    Returns\n    -------\n    None\n    \"\"\"\n    total = 0\n    for sales_value in sales:\n        total = total + sales_value\n    print(\"Total sales are:\", total)\n\n\ndef average_sales():\n    \"\"\"\n    Print out the average sales of a sales list\n\n    Returns\n    -------\n    None\n    \"\"\"\n    total = 0\n    for sales_value in sales:\n        total = total + sales_value\n    average_sales = total / len(sales)\n    print(\"Average sales are:\", average_sales)\n\n\n# Get initial sales list\nread_sales(10)\n\n\nmenu = \"\"\"\nIce Cream Sales\n\n0. Quit the Program\n1. Print the Sales\n2. Sort High to Low\n3. Sort Low to High\n4. Highest and Lowest\n5. Total Sales\n6. Average Sales\n7. Enter Figures\n\nEnter your command: \"\"\"\n\nwhile True:\n    command = BTCInput.read_int_ranged(menu, 0, 7)\n    if command == 0:\n        break\n    if command == 1:\n        print_sales()\n    elif command == 2:\n        sort_high_to_low()\n    elif command == 3:\n        sort_low_to_high()\n    elif command == 4:\n        highest_and_lowest()\n    elif command == 5:\n        total_sales()\n    elif command == 6:\n        average_sales()\n    elif command == 7:\n        read_sales(10)\n    else:\n        raise ValueError(\"Unexpected value \" + str(command) + \" found\")\n\n\n\n\n\n\nWarning\n\n\n\nKeeping Information Synchronised when Sorting\nPlaying around with the program you might notice one thing. The stands are numbered in the order that they are printed. This works great for printing the original list out, but once we start sorting these numbers don’t match their original value. This is fine if we only care about the sales figures, but if we want to maintain a relationship between a stand and its sales this is something that would have to be modified.\nThis is something you would discuss with the client\n\n\n\n\n\n\n\nA natural extension to the program would be the ability to read or store the sales data to a file\nFiles allow for persisting the data between sessions\nTo do this we’ll add two new options, 8. Save Sales and 9. Load Sales\nLet us start by stubbing out our functions (the complete integration is found in LoadAndSave.py),\n  def save_sales(file_path):\n      \"\"\"\n      Saves the contents of the sales list to a file\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to save to\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the save fails\n\n      See Also\n      --------\n      load_sales : load sales from a sales list file\n      \"\"\"\n      print(\"Save the sales in:\", file_path)\n\n\n  def load_sales(file_path):\n      \"\"\"\n      loads the contents of a file into the sales list\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to load from\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the load fails\n\n      See Also\n      --------\n      save_sales : save the sales list into a file\n      \"\"\"\n      print(\"Load the sales in:\", file_path)\nWe also add a basic integration to the user menu, where we use BTCInput.read_text to get a file name, then call the function\nObserve that by adding the complete docstring’s we’re also starting to document the requirements for these functions in-code\n    elif command == 7:\n      read_sales(10)\n  elif command == 8:\n      file_to_save_to = BTCInput.read_text(\"Enter file to save to: \")\n      save_sales(file_to_save_to)\n  elif command == 9:\n      file_to_load_from = BTCInput.read_text(\"Enter file to load: \")\n      load_sales(file_to_load_from)\n  else:\n      raise ValueError(\"Unexpected value \" + str(command) + \" found\")\n\n\n\n\nWhen interacting with a file, python represents it as a memory object\n\nTechnically representing the connection\n\nopen creates a connection to a file, the below, opens a file, test.txt, in write mode w and stores it in the variable output_file\n  output_file = open('test.txt', 'w')\n\nThe two arguments are called the file_path and the mode\n\nfile_path is the file you want to open\nmode is what you want to do with it\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\nIt’s very easy to overwrite an existing file\nThe open function will not prevent you from modifying important files. For example files opened for write will first wipe the contents of any existing file that matches the path then write the new contents.\nPython provides the os module which has some extra functionality for handling files and directories, e.g. you can check that a file exists before you open it if you then want check if the user wants to overwrite it before opening it\nimport os.path\nif os.path.isfile(\"text.txt\"):\n    print(\"The file exists\")\n\n\n\nIf we’ve opened a file in write mode, we can use the write method on the file object to write to the file\n  output_file.write(\"First line\\n\")\n  output_file.write(\"Second line\\n\")\n  output_file.close()\nOnce you’re done with a file you need to call close\n\nCompletes any unfinished writes (ensures data integrity)\nReleases the file so other programs or processes can use it\n\nFiles open for writing are locked for editing by that process, nothing else can use them\n\n\nPutting everything together our simple file writing program is,\n  # Exercise 8.15 File Output\n  #\n  # A simple program to demonstrate opening and writing to a file\n\n  output_file = open(\"test.txt\", \"w\")\n  output_file.write(\"line 1\\n\")\n  output_file.write(\"line 2\\n\")\n  output_file.close()\n\n\n\nConsider the following questions about file writing\n\nWhy have you called the write function a method? Isn’t it a function?\n\nAs discussed earlier, methods are functions associated with a specific object\nTypically when we say functionw we refer to a function that is defined outside of an object\nwrite is a method on the file object\n\nIt is impossible to use write without there being a file object to use\nMethods allow us to work with multiple file objects without having to worry about making sure we pass the correct one to the function\n\n\nWhat does the \\n mean at the end of the strings?\n\nIt’s the new line symbol write doesn’t automatically end the line after we call it\nWe have to manually pass the new line\n\nWhere is the file text.txt actually created?\n\nThe file_path is relative to the current running python program\nHence the file is written to the same directory\n\nE.g. if we had a folder called “My Programs” with a python program “MakeFiles.py”, when we run “MakeFiles.py” the files it makes are stored in “My Programs”\n\nYou can use more complicated file_paths\n\npath = \"./data/test.txt\" would look for test.txt in the data subdirectory of the current python program (relative path)\npath = \"c:/data/test.txt\" would look for test.txt in the data subdirectory of the c drive (absolute path)\n\n\n\n\n\n\n\nNote\n\n\n\nDenoting a Directory Seperator\nOn Windows \\ is used to seperate directories, but in python you always use /\n\n\n\nCan any program use a file written from a Python program?\n\nYes, python uses the underlying operating systems file handling services\nAny other program on the operating system can access files created or modified by python\n\nCan I add lines at the end of a python file?\n\nYes, rather than open the file in write w, you open the file in append (a).\nAny writes will then be appended to the end of the file.\nA non-existent file will be created the same way as for write mode\n\n\n\n\n\n\nUsing the above discussion we can implement the write_sales function\n  # Example 8.16 Write Sales\n  #\n  # Implements the Write Sales function\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def save_sales(file_path):\n      \"\"\"\n      Saves the contents of the sales list to a file\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to save to\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the save fails\n      \"\"\"\n      print(\"Save the sales in: \", file_path)\n      output_file = open(file_path, \"w\")\n      for sale in sales:\n          output_file.write(str(sale) + \"\\n\")\n      output_file.close()\n\n\n  save_sales(\"test_output.txt\")\n\n\n\n\nThe save_sales function combines several behaviours and is worth examining in detail. What is the purpose of the function? To take a list of sales figures and write those figures to a file (preferably in a format that is easy for a human to read and to load back into the program.) Consider the following questions\n\nWhat does the str function do? Why are we using it?\n\nThe str function converts the sales number to a string\nWhile print can handle non-string inputs, write can only take a string\n\nWhy can’t we just write out the sales list as one object?\n\nA list does not provide any built-in methods for writing an object out to a file\nWe could try and print out it’s string representation (i.e. call str and output that)\nDoesn’t give us great ability to control the way the data is output\n\n\n\n\n\n\n\nWe an also use open to read from a file, we just use the read mode (r)\n  input_file = open(\"test.txt\", \"r\")\nWe can then loop over the lines in a file using a for loop\nfor line in input_file:\n      print(line)\nWe should still use close() when we’re done reading\n  input_file.close()\nThe complete sample program looks like,\n  # Example 8.17 File Input\n  #\n  # Demonstrates reading input from a file\n\n  input_file = open(\"test.txt\", \"r\")\n  for line in input_file:\n      print(line)\n  input_file.close()\n\n\n\nWork through the following questions to understand how reading from files works\n\nIf you look at the following output, you’ll notice there are empty lines after each line of text. Why is that?\n line 1\n\n line 2\n\n\nEvery time we read a line from a file, we read the terminating new line\nThis is included in the string stored in line so when we call print we get that new line and the new line added by print\nWe could fix this by modifying our print call, to remove the new line\n  print(line, end='')\nA more natural way to fix this is to remove the newline when we first read in the string\nThe strip method when called without arguments returns a copy of the string with all leading and trailing whitespace removed from the string\n\n  line = line.strip()\n\nThis is an example of conditioning input\nProcess of making sure that an input does not contain any unexpected values\nE.g. we might also want to use strip to remove non-printable characters\n\nlstrip and rstrip are variants of strip that only work on the lead or end of the string respectively\n\n\nWhy do we have to close the file we’re reading?\n\nFor reading a file forgetting to close it won’t cause issues with other programs or processes that also try to read from the file\nHowever, lets other programs now write to that file\nReleases the memory associated with holding the connection\nYour computer might not let you shut down if it thinks there are still unclosed files\n\nWhat would happen if you tried to write to a file that had been opened for reading?\n\nAn exception will be raised\nr+ is a mode that lets you read and write to a file\nYou typically don’t want to read and write to a file at the same time\n\nHard to ensure the integrity of the data and avoid corrupting it\nSuch as by writing a line longer than the one previously written\n\nthis may corrupt the next line\n\n\nA better pattern is to load data, update the data then write that back into the file\n\nA temporary file (often abreviated as a tmp file) can be used if we need an intermediate file to write to\n\n\nCan a program read an entire file at once?\n\nYes, the* read method by default will try to read an entire file\nline endings are preserved\nBe careful with large files, as this may overwhelm your computers memory…\n\n # Example 8.18 File Read\n #\n # Demonstrates the use of file_object.read to read\n # the contents of a file in one go\n\n input_file = open(\"test.txt\", \"r\")\n total_file = input_file.read()\n print(total_file)\n input_file.close()\n\n\n\n\n\nLet’s now implement load_sales\n  # Example 8.19 Load Sales\n  #\n  # Implements the Load Sales function\n\n  sales = []\n\n\n  def load_sales(file_path):\n      \"\"\"\n      loads the contents of a file into the sales list\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to load from\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the load fails\n      \"\"\"\n      print(\"Load the sales in:\", file_path)\n      sales.clear()\n      input_file = open(file_path, \"r\")\n      for line in input_file:\n          line = line.strip()\n          sales.append(int(line))\n      input_file.close()\n\n\n\nload_sales works as the opposite of save_sales instead of taking a sales list and putting it into a text file, we pull the figures from a file and load them into the sales list. Consider the following questions\n\nWhat does the int function do?\n\nThe numbers pulled out of the file are initially stored as a string\nWe need to convert them to a number, so we call int\n\nWhat happens if the input file was empty?\n\nThe function works as one would hope\nThe loop doesn’t iterate and we get an empty sales list\n\n\n\n\n\n\n\n\nDealing with files, also means dealing with the errors they can introduce\n\ne.g. A file might have been deleted, a USB removed, or simply the user might pass the wrong name\n\nWhen an error occurs we want to ensure two things:\n\nNo files are left open\nThe user is aware that the error has occured\n\nFile objects typically raise exceptions when their methods\n\nEnables us to handle and report on their errors\nUse the try ... except syntax we’ve seen before\n\n  try:\n      output_file = open(file_path, \"w\")\n      for sale in sales:\n          output_file.write(str(sale) + \"\\n\")\n      output_file.close()\n      print(\"File Written Successfully\")\n  except:\n      print(\"Something went wrong with the file\")\n\n\n\nThe code performing the file write is wrapped in a try...except block. If write, open or close causes an exception it will be caught and handled by the except clause. Let’s work through the following questions to see if this solves the ensures that the file is closed and the user is informed\n\nIn what circumstances will the code in the except part be executed?\n\nIf any of the file functions, write, open, or close raise an exception, the code in the except part will be executed\nAn error message is thus only printed when an error occurs\n\nIn what circumstances will the “File written successfully?” message be printed?\n\nThis is only printed if every step in the file writing process is completed successfully\n\nAn error message is always printed if an error is thrown, but will the file always be closed?\n\nNo, this is a problem, as we said that all files needed to be closed even when an error occurs!\nWe could put the close statement in the exception handling section to, but a more general solution to this problem is to use a finally block\n\nA finally block contains code that is always executed after all of the try and/or except code has executed\nGood for code that we naturally want to run after the block no matter if the process succeeds or fail (such as clean-up)\n\n\n try:\n     output_file = open(filename, \"w\")\n     for sale in sales:\n         output_file.write(str(sale) + \"\\n\")\n except:\n     print(\"Something went wrong with writing to the file\")\n finally:\n     output_file.close()\n\n\n\n\n\n\nIt would be great if we didn’t have to remember to manually ensure a file gets closed\n\nFailing to properly close a file can lead to hard to pin down behaviour\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIntermittent Faults are the Worst Kind to Fix\nA piece of code that is broken all the time is annoying, but at least you can typically easily identify what is not working. If a program fails only some of the time this can be much harder to solve. Often you require precise directions as to the steps taken up to the point of failure in order to be able to attempt to replicate the problem. This adds significant overhead to fixing the problem\n\n\n\nThe with construct allows the programmer to automatically manage the acquisition and release of resources\n\nMore generic than just file access\nYou can write your own services to work with with\n\nAdvanced topic we can ignore for now\n\n\n\n\n\n\n\n\nblock-beta\n    columns 6\n\n    classDef BG stroke:transparent, fill:transparent\n\n\n    space\n    title[\"Breakdown of a with statement\"]:4\n    space\n\n    class title BG\n\n    block:With\n    columns 1\n        with[\"with\"]\n        withDescr[\"(start of a with block)\"]\n    end\n\n    class with BG\n    class withDescr BG\n\n\n    block:Expression\n    columns 1\n        expression[\"expression\"]\n        expressionDescr[\"(expression generating resource to use)\"]\n    end\n\n    class expression BG\n    class expressionDescr BG\n\n    block:As\n    columns 1\n        as[\"as\"]\n        space\n    end\n\n    class as BG\n\n    block:Name\n    columns 1\n        name[\"name\"]\n        nameDescr[\"(name to represent the resource)\"]\n    end\n\n    class name BG\n    class nameDescr BG\n\n    block:Colon\n    columns 1\n        colon[\":\"]\n        space\n    end\n\n    class colon BG\n\n    block:Suite\n    columns 1\n        suite[\"Statement block\"]\n        suiteDescr[\"(statements)\"]\n    end\n\n    class suite BG\n    class suiteDescr BG\n\n\n\n\n\n\n\nwith is used to provide an object that provides a service\nas is used to assign a semantically meaningful name to the resource\nwith activates an “enter” behaviour on its object\n\nFor files this is open\n\nWhen the block is finished, with calls some exit behaviour on the object\n\nFor files this causes the file to be closed\n\nwith allows us to ensure a few things\n\nThe file is always closed\nThe reference to the file only exists as long as we are using it\n\n  # Example 8.20 Using with to Access Files\n  #\n  # Rewrites read_sales and load_sales to use the with functionality\n  # implemented in python\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def save_sales(file_path):\n      \"\"\"\n      Saves the contents of the sales list to a file\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to save to\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the save fails\n\n      See Also\n      --------\n      load_sales : load sales from a given file\n      \"\"\"\n      print(\"Save the sales in:\", file_path)\n      try:\n          with open(file_path, \"w\") as output_file:\n              for sale in sales:\n                  output_file.write(str(sale) + \"\\n\")\n      except:  # noqa: E722\n          print(\"Something went wrong with the file\")\n\n\n  def load_sales(file_path):\n      \"\"\"\n      loads the contents of a file into the sales list\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to load from\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the load fails\n\n      See Also\n      --------\n      save_sales : save sales to a file\n      \"\"\"\n      print(\"Load the sales in:\", file_path)\n      sales.clear()\n      try:\n          with open(file_path, \"r\") as input_file:\n              for line in input_file:\n                  line = line.strip()\n                  sales.append(int(line))\n      except:  # noqa: E722\n          print(\"Something went wrong with the file\")\n\n\n  print(\"Sales before save and load:\", sales)\n  save_sales(\"test.txt\")\n  load_sales(\"test.txt\")\n  print(\"Sales after save and load:\", sales)\nObserve that we no longer have to explicitly include the close call\nwith does not handle exceptions however, so we still have to include a try...except block\nWhen an exception occurs the with first releases the resource with its exit behaviour\n\ne.g. closes the file\nThen the excecution moves to the except block\n\nIf we wanted to handle exceptions without releasing the resource, we would have to swap the order to,\n  with open(\"file\", \"mode\"):\n      try:\n          #do standard thing here\n      except:\n          # handle exception without releasing resource\n      finally:\n          # do something regardless of success or fail without releasing resource\n\n\n\n\nAdd a save function to your party guest program so that you can record a list of people who attended your party\nWe build off our version that generates a sorted list. We can basically copy the save_sales function making changes to the refer to the guests list instead of sales and giving a more appropriate name to the loop variable.\ndef save(file_path):\n    \"\"\"\n    Saves the guest list to a file\n\n    Parameters\n    ----------\n\n    file_path : str\n        string giving the file path to save to\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    FileException\n        Raised if the save fails\n    \"\"\"\n    print(\"Save the guest list in:\", file_path)\n    try:\n        with open(file_path, \"w\") as output_file:\n            for guest in guests:\n                output_file.write(str(guest) + \"\\n\")\n    except:  # noqa: E722\n        print(\"Something went wrong with the file\")\nWe then run the program as normal\n\nAsk for the number of guests\nRead in the guests\nSort the guest list\nDisplay the guest list\n\nWe then ask the user if they want to save the guest list. For simplicity we use BTCInput.read_input_ranged to ask for a \\(0\\) or a \\(1\\) where a \\(1\\) indicates the user wishes to save, while \\(0\\) indicates they dont. If the user wishes to save we then prompt them using BTCInput.read_text for a file name and then call save on the given file path\nuser_wants_to_save = BTCInput.read_int_ranged(\n    \"Would you like save the list? (1 for yes, 0 for no): \", min_value=0, max_value=1\n)\n\nif user_wants_to_save:\n    save_file_name = BTCInput.read_text(\"Enter file name to save as: \")\n    save(save_file_name)\n\nThe complete integrated code is given in GuestListWithSave.py\n\n\n\n\n\n\nA list holds data in one dimension, i.e. its length\nOften data is multi-dimensional\ne.g. Our Ice Cream Sales client might now ask for the ability to track sales, by store and by day of the week\n\n\n\n\n\n\nblock-beta\n    columns 5\n\n    classDef Header fill:#bbf,stroke:#333,stroke-width:4px;\n    classDef BG stroke:transparent, fill:transparent\n\n    space:2\n    title[\"Data Table\"]:2\n    space:1\n\n    class title BG\n\n    space\n    block:fields:4\n    columns 4\n        monday[\"Monday\"]\n        tuesday[\"Tuesday\"]\n        wednesday[\"Wednesday\"]\n        stop[\"...\"]\n    end\n\n    class fields Header\n\n    Stand1[\"Stand 1\"]\n    50\n    80\n    10\n    Blank1[\"...\"]\n\n    class Stand1 BG\n\n    Stand2[\"Stand 2\"]\n    54\n    98\n    7\n    Blank2[\"...\"]\n\n    class Stand2 BG\n\n    Stand3[\"Stand 3\"]\n    29\n    40\n    80_2[\"80\"]\n    Blank3[\"...\"]\n\n    class Stand3 BG\n\n    Stand4[\"...\"]\n    stand4_1[\" \"]\n    stand4_2[\" \"]\n    stand4_3[\" \"]\n    stand4_4[\" \"]\n\n    class Stand4 BG\n\n\n\n\n\n\n\n\nOur current implementation is effectively a vertical slice for one of the days\nCan implement multiple lists, one per day of the week\n\nEffectively repeats the problem we had before of a distinct named variable for each item\n\nWe want a list of lists\n\n  mon_sales = [50, 54, 29, 33,  22, 100, 45, 54, 89, 75]\n  tue_sales = [80, 98, 40, 43, 43, 80, 50, 60, 79, 30]\n  wed_sales = [10, 7, 80, 43, 48, 82, 33, 55, 83, 80]\n  thu_sales = [15, 20, 38, 10, 36, 50, 20, 26, 45, 20]\n  fri_sales = [20, 25, 47, 18, 56, 70, 30, 36, 65, 28]\n  sat_sales = [122, 140, 245, 128, 156, 163, 90, 140, 150, 128]\n  sun_sales = [100, 130, 234, 114, 138, 156, 107, 132, 134, 148]\n\n  week_sales = [mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales, sun_sales]\n\nThink of lists of lists as a collection of rows and columns\n\nWe first specify the row we want say tue_sales\nThen the column, say Stand 1\n\n  print(week_sales[1][0])\n\n80\n\n\n\n\n\n\nIt can be difficult to get the hang of working with multiple indices. Which of the following indices would fail when the program runs?\nStatement 1: week_sales[0][0] = 50\nStatement 2: week_sales[8][7] = 88\nStatement 3: week_sales[7][10] = 100\n\nStatement 1 is valid\nStatement 2 is invalid because the first index \\(8\\) corresponds to the day of the week\n\nThe valid indices here are \\(0\\) to \\(6\\)\n\nStatement 3 is also invalid for the same reason\n\nEven though there are seven days of the week\nThe list is zero indexed\n\n\nLet’s see this in action\n\nStatement 1:\n\n\nweek_sales[0][0]\n\n50\n\n\n\nStatement 2:\n\n\nweek_sales[8][7]\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[20], line 1\n----&gt; 1 week_sales[8][7]\n\nIndexError: list index out of range\n\n\n\n\nStatement 3:\n\n\nweek_sales[7][10]\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[21], line 1\n----&gt; 1 week_sales[7][10]\n\nIndexError: list index out of range\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nMake it easy to test your program\nTesting is important, but unless it’s easy or automatic it’s pretty common to get left by the wayside.\nIn a program one might use a function make_test_data or for larger projects a test framework that is used to generate test data.\nWhenever you find yourself repeating a pattern to test code, consider how you can automate or bypass that process\n\n\n\n\n\n\nWe can use nested for loops to work through individual values in a list of lists\nE.g. if we want to calculate the total sales over a week, (full code given in TablesOfSaleData.py)\n\n  total_sales = 0\n  for day_sales in week_sales:\n      for sales_value in day_sales:\n          total_sales = total_sales + sales_value\n\n  print(\"Total sales for the week are\", total_sales)\n\nTotal sales for the week are 5205\n\n\n\nday_sales in the outer loop iterates over each constituent list in the list of lists\nsales_value is then each value in the current list referenced by day_sales\n\n\n\n\nConsider the code for summing the sales data in the previous example. Answer the following questions to make sure you understand how it works\n\nHow many times will the statements inside the two loops be obeyed?\n\nIn total they will be run \\(70\\) times\nThe outer loop runs seven times (once for each day of the week)\nThe inner loop runs ten times (one for each stand)\n\nfor each iteration of the outer loop\n\n\nHow would you change this program so that it could handle more than one week’s worth of sales?\n\nWe can add more days to the list\nRather than have them correspond to Monday - Friday it might be Week 1 Day 1 etc.\nThese would be additional rows in the list of lists\n\nHow would we add a day’s worth of sales to the list?\n\nWe have to read in a new list of values\nCan then append it to the list of lists\n  read_sales(10) # read ten values into sales list\n  week_sales.append(sales) # append the values to the weekly sales list\n\n\n\n\n\n\n\nIt is possible to work with higher dimensions\nFor example we might want to store multiple weeks of data\n\nThen we would have a list of (list of (lists))s\n\nWorks just like two dimensions but with an extra index, for example we can append a week of sales like so,\n  annual_sales.append(week_sales)\n\n\n\n\n\n\n\nTip\n\n\n\nKeep your dimensions low\nYou should rarely have to use more than three dimensions. If you find yourself using highly nested / high-dimensional structures you might want to rethink how you’re representing your data\nOne technique we will see later is the use of classes, which can make it easier to create linear collections\nThe computer itself is perfectly happy working in higher dimensions. The real difficulty is that you probably aren’t and it can be hard to reason about high dimension data\n\n\n\n\n\n\n\nNow we have the ability to manipulate weekly sales data, the next question is how to display that data and the requests.\nWhen we enter the data we want to see something like,\n  Enter the Monday sales figures for stand 2:\nHere we need to have a variable to control what day is printed\n\nSimplest implementation is an integer to track the day, implemented in DayNameIf.py\n\n\n  # Example 8.22 Day Name If\n  #\n  # Uses a if, elif, else construction to convert an integer\n  # to a string representation of the day of the week\n\n  import time\n\n  current_time = time.localtime()\n  day_number = current_time.tm_wday\n\n  if day_number == 0:\n      day_name = \"Monday\"\n  elif day_number == 1:\n      day_name = \"Tuesday\"\n  elif day_number == 2:\n      day_name = \"Wednesday\"\n  elif day_number == 3:\n      day_name = \"Thursday\"\n  elif day_number == 4:\n      day_name = \"Friday\"\n  elif day_number == 5:\n      day_name = \"Saturday\"\n  elif day_number == 6:\n      day_name = \"Sunday\"\n  else:\n      raise ValueError(\"Unexpected day_number \" + str(day_number) + \" encountered\")\n\n  print(day_name)\n\nTuesday\n\n\nThis works, but is fragile, a cleaner way to do this is to use a lookup table\n\ni.e. we use day_number to index a list that stores the correct day\n\nWe use thetime library for fun so the program prints the current day\n\n  # Example 8.23 Day Name List\n  #\n  # Uses a lookup table to correctly print the day\n\n  import time\n\n  current_time = time.localtime()\n  day_number = current_time.tm_wday\n\n  day_names = [\n      \"Monday\",\n      \"Tuesday\",\n      \"Wednesday\",\n      \"Thursday\",\n      \"Friday\",\n      \"Saturday\",\n      \"Sunday\",\n  ]\n\n  day_name = day_names[day_number]\n\n  print(\"Today is\", day_name)\n\nToday is Tuesday\n\n\nLookup tables are powerful for shrinking written code\nThey also are used to create data-driven applications\n\nPrograms that use built-in or loaded data rather than fixed behaviour\n\n\n\n\n\n\nLists are the standard collection type\n\nThey are mutable, i.e. we can change the value of a given index or add new items\n\nConsider the day_names list, once defined we don’t want to change it\n\nWe would like to also prevent this, to catch potential programming errors e.g.\n  day_names[5] = \"Splatterday\"\n\nA tuple is like a list, but the contents cannot be changed\n\nA tuple is said to be immutable\nIf we attempt to change the tuple we get an error, (demonstrated in the implementation DayNameList.py)\n\nSpecifically a TypeError\nBecause the action we are trying to take (change the value at an index) is not supported by the object type (tuple)\n\n\n  # Example 8.24 Day Name Tuple\n  #\n  # Reimplements the Day Name lookup table with a tuple\n  # and demonstrates the immutability of the data structure\n\n  import time\n\n  current_time = time.localtime()\n  day_number = current_time.tm_wday\n\n  day_names = (\n      \"Monday\",\n      \"Tuesday\",\n      \"Wednesday\",\n      \"Thursday\",\n      \"Friday\",\n      \"Saturday\",\n      \"Sunday\",\n  )\n\n  day_name = day_names[day_number]\n\n  print(\"Today is\", day_name)\n\n  print(\"Attempting to change the lookup table...\")\n\n  day_names[day_number] = \"Splatterday\"  # type: ignore\n  print(\"Today is\", day_names[day_number])\n\nToday is Tuesday\nAttempting to change the lookup table...\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[25], line 27\n     23 print(\"Today is\", day_name)\n     25 print(\"Attempting to change the lookup table...\")\n---&gt; 27 day_names[day_number] = \"Splatterday\"  # type: ignore\n     28 print(\"Today is\", day_names[day_number])\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\n\nTuple is created as for a list but using () to delimit the items rather than []\nTuples are good for working with complicated values\n\ne.g. composite types\n\nFor Example, consider a pirates treasure map\n\nTreasure’s location is given by\n\nA reference landmark\nNumber of steps north\nNumber of steps east\n\n\nA function can strictly speaking return one value\n\nWe can return multiple values as a tuple\n\n  def get_treasure_location():\n      # get the treasures location\n      return (\"The old oak tree\", 20, 30)\n\nThis returns three values\n\nThe string \"The old oak tree\"\nThe number of steps north, 20\nThe number of steps east, 30\n\n\nLike lists, tuples are zero-indexed\n\n\n\n\n\n\n\nWarning\n\n\n\nTake care with your tuple indices\nWhen returning multiple items from a function via a tuple, we have to be clear to specify the order of what the items in the tuple correspond to. This is effectively a contract between the function and any caller (if you change the order, you will break the code of anyone who relies on the current order)\nThe order that parameters are returned in should thus be clearly documented, e.g.\ndef get_treasure_location():\n    \"\"\"\n    Gets the location of the treasure\n\n    Returns\n    -------\n    str\n        Name of a landmark to start at\n    int\n        Number of paces north\n    int\n        Number of paces east\n    \"\"\"\n\n    return (\"The old oak tree\", 20, 30)\n\n\n\nAn alternative to explicitly referencing the index of a returned tuple, is called tuple-unpacking\n\nWe provide a comma-seperated list of variables to assign the tuple values (in order) to, e.g.\n      landmark, north, east = get_treasure_location()\n  print(\"Start at\", landmark, \"walk\", north, \"paces north and\", east, \"paces east\")\n\nThe complete Pirate’s Treasure program implemention is given in PiratesTreasure.py",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 8: Storing Collections of Data"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/08_StoringCollectionsOfData/Chapter_08.html#notes",
    "href": "01_ProgrammingFundamentals/08_StoringCollectionsOfData/Chapter_08.html#notes",
    "title": "Chapter 8: Storing Collections of Data",
    "section": "",
    "text": "Consider the following vignette\nThe owner of an ice-cream stand wants a program to track sales\n\nThere are ten stands, each selling multiple items\nThe program should take sales data as input and then provide the following views on the data\n\nSorted from lowest to highest\nSorted from highest to lowest\nShow just the highest and the lowest\nShow the total number of sales\nShow the average number of sales\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nGetting the specification right: Storyboarding\nAgreeing on the specification with your client is important. A technique is called storyboarding, best done by sitting down with a paper and pen (or a whiteboard)\nA storyboard shows how the program should flow in response to various user inputs. E.g. depicting the menus the user might use, with a storyboard for each menu choice. The storyboard should also show how the program will work\nFor bigger programs you can break different components out into their own storyboards, much in the same way we built up functions. Storyboards depict what needs to happen, but not how to do it.\n\n\n\nGiven the spec for the ice cream stand we can now outline the program\n\nStore the sales data in variables\nImplement a way to sort the data\nA way to print the output\nStore the data globally and pass it to functions to handle the work\n\nWe can construct the prototype interface, similar to the Ride Selector Program\n  Ice-Cream Sales\n\n  1: Print the Sales\n  2: Sort Low to High\n  3: Sort High to Low\n  4: Highest and Lowest\n  5: Total Sales\n  6: Average Sales\n  7: Enter Figures\n\n  Enter your command: 3\n\n\n\n\nWe first need to store the sales\n\nFor ten stores, we could theoretically use ten variables, one for each store\nBut this method becomes clunky when we want to start analysing the variables\nE.g. the following code (FindingLargestSales.py), only handles finding if the first stand is the one with the greatest sales\n  # Example 8.1 Finding the Largest Sales\n  #\n  # Checks if sales1 has the largest sales. Demonstrates the difficulty of using\n  # individual named variables to deal with aggregate data\n\n  import BTCInput\n\n  sales1 = BTCInput.read_int(\"Enter the sales for stand 1: \")\n  sales2 = BTCInput.read_int(\"Enter the sales for stand 2: \")\n  sales3 = BTCInput.read_int(\"Enter the sales for stand 3: \")\n  sales4 = BTCInput.read_int(\"Enter the sales for stand 4: \")\n  sales5 = BTCInput.read_int(\"Enter the sales for stand 5: \")\n  sales6 = BTCInput.read_int(\"Enter the sales for stand 6: \")\n  sales7 = BTCInput.read_int(\"Enter the sales for stand 7: \")\n  sales8 = BTCInput.read_int(\"Enter the sales for stand 8: \")\n  sales9 = BTCInput.read_int(\"Enter the sales for stand 9: \")\n  sales10 = BTCInput.read_int(\"Enter the sales for stand 10: \")\n\n  if (\n      sales1 &gt; sales2\n      and sales1 &gt; sales3\n      and sales1 &gt; sales4\n      and sales1 &gt; sales5\n      and sales1 &gt; sales6\n      and sales1 &gt; sales7\n      and sales1 &gt; sales8\n      and sales1 &gt; sales9\n      and sales1 &gt; sales10\n  ):\n      print(\"Stand 1 had the best sales\")\nProblem: We would have to repeat the code each time for each individual sales variable\nIf we add more stands, we have add another named variable and another big if statement\n\nAND modify all the previous if statements\n\n\nClearly this approach is not very maintainable\n\n\n\n\n\nA collection is a composite type\n\nIt stores multiple elements of another type\n\nWe’ve already (briefly) seen one type of collection the tuple\nThe most common form of collection is the list\n\nWhat it sounds like, a list of items\n\n\n\n\nOpen a python interpreter and work through the following steps to learn about list\n\nA list is created using brackets around the contents [], e.g.\n\n sales = []\n\n\nThe above defines sales as an empty list\n\nItems can be appended to a list using the append function\n\n sales.append(99)\n sales\n\n[99]\n\n\n\nAs we can see from above sales now contains the value 99\n\nCalling append again, adds the new item to the end of the list\n\n sales.append(100)\n sales\n\n[99, 100]\n\n\nObserve from above you can see the contents of a list, by simply typing the variable name in the interpreter\n\nIn scripts we can also use the explicit print call\n\n  print(sales)\n\n[99, 100]\n\n\n\nYou can access individual items of the list, using the indexing operator []\n\n sales[0]\n\n99\n\n\n\nSyntax is list_name[index] where index is an integer giving the index of the item\nPython lists are zero-indexed. i.e. the first value is stored at index \\(0\\)\n\nThe indexing operator can be used to change the value of an item at a given index\n\n sales[1] = 101\n sales\n\n[99, 101]\n\n\n\nThe above changes the value of the second item in sales to \\(101\\)\n\n\n\n\n\n\n\nWarning\n\n\n\nIndexed elements must exist\nWhenever we use the indexing operator the index must exist! For example if we tried to view the (non-existent) third item, we would get an error, e.g.\n\n example_list = [1, 2]\n print(example_list[2])\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[7], line 2\n      1 example_list = [1, 2]\n----&gt; 2 print(example_list[2])\n\nIndexError: list index out of range\n\n\n\nThe above illustrates the common off-by-one error where we access the last index past the list rather than the last element of the list. Here the type of exception thrown is called an IndexError\n\n\nA single list can store values of different types, and can replace items with new items of a different type\n\n sales.append(\"Rob\")\n sales[0] = \"Python\"\n sales\n\n['Python', 101, 'Rob']\n\n\n\nThe above appends a new string \"Rob\", converts sales[0] from an int to the string \"Python\" and leaves the number \\(101\\) in sales[1] untouched\nOverall list thus mixes string and integer types*\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAvoid Mixing Types in Lists\nust because you can* mix types in lists, doesn’t mean you should. Typically lists and list processing is much easier when a list stores all items of the same type*\n\n\n\n\n\n\n\nYou can use loops to populate a list (see ReadAndDisplay.py)\n  # Example 8.2.1 Read and Display\n  #\n  # Demonstrates using a loop to populate a list\n\n  import BTCInput\n\n  # create an empty list to populate\n  sales = []\n\n  for count in range(1, 11):\n      prompt = \"Enter the sales for stand \" + str(count) + \": \"\n      sales.append(BTCInput.read_int(prompt))\n\n  print(sales)\n\n\n\nExamine the code given above and consider the following questions to understand how the list is processed\n\nWhat is the purpose of the count variable?\n\ncount tracks the value of the current index in the loop. This is used to print the id for the sales stand we are collecting the data from\n\nWhy does the range of count go from \\(1\\) to \\(11\\)?\n\nThe range function returns a collection with the start included but the stop excluded. Since we have stores \\(1\\) through \\(10\\), we want the range to go from \\(1\\) to \\(11\\) so the generated numbers are \\(1\\) through to \\(10\\)\n\nWhich item in the list would hold the sales for stand number \\(1\\)?\n\nThe first item in the list, or the zeroth indexed, i.e. sales[0]\n\nWhat part of the code would have to be changed if we instead had \\(100\\) stands?\n\nWe simply change range(1,11) through to range(1,101)\nThe program below (ReadAndDisplay2.py) is a variant in which the user specifies the number of stands\n  # Example 8.2.2 Read and Display 2\n  #\n  # Improved version of Read and Display which allows the user to specify\n  # the number of stands\n\n  import BTCInput\n\n  # create an empty list to populate\n  sales = []\n\n  number_of_stands = BTCInput.read_int(\"Enter the number of stands: \")\n  for count in range(1, number_of_stands + 1):\n      prompt = \"Enter the sales for stand \" + str(count) + \": \"\n      sales.append(BTCInput.read_int(prompt))\n\n  print(sales)\nThe above is more flexible, but as a result it is more complicated, the trade off between flexibility and ease of use is one that should be considered with the input of the users\n\nIf I got one sales value wrong, would it be possible to edit the list to put in a corrected version?\n\nThis is not implemented in the current program, but we have already seen that you can reassign the value of list at a given index, so we could implement this in a more complete program\n\n\n\n\n\n\n\nWe’ve already seen that print has a default way of displaying a list\nWe can use a for loop for if we want custom printing for each item\n  # Example 8.3 Read and Display Loop\n  #\n  # Uses a for loop to provide custom list printing\n\n  import BTCInput\n\n  sales = []\n\n  for count in range(1, 11):\n      prompt = \"Enter the sales for stand \" + str(count) + \": \"\n      sales.append(BTCInput.read_int(prompt))\n\n  # print a heading\n  print(\"Sales Figures\")\n  count = 1\n  for sales_value in sales:\n      print(\"Sales for stand\", count, \"are\", sales_value)\n      count = count + 1\n\n\n\nLists can hold any type of data that you need to store, including strings. You can change the ice-cream sales program to read and store the names of guests for a party or an event you’re planning. Make a modified version of the sales program that reads in some guest names and then displays them. Make your program handle between \\(5\\) and \\(15\\) guests\n\nWe basically just copy the previous program with the following changes\n\nsales \\(\\rightarrow\\) guests\nsales_value \\(\\rightarrow\\) guest\nWe change the prompts to appropriately refer to guests rather than sales\n\nThe two main changes are\n\nWe add an initial prompt for the number of guests\n\nWe use BTCInput.read_int_ranged to ensure the value is from \\(5\\) to \\(15\\)\n\nWe use BTCInput.read_text instead of BTCInput.read_int to get the guest names\n\n\n    # Exercise 8.1 Party Guests\n    #\n    # A program that receives and then prints a list of party guests\n    # Works for between 5 and 15 guests\n\n    import BTCInput\n\n    guests = []\n    number_of_guests = BTCInput.read_int_ranged(\n        \"Enter the number of guests (5-15): \", 5, 15\n    )\n\n    for count in range(1, number_of_guests + 1):\n        prompt = \"Enter the name of guest \" + str(count) + \": \"\n        guests.append(BTCInput.read_text(prompt))\n\n    # print a heading\n    print(\"\\nGuests attending:\")\n    count = 1\n    for guest in guests:\n        print(\"- \", guest)\n        count = count + 1\n\n\n\n\n\n\nThe previous examples build up our program as one long chain of events\nHowever, if we think about our program this isn’t strictly the cleanest\n\nThere are two distinct responsibilities occuring\n\nFirst we read in the data\nSecond we display the data\n\nThese are natural candidates to be converted into functions\n\nBy pairing these behaviours the program locks us into one way of processing data\n\nWhat happens if we want to read in a second set of data?\nWhat if we want to print the data multiple times?\n\nRefactoring is the process of modifying existing code\n\nSpecifically changing how factors interact\n\nRefactoring avoids the problem of overcomplicating the design at the start of the process\n\nInstead we write the program the most simple way we can\nThen once a structure emerges, or we need to add functionality we can refactor the design\n\nLet us factor out the two key components identified above into a new implementation (Functions.py)\n  # Example 8.4 Functions\n  #\n  # Demonstrates refactoring a program into component functions\n\n  import BTCInput\n\n  sales = []\n\n\n  def read_sales(number_of_sales):\n      \"\"\"\n      Reads in the sales values and stores them in the sales list\n\n      Parameters\n      ----------\n      number_of_sales : int\n          Number of Stores to record sales values for\n\n      Returns\n      -------\n      None\n          Results are read into the sales list\n      \"\"\"\n      sales.clear()  # remove existing sales values\n      for count in range(1, number_of_sales + 1):\n          prompt = \"Enter the sales for stand \" + str(count) + \": \"\n          sales.append(BTCInput.read_int(prompt))\n\n\n  def print_sales():\n      \"\"\"\n      Prints the sales figures on the screen with a heading.\n\n      Each figure is numbered in sequence\n\n      Returns\n      -------\n      None\n      \"\"\"\n      print(\"Sales Figures\")\n      count = 1\n      for sales_value in sales:\n          print(\"Sales for stand\", count, \"are\", sales_value)\n          count = count + 1\n\n\n  read_sales(10)\n  print_sales()\n\n\n\nOur sales analysis program now consists of two functions, read_sales and print_sales\n\nWhat does the parameter for the read_sales function do?\n\nWe hinted at in the previous section that we might want to account for the potential for the number of stands to change in a future implementation. To support this behaviour read_sales reads in the number of sales value that it should reads\n\nWhat does clear do?\n\nWe want to start with a fresh list every time we read the sales values\nclear is a method on list objects that clears its contents\n\nWhy don’t we need to tell the print_sales function how many sales figures to print?\n\nThe for loop goes through the contents of the sales list\nA list tracks its own size\nIn some languages like C, containers do not naturally track their sizes and we would need to specify them\n\nWhy didn’t we have to write global sales in the read_sales function?\n\nPython variable names are references to memory\nThese are distinct from the objects that live in that memory\nAssignments change what object a reference (variable) refers to\n\ne.g. sales=[]\n\nHowever, calling methods on a variable, is not changing the reference e.g. sales.append(99) (They change the object contents)\n\nSo we don’t need to use global because by calling methods its clear what reference we’re using\n\n\n\n\n\n\n\nA development technique called stubs is where we write placeholder functions before we can provide a complete implementation for a given behaviour\nThe placeholders are sometimes called stub functions e.g. the two below\n\ndef sort_high_to_low():\n    \"\"\"\n    Print out a sales list from highest to lowest\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    sort_low_to_high : sorts from lowest to highest\n    \"\"\"\n    pass\n\n\ndef sort_low_to_high():\n    \"\"\"\n    Print out a sales list from lowest to highest\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    sort_high_to_low : sorts from highest to lowest\n    \"\"\"\n    pass\n\nPlaceholders let us model the flow of program before we have all the behaviours specified\n\nObviously does not model the complete program since the functions are incomplete\n\npass is a keyword for a statement that does nothing\n\nIt is effectively a placeholder statement\n\n\n\n\n\n\nAt the start of the Chapter we defined a user interface\n\nBy using the previous discussion on stubbing, and our initial functions we can implement this menu (see the full implementation in FunctionsAndMenu.py)\n\n  menu = \"\"\"\n  Ice Cream Sales\n\n  1. Print the Sales\n  2. Sort High to Low\n  3. Sort Low to High\n  4. Highest and Lowest\n  5. Total Sales\n  6. Average Sales\n  7. Enter Figures\n\n  Enter your command: \"\"\"\n\n  command = BTCInput.read_int_ranged(menu, 1, 7)\n\n  if command == 1:\n      print_sales()\n  elif command == 2:\n      sort_high_to_low()\n  elif command == 3:\n      sort_low_to_high()\n  elif command == 4:\n      highest_and_lowest()\n  elif command == 5:\n      total_sales()\n  elif command == 6:\n      average_sales()\n  elif command == 7:\n      read_sales(10)\n  else:\n      raise ValueError(\"Unexpected value \" + str(command) + \" found\")\nWe use stub functions for the unimplemented behaviour\n\n\n\n\n\n\n\nTip\n\n\n\nUsing Else Clauses to Guard Against Modification\nIn the example above the final else clause should never trip because we expect the result of BTCInput.read_int_ranged(menu, 1, 7) to be between \\(1\\) and \\(7\\) (inclusive) which is captured by the if..elif chain\nWhy then do we include the else clause? The reason is to protect against modification. This could include,\n\nThe author of BTCInput introduces a bug in read_int_ranged that allows invalid input to leak through\nSomeone editing the sales program changes the allowed range of input for read_int_ranged (perhaps to introduce new functions) but forgets to include them in the elif chain\n\nIn either case, the else clause trips, and rather than a silent error which may have occured if we expected the else to catch a \\(7\\), or if there was no else an exception is raised, which immediately notifies us that there’s a problem in the code\nThis technique of guarding against potential modifications is a simple technique for catching sources of errors and making sure you’re confirming your assumptions\n\n\n\n\n\nIn many of the examples and exercises I’ve used elif to simplify cases where we would otherwise have a bunch of nested if...else conditions.\nelif is short for else if and is effectively a next condition to check if the first if (or all preceding elif) statement is False\n\nAll elif conditions must come before the else\n\n\n\n\n\n\n\n\nSorting is a common task for computing programs\nIt can be time-intensive\nThere are often multiple ways that we may wish to sort things, e.g.\n\nAlphabetically vs Numerically\nIncreasing vs Decreasing\nCase-sensitive vs Case-insensitive\n\nTraditional sorts are down, one item (or pair of items) at a time\nAlgorithms, are a sequence of steps that solve a problem\n\nSorting Algorithms are algorithms that sort collections\nProgramming is really the implementation of an algorithm\n\nBubble Sort is a simple sorting algorithm\n\nEasy to follow and understand\nNot scalable to larger data sets\n\n\n\n\n\nOften when implementing an algorithm we want to use a fixed set of test data\n\ni.e. Data for which we can easily know the desired final state or output\nAllows us to check our algorithm is not incorrect\n\nWe can define a list in python with some contents,\n\nsales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n\n\n\n\n\n\nblock-beta\n    columns 6\n\n    classDef BG stroke:transparent, fill:transparent\n\n    index[\"Index\"]:1\n    class index BG\n\n    block:Indices:5\n    columns 10\n        0\n        1\n        2\n        3\n        4\n        5\n        6\n        7\n        8\n        9\n    end\n\n    value[\"Value\"]:1\n    class value BG\n\n    block:Values:5\n    columns 10\n        50\n        54_1[\"54\"]\n        29\n        33\n        22\n        100\n        45\n        54_2[\"54\"]\n        89\n        75\n    end\n\n\n\n\n\n\n\n\nThe above shows how the test data looks in a python list\nFor a highest to lowest sort we want the largest value to be in index \\(0\\) and the lowest in index \\(9\\)\nThe basic idea of Bubble sort is to compare neighbouring values, if the right value is larger we want to swap them so the larger value is on the left\n\nThus closer to the top of the list\n\n\n\n\n\n\n\n\nImportant\n\n\n\nSwap Two Values in a Variable\nThe following code to swap two variables is broken,\nif sales[0] &lt; sales[1]:\n    # the two items are in the wrong order and must be swapped\n    sales[0] = sales[1]\n    sales[1] = sales[0]\nWhy? Lets work through what happens\n\nsales[0] is set to the value of sales[1]\nsales[1] is set to the current value of sales[0]\nBut, sales[0] has already been set to sales[1]\n\nSo sales[1] is set to the same value it already has\n\n\nThe net result is that we only copy sales[1] to sales[0]\nThe correct implementation is given below,\nif sales[0] &lt; sales[1]:\n    temp = sales[0]\n    sales[0] = sales[1]\n    sales[1] = temp\ntemp is used to store the value of sales[0] before it was overwritten\n\n\nObviously, we don’t want to write the code with explicit reference to indices. However we can write this generically with a for loop as below\nfor count in range(0, len(sales) - 1):\n    if sales[count] &lt; sales[count - 1]:\n        temp = sales[count]\n        sales[count] = sales[count + 1]\n        sales[count + 1] = temp\n\n\nThe above code uses some new python features. Work through the following questions to understand what’s going on\n\nWhy have you used a for loop, rather than a while loop?\n\nWe could use either, the for loop is slightly smaller since we don’t have to manually increment count\nAdditionally range technically returns what is called a generator,\nThis is more memory efficient\n\nRather than creating a full list of numbers in memory, it just returns the next number each time the for loop requests it\n\n\nWhat does the len function do on line \\(1\\)?\n\nlen returns the length of a collection, i.e. the number of items in the collection\nThis lets you write code that is insensitive to the size of the collection being worked with\nMeans our sorting code could work on any length list\n\nWhy is the limit of count the length of the list minus 1?\n\nThis is because bubble sort compares the current item to the item to its right, i.e. at the next index\nIf the range goes to the last index, then program will try an access an element one past the end of the list which doesn’t exist\n\nThis will cause an error. e.g.\n\n\n\n a_list = [1,2]\n for count in range(0, len(a_list)):\n     if a_list[count] &lt; a_list[count + 1]:\n         temp = a_list[count]\n         a_list[count] = a_list[count + 1]\n         a_list[count + 1] = temp\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[9], line 3\n      1 a_list = [1,2]\n      2 for count in range(0, len(a_list)):\n----&gt; 3     if a_list[count] &lt; a_list[count + 1]:\n      4         temp = a_list[count]\n      5         a_list[count] = a_list[count + 1]\n\nIndexError: list index out of range\n\n\n\n\n\nThe complete implementation of the above discussion below performs one pass through the list\n\n\n# Example 8.6 Bubble Sort First Pass\n#\n# Implements the first pass of bubble sort and shows the impact on the list\n\n# test data\nsales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\ndef sort_high_to_low():\n    \"\"\"\n    Print out a sales list from highest to lowest\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    for count in range(0, len(sales) - 1):\n        if sales[count] &lt; sales[count + 1]:\n            temp = sales[count]\n            sales[count] = sales[count + 1]\n            sales[count + 1] = temp\n\n\nprint(\"Input list:\", sales)\n\nsort_high_to_low()\n\nprint(\"Output list:\", sales)\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nOutput list: [54, 50, 33, 29, 100, 45, 54, 89, 75, 22]\n\n\nafter which the test data looks like this\n\n\n\n\n\nblock-beta\n    columns 6\n\n    classDef BG stroke:transparent, fill:transparent\n\n    index[\"Index\"]:1\n    class index BG\n\n    block:Indices:5\n    columns 10\n        0\n        1\n        2\n        3\n        4\n        5\n        6\n        7\n        8\n        9\n    end\n\n    value[\"Value\"]:1\n    class value BG\n\n    block:Values:5\n    columns 10\n        54_1[\"54\"]\n        50\n        33\n        29\n        100\n        45\n        54_2[\"54\"]\n        89\n        75\n        22\n    end\n\n\n\n\n\n\n\nNotice that the list has been partially sorted\n\nAlso notice that the smallest value \\(22\\) has been moved to the correct index (the end)\nThe high numbers effectively bubble left past one of the values smaller than them\n\nSince we can see that after sorting the smallest value has been moved to the end we expect on the second loop through the second smallest value will have been moved to the correct spot\n\nSo we want to loop through len(sales) times\n\nThe working bubble sort implemention is then,\n\n\n# Example 8.7 Bubble Sort Multiple Pass\n#\n# Implements a complete working version of bubble sort\n\n# test data\nsales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\ndef sort_high_to_low():\n    \"\"\"\n    Print out a sales list from highest to lowest\n\n    Returns\n    -------\n    None\n    \"\"\"\n    for sort_pass in range(0, len(sales)):\n        for count in range(0, len(sales) - 1):\n            if sales[count] &lt; sales[count + 1]:\n                temp = sales[count]\n                sales[count] = sales[count + 1]\n                sales[count + 1] = temp\n\n\nprint(\"Input list:\", sales)\n\nsort_high_to_low()\n\nprint(\"Output list:\", sales)\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nOutput list: [100, 89, 75, 54, 54, 50, 45, 33, 29, 22]\n\n\n\n\n\nAs seen above, the sorting program now works correctly. Once you have a working implementation its worth investigating if there are changes you can make to improve the efficiency. Work through the following questions to get the idea\n\nIs the program making more comparisons than necessary?\n\nYes, as we mentioned before, after one pass the smallest item will always be at the end of the collection\nThis means we don’t need to check any swaps against it any more for the inner loop\nAfter each pass the size of this sorted section increases by at least one\nAn implementation taking this into account is,\n  for sort_pass in range(0, len(sales)):\n      for count in range(0, len(sales) - 1 - sort_pass):\n          if sales[count] &lt; sales[count + 1]:\n              temp = sales[count]\n              sales[count] = sales[count + 1]\n              sales[count + 1] = temp\n\nIs the program performing more passes through the list than nessecary?\n\nProbably, unless the largest value is at the end of the list all values should be bubbled to their correct spot in less than len(sales) passes\nWe can stop doing additional passes if we work out the list is already sorted\nHow?\n\nWe use a flag to track if any swaps occur in a pass\nIf none do then the list is already sorted and we can stop\n\n\n  # Example 8.8 Efficient Bubble Sort\n  #\n  # A bubble sort implementation incorporating efficiency savings to the number\n  # of comparisons and passes through the list\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def sort_high_to_low():\n      \"\"\"\n      Print out a sales list from highest to lowest\n\n      Returns\n      -------\n      None\n      \"\"\"\n      for sort_pass in range(0, len(sales)):\n          done_swap = False\n          for count in range(0, len(sales) - 1 - sort_pass):\n              if sales[count] &lt; sales[count + 1]:\n                  temp = sales[count]\n                  sales[count] = sales[count + 1]\n                  sales[count + 1] = temp\n                  done_swap = True\n          if not done_swap:\n              break\n\n  print(\"Input list:\", sales)\n\n  sort_high_to_low()\n\n  print(\"Output list:\", sales)\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nOutput list: [100, 89, 75, 54, 54, 50, 45, 33, 29, 22]\n\n\n\n\n\n\n\nBubble sort works for strings as well as integers. We saw that in Chapter 5 the python relational operators also work for strings. See if you can modify the Party Guest Program to display the names in alphabetical order\nWe can basically just reuse our sort code, but renamed for the guest program.\ndef sort_alphabetical():\n    \"\"\"\n    Sorts a list alphabetically\n\n    Returns\n    -------\n    None\n    \"\"\"\n    for sort_pass in range(0, len(guests)):\n        done_swap = False\n        for count in range(0, len(guests) - 1 - sort_pass):\n            if guests[count] &gt; guests[count + 1]:\n                temp = guests[count]\n                guests[count] = guests[count + 1]\n                guests[count + 1] = temp\n                done_swap = True\n        if not done_swap:\n            break\nThere is a second modification above, which is changing the sign of the relational operator, e.g.\nguests[count] &lt; guests[count + 1]\nhas been changed to,\nguests[count] &gt; guests[count + 1]\nThis is because as written the program tries to put the smallest strings last, but for strings; where the relational operator is alphabetically ordered this puts strings starting with a for example, after those starting with z etc. So we need to swap the sign so that the list is printed a, b, … , z etc.\nWhy don’t we have to make more modifications? Well the code as written only requires that the items being sorted are stored in a list, and that the items in the list can be compared with a relational operator. Both of these properties are satisfied by a collection of strings so the code effectively works out of the box\nThe complete code, including the integration with reading and printing the guest list is given in SortAlphabetically.py\n\n\n\n\n\nTo flip the direction of the sort, we just need the condition that determines what is out of order or not\n\nWe do this by changing \\(&lt;\\) to \\(&gt;\\), i.e.\n\n  # Example 8.9 Bubble Sort Low to High\n  #\n  # Implementation of Bubble Sort that sorts from low to high\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def sort_low_to_high():\n      \"\"\"\n      Print out a sales list from highest to lowest\n\n      Returns\n      -------\n      None\n      \"\"\"\n      for sort_pass in range(0, len(sales)):\n          done_swap = False\n          for count in range(0, len(sales) - 1 - sort_pass):\n              if sales[count] &gt; sales[count + 1]:\n                  temp = sales[count]\n                  sales[count] = sales[count + 1]\n                  sales[count + 1] = temp\n                  done_swap = True\n          if not done_swap:\n              break\n\n\n  print(\"Input list:\", sales)\n\n  sort_low_to_high()\n\n  print(\"Output list:\", sales)\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nOutput list: [22, 29, 33, 45, 50, 54, 54, 75, 89, 100]\n\n\n\nThe code above is given in BubbleSortLowToHigh.py\n\n\n\n\n\nIn comparison to sorting, finding a value is much easier\nThe basic outline for finding the highest is,\n  for values in collection\n      if(new value &gt; highest seen so far)\n          highest = new value\nWe can write the code for the highest and lowest in python then as,\n  highest = sales[0]\n  for sales_value in sales:\n      if sales_value &gt; highest:\n          highest = sales_value\n\n  lowest = sales[0]\n  for sales_value in sales:\n      if sales_value &lt; lowest:\n          lowest = sales_value\nIf we want to find both at the same time, then we can combine the code above, which means we only have to do one pass through the collection\n\n  # Example 8.10 Highest and Lowest\n  #\n  # Function that finds the highest and lowest value in a collection\n\n  # Example 8.9 Bubble Sort Low to High\n  #\n  # Implementation of Bubble Sort that sorts from low to high\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def highest_and_lowest():\n      \"\"\"\n      Print out the highest and lowest elements of a sales list\n\n      Returns\n      -------\n      None\n      \"\"\"\n      highest = sales[0]\n      lowest = sales[0]\n\n      for sales_value in sales:\n          if sales_value &gt; highest:\n              highest = sales_value\n          elif sales_value &lt; lowest:\n              lowest = sales_value\n      print(\"The highest is:\", highest)\n      print(\"The lowest is\", lowest)\n\n\n  print(\"Input list:\", sales)\n\n  highest_and_lowest()\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nThe highest is: 100\nThe lowest is 22\n\n\n\nThe code above is given in HighestAndLowest.py\n\n\n\n\n\n\nTo evaluate the total we have to sum the contents of a list, simple using the for loops we’ve looked at, (implementation in TotalSales.py)\n\n  # Example 8.11 Total Sales\n  #\n  # Calculate the Total Sales\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def total_sales():\n      \"\"\"\n      Print out the total sales of a sales list\n\n      Returns\n      -------\n      None\n      \"\"\"\n      total = 0\n      for sales_value in sales:\n          total = total + sales_value\n      print(\"Total sales are:\", total)\n\n\n  print(\"Input list:\", sales)\n\n  total_sales()\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nTotal sales are: 551\n\n\nIt is a simple extra step to them calculate the average, (divide the total by the number of elements in the collection)\n\n  # Example 8.12 Average Sales\n  #\n  # Calculate the Average Sales\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def average_sales():\n      \"\"\"\n      Print out the average sales of a sales list\n\n      Returns\n      -------\n      None\n      \"\"\"\n      total = 0\n      for sales_value in sales:\n          total = total + sales_value\n      average_sales = total / len(sales)\n      print(\"Average sales are:\", average_sales)\n\n\n  print(\"Input list:\", sales)\n\n  average_sales()\n\nInput list: [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\nAverage sales are: 55.1\n\n\n\n\n\n\n\nThe previous Exercises have given us all the parts, now we want to put it together\nThe crux of our program should be a loop around the menu through which the user selects different functions\nWe first however need to read in the data from the user\nFor useability we should add the ability to quit the program\nThe final program implements this\n\n# Example 8.13 Complete Program\n#\n# A Complete implementation of the Sales Program combining all the individual\n# programs that we have implemented\n\nimport BTCInput\n\nsales = []\n\n\ndef read_sales(number_of_sales):\n    \"\"\"\n    Reads in the sales values and stores them in the sales list\n\n    Parameters\n    ----------\n    number_of_sales : int\n        Number of Stores to record sales values for\n\n    Returns\n    -------\n    None\n        Results are read into the sales list\n    \"\"\"\n    sales.clear()  # remove existing sales values\n    for count in range(1, number_of_sales + 1):\n        prompt = \"Enter the sales for stand \" + str(count) + \": \"\n        sales.append(BTCInput.read_int(prompt))\n\n\ndef print_sales():\n    \"\"\"\n    Prints the sales figures on the screen with a heading. Each figure is\n    numbered in sequence\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"Sales Figures\")\n    count = 1\n    for sales_value in sales:\n        print(\"Sales for stand\", count, \"are\", sales_value)\n        count = count + 1\n\n\ndef sort_high_to_low():\n    \"\"\"\n    Print out a sales list from highest to lowest\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    sort_low_to_high : sorts from lowest to highest\n    \"\"\"\n    for sort_pass in range(0, len(sales)):\n        done_swap = False\n        for count in range(0, len(sales) - 1 - sort_pass):\n            if sales[count] &lt; sales[count + 1]:\n                temp = sales[count]\n                sales[count] = sales[count + 1]\n                sales[count + 1] = temp\n                done_swap = True\n        if not done_swap:\n            break\n\n\ndef sort_low_to_high():\n    \"\"\"\n    Print out a sales list from lowest to highest\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    sort_high_to_low : sorts from highest to lowest\n    \"\"\"\n    for sort_pass in range(0, len(sales)):\n        done_swap = False\n        for count in range(0, len(sales) - 1 - sort_pass):\n            if sales[count] &gt; sales[count + 1]:\n                temp = sales[count]\n                sales[count] = sales[count + 1]\n                sales[count + 1] = temp\n                done_swap = True\n        if not done_swap:\n            break\n\n\ndef highest_and_lowest():\n    \"\"\"\n    Print out the highest and lowest elements of a sales list\n\n    Returns\n    -------\n    None\n    \"\"\"\n    highest = sales[0]\n    lowest = sales[0]\n\n    for sales_value in sales:\n        if sales_value &gt; highest:\n            highest = sales_value\n        elif sales_value &lt; lowest:\n            lowest = sales_value\n    print(\"The highest is:\", highest)\n    print(\"The lowest is\", lowest)\n\n\ndef total_sales():\n    \"\"\"\n    Print out the total sales of a sales list\n\n    Returns\n    -------\n    None\n    \"\"\"\n    total = 0\n    for sales_value in sales:\n        total = total + sales_value\n    print(\"Total sales are:\", total)\n\n\ndef average_sales():\n    \"\"\"\n    Print out the average sales of a sales list\n\n    Returns\n    -------\n    None\n    \"\"\"\n    total = 0\n    for sales_value in sales:\n        total = total + sales_value\n    average_sales = total / len(sales)\n    print(\"Average sales are:\", average_sales)\n\n\n# Get initial sales list\nread_sales(10)\n\n\nmenu = \"\"\"\nIce Cream Sales\n\n0. Quit the Program\n1. Print the Sales\n2. Sort High to Low\n3. Sort Low to High\n4. Highest and Lowest\n5. Total Sales\n6. Average Sales\n7. Enter Figures\n\nEnter your command: \"\"\"\n\nwhile True:\n    command = BTCInput.read_int_ranged(menu, 0, 7)\n    if command == 0:\n        break\n    if command == 1:\n        print_sales()\n    elif command == 2:\n        sort_high_to_low()\n    elif command == 3:\n        sort_low_to_high()\n    elif command == 4:\n        highest_and_lowest()\n    elif command == 5:\n        total_sales()\n    elif command == 6:\n        average_sales()\n    elif command == 7:\n        read_sales(10)\n    else:\n        raise ValueError(\"Unexpected value \" + str(command) + \" found\")\n\n\n\n\n\n\nWarning\n\n\n\nKeeping Information Synchronised when Sorting\nPlaying around with the program you might notice one thing. The stands are numbered in the order that they are printed. This works great for printing the original list out, but once we start sorting these numbers don’t match their original value. This is fine if we only care about the sales figures, but if we want to maintain a relationship between a stand and its sales this is something that would have to be modified.\nThis is something you would discuss with the client\n\n\n\n\n\n\n\nA natural extension to the program would be the ability to read or store the sales data to a file\nFiles allow for persisting the data between sessions\nTo do this we’ll add two new options, 8. Save Sales and 9. Load Sales\nLet us start by stubbing out our functions (the complete integration is found in LoadAndSave.py),\n  def save_sales(file_path):\n      \"\"\"\n      Saves the contents of the sales list to a file\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to save to\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the save fails\n\n      See Also\n      --------\n      load_sales : load sales from a sales list file\n      \"\"\"\n      print(\"Save the sales in:\", file_path)\n\n\n  def load_sales(file_path):\n      \"\"\"\n      loads the contents of a file into the sales list\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to load from\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the load fails\n\n      See Also\n      --------\n      save_sales : save the sales list into a file\n      \"\"\"\n      print(\"Load the sales in:\", file_path)\nWe also add a basic integration to the user menu, where we use BTCInput.read_text to get a file name, then call the function\nObserve that by adding the complete docstring’s we’re also starting to document the requirements for these functions in-code\n    elif command == 7:\n      read_sales(10)\n  elif command == 8:\n      file_to_save_to = BTCInput.read_text(\"Enter file to save to: \")\n      save_sales(file_to_save_to)\n  elif command == 9:\n      file_to_load_from = BTCInput.read_text(\"Enter file to load: \")\n      load_sales(file_to_load_from)\n  else:\n      raise ValueError(\"Unexpected value \" + str(command) + \" found\")\n\n\n\n\nWhen interacting with a file, python represents it as a memory object\n\nTechnically representing the connection\n\nopen creates a connection to a file, the below, opens a file, test.txt, in write mode w and stores it in the variable output_file\n  output_file = open('test.txt', 'w')\n\nThe two arguments are called the file_path and the mode\n\nfile_path is the file you want to open\nmode is what you want to do with it\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\nIt’s very easy to overwrite an existing file\nThe open function will not prevent you from modifying important files. For example files opened for write will first wipe the contents of any existing file that matches the path then write the new contents.\nPython provides the os module which has some extra functionality for handling files and directories, e.g. you can check that a file exists before you open it if you then want check if the user wants to overwrite it before opening it\nimport os.path\nif os.path.isfile(\"text.txt\"):\n    print(\"The file exists\")\n\n\n\nIf we’ve opened a file in write mode, we can use the write method on the file object to write to the file\n  output_file.write(\"First line\\n\")\n  output_file.write(\"Second line\\n\")\n  output_file.close()\nOnce you’re done with a file you need to call close\n\nCompletes any unfinished writes (ensures data integrity)\nReleases the file so other programs or processes can use it\n\nFiles open for writing are locked for editing by that process, nothing else can use them\n\n\nPutting everything together our simple file writing program is,\n  # Exercise 8.15 File Output\n  #\n  # A simple program to demonstrate opening and writing to a file\n\n  output_file = open(\"test.txt\", \"w\")\n  output_file.write(\"line 1\\n\")\n  output_file.write(\"line 2\\n\")\n  output_file.close()\n\n\n\nConsider the following questions about file writing\n\nWhy have you called the write function a method? Isn’t it a function?\n\nAs discussed earlier, methods are functions associated with a specific object\nTypically when we say functionw we refer to a function that is defined outside of an object\nwrite is a method on the file object\n\nIt is impossible to use write without there being a file object to use\nMethods allow us to work with multiple file objects without having to worry about making sure we pass the correct one to the function\n\n\nWhat does the \\n mean at the end of the strings?\n\nIt’s the new line symbol write doesn’t automatically end the line after we call it\nWe have to manually pass the new line\n\nWhere is the file text.txt actually created?\n\nThe file_path is relative to the current running python program\nHence the file is written to the same directory\n\nE.g. if we had a folder called “My Programs” with a python program “MakeFiles.py”, when we run “MakeFiles.py” the files it makes are stored in “My Programs”\n\nYou can use more complicated file_paths\n\npath = \"./data/test.txt\" would look for test.txt in the data subdirectory of the current python program (relative path)\npath = \"c:/data/test.txt\" would look for test.txt in the data subdirectory of the c drive (absolute path)\n\n\n\n\n\n\n\nNote\n\n\n\nDenoting a Directory Seperator\nOn Windows \\ is used to seperate directories, but in python you always use /\n\n\n\nCan any program use a file written from a Python program?\n\nYes, python uses the underlying operating systems file handling services\nAny other program on the operating system can access files created or modified by python\n\nCan I add lines at the end of a python file?\n\nYes, rather than open the file in write w, you open the file in append (a).\nAny writes will then be appended to the end of the file.\nA non-existent file will be created the same way as for write mode\n\n\n\n\n\n\nUsing the above discussion we can implement the write_sales function\n  # Example 8.16 Write Sales\n  #\n  # Implements the Write Sales function\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def save_sales(file_path):\n      \"\"\"\n      Saves the contents of the sales list to a file\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to save to\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the save fails\n      \"\"\"\n      print(\"Save the sales in: \", file_path)\n      output_file = open(file_path, \"w\")\n      for sale in sales:\n          output_file.write(str(sale) + \"\\n\")\n      output_file.close()\n\n\n  save_sales(\"test_output.txt\")\n\n\n\n\nThe save_sales function combines several behaviours and is worth examining in detail. What is the purpose of the function? To take a list of sales figures and write those figures to a file (preferably in a format that is easy for a human to read and to load back into the program.) Consider the following questions\n\nWhat does the str function do? Why are we using it?\n\nThe str function converts the sales number to a string\nWhile print can handle non-string inputs, write can only take a string\n\nWhy can’t we just write out the sales list as one object?\n\nA list does not provide any built-in methods for writing an object out to a file\nWe could try and print out it’s string representation (i.e. call str and output that)\nDoesn’t give us great ability to control the way the data is output\n\n\n\n\n\n\n\nWe an also use open to read from a file, we just use the read mode (r)\n  input_file = open(\"test.txt\", \"r\")\nWe can then loop over the lines in a file using a for loop\nfor line in input_file:\n      print(line)\nWe should still use close() when we’re done reading\n  input_file.close()\nThe complete sample program looks like,\n  # Example 8.17 File Input\n  #\n  # Demonstrates reading input from a file\n\n  input_file = open(\"test.txt\", \"r\")\n  for line in input_file:\n      print(line)\n  input_file.close()\n\n\n\nWork through the following questions to understand how reading from files works\n\nIf you look at the following output, you’ll notice there are empty lines after each line of text. Why is that?\n line 1\n\n line 2\n\n\nEvery time we read a line from a file, we read the terminating new line\nThis is included in the string stored in line so when we call print we get that new line and the new line added by print\nWe could fix this by modifying our print call, to remove the new line\n  print(line, end='')\nA more natural way to fix this is to remove the newline when we first read in the string\nThe strip method when called without arguments returns a copy of the string with all leading and trailing whitespace removed from the string\n\n  line = line.strip()\n\nThis is an example of conditioning input\nProcess of making sure that an input does not contain any unexpected values\nE.g. we might also want to use strip to remove non-printable characters\n\nlstrip and rstrip are variants of strip that only work on the lead or end of the string respectively\n\n\nWhy do we have to close the file we’re reading?\n\nFor reading a file forgetting to close it won’t cause issues with other programs or processes that also try to read from the file\nHowever, lets other programs now write to that file\nReleases the memory associated with holding the connection\nYour computer might not let you shut down if it thinks there are still unclosed files\n\nWhat would happen if you tried to write to a file that had been opened for reading?\n\nAn exception will be raised\nr+ is a mode that lets you read and write to a file\nYou typically don’t want to read and write to a file at the same time\n\nHard to ensure the integrity of the data and avoid corrupting it\nSuch as by writing a line longer than the one previously written\n\nthis may corrupt the next line\n\n\nA better pattern is to load data, update the data then write that back into the file\n\nA temporary file (often abreviated as a tmp file) can be used if we need an intermediate file to write to\n\n\nCan a program read an entire file at once?\n\nYes, the* read method by default will try to read an entire file\nline endings are preserved\nBe careful with large files, as this may overwhelm your computers memory…\n\n # Example 8.18 File Read\n #\n # Demonstrates the use of file_object.read to read\n # the contents of a file in one go\n\n input_file = open(\"test.txt\", \"r\")\n total_file = input_file.read()\n print(total_file)\n input_file.close()\n\n\n\n\n\nLet’s now implement load_sales\n  # Example 8.19 Load Sales\n  #\n  # Implements the Load Sales function\n\n  sales = []\n\n\n  def load_sales(file_path):\n      \"\"\"\n      loads the contents of a file into the sales list\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to load from\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the load fails\n      \"\"\"\n      print(\"Load the sales in:\", file_path)\n      sales.clear()\n      input_file = open(file_path, \"r\")\n      for line in input_file:\n          line = line.strip()\n          sales.append(int(line))\n      input_file.close()\n\n\n\nload_sales works as the opposite of save_sales instead of taking a sales list and putting it into a text file, we pull the figures from a file and load them into the sales list. Consider the following questions\n\nWhat does the int function do?\n\nThe numbers pulled out of the file are initially stored as a string\nWe need to convert them to a number, so we call int\n\nWhat happens if the input file was empty?\n\nThe function works as one would hope\nThe loop doesn’t iterate and we get an empty sales list\n\n\n\n\n\n\n\n\nDealing with files, also means dealing with the errors they can introduce\n\ne.g. A file might have been deleted, a USB removed, or simply the user might pass the wrong name\n\nWhen an error occurs we want to ensure two things:\n\nNo files are left open\nThe user is aware that the error has occured\n\nFile objects typically raise exceptions when their methods\n\nEnables us to handle and report on their errors\nUse the try ... except syntax we’ve seen before\n\n  try:\n      output_file = open(file_path, \"w\")\n      for sale in sales:\n          output_file.write(str(sale) + \"\\n\")\n      output_file.close()\n      print(\"File Written Successfully\")\n  except:\n      print(\"Something went wrong with the file\")\n\n\n\nThe code performing the file write is wrapped in a try...except block. If write, open or close causes an exception it will be caught and handled by the except clause. Let’s work through the following questions to see if this solves the ensures that the file is closed and the user is informed\n\nIn what circumstances will the code in the except part be executed?\n\nIf any of the file functions, write, open, or close raise an exception, the code in the except part will be executed\nAn error message is thus only printed when an error occurs\n\nIn what circumstances will the “File written successfully?” message be printed?\n\nThis is only printed if every step in the file writing process is completed successfully\n\nAn error message is always printed if an error is thrown, but will the file always be closed?\n\nNo, this is a problem, as we said that all files needed to be closed even when an error occurs!\nWe could put the close statement in the exception handling section to, but a more general solution to this problem is to use a finally block\n\nA finally block contains code that is always executed after all of the try and/or except code has executed\nGood for code that we naturally want to run after the block no matter if the process succeeds or fail (such as clean-up)\n\n\n try:\n     output_file = open(filename, \"w\")\n     for sale in sales:\n         output_file.write(str(sale) + \"\\n\")\n except:\n     print(\"Something went wrong with writing to the file\")\n finally:\n     output_file.close()\n\n\n\n\n\n\nIt would be great if we didn’t have to remember to manually ensure a file gets closed\n\nFailing to properly close a file can lead to hard to pin down behaviour\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIntermittent Faults are the Worst Kind to Fix\nA piece of code that is broken all the time is annoying, but at least you can typically easily identify what is not working. If a program fails only some of the time this can be much harder to solve. Often you require precise directions as to the steps taken up to the point of failure in order to be able to attempt to replicate the problem. This adds significant overhead to fixing the problem\n\n\n\nThe with construct allows the programmer to automatically manage the acquisition and release of resources\n\nMore generic than just file access\nYou can write your own services to work with with\n\nAdvanced topic we can ignore for now\n\n\n\n\n\n\n\n\nblock-beta\n    columns 6\n\n    classDef BG stroke:transparent, fill:transparent\n\n\n    space\n    title[\"Breakdown of a with statement\"]:4\n    space\n\n    class title BG\n\n    block:With\n    columns 1\n        with[\"with\"]\n        withDescr[\"(start of a with block)\"]\n    end\n\n    class with BG\n    class withDescr BG\n\n\n    block:Expression\n    columns 1\n        expression[\"expression\"]\n        expressionDescr[\"(expression generating resource to use)\"]\n    end\n\n    class expression BG\n    class expressionDescr BG\n\n    block:As\n    columns 1\n        as[\"as\"]\n        space\n    end\n\n    class as BG\n\n    block:Name\n    columns 1\n        name[\"name\"]\n        nameDescr[\"(name to represent the resource)\"]\n    end\n\n    class name BG\n    class nameDescr BG\n\n    block:Colon\n    columns 1\n        colon[\":\"]\n        space\n    end\n\n    class colon BG\n\n    block:Suite\n    columns 1\n        suite[\"Statement block\"]\n        suiteDescr[\"(statements)\"]\n    end\n\n    class suite BG\n    class suiteDescr BG\n\n\n\n\n\n\n\nwith is used to provide an object that provides a service\nas is used to assign a semantically meaningful name to the resource\nwith activates an “enter” behaviour on its object\n\nFor files this is open\n\nWhen the block is finished, with calls some exit behaviour on the object\n\nFor files this causes the file to be closed\n\nwith allows us to ensure a few things\n\nThe file is always closed\nThe reference to the file only exists as long as we are using it\n\n  # Example 8.20 Using with to Access Files\n  #\n  # Rewrites read_sales and load_sales to use the with functionality\n  # implemented in python\n\n  # test data\n  sales = [50, 54, 29, 33, 22, 100, 45, 54, 89, 75]\n\n\n  def save_sales(file_path):\n      \"\"\"\n      Saves the contents of the sales list to a file\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to save to\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the save fails\n\n      See Also\n      --------\n      load_sales : load sales from a given file\n      \"\"\"\n      print(\"Save the sales in:\", file_path)\n      try:\n          with open(file_path, \"w\") as output_file:\n              for sale in sales:\n                  output_file.write(str(sale) + \"\\n\")\n      except:  # noqa: E722\n          print(\"Something went wrong with the file\")\n\n\n  def load_sales(file_path):\n      \"\"\"\n      loads the contents of a file into the sales list\n\n      Parameters\n      ----------\n\n      file_path : str\n          string giving the file path to load from\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      FileException\n          Raised if the load fails\n\n      See Also\n      --------\n      save_sales : save sales to a file\n      \"\"\"\n      print(\"Load the sales in:\", file_path)\n      sales.clear()\n      try:\n          with open(file_path, \"r\") as input_file:\n              for line in input_file:\n                  line = line.strip()\n                  sales.append(int(line))\n      except:  # noqa: E722\n          print(\"Something went wrong with the file\")\n\n\n  print(\"Sales before save and load:\", sales)\n  save_sales(\"test.txt\")\n  load_sales(\"test.txt\")\n  print(\"Sales after save and load:\", sales)\nObserve that we no longer have to explicitly include the close call\nwith does not handle exceptions however, so we still have to include a try...except block\nWhen an exception occurs the with first releases the resource with its exit behaviour\n\ne.g. closes the file\nThen the excecution moves to the except block\n\nIf we wanted to handle exceptions without releasing the resource, we would have to swap the order to,\n  with open(\"file\", \"mode\"):\n      try:\n          #do standard thing here\n      except:\n          # handle exception without releasing resource\n      finally:\n          # do something regardless of success or fail without releasing resource\n\n\n\n\nAdd a save function to your party guest program so that you can record a list of people who attended your party\nWe build off our version that generates a sorted list. We can basically copy the save_sales function making changes to the refer to the guests list instead of sales and giving a more appropriate name to the loop variable.\ndef save(file_path):\n    \"\"\"\n    Saves the guest list to a file\n\n    Parameters\n    ----------\n\n    file_path : str\n        string giving the file path to save to\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    FileException\n        Raised if the save fails\n    \"\"\"\n    print(\"Save the guest list in:\", file_path)\n    try:\n        with open(file_path, \"w\") as output_file:\n            for guest in guests:\n                output_file.write(str(guest) + \"\\n\")\n    except:  # noqa: E722\n        print(\"Something went wrong with the file\")\nWe then run the program as normal\n\nAsk for the number of guests\nRead in the guests\nSort the guest list\nDisplay the guest list\n\nWe then ask the user if they want to save the guest list. For simplicity we use BTCInput.read_input_ranged to ask for a \\(0\\) or a \\(1\\) where a \\(1\\) indicates the user wishes to save, while \\(0\\) indicates they dont. If the user wishes to save we then prompt them using BTCInput.read_text for a file name and then call save on the given file path\nuser_wants_to_save = BTCInput.read_int_ranged(\n    \"Would you like save the list? (1 for yes, 0 for no): \", min_value=0, max_value=1\n)\n\nif user_wants_to_save:\n    save_file_name = BTCInput.read_text(\"Enter file name to save as: \")\n    save(save_file_name)\n\nThe complete integrated code is given in GuestListWithSave.py\n\n\n\n\n\n\nA list holds data in one dimension, i.e. its length\nOften data is multi-dimensional\ne.g. Our Ice Cream Sales client might now ask for the ability to track sales, by store and by day of the week\n\n\n\n\n\n\nblock-beta\n    columns 5\n\n    classDef Header fill:#bbf,stroke:#333,stroke-width:4px;\n    classDef BG stroke:transparent, fill:transparent\n\n    space:2\n    title[\"Data Table\"]:2\n    space:1\n\n    class title BG\n\n    space\n    block:fields:4\n    columns 4\n        monday[\"Monday\"]\n        tuesday[\"Tuesday\"]\n        wednesday[\"Wednesday\"]\n        stop[\"...\"]\n    end\n\n    class fields Header\n\n    Stand1[\"Stand 1\"]\n    50\n    80\n    10\n    Blank1[\"...\"]\n\n    class Stand1 BG\n\n    Stand2[\"Stand 2\"]\n    54\n    98\n    7\n    Blank2[\"...\"]\n\n    class Stand2 BG\n\n    Stand3[\"Stand 3\"]\n    29\n    40\n    80_2[\"80\"]\n    Blank3[\"...\"]\n\n    class Stand3 BG\n\n    Stand4[\"...\"]\n    stand4_1[\" \"]\n    stand4_2[\" \"]\n    stand4_3[\" \"]\n    stand4_4[\" \"]\n\n    class Stand4 BG\n\n\n\n\n\n\n\n\nOur current implementation is effectively a vertical slice for one of the days\nCan implement multiple lists, one per day of the week\n\nEffectively repeats the problem we had before of a distinct named variable for each item\n\nWe want a list of lists\n\n  mon_sales = [50, 54, 29, 33,  22, 100, 45, 54, 89, 75]\n  tue_sales = [80, 98, 40, 43, 43, 80, 50, 60, 79, 30]\n  wed_sales = [10, 7, 80, 43, 48, 82, 33, 55, 83, 80]\n  thu_sales = [15, 20, 38, 10, 36, 50, 20, 26, 45, 20]\n  fri_sales = [20, 25, 47, 18, 56, 70, 30, 36, 65, 28]\n  sat_sales = [122, 140, 245, 128, 156, 163, 90, 140, 150, 128]\n  sun_sales = [100, 130, 234, 114, 138, 156, 107, 132, 134, 148]\n\n  week_sales = [mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales, sun_sales]\n\nThink of lists of lists as a collection of rows and columns\n\nWe first specify the row we want say tue_sales\nThen the column, say Stand 1\n\n  print(week_sales[1][0])\n\n80\n\n\n\n\n\n\nIt can be difficult to get the hang of working with multiple indices. Which of the following indices would fail when the program runs?\nStatement 1: week_sales[0][0] = 50\nStatement 2: week_sales[8][7] = 88\nStatement 3: week_sales[7][10] = 100\n\nStatement 1 is valid\nStatement 2 is invalid because the first index \\(8\\) corresponds to the day of the week\n\nThe valid indices here are \\(0\\) to \\(6\\)\n\nStatement 3 is also invalid for the same reason\n\nEven though there are seven days of the week\nThe list is zero indexed\n\n\nLet’s see this in action\n\nStatement 1:\n\n\nweek_sales[0][0]\n\n50\n\n\n\nStatement 2:\n\n\nweek_sales[8][7]\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[20], line 1\n----&gt; 1 week_sales[8][7]\n\nIndexError: list index out of range\n\n\n\n\nStatement 3:\n\n\nweek_sales[7][10]\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[21], line 1\n----&gt; 1 week_sales[7][10]\n\nIndexError: list index out of range\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nMake it easy to test your program\nTesting is important, but unless it’s easy or automatic it’s pretty common to get left by the wayside.\nIn a program one might use a function make_test_data or for larger projects a test framework that is used to generate test data.\nWhenever you find yourself repeating a pattern to test code, consider how you can automate or bypass that process\n\n\n\n\n\n\nWe can use nested for loops to work through individual values in a list of lists\nE.g. if we want to calculate the total sales over a week, (full code given in TablesOfSaleData.py)\n\n  total_sales = 0\n  for day_sales in week_sales:\n      for sales_value in day_sales:\n          total_sales = total_sales + sales_value\n\n  print(\"Total sales for the week are\", total_sales)\n\nTotal sales for the week are 5205\n\n\n\nday_sales in the outer loop iterates over each constituent list in the list of lists\nsales_value is then each value in the current list referenced by day_sales\n\n\n\n\nConsider the code for summing the sales data in the previous example. Answer the following questions to make sure you understand how it works\n\nHow many times will the statements inside the two loops be obeyed?\n\nIn total they will be run \\(70\\) times\nThe outer loop runs seven times (once for each day of the week)\nThe inner loop runs ten times (one for each stand)\n\nfor each iteration of the outer loop\n\n\nHow would you change this program so that it could handle more than one week’s worth of sales?\n\nWe can add more days to the list\nRather than have them correspond to Monday - Friday it might be Week 1 Day 1 etc.\nThese would be additional rows in the list of lists\n\nHow would we add a day’s worth of sales to the list?\n\nWe have to read in a new list of values\nCan then append it to the list of lists\n  read_sales(10) # read ten values into sales list\n  week_sales.append(sales) # append the values to the weekly sales list\n\n\n\n\n\n\n\nIt is possible to work with higher dimensions\nFor example we might want to store multiple weeks of data\n\nThen we would have a list of (list of (lists))s\n\nWorks just like two dimensions but with an extra index, for example we can append a week of sales like so,\n  annual_sales.append(week_sales)\n\n\n\n\n\n\n\nTip\n\n\n\nKeep your dimensions low\nYou should rarely have to use more than three dimensions. If you find yourself using highly nested / high-dimensional structures you might want to rethink how you’re representing your data\nOne technique we will see later is the use of classes, which can make it easier to create linear collections\nThe computer itself is perfectly happy working in higher dimensions. The real difficulty is that you probably aren’t and it can be hard to reason about high dimension data\n\n\n\n\n\n\n\nNow we have the ability to manipulate weekly sales data, the next question is how to display that data and the requests.\nWhen we enter the data we want to see something like,\n  Enter the Monday sales figures for stand 2:\nHere we need to have a variable to control what day is printed\n\nSimplest implementation is an integer to track the day, implemented in DayNameIf.py\n\n\n  # Example 8.22 Day Name If\n  #\n  # Uses a if, elif, else construction to convert an integer\n  # to a string representation of the day of the week\n\n  import time\n\n  current_time = time.localtime()\n  day_number = current_time.tm_wday\n\n  if day_number == 0:\n      day_name = \"Monday\"\n  elif day_number == 1:\n      day_name = \"Tuesday\"\n  elif day_number == 2:\n      day_name = \"Wednesday\"\n  elif day_number == 3:\n      day_name = \"Thursday\"\n  elif day_number == 4:\n      day_name = \"Friday\"\n  elif day_number == 5:\n      day_name = \"Saturday\"\n  elif day_number == 6:\n      day_name = \"Sunday\"\n  else:\n      raise ValueError(\"Unexpected day_number \" + str(day_number) + \" encountered\")\n\n  print(day_name)\n\nTuesday\n\n\nThis works, but is fragile, a cleaner way to do this is to use a lookup table\n\ni.e. we use day_number to index a list that stores the correct day\n\nWe use thetime library for fun so the program prints the current day\n\n  # Example 8.23 Day Name List\n  #\n  # Uses a lookup table to correctly print the day\n\n  import time\n\n  current_time = time.localtime()\n  day_number = current_time.tm_wday\n\n  day_names = [\n      \"Monday\",\n      \"Tuesday\",\n      \"Wednesday\",\n      \"Thursday\",\n      \"Friday\",\n      \"Saturday\",\n      \"Sunday\",\n  ]\n\n  day_name = day_names[day_number]\n\n  print(\"Today is\", day_name)\n\nToday is Tuesday\n\n\nLookup tables are powerful for shrinking written code\nThey also are used to create data-driven applications\n\nPrograms that use built-in or loaded data rather than fixed behaviour\n\n\n\n\n\n\nLists are the standard collection type\n\nThey are mutable, i.e. we can change the value of a given index or add new items\n\nConsider the day_names list, once defined we don’t want to change it\n\nWe would like to also prevent this, to catch potential programming errors e.g.\n  day_names[5] = \"Splatterday\"\n\nA tuple is like a list, but the contents cannot be changed\n\nA tuple is said to be immutable\nIf we attempt to change the tuple we get an error, (demonstrated in the implementation DayNameList.py)\n\nSpecifically a TypeError\nBecause the action we are trying to take (change the value at an index) is not supported by the object type (tuple)\n\n\n  # Example 8.24 Day Name Tuple\n  #\n  # Reimplements the Day Name lookup table with a tuple\n  # and demonstrates the immutability of the data structure\n\n  import time\n\n  current_time = time.localtime()\n  day_number = current_time.tm_wday\n\n  day_names = (\n      \"Monday\",\n      \"Tuesday\",\n      \"Wednesday\",\n      \"Thursday\",\n      \"Friday\",\n      \"Saturday\",\n      \"Sunday\",\n  )\n\n  day_name = day_names[day_number]\n\n  print(\"Today is\", day_name)\n\n  print(\"Attempting to change the lookup table...\")\n\n  day_names[day_number] = \"Splatterday\"  # type: ignore\n  print(\"Today is\", day_names[day_number])\n\nToday is Tuesday\nAttempting to change the lookup table...\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[25], line 27\n     23 print(\"Today is\", day_name)\n     25 print(\"Attempting to change the lookup table...\")\n---&gt; 27 day_names[day_number] = \"Splatterday\"  # type: ignore\n     28 print(\"Today is\", day_names[day_number])\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\n\nTuple is created as for a list but using () to delimit the items rather than []\nTuples are good for working with complicated values\n\ne.g. composite types\n\nFor Example, consider a pirates treasure map\n\nTreasure’s location is given by\n\nA reference landmark\nNumber of steps north\nNumber of steps east\n\n\nA function can strictly speaking return one value\n\nWe can return multiple values as a tuple\n\n  def get_treasure_location():\n      # get the treasures location\n      return (\"The old oak tree\", 20, 30)\n\nThis returns three values\n\nThe string \"The old oak tree\"\nThe number of steps north, 20\nThe number of steps east, 30\n\n\nLike lists, tuples are zero-indexed\n\n\n\n\n\n\n\nWarning\n\n\n\nTake care with your tuple indices\nWhen returning multiple items from a function via a tuple, we have to be clear to specify the order of what the items in the tuple correspond to. This is effectively a contract between the function and any caller (if you change the order, you will break the code of anyone who relies on the current order)\nThe order that parameters are returned in should thus be clearly documented, e.g.\ndef get_treasure_location():\n    \"\"\"\n    Gets the location of the treasure\n\n    Returns\n    -------\n    str\n        Name of a landmark to start at\n    int\n        Number of paces north\n    int\n        Number of paces east\n    \"\"\"\n\n    return (\"The old oak tree\", 20, 30)\n\n\n\nAn alternative to explicitly referencing the index of a returned tuple, is called tuple-unpacking\n\nWe provide a comma-seperated list of variables to assign the tuple values (in order) to, e.g.\n      landmark, north, east = get_treasure_location()\n  print(\"Start at\", landmark, \"walk\", north, \"paces north and\", east, \"paces east\")\n\nThe complete Pirate’s Treasure program implemention is given in PiratesTreasure.py",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 8: Storing Collections of Data"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/08_StoringCollectionsOfData/Chapter_08.html#summary",
    "href": "01_ProgrammingFundamentals/08_StoringCollectionsOfData/Chapter_08.html#summary",
    "title": "Chapter 8: Storing Collections of Data",
    "section": "Summary",
    "text": "Summary\n\nLists can be used to store large and arbitarily sized data\n\nWe refer to the individual elements of a list as items\nappend lets us add new elements to a list (at the end)\nlen returns the number of items in a list\nlists can contain different types of data in the same list\nlist values are accessed via the indexing operator []\n\nlists are indexed from \\(0\\)\nThe last index in a list is len(list) - 1\n\nNested lists allow for multi-dimensional structures\n\nFiles can be manipulated by python\n\nopen is used to access a file\nfiles can be read from or written to\nfor can be used to loop over lines from a file\nwhen using write to write to a file, newlines ('\\n') must be added exactly\nstrip can be used to remove whitespace when reading lines from a file\nFiles must be closed using the close method once they are no longer in use\nFiles can raise exceptions which must be handled or notified to the user\n\nThey must ensure the file is still closed\n\nwith can be used to automatically ensure a file is closed once it is no longer used, even in error scenarios\n\nTuples are immutable collections\n\nOnce they are defined we cannot modify or add values\nTuples are suitable for tuples or other fixed collections\nTuples can be used by functions that return more than one value",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 8: Storing Collections of Data"
    ]
  },
  {
    "objectID": "01_ProgrammingFundamentals/08_StoringCollectionsOfData/Chapter_08.html#questions-and-answers",
    "href": "01_ProgrammingFundamentals/08_StoringCollectionsOfData/Chapter_08.html#questions-and-answers",
    "title": "Chapter 8: Storing Collections of Data",
    "section": "Questions and Answers",
    "text": "Questions and Answers\n\nDo we really need lists?\n\nYes, any scenario with large or arbitrary data needs collections to meaningfully handle and manipulate them\n\nDo we really need tuples?\n\nNo, techically we could just use lists instead. They are useful though because they enforce properties that lists don’t such as immutability which is useful in some cases\n\nHow does the list actually work?\n\nWhen a list is created the program reserves memory to hold a few items\nThe memory also tracks the number of items currently stored in the list\nAppending an item consumes part of the allocated memory\nIf the list doesn’t have enough room, then more memory is allocated to the list\nWhen accessing a list item, the list checks if the item exists\n\nIf the item doesn’t exist, an exception is thrown\nelse, the item is found and returned\n\n\nWhy are tuples called tuples?\n\nTuples are ordered collections of elements in mathematics. Python adopted the terminology\n\nShould the sales program use a list to store the sales figures or a tuple?\n\nIt depends on the operations we want to peform\nOnce we have the list of sales figures, none of our operations strictly change the tuple (except sorting)\n\nCan implement sorting them as creating a new tuple\nProbably good to then use a tuple from a security perspective\nHowever, this makes the code more complicated\n\nIf we wanted to introduce an edit function later to modify sales data we might prefer a list for the clean implementation\n\nAs again opposed to the tuple approach\n\n\nCan functions return lists instead of tuples?\n\nYes, they can.\nHowever, typically the results of functions cannot be changed\n\nSo naturally a tuple\n\n\nWill my program run faster if I use tuples to store all the data in it?\n\nPotentially, tuples are faster to implement than lists\nDepends on what the program does, if you’re mutating a lot of data, the cost of constantly recreating multiple tuples might be greater than the cost of creating and modifying a list\nThe speed difference should hardly be noticable in any case\n\nDoes the with construction stop objects from throwing exceptions?\n\nNo, with is designed to ensure that even if an object throws an exception the managed resource is released correctly\nwith will still pass on the exception",
    "crumbs": [
      "Home",
      "Programming Fundamentals",
      "Chapter 8: Storing Collections of Data"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/09_UsingClasses/Chapter_09_ExtensionExercises.html",
    "href": "02_AdvancedProgramming/09_UsingClasses/Chapter_09_ExtensionExercises.html",
    "title": "Extended Exercises for Chapter 9",
    "section": "",
    "text": "Write a music track storage program that lets you search for tracks based on the length of the track. The program could suggest tracks that could be combined to fill an exact amount of time or give the total play time of a specific playlist.\nYou will have to create a class that can hold track information, store the information in a list and then create some behaviours that would search through and process the data\nThis is the most complicated application that we have built so far, and so it is best to both design and implement in stages. We’ll sketch the process and some of the functions out here, but the full program can be found in our implementation. First storyboard out the high level functionality we want.\n\n\nAt the highest level there are two functionalities we need from the given brief,\n1. Enter Tracks and manage tracks in a database\n2. Use these Tracks to build playlists\nIf we focus in on the first item, this is similar to our Tiny Contacts Program. We also have the feature that we want to be able to search for tracks based on their length. This leads to the following interface,\n1. Add a Track\n2. Edit a Track\n3. Remove a Track\n4. Sort Tracks by decreasing length\n5. Sort Tracks by increasing length\n6. Find Tracks by Name\n7. Find Tracks shorter than a given length\n8. Find Tracks longer than a  given length\n\nEnter a command:\nSince we want to be able to easily save, load and reconstruct the music track objects we’ll use pickle to implement saving and loading in the same way as for Tiny Contacts (i.e. on program start and exit)\nWe can then turn to our playlist interface. At some level this will look like the interface for adding tracks to the database. With some extra features such as a convenience function to remove all the tracks in a playlist. The two functions we were told that we had to add was\n\nTo be able to get the length of a given playlist, and,\nTo be able to generate a playlist of an exact length given the tracks in the database.\n\nIt would also be nice for the user to be able to save their playlist. We want this to be something human readable they could give to a friend, so we’ll simply output the track names to a text file.\nFor simplicity we’ll assume that the user can only work on one playlist at a time.\nOur interface would look like,\n1. Add Track to Playlist\n2. Remove Track from Playlist\n3. Clear Playlist\n4. Display Current Playlist\n5. Show Runtime of Current Playlist\n6. Suggest Playlist of Specified Length\n7. Save Current Playlist\n\n\n\nThe most immediate problem is that we have a lot of functionality, that would probably overwhelm the user. To get around this we will have a general main menu (as seen below) and sub-menus for\n\nModifying the track database\nDisplaying / Searching the Track database\nBuild Playlists\n\ndef run_main_menu():\n    \"\"\"Provides the user with a looping main menu\n\n    The user has the option to,\n    1. Manage Tracks\n    2. Find and Display Tracks\n    3. Manage a Playlist\n    4. Exit the program\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    ValueError\n        An invalid number is encountered in menu selection, should not\n        occur in live code, please raise a bug report if encountered\n\n    \"\"\"\n    main_menu = \"\"\"Music Storage\n\n1. Track Management\n2. Find and Display Tracks\n3. Playlist Management\n4. Exit Program\n\nEnter your command: \"\"\"\n    while True:\n        command = BTCInput.read_int_ranged(prompt=main_menu, min_value=1, max_value=4)\n        if command == 1:\n            run_track_menu()\n        elif command == 2:\n            run_display_track_menu()\n        elif command == 3:\n            run_playlist_management_menu()\n        elif command == 4:\n            try:\n                save_tracks(file_name)\n            except:  # noqa: E722\n                print(\"Tracks failed to save\")\n            break\n        else:\n            raise ValueError(\n                \"Unexpected command id found: \" + str(command) + \" in main menu\"\n            )\nThe sub-menu’s look similar (see below). The main menu lets us exit the program, while the sub-menu’s exit back to the main menu.\ndef run_display_track_menu():\n    \"\"\"\n    Provides the user with a looping menu to display tracks\n\n    The user has the option to\n    1. Display tracks matching a name\n    2. Display tracks less than (or equal to) a given max length\n    3. Display tracks greater than (or equal to) a given min length\n    4. Return to the Main Menu\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    ValueError\n        An invalid number is encountered in menu selection, should not\n        occur in live code, please raise a bug report if encountered\n    \"\"\"\n\n    display_track_menu = \"\"\"Find and Display Tracks\n\n1. Find Tracks by Name\n2. Find Tracks by length (Maximum length)\n3. Find Tracks by length (Minimum length)\n4. Back to Main Menu\n\nEnter your command: \"\"\"\n    while True:\n        command = BTCInput.read_int_ranged(\n            prompt=display_track_menu, min_value=1, max_value=4\n        )\n        if command == 1:\n            find_tracks_by_name()\n        elif command == 2:\n            find_tracks_shorter_than_length()\n        elif command == 3:\n            find_tracks_greater_than_length()\n        elif command == 4:\n            break\n        else:\n            raise ValueError(\n                \"Invalid command id \"\n                + str(command)\n                + \" found in track display sub-menu\"\n            )\n\n\n\nLet’s work through the sections step by step.\n\n\nFirst we need to define our Music Track objects. We use a simple class that stores a name and a track length. We use seconds for the length. We name the variables name and length_in_seconds to make them clear.\n\nclass MusicTrack:\n    \"\"\"\n    Music Track with a name and a length (in seconds)\n\n    Attributes\n    ----------\n    name : str\n        name of the music track\n    length_in_seconds : int\n        length of the track in seconds\n\n    Examples\n    --------\n    &gt;&gt;&gt; MusicTrack(\"Merry Christmas Everyone\", 220)\n    &lt;MusicTrack ...&gt;\n    \"\"\"\n\n    def __init__(self, name, length_in_seconds):\n        \"\"\"\n        Create a new `MusicTrack` instance\n\n        Parameters\n        ----------\n        name : str\n            name of the music track\n        length_in_seconds : int\n            length of the track in seconds (must be positive)\n\n        Raises\n        ------\n        ValueError\n                Raised if `length_in_seconds` is invalid\n        \"\"\"\n        self.name = name\n        if length_in_seconds &lt;= 0:\n            raise ValueError(\"Track length must be greater than zero\")\n        self.length_in_seconds = length_in_seconds\n\nOne immediate caveat is that a music track should not have a length that isn’t a positive integer. We enforce this by raising an exception if one is passed to the constructor.\nWe would also ideally like to take care of this at the user input level. It would be pretty frustrating to put in a number as a user then have the program crash. We would like to enforce that the user can put in any positive number, unfortunately BTCInput doesn’t provide this. We could simply put an upper bound on the track length, instead we roll our own input function.\ndef read_min_valued_integer(prompt, min_value):\n    \"\"\"\n    Displays a prompt and reads in a integer number greater\n    than or equal to `min_value`.\n\n    Keyboard interrupts (CTRL+C) are ignored\n    Invalid numbers are rejected\n    returns a number containing the value input by the user\n\n    Parameters\n    ----------\n    prompt : str\n        string to display to the user before the enter the number\n\n    min_value : int\n        minimum value (inclusive) to accept from the user\n\n    Returns\n    -------\n    int\n        integer &gt;= `min_value` entered by the user\n    \"\"\"\n    while True:\n        result = BTCInput.read_int(prompt)\n        if result &gt;= min_value:\n            return result\n        else:\n            print(\"That number is invalid\")\n            print(\"Number must be &gt;\", min_value)\nWe make this generic by calling it read_min_valued_integer and using a parameter to define a min_value. There is no bound on the max_value. We then use BTCInput.read_int and wrap it in the bound checking we need.\n\n\n\nWe can then define a function new_track to add tracks to the database,\ndef new_track():\n    \"\"\"\n    Creates and adds a new track to the track storage program\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    MusicTrack : class for storing music track information\n    \"\"\"\n    print(\"Add a new track\")\n    name = BTCInput.read_text(\"Enter the track name: \")\n    length = read_min_valued_integer(\n        \"Enter the track length (in seconds): \", min_value=1\n    )\n    tracks.append(MusicTrack(name=name, length_in_seconds=length))\n\nRunning the above with the input, (represented by red text), generates output like,\n\n\nprint(\"Enter the track name: \\033[31mMerry Christmas Everyone\\033[0m\")\nprint(\"Enter the track length (in seconds): \\033[31m220\\033[0m\")\nprint(tracks)\nprint(tracks[0].name)\nprint(tracks[0].length_in_seconds)\n\n\nEnter the track name: Merry Christmas Everyone\n\nEnter the track length (in seconds): 220\n\n[&lt;__main__.MusicTrack object at 0x7f7db44fc740&gt;]\n\nMerry Christmas Everyone\n\n220\n\n\n\n\n\n\n\nBefore we go further we need to implement a search by name functionality. We’ll adopt the following convention\n\nA filter_ function takes a search parameter, and a list of of MusicTrack objects to search through and returns a list of MusicTrack objects that meet the conditions\n\nBy adding the list parameter we can reuse these functions for the playlist functionality later\n\nA find_ function, prompts the user for the search parameter, calls the corresponding filter_ and displays the list\n\nThe first filter_ we implement is filter_by_name which uses the same logic as Tiny Contacts (a name is searched using startswith). See below,\n\ndef filter_tracks_by_name(search_name, tracks_to_search):\n    \"\"\"\n    Finds tracks matching a search name\n\n    Filters tracks from the list `tracks_to_search` with a name\n    containing `search_name` as a prefix\n\n    Parameters\n    ----------\n    search_name : str\n        name to search for (search uses prefix matching)\n\n    tracks_to_search : list[MusicTrack]\n        list of music tracks to search through\n\n    Returns\n    -------\n    list[MusicTrack]\n        list of contacts matching the name. If no matches\n        exist the list is empty\n\n    \"\"\"\n    search_name = search_name.strip().lower()  # normalise the search name\n    results = []\n    for track in tracks_to_search:\n        name = track.name.strip().lower()  # normalise track word\n        if name.startswith(search_name):\n            results.append(track)\n    return results\n\nRunning this for the track we just added,\n\n# looking for a match that exists\nresults = filter_tracks_by_name(\"Merry Christmas\", tracks)\n\nprint(results)\nprint(results[0].name)\nprint(results[0].length_in_seconds)\n\n# looking for non existent match\nprint(filter_tracks_by_name(\"Missing Track\", tracks))\n\n[&lt;__main__.MusicTrack object at 0x7f7db44fc740&gt;]\nMerry Christmas Everyone\n220\n[]\n\n\n\n\n\nWe can now implement the edit functionality with edit_tracks, using the same pattern we discussed before.\n\nWe find all the matches to a named search\nThe user is then prompted if they want to edit each match\nThe user can then edit each entry\n\ndef edit_tracks():\n    \"\"\"\n    Edits a user selected track\n\n    Reads in a name to search for and then allows the user to edit\n    the details of the Music Track\n\n    If there a no matching Music Tracks the function will indicate\n    that the name was not found. If multiple matches are found, the\n    user will have the option to edit each of them\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    filter_tracks_by_name : filters a list of tracks by a search name\n    \"\"\"\n    print(\"Edit Music Tracks\")\n    matched_tracks = filter_tracks_by_name(\n        BTCInput.read_text(\"Enter track name to edit: \"), tracks\n    )\n    print(\"Found\", len(matched_tracks), \"matches\")\n\n    for track in matched_tracks:\n        display_track(track)\n        if BTCInput.read_int_ranged(\n            \"Edit this track? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        ):\n            new_name = BTCInput.read_text(\"Enter new name or . to leave unchanged: \")\n            if new_name != \".\":\n                track.name = new_name\n            new_length_in_seconds = read_min_valued_integer(\n                \"Enter new length (in seconds) or 0 to leave unchanged: \", min_value=0\n            )\n            if new_length_in_seconds != 0:\n                track.length_in_seconds = new_length_in_seconds\nWe have to make one change to the pattern of the Tiny Contacts which is to account for the fact that length is a positive number. To do this we use 0 rather than \".\" to indicate that the variable should be left unchanged. An example use might look like,\n\nprint(\"Edit Music Tracks\")\nprint(\"Enter track name to edit: \\033[31mMerry Christmas Everyone\\033[0m\")\nprint(\"Found 1 matches\")\nprint(\"Merry Christmas Everyone (220 seconds)\")\nprint(\"Edit this track? (1 - Yes, 0 - No): \\033[31m1\\033[0m\")\nprint(\"Enter new name or . to leave unchanged: \\033[31m.\\033[0m\")\nprint(\"Enter new name or 0 to leave unchanged: \\033[31m210\\033[0m\")\n\nprint(tracks[0].name)\nprint(tracks[0].length_in_seconds)\n\n\nEdit Music Tracks\n\nEnter track name to edit: Merry Christmas Everyone\n\nFound 1 matches\n\nMerry Christmas Everyone (220 seconds)\n\nEdit this track? (1 - Yes, 0 - No): 1\n\nEnter new name or . to leave unchanged: .\n\nEnter new name or 0 to leave unchanged: 210\n\nMerry Christmas Everyone\n\n210\n\n\n\n\n\n\n\nThe remove_track follows the same pattern, instead of the edit dialog, we use the .remove method on a list to remove the matching track,\n    for track in matched_tracks:\n        display_track(track)\n        if BTCInput.read_int_ranged(\"Delete this track? (1 - Yes, 0 - No): \", 0, 1):\n            tracks.remove(track)\n\n\n\nThe next step is to implement sorting functionality. Based on the description we implement these sorts based on the length of the track. The ascending order search is then,\n\ndef sort_low_to_high(tracks_to_sort):\n    \"\"\"\n    Sorts tracks by increasing track length\n\n    Sorts the music track list given by `tracks_to_sort`\n    by length from shortest to greatest\n\n    Parameters\n    ----------\n    tracks_to_sort : list[MusicTrack]\n        list of tracks to sort\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    sort_high_to_low : sort tracks by decreasing track length\n    \"\"\"\n    print(\"Sort low to high\")\n    for sort_pass in range(0, len(tracks)):\n        done_swap = False\n        for count in range(0, len(tracks) - 1 - sort_pass):\n            if (\n                tracks_to_sort[count].length_in_seconds\n                &gt; tracks_to_sort[count + 1].length_in_seconds\n            ):\n                temp = tracks_to_sort[count]\n                tracks_to_sort[count] = tracks_to_sort[count + 1]\n                tracks_to_sort[count + 1] = temp\n                done_swap = True\n        if not done_swap:\n            break\n\nLet’s add another track Rockin Little Christmas, 157 seconds,\n\ntracks.append(MusicTrack(\"Rockin Little Christmas\", 157))\n\nprint(\"tracks[0]:\", tracks[0].name, tracks[0].length_in_seconds)\nprint(\"tracks[1]:\", tracks[1].name, tracks[1].length_in_seconds)\n\ntracks[0]: Merry Christmas Everyone 210\ntracks[1]: Rockin Little Christmas 157\n\n\nThen if we run the sort,\n\nsort_low_to_high(tracks)\nprint(\"tracks[0]:\", tracks[0].name, tracks[0].length_in_seconds)\nprint(\"tracks[1]:\", tracks[1].name, tracks[1].length_in_seconds)\n\nSort low to high\ntracks[0]: Rockin Little Christmas 157\ntracks[1]: Merry Christmas Everyone 210\n\n\nThe descending order search follows the same structure.\n\n\n\nThe only two track database management functions now are save and load, which are done simply via pickle.\ndef save_tracks(file_name):\n    \"\"\"\n    Saves the music tracks to the given file\n\n    Music tracks are stored in binary as a pickled file\n\n    Parameters\n    ----------\n    file_name : str\n        string giving the path to the file to store the track data in\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    An Exception is raised if the file could not be saved\n\n    See Also\n    --------\n    load_tracks : load music tracks from a pickled file\n    \"\"\"\n    print(\"Save music tracks\")\n    with open(file_name, \"wb\") as out_file:\n        pickle.dump(tracks, out_file)\n\n\ndef load_tracks(file_name):\n    \"\"\"\n    Loads the music tracks from the given file\n\n    Music Tracks are stored in binary as a pickled file\n\n    Parameters\n    ----------\n    file_name : str\n        string giving the path to the file where the recipes data is stored\n\n    Returns\n    -------\n    None\n        Music Tracks are loaded into the global `tracks` list\n\n    Raises\n    ------\n    An Exception is raised if the file could not be loaded\n\n    See Also\n    --------\n    save_tracks : save tracks as a pickled file\n    \"\"\"\n    global tracks  # connect to global track list to load into\n    print(\"Load contacts\")\n    with open(file_name, \"rb\") as input_file:\n        tracks = pickle.load(input_file)\nsave_tracks is called on program exit to write out the track database to a hard-coded database file. Similarly, load_tracks will attempt to read the database file on program start. If it can’t find the database file then a new blank database is generated\n\n\n\n\nWith our track database management up and running the next step is to look set up how we can display and search for the tracks in the database. The three functionalities we have to implement are,\n1. Find Tracks (by name)\n2. Find Tracks by length (Maximum length)\n3. Find Tracks by length (Minimum length)\nThe first one simply wraps the filter_tracks_by_name in a user prompt for a search name and displays the matches. This just leaves us to implement the display functionality.\n\n\nWe first define a function display_track to display a single track,\n\ndef display_track(track):\n    \"\"\"\n    Displays the name and length (in seconds) of a track\n\n    Params\n    ------\n    track : MusicTrack\n        track to display\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_tracks : display all tracks in a list\n    \"\"\"\n    print(\"Name:\", track.name, \"(\", track.length_in_seconds, \"seconds )\")\n\nWe can see how it used below,\n\ndisplay_track(tracks[0])\n\nName: Rockin Little Christmas ( 157 seconds )\n\n\nWe can then define a higher level function display_tracks that displays an entire list of tracks,\n\ndef display_tracks(tracks):\n    \"\"\"\n    Displays all the tracks in the provided list of tracks\n\n    Params\n    ------\n    list[MusicTrack]\n        List of MusicTrack objects to display\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_track : display a single track\n    \"\"\"\n    if len(tracks) &gt; 0:\n        for track in tracks:\n            display_track(track)\n    else:\n        print(\"No tracks found\")\n\nFor example, running on our small little example track list,\n\ndisplay_tracks(tracks)\n\nName: Rockin Little Christmas ( 157 seconds )\nName: Merry Christmas Everyone ( 210 seconds )\n\n\n\n\n\nLet us consider the problem of now finding tracks by a given length. We want two functions. One where we return all tracks with a length less than or equal to the provided length, and a second which returns all with a length greater than or equal to the provided length. Both have the same logic so we’ll only focus on the first case. As with filter_tracks_by_name we first define a filter function that takes in a maximum length as a parameter (and a search list) and returns a list of matches. This looks like,\n\ndef filter_tracks_shorter_than_length(max_length, tracks_to_filter):\n    \"\"\"\n    Filter a list of tracks to those shorter than a target length\n\n    Finds and returns a list of all tracks with a length\n    shorter (or equal to) `max_length` in the provided `tracks_to_filter`\n\n    Parameters\n    ----------\n    max_length : int\n        maximum (inclusive) length of tracks to include in\n        the filtered result\n\n    tracks_to_filter : list[MusicTrack]\n        list of tracks to filter\n\n    Returns\n    -------\n    list[MusicTrack]\n        List of MusicTracks satisfying\n        `MusicTrack.length_in_seconds &lt;= maximum length`.\n        If no MusicTracks are found an empty list is returned\n\n    See Also\n    --------\n    filter_tracks_greater_than_length : filters out tracks shorter than a given length\n    \"\"\"\n    tracks_shorter_than_max_length = []\n    for track in tracks_to_filter:\n        if track.length_in_seconds &lt;= max_length:\n            tracks_shorter_than_max_length.append(track)\n    return tracks_shorter_than_max_length\n\nTo see how this function works, lets run it on our test list, with three values, 220 which should catch everything, 200 which should catch one track, and 100 which should catch nothing.\n\nprint(\"Filter all the tracks...\")\ndisplay_tracks(filter_tracks_shorter_than_length(220, tracks))\nprint(\"Filter some of the tracks...\")\ndisplay_tracks(filter_tracks_shorter_than_length(200, tracks))\nprint(\"Filter none of the tracks\")\ndisplay_tracks(filter_tracks_shorter_than_length(100, tracks))\n\nFilter all the tracks...\nName: Rockin Little Christmas ( 157 seconds )\nName: Merry Christmas Everyone ( 210 seconds )\nFilter some of the tracks...\nName: Rockin Little Christmas ( 157 seconds )\nFilter none of the tracks\nNo tracks found\n\n\nWe can then define the find_tracks_shorter_than_length function, we prompts the user for the maximum time, passes this time and the tracks list through to the filter function and displays the results.\ndef find_tracks_shorter_than_length():\n    \"\"\"\n    Finds and displays all tracks shorter (or equal to) a user prompted\n    maximum length\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    filter_tracks_shorter_than_length : filters out tracks greater than a given length\n    \"\"\"\n    max_length = read_min_valued_integer(\n        \"Enter the maximum track length (in seconds): \", min_value=1\n    )\n    display_tracks(filter_tracks_shorter_than_length(max_length, tracks))\nThe case where we instead pass a minimum time is identical\n\n\n\n\nFor the most part, the playlist management repeats code that has already been seen before. We’ll only allow the user to work with one playlist at a time, and store the playlist as a list of MusicTrack objects. Recall that our interface is,\n1. Add Track to Playlist\n2. Remove Track from Playlist\n3. Clear Playlist\n4. Display Current Playlist\n5. Show Runtime of Current Playlist\n6. Suggest Playlist of Specified Length\n7. Save Current Playlist\n8. Back to Main Menu\nLet’s step through each of these and look at what needs new functionality\n\nadd_track_to_playlist - Uses existing filter_track_by_name to search for a user prompted track name. User is then prompted to optionally add matches to the playlist\nremove_tracks_from_playlist - Identical to remove_track but runs against the current playlist list\nclear_playlist - We use the list inbuilt method clear to clear the playlist\ndisplay_current_playlist - Achieved by passing the playlist list variable to the display_tracks function\ncalculate_playlist_length - No functionality yet implemented\nsuggest_playlist_of_given_length - No functionality yet implemented\nsave_playlist - Not yet implemented\n\nSo as we can see most of the functionality is already implemented. Let’s focus on the three remaining features, calculate_playlist_length, suggest_playlist_of_given_length and save_playlist\n\n\nImplementing calculate_playlist_length is pretty straightforward. We simply iterate over the tracks in the playlist and sum up their lengths\n\ndef calculate_playlist_length():\n    \"\"\"\n    Calculates and displays the total length of the\n    current playlist in seconds\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"Calculate length of playlist\")\n    total_length = 0\n    for track in playlist:\n        total_length = total_length + track.length_in_seconds\n    print(\"The playlist is\", total_length, \"seconds long\")\n\nFor example, if we use a little bit of magic to change our tracks list to the playlist, we can demonstrate the above function,\n\nplaylist = tracks\ncalculate_playlist_length()\n\nCalculate length of playlist\nThe playlist is 367 seconds long\n\n\n\n\n\nSimilarly, save_playlist can be implemented pretty easily using what we’ve seen. We prompt the user for the file that they want to save to, then write out the names of all of the tracks (one per line) using the standard try...except and with construct we’ve seen before\ndef save_playlist():\n    \"\"\"\n    Saves the current playlist as a human readable list\n\n    The user is prompted to give a file name to save the playlist in\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    Exceptions are raised if the save fails\n    \"\"\"\n    print(\"Save playlist\")\n    if len(playlist) == 0:\n        print(\"No playlist to save\")\n        return\n\n    file_name = BTCInput.read_text(\"Enter file to save playlist to: \")\n    try:\n        with open(file_name, \"w\") as output_file:\n            for track in playlist:\n                output_file.write(track.name + \"\\n\")\n    except:  # noqa: E722\n        print(\"Failed to save playlist\")\n\n\n\nObserve that the user always has to choose to save the playlist. This is because we implement it much more as form of printing out a list of songs to give to someone else rather than ensuring that a database is maintained. As a result we provide no behaviour for loading a playlist\nThe last function we want to implement is the ability to suggest a playlist of a given length. The original exercise suggests this as being to create a playlist of an exact length. Doing this requires us to solve what is called the Subset Sum Problem which is in general very difficult - we are asked to find a subset of the tracks in the database such that the sum of their lengths matches the target. Intuitively we should also recognise that given the granularity of song lengths for many lengths the user might put in, no exact solution exists.\nOur solution to this will be to instead ask the user for an upper bound on the playlist length. We will then randomly select songs such that the total length is less than this length. The user is then shown the proposed playlist and can either accept or reject it. If the reject it they can then ask the program to generate a new one. Once a playlist is accepted it can be edited using the other playlist management functions.\nOur implementation for this is below,\ndef suggest_playlist_of_given_length():\n    \"\"\"\n    Suggests a playlist of length less than or equal to\n    a user prompted length\n\n    Asks the user for a maximum playlist length, and\n    then suggests a playlist by combining tracks randomly\n    such that the suggested playlist is no greater than\n    the length\n\n    The user has the option to review the proposed list\n    and either accept, reject or regenerate the list\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"Suggest playlist of given length\")\n    global playlist\n\n    target_length = read_min_valued_integer(\n        \"Enter maximum playlist length: \", min_value=1\n    )\n\n    while True:\n        suggested_playlist = []\n        playlist_length = 0\n        # find tracks that could fit in the playlist\n        candidate_songs = filter_tracks_shorter_than_length(target_length, tracks)\n\n        if len(candidate_songs) == 0:\n            print(\"Could not generate a playlist of that length. Try a longer playlist\")\n            return\n\n        while len(candidate_songs) &gt; 0:  # stop when no more eligible songs\n            # add a random song and update the playlist length\n            song_choice = random.choice(candidate_songs)\n            suggested_playlist.append(song_choice)\n            playlist_length = playlist_length + song_choice.length_in_seconds\n\n            # filter out songs that no longer fit\n            candidate_songs = filter_tracks_shorter_than_length(\n                target_length - playlist_length, candidate_songs\n            )\n        print(\"Generated a playlist...\")\n        # let the user review the playlist\n        display_tracks(suggested_playlist)\n        if BTCInput.read_int_ranged(\n            \"Accept this playlist? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        ):\n            playlist = suggested_playlist\n            return\n        else:\n            if BTCInput.read_int_ranged(\n                \"Generate again? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n            ):\n                continue\n            return\nThe bulk of the logic however is given by (after getting target_length from the user),\n        candidate_songs = filter_tracks_shorter_than_length(target_length, tracks)\n\n        if len(candidate_songs) == 0:\n            print(\"Could not generate a playlist of that length. Try a longer playlist\")\n            return\n\n        while len(candidate_songs) &gt; 0:  # stop when no more eligible songs\n            # add a random song and update the playlist length\n            song_choice = random.choice(candidate_songs)\n            suggested_playlist.append(song_choice)\n            playlist_length = playlist_length + song_choice.length_in_seconds\n\n            # filter out songs that no longer fit\n            candidate_songs = filter_tracks_shorter_than_length(\n                target_length - playlist_length, candidate_songs\n            )\n\nWe filter the track database to get all the tracks that could fit in the allowed playlist time\nWe then randomly pick one of the songs using random.choice\n\nWe add this to our proposed playlist, and add its length to a counter tracking the total length\n\nWe then filter the candidate list again but with the amount of time we have yet to use (target_time - playlist_length)\nWe repeat steps 2-3 until there are no more candidate songs, this gives our final playlist which we can then propose to the user\n\nThis sums up the description of the music storage app. The provided code demonstrates a sample database in tracks.pickle and a sample playlist in example_playlist.txt. You are encouraged to play around with the code and make sure you understand what is going on. This program is not super complicated but it has many components, if you can follow it, you are doing well!",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 9: Use Classes to Store Data",
      "Extended Exercises for Chapter 9"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/09_UsingClasses/Chapter_09_ExtensionExercises.html#make-something-happen-music-storage-app",
    "href": "02_AdvancedProgramming/09_UsingClasses/Chapter_09_ExtensionExercises.html#make-something-happen-music-storage-app",
    "title": "Extended Exercises for Chapter 9",
    "section": "",
    "text": "Write a music track storage program that lets you search for tracks based on the length of the track. The program could suggest tracks that could be combined to fill an exact amount of time or give the total play time of a specific playlist.\nYou will have to create a class that can hold track information, store the information in a list and then create some behaviours that would search through and process the data\nThis is the most complicated application that we have built so far, and so it is best to both design and implement in stages. We’ll sketch the process and some of the functions out here, but the full program can be found in our implementation. First storyboard out the high level functionality we want.\n\n\nAt the highest level there are two functionalities we need from the given brief,\n1. Enter Tracks and manage tracks in a database\n2. Use these Tracks to build playlists\nIf we focus in on the first item, this is similar to our Tiny Contacts Program. We also have the feature that we want to be able to search for tracks based on their length. This leads to the following interface,\n1. Add a Track\n2. Edit a Track\n3. Remove a Track\n4. Sort Tracks by decreasing length\n5. Sort Tracks by increasing length\n6. Find Tracks by Name\n7. Find Tracks shorter than a given length\n8. Find Tracks longer than a  given length\n\nEnter a command:\nSince we want to be able to easily save, load and reconstruct the music track objects we’ll use pickle to implement saving and loading in the same way as for Tiny Contacts (i.e. on program start and exit)\nWe can then turn to our playlist interface. At some level this will look like the interface for adding tracks to the database. With some extra features such as a convenience function to remove all the tracks in a playlist. The two functions we were told that we had to add was\n\nTo be able to get the length of a given playlist, and,\nTo be able to generate a playlist of an exact length given the tracks in the database.\n\nIt would also be nice for the user to be able to save their playlist. We want this to be something human readable they could give to a friend, so we’ll simply output the track names to a text file.\nFor simplicity we’ll assume that the user can only work on one playlist at a time.\nOur interface would look like,\n1. Add Track to Playlist\n2. Remove Track from Playlist\n3. Clear Playlist\n4. Display Current Playlist\n5. Show Runtime of Current Playlist\n6. Suggest Playlist of Specified Length\n7. Save Current Playlist\n\n\n\nThe most immediate problem is that we have a lot of functionality, that would probably overwhelm the user. To get around this we will have a general main menu (as seen below) and sub-menus for\n\nModifying the track database\nDisplaying / Searching the Track database\nBuild Playlists\n\ndef run_main_menu():\n    \"\"\"Provides the user with a looping main menu\n\n    The user has the option to,\n    1. Manage Tracks\n    2. Find and Display Tracks\n    3. Manage a Playlist\n    4. Exit the program\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    ValueError\n        An invalid number is encountered in menu selection, should not\n        occur in live code, please raise a bug report if encountered\n\n    \"\"\"\n    main_menu = \"\"\"Music Storage\n\n1. Track Management\n2. Find and Display Tracks\n3. Playlist Management\n4. Exit Program\n\nEnter your command: \"\"\"\n    while True:\n        command = BTCInput.read_int_ranged(prompt=main_menu, min_value=1, max_value=4)\n        if command == 1:\n            run_track_menu()\n        elif command == 2:\n            run_display_track_menu()\n        elif command == 3:\n            run_playlist_management_menu()\n        elif command == 4:\n            try:\n                save_tracks(file_name)\n            except:  # noqa: E722\n                print(\"Tracks failed to save\")\n            break\n        else:\n            raise ValueError(\n                \"Unexpected command id found: \" + str(command) + \" in main menu\"\n            )\nThe sub-menu’s look similar (see below). The main menu lets us exit the program, while the sub-menu’s exit back to the main menu.\ndef run_display_track_menu():\n    \"\"\"\n    Provides the user with a looping menu to display tracks\n\n    The user has the option to\n    1. Display tracks matching a name\n    2. Display tracks less than (or equal to) a given max length\n    3. Display tracks greater than (or equal to) a given min length\n    4. Return to the Main Menu\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    ValueError\n        An invalid number is encountered in menu selection, should not\n        occur in live code, please raise a bug report if encountered\n    \"\"\"\n\n    display_track_menu = \"\"\"Find and Display Tracks\n\n1. Find Tracks by Name\n2. Find Tracks by length (Maximum length)\n3. Find Tracks by length (Minimum length)\n4. Back to Main Menu\n\nEnter your command: \"\"\"\n    while True:\n        command = BTCInput.read_int_ranged(\n            prompt=display_track_menu, min_value=1, max_value=4\n        )\n        if command == 1:\n            find_tracks_by_name()\n        elif command == 2:\n            find_tracks_shorter_than_length()\n        elif command == 3:\n            find_tracks_greater_than_length()\n        elif command == 4:\n            break\n        else:\n            raise ValueError(\n                \"Invalid command id \"\n                + str(command)\n                + \" found in track display sub-menu\"\n            )\n\n\n\nLet’s work through the sections step by step.\n\n\nFirst we need to define our Music Track objects. We use a simple class that stores a name and a track length. We use seconds for the length. We name the variables name and length_in_seconds to make them clear.\n\nclass MusicTrack:\n    \"\"\"\n    Music Track with a name and a length (in seconds)\n\n    Attributes\n    ----------\n    name : str\n        name of the music track\n    length_in_seconds : int\n        length of the track in seconds\n\n    Examples\n    --------\n    &gt;&gt;&gt; MusicTrack(\"Merry Christmas Everyone\", 220)\n    &lt;MusicTrack ...&gt;\n    \"\"\"\n\n    def __init__(self, name, length_in_seconds):\n        \"\"\"\n        Create a new `MusicTrack` instance\n\n        Parameters\n        ----------\n        name : str\n            name of the music track\n        length_in_seconds : int\n            length of the track in seconds (must be positive)\n\n        Raises\n        ------\n        ValueError\n                Raised if `length_in_seconds` is invalid\n        \"\"\"\n        self.name = name\n        if length_in_seconds &lt;= 0:\n            raise ValueError(\"Track length must be greater than zero\")\n        self.length_in_seconds = length_in_seconds\n\nOne immediate caveat is that a music track should not have a length that isn’t a positive integer. We enforce this by raising an exception if one is passed to the constructor.\nWe would also ideally like to take care of this at the user input level. It would be pretty frustrating to put in a number as a user then have the program crash. We would like to enforce that the user can put in any positive number, unfortunately BTCInput doesn’t provide this. We could simply put an upper bound on the track length, instead we roll our own input function.\ndef read_min_valued_integer(prompt, min_value):\n    \"\"\"\n    Displays a prompt and reads in a integer number greater\n    than or equal to `min_value`.\n\n    Keyboard interrupts (CTRL+C) are ignored\n    Invalid numbers are rejected\n    returns a number containing the value input by the user\n\n    Parameters\n    ----------\n    prompt : str\n        string to display to the user before the enter the number\n\n    min_value : int\n        minimum value (inclusive) to accept from the user\n\n    Returns\n    -------\n    int\n        integer &gt;= `min_value` entered by the user\n    \"\"\"\n    while True:\n        result = BTCInput.read_int(prompt)\n        if result &gt;= min_value:\n            return result\n        else:\n            print(\"That number is invalid\")\n            print(\"Number must be &gt;\", min_value)\nWe make this generic by calling it read_min_valued_integer and using a parameter to define a min_value. There is no bound on the max_value. We then use BTCInput.read_int and wrap it in the bound checking we need.\n\n\n\nWe can then define a function new_track to add tracks to the database,\ndef new_track():\n    \"\"\"\n    Creates and adds a new track to the track storage program\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    MusicTrack : class for storing music track information\n    \"\"\"\n    print(\"Add a new track\")\n    name = BTCInput.read_text(\"Enter the track name: \")\n    length = read_min_valued_integer(\n        \"Enter the track length (in seconds): \", min_value=1\n    )\n    tracks.append(MusicTrack(name=name, length_in_seconds=length))\n\nRunning the above with the input, (represented by red text), generates output like,\n\n\nprint(\"Enter the track name: \\033[31mMerry Christmas Everyone\\033[0m\")\nprint(\"Enter the track length (in seconds): \\033[31m220\\033[0m\")\nprint(tracks)\nprint(tracks[0].name)\nprint(tracks[0].length_in_seconds)\n\n\nEnter the track name: Merry Christmas Everyone\n\nEnter the track length (in seconds): 220\n\n[&lt;__main__.MusicTrack object at 0x7f7db44fc740&gt;]\n\nMerry Christmas Everyone\n\n220\n\n\n\n\n\n\n\nBefore we go further we need to implement a search by name functionality. We’ll adopt the following convention\n\nA filter_ function takes a search parameter, and a list of of MusicTrack objects to search through and returns a list of MusicTrack objects that meet the conditions\n\nBy adding the list parameter we can reuse these functions for the playlist functionality later\n\nA find_ function, prompts the user for the search parameter, calls the corresponding filter_ and displays the list\n\nThe first filter_ we implement is filter_by_name which uses the same logic as Tiny Contacts (a name is searched using startswith). See below,\n\ndef filter_tracks_by_name(search_name, tracks_to_search):\n    \"\"\"\n    Finds tracks matching a search name\n\n    Filters tracks from the list `tracks_to_search` with a name\n    containing `search_name` as a prefix\n\n    Parameters\n    ----------\n    search_name : str\n        name to search for (search uses prefix matching)\n\n    tracks_to_search : list[MusicTrack]\n        list of music tracks to search through\n\n    Returns\n    -------\n    list[MusicTrack]\n        list of contacts matching the name. If no matches\n        exist the list is empty\n\n    \"\"\"\n    search_name = search_name.strip().lower()  # normalise the search name\n    results = []\n    for track in tracks_to_search:\n        name = track.name.strip().lower()  # normalise track word\n        if name.startswith(search_name):\n            results.append(track)\n    return results\n\nRunning this for the track we just added,\n\n# looking for a match that exists\nresults = filter_tracks_by_name(\"Merry Christmas\", tracks)\n\nprint(results)\nprint(results[0].name)\nprint(results[0].length_in_seconds)\n\n# looking for non existent match\nprint(filter_tracks_by_name(\"Missing Track\", tracks))\n\n[&lt;__main__.MusicTrack object at 0x7f7db44fc740&gt;]\nMerry Christmas Everyone\n220\n[]\n\n\n\n\n\nWe can now implement the edit functionality with edit_tracks, using the same pattern we discussed before.\n\nWe find all the matches to a named search\nThe user is then prompted if they want to edit each match\nThe user can then edit each entry\n\ndef edit_tracks():\n    \"\"\"\n    Edits a user selected track\n\n    Reads in a name to search for and then allows the user to edit\n    the details of the Music Track\n\n    If there a no matching Music Tracks the function will indicate\n    that the name was not found. If multiple matches are found, the\n    user will have the option to edit each of them\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    filter_tracks_by_name : filters a list of tracks by a search name\n    \"\"\"\n    print(\"Edit Music Tracks\")\n    matched_tracks = filter_tracks_by_name(\n        BTCInput.read_text(\"Enter track name to edit: \"), tracks\n    )\n    print(\"Found\", len(matched_tracks), \"matches\")\n\n    for track in matched_tracks:\n        display_track(track)\n        if BTCInput.read_int_ranged(\n            \"Edit this track? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        ):\n            new_name = BTCInput.read_text(\"Enter new name or . to leave unchanged: \")\n            if new_name != \".\":\n                track.name = new_name\n            new_length_in_seconds = read_min_valued_integer(\n                \"Enter new length (in seconds) or 0 to leave unchanged: \", min_value=0\n            )\n            if new_length_in_seconds != 0:\n                track.length_in_seconds = new_length_in_seconds\nWe have to make one change to the pattern of the Tiny Contacts which is to account for the fact that length is a positive number. To do this we use 0 rather than \".\" to indicate that the variable should be left unchanged. An example use might look like,\n\nprint(\"Edit Music Tracks\")\nprint(\"Enter track name to edit: \\033[31mMerry Christmas Everyone\\033[0m\")\nprint(\"Found 1 matches\")\nprint(\"Merry Christmas Everyone (220 seconds)\")\nprint(\"Edit this track? (1 - Yes, 0 - No): \\033[31m1\\033[0m\")\nprint(\"Enter new name or . to leave unchanged: \\033[31m.\\033[0m\")\nprint(\"Enter new name or 0 to leave unchanged: \\033[31m210\\033[0m\")\n\nprint(tracks[0].name)\nprint(tracks[0].length_in_seconds)\n\n\nEdit Music Tracks\n\nEnter track name to edit: Merry Christmas Everyone\n\nFound 1 matches\n\nMerry Christmas Everyone (220 seconds)\n\nEdit this track? (1 - Yes, 0 - No): 1\n\nEnter new name or . to leave unchanged: .\n\nEnter new name or 0 to leave unchanged: 210\n\nMerry Christmas Everyone\n\n210\n\n\n\n\n\n\n\nThe remove_track follows the same pattern, instead of the edit dialog, we use the .remove method on a list to remove the matching track,\n    for track in matched_tracks:\n        display_track(track)\n        if BTCInput.read_int_ranged(\"Delete this track? (1 - Yes, 0 - No): \", 0, 1):\n            tracks.remove(track)\n\n\n\nThe next step is to implement sorting functionality. Based on the description we implement these sorts based on the length of the track. The ascending order search is then,\n\ndef sort_low_to_high(tracks_to_sort):\n    \"\"\"\n    Sorts tracks by increasing track length\n\n    Sorts the music track list given by `tracks_to_sort`\n    by length from shortest to greatest\n\n    Parameters\n    ----------\n    tracks_to_sort : list[MusicTrack]\n        list of tracks to sort\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    sort_high_to_low : sort tracks by decreasing track length\n    \"\"\"\n    print(\"Sort low to high\")\n    for sort_pass in range(0, len(tracks)):\n        done_swap = False\n        for count in range(0, len(tracks) - 1 - sort_pass):\n            if (\n                tracks_to_sort[count].length_in_seconds\n                &gt; tracks_to_sort[count + 1].length_in_seconds\n            ):\n                temp = tracks_to_sort[count]\n                tracks_to_sort[count] = tracks_to_sort[count + 1]\n                tracks_to_sort[count + 1] = temp\n                done_swap = True\n        if not done_swap:\n            break\n\nLet’s add another track Rockin Little Christmas, 157 seconds,\n\ntracks.append(MusicTrack(\"Rockin Little Christmas\", 157))\n\nprint(\"tracks[0]:\", tracks[0].name, tracks[0].length_in_seconds)\nprint(\"tracks[1]:\", tracks[1].name, tracks[1].length_in_seconds)\n\ntracks[0]: Merry Christmas Everyone 210\ntracks[1]: Rockin Little Christmas 157\n\n\nThen if we run the sort,\n\nsort_low_to_high(tracks)\nprint(\"tracks[0]:\", tracks[0].name, tracks[0].length_in_seconds)\nprint(\"tracks[1]:\", tracks[1].name, tracks[1].length_in_seconds)\n\nSort low to high\ntracks[0]: Rockin Little Christmas 157\ntracks[1]: Merry Christmas Everyone 210\n\n\nThe descending order search follows the same structure.\n\n\n\nThe only two track database management functions now are save and load, which are done simply via pickle.\ndef save_tracks(file_name):\n    \"\"\"\n    Saves the music tracks to the given file\n\n    Music tracks are stored in binary as a pickled file\n\n    Parameters\n    ----------\n    file_name : str\n        string giving the path to the file to store the track data in\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    An Exception is raised if the file could not be saved\n\n    See Also\n    --------\n    load_tracks : load music tracks from a pickled file\n    \"\"\"\n    print(\"Save music tracks\")\n    with open(file_name, \"wb\") as out_file:\n        pickle.dump(tracks, out_file)\n\n\ndef load_tracks(file_name):\n    \"\"\"\n    Loads the music tracks from the given file\n\n    Music Tracks are stored in binary as a pickled file\n\n    Parameters\n    ----------\n    file_name : str\n        string giving the path to the file where the recipes data is stored\n\n    Returns\n    -------\n    None\n        Music Tracks are loaded into the global `tracks` list\n\n    Raises\n    ------\n    An Exception is raised if the file could not be loaded\n\n    See Also\n    --------\n    save_tracks : save tracks as a pickled file\n    \"\"\"\n    global tracks  # connect to global track list to load into\n    print(\"Load contacts\")\n    with open(file_name, \"rb\") as input_file:\n        tracks = pickle.load(input_file)\nsave_tracks is called on program exit to write out the track database to a hard-coded database file. Similarly, load_tracks will attempt to read the database file on program start. If it can’t find the database file then a new blank database is generated\n\n\n\n\nWith our track database management up and running the next step is to look set up how we can display and search for the tracks in the database. The three functionalities we have to implement are,\n1. Find Tracks (by name)\n2. Find Tracks by length (Maximum length)\n3. Find Tracks by length (Minimum length)\nThe first one simply wraps the filter_tracks_by_name in a user prompt for a search name and displays the matches. This just leaves us to implement the display functionality.\n\n\nWe first define a function display_track to display a single track,\n\ndef display_track(track):\n    \"\"\"\n    Displays the name and length (in seconds) of a track\n\n    Params\n    ------\n    track : MusicTrack\n        track to display\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_tracks : display all tracks in a list\n    \"\"\"\n    print(\"Name:\", track.name, \"(\", track.length_in_seconds, \"seconds )\")\n\nWe can see how it used below,\n\ndisplay_track(tracks[0])\n\nName: Rockin Little Christmas ( 157 seconds )\n\n\nWe can then define a higher level function display_tracks that displays an entire list of tracks,\n\ndef display_tracks(tracks):\n    \"\"\"\n    Displays all the tracks in the provided list of tracks\n\n    Params\n    ------\n    list[MusicTrack]\n        List of MusicTrack objects to display\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    display_track : display a single track\n    \"\"\"\n    if len(tracks) &gt; 0:\n        for track in tracks:\n            display_track(track)\n    else:\n        print(\"No tracks found\")\n\nFor example, running on our small little example track list,\n\ndisplay_tracks(tracks)\n\nName: Rockin Little Christmas ( 157 seconds )\nName: Merry Christmas Everyone ( 210 seconds )\n\n\n\n\n\nLet us consider the problem of now finding tracks by a given length. We want two functions. One where we return all tracks with a length less than or equal to the provided length, and a second which returns all with a length greater than or equal to the provided length. Both have the same logic so we’ll only focus on the first case. As with filter_tracks_by_name we first define a filter function that takes in a maximum length as a parameter (and a search list) and returns a list of matches. This looks like,\n\ndef filter_tracks_shorter_than_length(max_length, tracks_to_filter):\n    \"\"\"\n    Filter a list of tracks to those shorter than a target length\n\n    Finds and returns a list of all tracks with a length\n    shorter (or equal to) `max_length` in the provided `tracks_to_filter`\n\n    Parameters\n    ----------\n    max_length : int\n        maximum (inclusive) length of tracks to include in\n        the filtered result\n\n    tracks_to_filter : list[MusicTrack]\n        list of tracks to filter\n\n    Returns\n    -------\n    list[MusicTrack]\n        List of MusicTracks satisfying\n        `MusicTrack.length_in_seconds &lt;= maximum length`.\n        If no MusicTracks are found an empty list is returned\n\n    See Also\n    --------\n    filter_tracks_greater_than_length : filters out tracks shorter than a given length\n    \"\"\"\n    tracks_shorter_than_max_length = []\n    for track in tracks_to_filter:\n        if track.length_in_seconds &lt;= max_length:\n            tracks_shorter_than_max_length.append(track)\n    return tracks_shorter_than_max_length\n\nTo see how this function works, lets run it on our test list, with three values, 220 which should catch everything, 200 which should catch one track, and 100 which should catch nothing.\n\nprint(\"Filter all the tracks...\")\ndisplay_tracks(filter_tracks_shorter_than_length(220, tracks))\nprint(\"Filter some of the tracks...\")\ndisplay_tracks(filter_tracks_shorter_than_length(200, tracks))\nprint(\"Filter none of the tracks\")\ndisplay_tracks(filter_tracks_shorter_than_length(100, tracks))\n\nFilter all the tracks...\nName: Rockin Little Christmas ( 157 seconds )\nName: Merry Christmas Everyone ( 210 seconds )\nFilter some of the tracks...\nName: Rockin Little Christmas ( 157 seconds )\nFilter none of the tracks\nNo tracks found\n\n\nWe can then define the find_tracks_shorter_than_length function, we prompts the user for the maximum time, passes this time and the tracks list through to the filter function and displays the results.\ndef find_tracks_shorter_than_length():\n    \"\"\"\n    Finds and displays all tracks shorter (or equal to) a user prompted\n    maximum length\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    filter_tracks_shorter_than_length : filters out tracks greater than a given length\n    \"\"\"\n    max_length = read_min_valued_integer(\n        \"Enter the maximum track length (in seconds): \", min_value=1\n    )\n    display_tracks(filter_tracks_shorter_than_length(max_length, tracks))\nThe case where we instead pass a minimum time is identical\n\n\n\n\nFor the most part, the playlist management repeats code that has already been seen before. We’ll only allow the user to work with one playlist at a time, and store the playlist as a list of MusicTrack objects. Recall that our interface is,\n1. Add Track to Playlist\n2. Remove Track from Playlist\n3. Clear Playlist\n4. Display Current Playlist\n5. Show Runtime of Current Playlist\n6. Suggest Playlist of Specified Length\n7. Save Current Playlist\n8. Back to Main Menu\nLet’s step through each of these and look at what needs new functionality\n\nadd_track_to_playlist - Uses existing filter_track_by_name to search for a user prompted track name. User is then prompted to optionally add matches to the playlist\nremove_tracks_from_playlist - Identical to remove_track but runs against the current playlist list\nclear_playlist - We use the list inbuilt method clear to clear the playlist\ndisplay_current_playlist - Achieved by passing the playlist list variable to the display_tracks function\ncalculate_playlist_length - No functionality yet implemented\nsuggest_playlist_of_given_length - No functionality yet implemented\nsave_playlist - Not yet implemented\n\nSo as we can see most of the functionality is already implemented. Let’s focus on the three remaining features, calculate_playlist_length, suggest_playlist_of_given_length and save_playlist\n\n\nImplementing calculate_playlist_length is pretty straightforward. We simply iterate over the tracks in the playlist and sum up their lengths\n\ndef calculate_playlist_length():\n    \"\"\"\n    Calculates and displays the total length of the\n    current playlist in seconds\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"Calculate length of playlist\")\n    total_length = 0\n    for track in playlist:\n        total_length = total_length + track.length_in_seconds\n    print(\"The playlist is\", total_length, \"seconds long\")\n\nFor example, if we use a little bit of magic to change our tracks list to the playlist, we can demonstrate the above function,\n\nplaylist = tracks\ncalculate_playlist_length()\n\nCalculate length of playlist\nThe playlist is 367 seconds long\n\n\n\n\n\nSimilarly, save_playlist can be implemented pretty easily using what we’ve seen. We prompt the user for the file that they want to save to, then write out the names of all of the tracks (one per line) using the standard try...except and with construct we’ve seen before\ndef save_playlist():\n    \"\"\"\n    Saves the current playlist as a human readable list\n\n    The user is prompted to give a file name to save the playlist in\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    Exceptions are raised if the save fails\n    \"\"\"\n    print(\"Save playlist\")\n    if len(playlist) == 0:\n        print(\"No playlist to save\")\n        return\n\n    file_name = BTCInput.read_text(\"Enter file to save playlist to: \")\n    try:\n        with open(file_name, \"w\") as output_file:\n            for track in playlist:\n                output_file.write(track.name + \"\\n\")\n    except:  # noqa: E722\n        print(\"Failed to save playlist\")\n\n\n\nObserve that the user always has to choose to save the playlist. This is because we implement it much more as form of printing out a list of songs to give to someone else rather than ensuring that a database is maintained. As a result we provide no behaviour for loading a playlist\nThe last function we want to implement is the ability to suggest a playlist of a given length. The original exercise suggests this as being to create a playlist of an exact length. Doing this requires us to solve what is called the Subset Sum Problem which is in general very difficult - we are asked to find a subset of the tracks in the database such that the sum of their lengths matches the target. Intuitively we should also recognise that given the granularity of song lengths for many lengths the user might put in, no exact solution exists.\nOur solution to this will be to instead ask the user for an upper bound on the playlist length. We will then randomly select songs such that the total length is less than this length. The user is then shown the proposed playlist and can either accept or reject it. If the reject it they can then ask the program to generate a new one. Once a playlist is accepted it can be edited using the other playlist management functions.\nOur implementation for this is below,\ndef suggest_playlist_of_given_length():\n    \"\"\"\n    Suggests a playlist of length less than or equal to\n    a user prompted length\n\n    Asks the user for a maximum playlist length, and\n    then suggests a playlist by combining tracks randomly\n    such that the suggested playlist is no greater than\n    the length\n\n    The user has the option to review the proposed list\n    and either accept, reject or regenerate the list\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"Suggest playlist of given length\")\n    global playlist\n\n    target_length = read_min_valued_integer(\n        \"Enter maximum playlist length: \", min_value=1\n    )\n\n    while True:\n        suggested_playlist = []\n        playlist_length = 0\n        # find tracks that could fit in the playlist\n        candidate_songs = filter_tracks_shorter_than_length(target_length, tracks)\n\n        if len(candidate_songs) == 0:\n            print(\"Could not generate a playlist of that length. Try a longer playlist\")\n            return\n\n        while len(candidate_songs) &gt; 0:  # stop when no more eligible songs\n            # add a random song and update the playlist length\n            song_choice = random.choice(candidate_songs)\n            suggested_playlist.append(song_choice)\n            playlist_length = playlist_length + song_choice.length_in_seconds\n\n            # filter out songs that no longer fit\n            candidate_songs = filter_tracks_shorter_than_length(\n                target_length - playlist_length, candidate_songs\n            )\n        print(\"Generated a playlist...\")\n        # let the user review the playlist\n        display_tracks(suggested_playlist)\n        if BTCInput.read_int_ranged(\n            \"Accept this playlist? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        ):\n            playlist = suggested_playlist\n            return\n        else:\n            if BTCInput.read_int_ranged(\n                \"Generate again? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n            ):\n                continue\n            return\nThe bulk of the logic however is given by (after getting target_length from the user),\n        candidate_songs = filter_tracks_shorter_than_length(target_length, tracks)\n\n        if len(candidate_songs) == 0:\n            print(\"Could not generate a playlist of that length. Try a longer playlist\")\n            return\n\n        while len(candidate_songs) &gt; 0:  # stop when no more eligible songs\n            # add a random song and update the playlist length\n            song_choice = random.choice(candidate_songs)\n            suggested_playlist.append(song_choice)\n            playlist_length = playlist_length + song_choice.length_in_seconds\n\n            # filter out songs that no longer fit\n            candidate_songs = filter_tracks_shorter_than_length(\n                target_length - playlist_length, candidate_songs\n            )\n\nWe filter the track database to get all the tracks that could fit in the allowed playlist time\nWe then randomly pick one of the songs using random.choice\n\nWe add this to our proposed playlist, and add its length to a counter tracking the total length\n\nWe then filter the candidate list again but with the amount of time we have yet to use (target_time - playlist_length)\nWe repeat steps 2-3 until there are no more candidate songs, this gives our final playlist which we can then propose to the user\n\nThis sums up the description of the music storage app. The provided code demonstrates a sample database in tracks.pickle and a sample playlist in example_playlist.txt. You are encouraged to play around with the code and make sure you understand what is going on. This program is not super complicated but it has many components, if you can follow it, you are doing well!",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 9: Use Classes to Store Data",
      "Extended Exercises for Chapter 9"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/09_UsingClasses/Chapter_09_ExtensionExercises.html#make-something-happen-recipe-storage-app",
    "href": "02_AdvancedProgramming/09_UsingClasses/Chapter_09_ExtensionExercises.html#make-something-happen-recipe-storage-app",
    "title": "Extended Exercises for Chapter 9",
    "section": "Make Something Happen: Recipe Storage App",
    "text": "Make Something Happen: Recipe Storage App\nMake a recipe storage app that stores lists of ingredients and preparation details. Remember that one of the items in a class could be a list of strings, which could be the steps performed to prepare the recipe\nThis program will have less individual features than our music storage program, however the object we’re working on will be complex so it’s worth also working through this exercise.\n\nStoryboarding out the design\nLet us start by setting out some design specifications,\n\nThe user should be able to add recipes\nThe user should be able to search for recipes\n\nSearch for a recipe by name\nSearch for recipes with a given ingredient\n\nThe user should be able to view a list of ingredients in a recipe\nThe user should be able to view a recipe’s steps\n\nAll steps displayed at once\nDisplayed step by step\n\nThe user should be able to edit a given recipe\n\nEdit ingredients (including remove them)\nEdit steps including remove them\n\nThe user should be able to delete a recipe\n\n\n\nDesigning the Recipe Class\nFrom this let’s design our recipe specification. A recipe at it’s most basic is a list of ingredients and a list of steps. However, if I look at the recipes that I have at home, quite often ingredients are often listed both with a quantity and some description of how they should be prepared. For example a recipe might specify\n\n2 spring onions (scallions), finely sliced\n\nWe would like to store this extra information. A natural way to do it would then be to use a dictionary, storing the ingredients as keys, and the description as the value, i.e.\n\ningredients = {\"spring onions\" : \"2, finely sliced\"}\n\nThis also means that the user could quickly get a list of ingredients for a recipe just by printing the dictionary. We can also easily search for recipes with a given ingredient by using,\nif ingredient in ingredients\nHowever, this comes with the downside that the user would need to specify the exact ingredient to search, i.e. we would have, for the previous example,\n\nprint(\"spring onions\" in ingredients)\nprint(\"Spring Onions\" in ingredients)\nprint(\"scallions\" in ingredients)\n\nTrue\nFalse\nFalse\n\n\nA user might certainly expect that all these match. The problem is worse when we consider for example an ingredient like\n\nsmall chicken thighs\n\nOne user might enter this as (in the dictionary notation),\ningredients = {\"chicken\" : \"thighs, small\"}\nwhile another might instead use,\ningredients = {\"chicken thighs\" : \"small\"}\nIf the first user was to search \"chicken\" on a recipe entered by the second user, they would not find what they expected!\nFor the purposes of this exercise to get familiarity working with dictionaries, we’ll simply note these challenges and continue.\nThe second problem to consider is duplicate keys. In the recipes I read it is quite common for recipes to be broken down into subcomponents, each of which may use the same ingredient. This results in an ingredient being listed multiple times. The way to resolve this is to store the ingredient description as a list of strings rather than just one string. For example if a recipe specified,\n\nblack pepper, to serve black pepper, 1/4 teaspoon ground\n\nThe resulting dictionary entry would look like,\ningredients = {\"black pepper\" : [\"to serve\", \"1/4 teaspoon ground\"]}\nThe next part of the recipe is the steps themselves. This can simply be treated as an ordered list of strings, so we just store them in a list. Finally a recipe should have a name. This leaves our Recipe object looking like,\n\nclass Recipe:\n    \"\"\"\n    Represent a cooking recipe.\n\n    Attributes\n    ----------\n    name : str\n        Recipe name\n\n    ingredients : dict[str, list[str]]\n        Ingredients required for the recipe. Ingredients are stored\n        as a dictionary in the format `ingredients[ingredient] = [\"description\", ...]`\n\n    steps: list[str]\n        Ordered list of instructions/steps to prepare the recipe.\n\n    Example\n    -------\n    &gt;&gt;&gt; Recipe(\"Omelette\", {\"eggs\" : [2], \"milk\": [\"1 cup\"]}, [\"Beat eggs\", \"Add milk\", \"Cook on pan\"])\n    \"\"\"\n\n    def __init__(self, name, ingredients, steps):\n        \"\"\"\n        Create a new `Recipe` instance\n\n        Parameters\n        ----------\n        name : str\n            Name of the Recipe\n        ingredients : dict[str, list[str]]\n            Ingredients required for the recipe. Ingredients are stored\n            as a dictionary in the format `ingredients[ingredient] = [\"description\", ...]`\n            e.g. `ingredients[\"Brown Onion\"] = [\"1 Medium, diced\"]`\n        steps : list[str]\n            Ordered list of instructions/steps to prepare the recipe.\n        \"\"\"\n        self.name = name\n        self.ingredients = ingredients\n        self.steps = steps\n\n\nCreating a Recipe from User Input\nWe wrap the construction of these objects in a function add_recipe to get input from the user,\ndef new_recipe():\n    \"\"\"\n    Add a new recipe to the recipe database.\n\n    A recipe consists of a name, dictionary of ingredients and a list of steps\n    The user is prompted for the name, ingredients and the steps\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    Recipe : Class responsible for storing recipe information\n    \"\"\"\n    print(\"Add New Recipe\")\n    name = BTCInput.read_text(\"Enter the recipe name: \")\n\n    print(\"Enter ingredients\")\n    ingredients = get_ingredients()\n    print(\"Enter Steps\")\n    steps = get_steps()\n    recipe = Recipe(name, ingredients, steps)\n    recipes.append(recipe)\nThis code should look pretty similar to what we’ve seen before except for the fact that we refer to an unspecified get_ingredients and get_steps. These functions both read ingredients or steps one at a time from the user to construct the appropriate dictionary (or list) for the Recipe object. Both are similar, so we’ll look at the more complicated get_ingredients to understand the idea,\ndef get_ingredients():\n    \"\"\"\n    Gets a dictionary of ingredients from the user.\n\n    Ingredients are processed\n    as key, value pairs of ingredients and descriptions such as their quantity\n    or how they are to be prepared.\n\n    Supports duplicates for an ingredient. If a duplicate is detected the\n    user will be prompted if they wish to overwrite the existing key, value\n    pair, add the description to the pair or ignore the current entry\n\n    Returns\n    -------\n    dict[str, list[str]]\n        Dictionary of Ingredient, description pairs. The dictionary is\n        keyed by ingredients and the descriptions are stored as a list\n        of strings\n\n    Raises\n    ------\n    ValueError\n        An invalid number is encountered in menu selection, should not\n        occur in live code, please raise a bug report if encountered\n    \"\"\"\n    ingredients = {}\n    while True:\n        ingredient = BTCInput.read_text(\"Enter next ingredient or . to stop: \")\n        if ingredient == \".\":\n            break\n        if ingredient in ingredients:\n            print(\"That ingredient is already included!\")\n            duplicate_choice = BTCInput.read_int_ranged(\n                \"Overwrite (2), append (1) or forget (0)?: \", min_value=0, max_value=2\n            )\n            if duplicate_choice == 0:\n                continue  # ignore this entry and move to the next\n            elif duplicate_choice == 1:\n                pass  # for append behave normally\n            elif duplicate_choice == 2:\n                del ingredients[ingredient]  # remove existing entries\n            else:\n                raise ValueError(\n                    \"Invalid value \"\n                    + str(duplicate_choice)\n                    + \"encountered resolving duplicate ingredient\"\n                )\n        ingredient_description = BTCInput.read_text(\"Enter quantity and description: \")\n        if ingredient in ingredients:\n            ingredients[ingredient].append(ingredient_description)\n        else:\n            ingredients[ingredient] = [ingredient_description]\n\n    return ingredients\nThis code can be broken down as follows,\n\nAsk the user for the name of the next ingredient\n\nThis next bit is a bit tricky, but we check if the ingredient already exists in the dictionary, if it does the user can,\n\nOverwrite it\n\nSay if they accidentally mis-entered the previous ingredient they can use this to correct it\nWe use the del keyword to delete the key and the list associated with the key ingredient\n\nAppend it\n\nThis allows the inclusion of multiple ingredient descriptions per ingredient\n\nForget it\n\nPerhaps the user simply accidentally entered an ingredient twice, this gives them to option to simply forget this entry and move on\n\n\n\nAsk the user for a description of the ingredient like the quantity or how to prepare it\nTo add the ingredient and description we then have to check,\n\nIf the ingredient doesn’t exist yet, we have to create a new list containing the description, this is then assigned to the key ingredient\nIf the ingredient exists we can simply append to the existing list\n\nThis repeats until the user provides the \".\" as input, indicating they wish to stop\nThe created dictionary is returned\n\nadd_steps follows the same process, except the processed steps are simply stored in an ordered list which is returned\n\n\n\nFinding Recipes\nLet’s now look at adding search to our recipes. Our specification states that we should be able to search for recipes by ingredients or by name\n\nListing Recipes\nFirst we need a way to display the recipes returned by a search. Since recipes can have many steps and ingredients we don’t want to follow the Tiny Contacts and Music Storage Track approach of printing out all the contents of the objects, instead we’ll simply print the names of the recipes.\n\ndef list_recipes(recipes):\n    \"\"\"\n    Prints the recipe names in a given list\n\n    Parameters\n    ----------\n    recipes : list[Recipe]\n        list of recipes to display\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"List Recipes\")\n    if len(recipes) == 0:\n        print(\"No recipes found\")\n        return\n    for recipe in recipes:\n        print(\"-\", recipe.name)\n\nWe can see this in action if we use the toy demonstration,\n\nbacon_and_eggs = Recipe(\n    name=\"Bacon and Eggs\",\n    ingredients={\"Bacon\": [\"2 rashs\"], \"Eggs\": [\"1 large\"]},\n    steps=[\"Cook bacon\", \"Cook Eggs\"],\n)\n\neggs_on_toast = Recipe(\n    name=\"Eggs on Toast\",\n    ingredients={\"Bread\": \"2 slices\", \"Eggs\": [\"1 large\"]},\n    steps=[\"Toast bread\", \"Cook Eggs\"],\n)\n\nrecipes = [bacon_and_eggs, eggs_on_toast]\nlist_recipes(recipes)\n\nList Recipes\n- Bacon and Eggs\n- Eggs on Toast\n\n\nObserve that list_recipes takes a list to print. That means we can use the similar filter vs find approach as used in Music Storage to managing recipe selection\n\n\nFind Recipes by Name\nThe by name search is similar to what we have already implemented in our Tiny Contacts and Music Storage programs. However, instead of using startswith we’ll use the find string method, the documentation for find reads,\n\n    import pydoc\n    pydoc.help(\"a string\".find)\n\nHelp on built-in function find:\n\nfind(...) method of builtins.str instance\n    S.find(sub[, start[, end]]) -&gt; int\n\n    Return the lowest index in S where substring sub is found,\n    such that sub is contained within S[start:end].  Optional\n    arguments start and end are interpreted as in slice notation.\n\n    Return -1 on failure.\n\n\n\nWe can see that find searches a string for matching substring anywhere in the string (like startswith searches a string for matching substring at the start)\nImportantly, it also returns -1 if there no match. This means that we can use find to see if a recipe name contains the user provided search string. So we define our filter function as,\n\ndef filter_recipe_by_name(search_name):\n    \"\"\"\n    Finds and returns recipes whose name contains a search name\n\n    Parameters\n    ----------\n    search_name : str\n        name to search for, search is conducted as a substring search\n\n    Returns\n    -------\n    list[Recipe]\n        list of recipes whose name contains `search_name` as a substring\n    \"\"\"\n    results = []\n    search_name = search_name.strip().lower()\n    for recipe in recipes:\n        if recipe.name.strip().lower().find(search_name) != -1:\n            results.append(recipe)\n    return results\n\nWe use the standard normalisation of strip().lower() then call find and check the return value is not -1 to determine if we have a match\n\n\n\n\n\n\nNote\n\n\n\nRemember our convention is a filter_ function takes a search parameter and returns a list of matches while a find_ prompts the user for the search parameter and displays / prints the matches\n\n\nWe can see the outcome of running, filter_by_name for a couple of inputs on our recipes list,\n\nprint(\"Looking for toast...\")\nlist_recipes(filter_recipe_by_name(\"toast\"))\nprint(\"Looking for eggs\")\nlist_recipes(filter_recipe_by_name(\"egg\"))\nprint(\"Looking for milk\")\nlist_recipes(filter_recipe_by_name(\"milk\"))\n\nLooking for toast...\nList Recipes\n- Eggs on Toast\nLooking for eggs\nList Recipes\n- Bacon and Eggs\n- Eggs on Toast\nLooking for milk\nList Recipes\nNo recipes found\n\n\nThe corresponding find_by_name function then looks very simple,\ndef find_recipe_by_name():\n    \"\"\"\n    Prints all recipes matching a user-specified search\n\n    Returns\n    -------\n    None\n        Matches are printed to standard output\n\n    See Also\n    --------\n    filter_recipe_by_name : returns a list containing recipes which match a name\n    find_recipe_by_ingredient : find recipes containing a user-prompted ingredient\n    \"\"\"\n    print(\"Find Recipe by Name\")\n    results = filter_recipe_by_name(BTCInput.read_text(\"Enter recipe name: \"))\n    list_recipes(results)\n\n\nFinding by Ingredients\nMatching for ingredients looks very similar to the search method proposed for the dictionary based Tiny Contacts, combined with our filter and find technique. The filter function,\n\ndef filter_recipe_by_ingredient(search_ingredient):\n    \"\"\"\n    Find and return a list of all recipes which contain a given ingredient\n\n    Parameters\n    ----------\n    search_ingredient : str\n        ingredient to search for\n\n    Returns\n    -------\n    list[Recipe]\n        list of Recipes containing `search_ingredient`\n\n    Warnings\n    --------\n    search matching is exact on `search_ingredient`, for example if a recipe\n    had the ingredient dictionary,\n\n    `{\"Bread\" : [\"sliced\"], \"chicken thighs\" : [\"large\"]}`\n\n    1. `filter_recipes_by_ingredient(\"Bread\")` would match\n    2. `filter_recipes_by_ingredient(\"bread\")` would not match\n    3. `filter_recipes_by_ingredient(\"chicken\")` would not match\n    \"\"\"\n    results = []\n    for recipe in recipes:\n        if search_ingredient in recipe.ingredients:\n            results.append(recipe)\n    return results\n\nWhich we can see would have the following results,\n\nprint(\"Searching by ingredient: Eggs\")\nlist_recipes(filter_recipe_by_ingredient(\"Eggs\"))\nprint(\"Searching by ingredient: eggs\")\nlist_recipes(filter_recipe_by_ingredient(\"eggs\"))\nprint(\"Searching by ingredients: Bacon\")\nlist_recipes(filter_recipe_by_ingredient(\"Bacon\"))\nprint(\"Searching by ingredients: Milk\")\nlist_recipes(filter_recipe_by_ingredient(\"milk\"))\n\nSearching by ingredient: Eggs\nList Recipes\n- Bacon and Eggs\n- Eggs on Toast\nSearching by ingredient: eggs\nList Recipes\nNo recipes found\nSearching by ingredients: Bacon\nList Recipes\n- Bacon and Eggs\nSearching by ingredients: Milk\nList Recipes\nNo recipes found\n\n\nWe can see that as discussed the dictionary key search is vulnerable to how the user chooses to input their ingredient. We could get around simple differences like eggs and Eggs by simply normalising the keys when they’re entered however if the user was to instead search egg this would still break. Even worse would be if they searched scallion instead of spring onion which would break even if we used a method like find\nAs you should be able to see, the general search and find problem is difficult!\n\n\n\nViewing a Recipe\nWe now have a way to find recipes so we can start looking at how to view them. As mentioned in printing out a recipe, they may have too much information to simply print them out. We have three specifications to implement\n\nDisplay a recipe’s ingredients\n\nThis might be useful if we are simply trying to write a shopping list\n\nDisplay a recipe’s steps\n\nThis might useful if we want to read through an entire recipe\n\nDisplay recipe step by step\n\nThis would be useful when working through a recipe, the user would then be able to step through each recipe as they completed it\n\n\n\nSelecting a Recipe to View\nWe will implement recipe viewing using a similar technique to the Music Track program. If the user selects to view a recipe, we will first perform a name based search, then the user can decide to view any matches. If they do they will be taken to a new menu, which looks like,\nCurrent Recipe: \"Recipe currently selected to view\"\nView Recipe\n1. View Ingredients\n2. View Steps\n3. View Step by Step\n4. Return to Main Menu\nThe implementation of this first part looks like,\ndef view_recipes():\n    \"\"\"\n    Provide a prompt for the user to select a recipe to view\n\n    Reports the number of successful matches. For each match\n    (if any) the user is then prompted if they wish to view\n    the recipe in which case they are taken to the view\n    recipe menu\n\n    See Also\n    --------\n    `run_view_recipe_menu` - provides options for viewing a specific recipe\n    \"\"\"\n    print(\"View Recipe\")\n    results = filter_recipe_by_name(BTCInput.read_text(\"Enter recipe to view: \"))\n    if len(results) == 0:\n        print(\"No recipe found matching that name\")\n    else:\n        print(\"Found\", len(results), \"matches\")\n    for recipe in results:\n        print(\"Recipe: \", recipe.name)\n        command = BTCInput.read_int_ranged(\n            \"View this recipe? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        )\n        if command == 1:\n            run_view_recipe_menu(recipe)\nObserve that we defer the viewing functionality to the run_view_recipe_menu function which accepts a Recipe object as a parameter.\n\n\nViewing a Selected Recipe\nTo implement each of these features, lets work through them step by step\n\nList ingredients\n\nWe could simply output the dictionary, but that won’t format nicely\nInstead loop over the dictionary and print each ingredient then the list of descriptions with each ingredient getting its own line\n\nList Steps\n\nAgain simply printing the list would not format nicely\nWe print the steps as a bullet-pointed list using by printing each list entry on a new line prepended by -\n\nList Step by Step\n\nFor this we can follow the same procedure as above, but\nBefore the next iteration of the loop over the step list, we prompt the user to continue\nFor usability we’ll allow the user quit stepping through at any point using q\n\n\nFinally after selecting any option, the function loops back to the start allowing the user to chose another view option until they choose to quit back to the main menu.\ndef run_view_recipe_menu(recipe):\n    \"\"\"\n    Provides a looping menu interface allowing the user\n    to view the details of a specific recipe\n\n    View Options are\n\n    1. List ingredients\n        - Shows all the ingredients in a recipe\n    2. View All Steps\n        - Shows all the steps in a recipe\n    3. Step through Recipe\n        - Allows the user to interactively step through a recipe\n        one step at a time\n\n    Parameters\n    ----------\n    recipe : Recipe\n        recipe to view\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    ValueError\n        An invalid number is encountered in menu selection, should not\n        occur in live code, please raise a bug report if encountered\n    \"\"\"\n    header = \"Current Recipe: \" + recipe.name + \"\\n\"\n    view_recipe_menu = (\n        header\n        + \"\"\"View Recipe\n1. List Ingredients\n2. View All Steps\n3. Step through Recipe\n4. Return to Main Menu\n\nEnter your command: \"\"\"\n    )\n    while True:\n        command = BTCInput.read_int_ranged(\n            prompt=view_recipe_menu, min_value=1, max_value=4\n        )\n        if command == 1:\n            print(\"Ingredients\")\n            for ingredient in recipe.ingredients:\n                print(ingredient, \"-\", recipe.ingredients[ingredient])\n        if command == 2:\n            print(\"View all Steps\")\n            for step in recipe.steps:\n                print(\"-\", step)\n        if command == 3:\n            print(\n                \"Step through Recipe\"\n            )  # waits for user confirmation before printing next step\n            for step in recipe.steps:\n                print(\"-\", step)\n                go_to_next = BTCInput.read_text(\"Next step? (Q - Quit): \")\n                if go_to_next.strip().upper() == \"Q\":\n                    return\n        if command == 4:\n            break\nA sample pipeline for above might look like,\n\n\n\nView Recipe\n\nEnter recipe to view:  Bacon\n\nFound 1 matches\n\nRecipe: Bacon and Eggs\n\nView this recipe? (1 - Yes, 0 - No): 1\n\nCurrent Recipe: Bacon and Eggs\n\nView Recipe\n\n1. List Ingredients\n\n2. View All Steps\n\n3. Step through Recipe\n\n4. Return to Main Menu\n\n\n\nEnter your command: 1\n\n\n\nBacon - 2 rashs\n\nEggs - 1 large\n\n\n\n\n\n\n\n\n\nEditing and Removing a Recipe\n\nRemove a Recipe\nThe last features to implement are the processes of editing and removing a recipe. Remove can be implemented simply enough, we use find_recipes_by_name to get a list of matching recipes from the user, then simply prompt them to see if the want to remove each one\ndef remove_recipe():\n    \"\"\"\n    Remove a recipe from the database\n\n    Prompts the user to select a recipe to match.\n    Reports the number of successful matches. For each match\n    (if any) the user is prompted if they want to remove the recipe\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    filter_recipe_by_name : gives a list of recipes matching a name\n    \"\"\"\n    print(\"Remove Recipe\")\n    results = filter_recipe_by_name(BTCInput.read_text(\"Enter recipe to remove: \"))\n    if len(results) == 0:\n        print(\"No recipe found matching that name\")\n    else:\n        print(\"Found\", len(results), \"matches\")\n    for recipe in results:\n        print(\"Recipe:\", recipe.name)\n        command = BTCInput.read_int_ranged(\n            \"View this recipe? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        )\n        if command == 1:\n            recipes.remove(recipe)\n\n\nEdit a Recipe\nFor editing we also go with a simple implementation similar to what we’ve already used for Tiny Contacts and the Music Track Storage App. Here the user will search for a track to edit, then after confirming they want to edit it, we prompt them for a new name, new ingredient dictionary or new list of steps.\ndef edit_recipe():\n    \"\"\"\n    Provides a prompt to the user to select a recipe to edit\n\n    Reports the number of successful matches. For each match\n    (if any) the user is prompted if they want to edit the recipe\n    in which case they are provided the options to edit the name,\n    ingredients or steps\n\n    Returns\n    -------\n    None\n\n    Warnings\n    --------\n\n    Edits are performed in-place and live, they cannot be rolled back\n\n    See Also\n    --------\n    filter_recipe_by_name : gives a list of recipes matching a name\n    \"\"\"\n    print(\"Edit Recipe\")\n    results = filter_recipe_by_name(BTCInput.read_text(\"Enter recipe to edit: \"))\n    if len(results) == 0:\n        print(\"No recipe found matching that name\")\n    else:\n        print(\"Found\", len(results), \"matches\")\n    for recipe in results:\n        print(\"Recipe:\", recipe.name)\n        command = BTCInput.read_int_ranged(\n            \"Edit this recipe? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        )\n        if command == 0:\n            continue\n        new_name = BTCInput.read_text(\"Enter new name or . to leave unchanged: \")\n        if new_name != \".\":\n            recipe.name = new_name\n        should_edit_ingredients = BTCInput.read_int_ranged(\n            \"Edit ingredients? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        )\n        if should_edit_ingredients:\n            recipe.ingredients = get_ingredients()\n        should_edit_steps = BTCInput.read_int_ranged(\n            \"Edit steps? (1 - Yes, 0 - No): \", min_value=0, max_value=1\n        )\n        if should_edit_steps:\n            recipe.steps = get_steps()\nThis implementation perhaps isn’t the greatest, for example it might be annoying to have to renter every step if you just want to fix a typo in one step, or to have to renter every ingredient if you want to add a new one. However for now this will do for a first pass\n\n\n\nImproving the Recipe Application\nAs we’ve hinted, there are plenty of ways that the recipe app could be completed. However as it stands now, I’m pretty happy with it as a something that’s gone through an initial design and a refactor. if you’re interested you might like to try improve the following features\n\nImprove the ingredient search to be more forgiving in how it matches\nImprove the edit functionality\n\nAllow the ingredient dictionary to be edited such that,\n\nAn individual key can be edited\nAn individual key can be removed\nAn individual key can be added, (including as a duplicate)\n\nAllow the steps list to be edited such that,\n\nAn individual step can be edited\nAn individual step can be removed\nAn individual step can be added",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 9: Use Classes to Store Data",
      "Extended Exercises for Chapter 9"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/11_ObjectBasedSolutionDesign/Chapter_11.html",
    "href": "02_AdvancedProgramming/11_ObjectBasedSolutionDesign/Chapter_11.html",
    "title": "Chapter 11: Object-based Solution Design",
    "section": "",
    "text": "The previous chapter looked at creating useful objects\nIn this chapter we’ll explore how to create systems comprising large numbers of different but related objects\nWe’ll also look at connecting objects via their methods\n\n\n\n\nConsider the following scenario\n\n\nA friend who runs a fashion shop would like you to build an application to help manage her stock. She sells a large range of clothing items and wants to be able to track inventory. Her workflow is as follows, stock arrives from suppliers, the details are entered in the system. When an item is sold it should be removed from the stock. She would also like to be produce reports indicating how many of each item are in stock.\n\n\nWorking with the client you define the following information about how her stock operates\nEach item has a unique reference\nEach reference contains:\n\nA description\nA price\nA number in stock\nA list of delivery amounts and dates, and sales\n\nFor now the client is happy to just print out the entire stock list\nHas indicated in future they may wish to have more analytics, e.g.\n\ndetermine which item has the lowest stock\n\nOur prototype interface is then,\n  Mary's Fashion Shop\n\n  1. Create a new stock item\n  2. Add stock to an existing item\n  3. Sell stock\n  4. Stock report\n  5. Exit\n\n  Enter your command:\nThe above options are all pretty straightforward for now\n\n\n\n\nBefore designing the program we need to understand the data we have to represent\nOur client tells us that each stock item requires,\n\nStock reference id\nPrice\nColour\nNumber in stock\n\nThe client also has specifics for different types of stock items\n\nFor Dresses we require\n\nSize\nStyle\nPattern\n\nFor pants we require\n\nLength\nWaist size\nStyle\nPattern\n\nFor hats we require\n\nSize\n\nFor blouses we require\n\nSize\nStyle\nPattern\n\n\nWe can map out some descriptions\n  Dress: stock reference: 'D0001' price: 100.0 colour: red pattern: swirly size: 12\n  Pants: stock reference: 'TR12327'price: 50 colour: black pattern: plain length: 30 waist: 30\nNow that we have our data requirements and some mock items, we want to carry out data design\nData design is the process of specifying how we represent a programs data\n\n\n\n\n\nA design paradigm we could use is to represent each data object as a class\n\nThis object-centric approach is called object-oriented programming\n\nSolution elements are mapped to software objects\nA way to formulate classes is to break a problem statement down into nouns\nnouns describe things which naturally translate to objects\n\ne.g. a food service point-of-sale system might be described as\n\n\n\nThe customer will select a dish from the menu and add it to his order.\n\n\n\n\nThe four nouns above (written in red) could map to classes in the application\n\nThis is only a starting point\nWe would have to dive deeper into the design requirements with the client\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nDon’t write any code before you have completed your data design\nDesign mistakes are easiest to correct early in a project’s lifecycle. For this reason data design is almost always carried out and completed before we actually starting to right code.\nIf we were to continue developing the restaurant point of sale system above, we would have to work through the data requirements with the client. For example if we were developing a Customer class, we might map out paper variants of the class, and work through usage scenarios with the client to ensure all the details are captured.\nFor example if a customer needed to provide a telephone number we would want to capture this design requirement early.\n\n\n\nFor our first design we could implement all these different stock items as different classes, (you can find the code in SeparateClasses.py)\n\n\n# Example 11.1 Fashion Items as Separate Classes\n#\n# Mocks out the class-based implementation of the fashion items, treating\n# each different item type as it's own standalone class\n\n\nclass Dress:\n    \"\"\"\n    Represents the inventory details for a Dress\n    \"\"\"\n\n    def __init__(self, stock_ref, price, colour, pattern, size):\n        \"\"\"\n        Creates a `Dress` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            stock reference code\n        price : int | float\n            dress price\n        colour : str\n            description of the dress colour\n        pattern : str\n            description of the dress pattern\n        size : int\n            dress size\n        \"\"\"\n        self.stock_ref = stock_ref\n        self.__price = price\n        self.__stock_level = 0\n        self.colour = colour\n        self.pattern = pattern\n        self.size = size\n\n    @property\n    def price(self):\n        \"\"\"\n        price : int | float\n            dress price\n        \"\"\"\n        return self.__price\n\n    @property\n    def stock_level(self):\n        \"\"\"\n        stock_level : int\n            amount of stock in inventory\n        \"\"\"\n        return self.__stock_level\n\n\nclass Pants:\n    \"\"\"\n    Represents the inventory details for a pair of Pants\n    \"\"\"\n\n    def __init__(self, stock_ref, price, colour, pattern, length, waist):\n        \"\"\"\n        Creates a `Pants` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            stock reference code\n        price : int | float\n            pants price\n        colour : str\n            description of the pants colour\n        pattern : str\n            description of the pants pattern\n        length: int\n            length of the pants\n        waist : int\n            pants waist size\n        \"\"\"\n        self.stock_ref = stock_ref\n        self.__price = price\n        self.__stock_level = 0\n        self.colour = colour\n        self.pattern = pattern\n        self.length = length\n        self.waist = waist\n\n    @property\n    def price(self):\n        \"\"\"\n        price : int | float\n            dress price\n        \"\"\"\n        return self.__price\n\n    @property\n    def stock_level(self):\n        \"\"\"\n        stock_level : int\n            amount of stock in inventory\n        \"\"\"\n        return self.__stock_level\n\n\nx = Dress(stock_ref=\"D001\", price=100, colour=\"Red\", pattern=\"Swirly\", size=12)\ny = Pants(\n    stock_ref=\"TR12327\", price=50, colour=\"Black\", pattern=\"Plain\", length=30, waist=25\n)\n\nprint(x.price)\nprint(y.stock_level)\n\n100\n0\n\n\n\nWe define a Dress and a Pants class\nEach class has to have an __init__ to set them up\nBoth classes have private price and stock levels\n\nThese are important parts of the inventory system that should have controlled modification\nWe don’t want the price being modified and overcharging customers\nWe don’t want the stock level being off causing us to mis-order\n\nBoth classes have properties to access price and stock levels\n\nLater we’ll make methods to control these\n\n\n\n\n\n\n\n\nCaution\n\n\n\nAvoid overusing block-copy\nUsing a text editor it might seem convenient to copy a large block of code when we have to reuse it elsewhere. Whenever you feel yourself copying lets of code to different sections this is usually a good indicator that something is not right. You should aim to write a piece of code once. Code written once is more maintainable, as we only need to modify it in one place. If the code is used multiple times, it is a good candidate to be converted into a function or a method\nAs mentioned block copying is liable to introduce bugs. If we need to slightly modify the code in the new section we have to make sure we do it correctly (which might be hard if you’ve copied a big chunk). Additionally if you latter find a bug, you may have to fix all the copies (which requires you to remember where they are).\nUse this as advice, if you find yourself copying lots of code, its a good time to take a step back at look at your overall design\n\n\n\n\n\n\nMany languages (including python) let us use inheritance\nInheritance allows one class to base itself on another\n\ni.e. it inherits the behaviour of another class\n\nThe original class is called the superclass\nCreating this new class is called extending the superclass\nBy default all python classes extend the object class\nWe could write this explicitly\n  class Contact(object)\nWe can replace the object in the above with the class we want to use as a superclass\nLooking at our data design we can see there is a bunch of behaviour common to all stock items\nWe can start by defining a StockItem to act as a superclass\n\nStockItem stores all common attributes\n\nStock reference\nPrice\nColour\nStock level\n\n\nDress and Pants now extend StockItem\n\nThe other stock items will do so as well\n\nThe diagram below shows what’s called a class diagram or inheritance hierarchy\n\n\n\n\n\n\n---\ntitle: Fashion Shop Class Diagram\n---\n\nclassDiagram\n    class object\n\n    class StockItem {\n        str stock_ref\n        str item_name\n        str colour\n        number price\n        int stock_level\n    }\n\n    class Dress {\n        str pattern\n        int size\n    }\n\n    class Pants {\n        int length\n        str pattern\n        int waist\n    }\n\n    object &lt;|-- StockItem\n    StockItem &lt;|-- Dress\n    StockItem &lt;|--  Pants\n\n\n\n\n\n\n\nWe can see that both Pants and Dress are subclasses of StockItem\nThe inverse relationship is StockItem is the superclass of Pants and Dress\nWe call this inheritance because the subclasses inherit the attributes of the superclass\nWhen building an inheritance hierarchy you need to focus on your data\n\nHere we have a collection of related data items\nThe basic behaviour of a data item is the same\nThe related items also have some common data attributes\n\nWe capture the common behaviour and data in a superclass\n\nThen extend with subclasses the specific behaviour of different data items\n\nAlso means that if we add new common behaviour we only have to add it in one place\n\ni.e. the superclass\nOtherwise we would have to put it in all the classes\n\n\n\n\n\nAbstraction is a term used to describe attempting to capture behaviours and data of a system at a higher level\nHere by introducing a StockItem class we are attempting to talk about the behaviour of stock items in generality as opposed to any specific type of stock item\n\ni.e. We know that a stock item should be,\n\nAble to be added\nAble to be sold\nFind out what stock items we have\n\nWe do not capture the specifics of how these processes occur\n\nJust know that we need to capture them in our program\n\n\nAbstract lets us look at processes without getting caught up in the details\nLater we can go and fill those details in\nTypically as we move down a class hierarchy, we should move from the more abstract to the more concrete\n\nAt the highest level a class or interface might just say what methods an object should have\nThe next level down might implement some common attributes and methods (StockItem)\nThe next level down might provide specialised attributes and specific methods (Dress and Pants)\n\n\n\n\n\nWork through the following questions on object-oriented design and inheritance. It’s a good idea to consider your own thoughts on the topic\n\nWhy don’t we put all the attributes in one class and not bother with subclasses?\n\nWe could add every possible attribute to one class\nHowever then we would have to handle the fact that some attributes are not defined for certain types\n\ne.g. Dress has no waist attribute and Pants has no size\n\nAs we add more classes we would have to consider all the valid possible combinations of attributes and manage them\n\nExactly the kind of thing that the subclass approach does naturally\n\nAdditionally if we want to customise behaviour by type, we would have to add an attribute to track this\n\nInheritance provides polymorphism as a way to do this naturally\n\n\nWhy is the superclass called super?\n\nIt is derived from mathematical terminology around sets\nIn maths \\(A\\) is a subset of \\(B\\) if \\(A\\) is entirely contained in \\(B\\)\n\\(A\\) is a superset of \\(B\\) if \\(A\\) contains \\(B\\)\nThe idea carries onto the language of classes, where the superclass is called super because every subclass is also an instance of the superclass.\n\nWhich is most abstract, a superclass or a subclass?\n\nRecall, the concept of the class hierarchy\nMoving down into subclasses is getting more concrete (less abstract)\nMoving up into superclasses is getting more abstract\n\nCan you extend a subclass?\n\nYes\nWe can see this in the class hierarchy\nStockItem is a subclass of Object\nDress extends StockItem to create a new subclass\n\nWhy is the pattern attribute not in the StockItem class?\n\nLooking at our current class diagram this does make sense\n\nBoth Dress and Pants have a pattern attribute\n\nHowever our client had other types of items e.g. Hat that didn’t have a pattern attribute\nIf we wanted to remove the duplication we might introduce a PatternedItem between StockItem and the Dress and Pants classes\n\nHowever for one specific attribute this is probably not necessary right now\nEspecially as the PatternedItem seems partially arbitrary rather than reflecting an actual category of item\n\n\nWill our system ever create a StockItem object?\n\nNothing prevents us from doing so\nHowever, in practice we there’s no real use case\n\nStockItem is not representing an actual physical item\nIt represents the concept of a stock item\n\nIf we wanted to do we could define StockItem as an abstract class\n\nAbstract classes can’t be instantiated\nThey are good for defining the structure and behaviour of a class\nImplementation left to the subclasses\n\n\nThe client decides in future she may like to track which customers have bought which stock items. Here are three potential implementations. Which implementation makes the most sense?\n\nExtend the StockItem class to make a Customer subclass that contains the customer details because customers buy StockItems\nAdd Customer details to each StockItem\nCreate a new Customer class that contains a list of the StockItems that the Customer has bought\n\n\nClass hierarchies should reflect an is-a relationship\nA Customer is not a Stock item\nSo option 1 is out\nMultiple customers might buy the same stock item\nThe stock item also represents a category of stock as opposed to one specific item\nSo we don’t want to have a Customer field\n\nWe could have a list of customers if we wanted to do it this way\n\nHowever, in the future we might want to add more behaviour for interacting with a customer itself\n\nThus makes sense to define a Customer class\n\n\n\n\n\n\n\nNow lets refactor our code to use a class hierarchy\nThe naive implementation looks like,\n\n\nfrom abc import ABC\n\n\nclass StockItem(ABC):\n    \"\"\"\n    Abstract base class representing a single inventory item.\n\n    Attributes\n    ----------\n    stock_ref : str\n        reference id of the stock item\n    colour : str\n        description of the item's colour\n    \"\"\"\n\n    def __init__(self, stock_ref, price, colour):\n        \"\"\"\n        Creates a `StockItem` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            stock reference id\n        price : int | float\n            stock price\n        colour : str\n            description of stock item's colour\n        \"\"\"\n        self.stock_ref = stock_ref\n        self.__price = price\n        self.colour = colour\n        self.__stock_level = 0\n        self.__stock_level = 0\n\n    @property\n    def price(self):\n        \"\"\"\n        price : int | float\n            dress price\n        \"\"\"\n        return self.__price\n\n    @property\n    def stock_level(self):\n        \"\"\"\n        stock_level : int\n            amount of stock in inventory\n        \"\"\"\n        return self.__stock_level\n\n\nThe StockItem looks pretty standard for a class\nYou may observe that we import ABC from the abc module\n\nabc is a python module to provide abstract classes\nABC is the superclass for abstract classes\n\nWe inherit from ABC to make StockItem abstract\n\nFor now this only indicates that the user should not directly instantiate it\nWe’ll see later the concept of abstract methods which can be used to prevent instantiation of an abstract class\n\nWe move the common attributes and properties to the class\nDefine an __init__ as usual\nNow lets define our Dress class, naively you might write,\n\n  class Dress(StockItem):\n      \"\"\"\n      Represents the inventory details for a Dress\n\n      Inherits from `StockItem`\n\n      Attributes\n      ----------\n      stock_ref : str\n          dress reference id\n      price : int | float\n          dress price\n      colour : str\n          description of dress's colour\n      pattern : str\n          description of the dress pattern\n      size : int\n          dress size\n\n      See Also\n      --------\n      `StockItem` : Parent Class\n      \"\"\"\n\n      def __init__(self, stock_ref, price, colour, pattern, size):\n          \"\"\"\n          Creates a `Dress` instance\n\n          Parameters\n          ----------\n          stock_ref : str\n              stock reference code\n          price : int | float\n              dress price\n          colour : str\n              description of the dress colour\n          pattern : str\n              description of the dress pattern\n          size : int\n              dress size\n          \"\"\"\n          self.pattern = pattern\n          self.size = size\n\nDress subclasses StockItem\nWe add the unique attributes\nCurrently no need to define any new behaviour\nHowever, when we try to create a Dress instance and use it we see\n\n  x = Dress(stock_ref=\"D0001\", price=100, colour=\"red\", pattern=\"swirly\", size=12)\n  print(x.pattern)\n  print(x.price)\n\nswirly\n\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[5], line 3\n      1 x = Dress(stock_ref=\"D0001\", price=100, colour=\"red\", pattern=\"swirly\", size=12)\n      2 print(x.pattern)\n----&gt; 3 print(x.price)\n\nCell In[3], line 41, in StockItem.price(self)\n     35 @property\n     36 def price(self):\n     37     \"\"\"\n     38     price : int | float\n     39         dress price\n     40     \"\"\"\n---&gt; 41     return self.__price\n\nAttributeError: 'Dress' object has no attribute '_StockItem__price'\n\n\n\nWe see that we have no issue creating the object\nCan also access the attributes defined in the subclass (pattern)\nBut we get an error, when we try to access a property on the superclass (price)\nIn fact the error tells us that we can’t find the attribute _StockItem__price\nWhy? Well if we look at the initializer we never seem to have set up the stock level, price, stock reference or colour\n\nWe can’t just write self.colour = colour etc\nBecause this adds an attribute on the subclass\nAlso basically means we’ve rewritten the superclass __init__ again\n\nNeed a way to pass arguments to the __init__ method of the superclass\nWe can do this using super()\n\nsuper() is like self\nUsed to return a reference to the superclass instance\n\n\n\nclass Dress(StockItem):\n    \"\"\"\n    Represents the inventory details for a Dress\n\n    Inherits from `StockItem`\n\n    Attributes\n    ----------\n    stock_ref : str\n        dress reference id\n    price : int | float\n        dress price\n    colour : str\n        description of dress's colour\n    pattern : str\n        description of the dress pattern\n    size : int\n        dress size\n\n    See Also\n    --------\n    `StockItem` : Parent Class\n    \"\"\"\n\n    def __init__(self, stock_ref, price, colour, pattern, size):\n        \"\"\"\n        Creates a `Dress` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            stock reference code\n        price : int | float\n            dress price\n        colour : str\n            description of the dress colour\n        pattern : str\n            description of the dress pattern\n        size : int\n            dress size\n        \"\"\"\n        super().__init__(stock_ref, price, colour)\n        self.pattern = pattern\n        self.size = size\n\n\nx = Dress(stock_ref=\"D0001\", price=100, colour=\"red\", pattern=\"swirly\", size=12)\nprint(x.pattern)\nprint(x.price)\n\nswirly\n100\n\n\n\nWe use super() to get a reference to the super object\nThen call the __init__ object on the instance and pass the required parameters\nKey Takeaway: When initialising a subclass you must explicitly initialise the superclass too\nThe complete code for our class hierarchy incorporating Pants can be found in ClassHierarchy.py\n\n\n\n\n\nSo far each class name matches the stock type being stored\nWe might not want to maintain this relationship\ne.g. if we introduced an “Evening Dress” we can’t create a Evening Dress class\n\nSince class names must be contiguous\n\nThe client thus wants us to provide a way of giving a user friendly string description off the item name\nIn the class diagram we defined a property called an Item Name in the Stock Item\n\nIntended to hold the item name\n\nProvides a user friendly string name\nImplement as a class property\n\n  class StockItem(object):\n\n      @property\n      def item_name(self):\n          \"\"\"\n          stock_level : int\n              amount of stock in inventory\n          \"\"\"\n          return \"Stock Item\"\n\nWe can then override this attribute in the subclasses\n\nOverridden attributes are used inplace of the superclass implementation\n\ne.g. For the Dress class we might write\n\n  class Dress(StockItem):\n      ...\n      @property\n      def item_name(self):\n          return \"Dress\"\n\n\nThen calling item_name on a Dress instance should return \"Dress\" instead of \"Stock Item\" as demonstrated below\n\n    item = StockItem()\n    print(\"item name is\", item.item_name)\n    dress = Dress()\n    print(\"dress name is\", dress.item_name)\n\nitem name is Stock Item\ndress name is Dress\n\n\n\n\n\n\n\nWe’ve just seen how StockItem defines a property item_name which returns a string\nHowever, the intention is that this is overwritten by a subclass\nIt would be good if we could force a subclass to define this method\nWe saw that the abc module allowed us to inherit a class ABC that meant the class should not be directly instantiated\n\nIs there something similar for methods\n\nTurns out there is!\n\nabc contains a abstractmethod decorator\nIf a class has methods decorated with @abstractmethod subclasses can’t be instantiated unless they override all the abstract methods\n\nWe can see this in practice below\n\n\n    import abc\n    class StockItem(abc.ABC):\n\n        @property\n        @abc.abstractmethod\n        def item_name(self):\n            \"\"\"\n            stock_level : int\n                amount of stock in inventory\n            \"\"\"\n            pass\n\n    class Dress(StockItem):\n\n        @property\n        def item_name(self):\n            return \"Dress\"\n\n    class Pants(StockItem):\n        pass\n\n\nHere we define StockItem with item_name as an abstract property\n\nWe do this by using both the @property and @abstractmethod decorators on the method\n\nSince item_name is always overridden, rather than return a value, we simply use pass to indicate a placeholder\nWe next define Dress and Pants as two subclasses\n\nDress overrides the item_name method\nPants does not\n\nLet’s see what happens when we try to instantiate these\n\n  d = Dress()\n  print(d.item_name)\n\n  p = Pants()\n  print(p.item_name)\n\nDress\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[11], line 4\n      1 d = Dress()\n      2 print(d.item_name)\n----&gt; 4 p = Pants()\n      5 print(p.item_name)\n\nTypeError: Can't instantiate abstract class Pants without an implementation for abstract method 'item_name'\n\n\n\nWe can see that the Dress instantiation works as expected\nWe can call Dress and access the overridden item_name property\nHowever, when we try to instantiate p as Pants we get a TypeError!\n\nThe message tells us we need to implement the abstract method item_name\n\n\n\n\n\n\n\nAs seen earlier objects can use the __str__ method to define a string representation\nWe should add these to StockItem and it’s derived classes\nDefining a __str__ method is technically overriding the __str__ method on the parent\n\nIncluding the object class\n\n\n\n\nOpen the python interpreter and work through the following steps to understand method overriding\nEnter the following statement\n\no = object()\n\nThis creates an object instance referenced by o. If we print the value of o we are calling the __str__ method on the object class\nRun the print statement as below\n\nprint(o)\n\n&lt;object object at 0x7f71f0872be0&gt;\n\n\nprint requires a str argument, so o is converted to a string by calling its __str__ method. In this case the __str__ method of the object class. We can see the result is a message that indicates the type of the object and the memory address where the instance is stored.\nThis should be familiar to what we see in the earlier Contact class before we defined a __str__ method. What happened there was that when __str__ was called to convert a Contact to an string, it deferred to the superclass __str__ method which was object\nTo define different behaviour we have to provide our own __str__ method which is said to override the superclass __str__ method.\nDefine a new class StrTest by entering the statements below\n\nclass StrTest(object):\n    def __str__(self):\n        return \"string from StrTest\"\n\nRemember that we don’t have to explicitly inherit from object we’ve just done it to be clear\nIf we now print this new StrTest object, we can see that the new __str__ method on the StrTest is used.\nTest this by running the line below\n\nprint(StrTest())\n\nstring from StrTest\n\n\nBut what if we want to use the __str__ method from the superclass as part of the __str__ method of the subclass? Well we can do so by using super() to access the superclass instance associated with the subclass instance. We can then directly reference the __str__ method\nDemonstrate this by defining a new class, as below\n\nclass StrTestSub(StrTest):\n    def __str__(self):\n        return super().__str__() + \"..with sub\"\n\nThe __str__ method still overrides the superclass, but super() lets us incorporate the __str__ result from the StrTest superclass. We can see this behaviour if we try to print the object.\nCall print on an instance of StrTestSub as below\n\nprint(StrTestSub())\n\nstring from StrTest..with sub\n\n\n\nNow let’s define __str__ methods for our StockItem and Subclasses\n  class StockItem(abc.ABC):\n      ...\n      def __str__(self):\n          template = \"\"\"Stock Reference: {0}\nType: {1}\nPrice: {2}\nStock level: {3}\nColour: {4}\"\"\"\n          return template.format(\n              self.stock_ref, self.item_name, self.price, self.stock_level, self.colour\n          )\nThis __str__ item uses a template string which is formatted\nStockItem attributes are printed one per line\nWhy are we making a __str__ method for the StockItem when we’re going to override this?\nWell the subclasses all have to refer to the common attributes in the StockItem\nMakes sense to use the __str__ method for the superclass to handle how we represent these common attributes\nLet’s see how we put this into practice with the Dress subclass\n\nclass Dress(StockItem):\n    ...\n    def __str__(self):\n        stock_details = super().__str__()\n        template = \"\"\"{0}\nPattern: {1}\nSize: {2}\"\"\"\n        return template.format(stock_details, self.pattern, self.size)\n\nWe use the super() to get the initial part of the string\nThen again use a template string\n\nFirst inject the superclasses string\nThen add on the new attributes in the same style\n\nLet us look at this in practice\n\n\nx = Dress(stock_ref=\"D001\", price=100, colour=\"red\", pattern=\"swirly\", size=12)\nprint(x)\n\nStock Reference: D001\nType: Dress\nPrice: 100\nStock level: 0\nColour: red\nPattern: swirly\nSize: 12\n\n\n\nWe can the final result merges the superclasses string with the added attributes of the Dress class. You can see the complete code in Stock Items with Str\n\n\n\n\n\nConsider the following questions about method overriding\n\nHow does method overriding work?\n\nWhen a method is called, python looks at the object to see if the method exists\nIf it doesn’t python looks up the class hierarchy to see if it can find a matching method\nFirst matching method found is called\nIf all the superclasses are exhausted then an AttributeError is raised\n\nIs an overriding method forced to call the method it is overriding?\n\nNo\nYou only need to do it, if you need to access the superclasses implementation\n__str__ method in the Dress class calls the __str__ in the super because the functionality is useful\n\nMeans if StockItem is updated, we can update the __str__ method and it automatically propagates through to the Dress class\n\n\n\n\n\n\n\nRecall in the Time Tracker we versioned our Session and Contact classes\nThere the goal was to keep old data files usable\n\nWe want to do the same for our Fashion Shop\n\nWhere should the version numbers go?\n\nFor example Dress is a subclass of StockItem, so we could\n\nVersion in the StockItem superclass\nVersion in the Dress superclass\nVersion in both the StockItem and the Dress superclass\n\nWe want both, why?\n\nStockItem might change, but the subclasses don’t\n\nWe don’t want to bump every subclass version\n\nDress might change\n\nStockItem doesn’t, so don’t want to bump it because then that would propagate through to all the other subclasses\n\n\n\nSo we need to implement a version and check_version for both\n\nclass StockItem(abc.ABC):\n\n    def __init__(self, stock_ref, price, colour):\n        self.stock_ref = stock_ref\n        self.__price = price\n        self.colour = colour\n        self.__stock_level = 0\n        self.__StockItem_version = 1\n\n    ...\n\n    def check_version(self):\n        \"\"\"\n        Checks the version of a StockItem instance and upgrades it if required\n\n        Returns\n        -------\n        None\n        \"\"\"\n        pass  # for version 1, no need to check\n\nFor StockItem we add a version attribute labelled __StockItem_version to distinguish from the version numbers of the subclasses\n\nVersion number is hard-coded by the constructor\nWhen we create a new version of the StockItem this is where we bump the version\n\nCurrently there is only one version of the StockItem class, so the corresponding check_version method doesn’t need to do anything\n\nWe still need to include it for the future API\nWe just use pass to make it a placeholder method for now\n\nWe can now define versions and version checking for our subclasses, e.g. for Dress\n\nclass Dress(StockItem):\n\n    def __init__(self, stock_ref, price, colour, pattern, size):\n        super().__init__(stock_ref, price, colour)\n        self.pattern = pattern\n        self.size = size\n        self.__Dress_version = 1\n\n    ...\n\n    def check_version(self):\n        \"\"\"\n        Checks the version of a `Dress` instance and upgrades it if required\n\n        Returns\n        -------\n        None\n        \"\"\"\n        super().check_version()\n\nAs before we add a version attribute (here __Dress_version)\nWe define a new check_version\n\nAgain, right now there is only one version of the Dress so we don’t need to do any self upgrades\nHowever, Dress doesn’t know about the version of StockItem so we have to call super to run check_version for the superclass instance\n\nTogether this means we can update Dress and StockItem independently and saved objects will still be synchronised across both class definitions\nThe implementation for Pants is similar and can be found along with the complete implementation in Versioned Stock Items\n\n\n\n\n\nOverriding methods is an example of a more broader concept of polymorphism\nPolymorphism refers to the same behaviour being able to be applied differently depending on the specific context or object\n\ne.g. all python objects have a __str__ method\ndefines how they are converted to a string representation\nWe can override the __str__ method to make different objects have different behaviours\n\ne.g. default object prints the memory address, an int gives a string representation of its number, and our StockItem class prints its attributes as a newline separated list\n\nThis behaviour is said to be polymorphic, because different objects have different responses to the same behaviour (string conversion)\n\nSoftware is frequently polymorphic\n\ne.g. a Play button might be used to start playback of music, video or a slide show\n\nSame concept (play button)\nDifferent outcome\n\n\nPolymorphism and Abstraction are typically a partnership\n\nAt an abstract level one might define a general set of behaviours a group of similar objects or classes need to do (e.g. “be played”)\nThen use polymorphic behaviour to capture that common concept in one function, say play that is implemented differently for each class e.g. music, video, slide show\n\n\n\n\nTry and work through the following questions about polymorphism before reading the answers\n\nIs polymorphism all about providing methods in a class hierarchy?\n\nNo\nIn this example we’ve used a class hierarchy\n\n__str__ behaves differently, but all objects have a __str__\nHowever we have defined a check_version\nStockItem and Dress both behave differently when check_version is called\n\nBut another object say Book might also have a check_version function\nAgain behaves completely differently\nBut no direct method overwrite chain\nWould still say this behaviour is polymorphic\n\n\nPolymorphism is a broader concept that a class hierarchy\n\nThough we’ve seen, a class hierarchy is one way of structuring polymorphic behaviour\n\n\nHow do I know which methods in my application should be polymorphic?\n\nThis is part of the design process\nIdentify the similar behaviours performed by different objects that work differently for each\ne.g. in a video game all enemies might attack but different enemy types might do so differently\n\nCould then define a class hierarchy with some base enemy type\nThis could then define attack, etc.\n\nSubclasses then override the behaviour polymorphically\nBut we can still talk about “enemies” as a whole\n\n\n\n\n\n\n\n\n\nWhen constructing our classes we made some attributes private\nHow does this carry through the class hierarchy? e.g.\n  class StockItem(abc.ABC):\n      \"\"\"\n      Abstract base class representing a single inventory item.\n\n      Subclasses are expected to overwrite the `item_name` abstract\n      property with a user friendly string description\n\n      Attributes\n      ----------\n      stock_ref : str\n          reference id of the stock item\n      colour : str\n          description of the item's colour\n      \"\"\"\n      def __init__(self, stock_ref, price, colour):\n          \"\"\"\n          Creates a `StockItem` instance\n\n          Parameters\n          ----------\n          stock_ref : str\n              stock reference id\n          price : int | float\n              stock price\n          colour : str\n              description of stock item's colour\n          \"\"\"\n          self.stock_ref = stock_ref\n          self.__price = price\n          self.colour = colour\n          self.__stock_level = 0\n          self.__StockItem_version = 1\nThe above shows the __init__ method for StockItem\nWe can see some public attributes\n\nstock_ref\ncolour\n\nThese can be accessed by anyone\n\nIncluding subclasses\n\nAlso some private ones\n\n__price\n__stock_level\n__StockItem_version\n\nPrivate means restricted to the class in which it was declared\n\nSubclasses are still regarded as other classes\nPrivate variables are thus not accessible in subclasses\n\nSometimes people refer to variables marked with _ i.e. one underscore as Protected\n\nA protected variable is one that can be accessed by the class it is defined in, or any subclasses of that class\n\nWhen designing a class hierarchy you should think about how the data may be used by subclasses\nIf you think you might need to customise behaviour on an attribute\n\nConsider a read-only property, or making it protected/public\n\n\n\n\n\n\n\nLet’s recap our design\nThe client owns a fashion shop\nShe sells several different clothing types\nShe needs a stock management system\nAll clothing items have\n\nA stock reference\nPrice\nStock level\nColour\n\nSpecific clothing items define additional attributes\nTo avoid duplicate code we define a StockItem class\n\nWe define subclasses for specific items\n\nDress\nPants\nHat\nBlouse\n\nsubclasses extend the attributes on a StockItem\n\nEach class has an __init__ to initialise it\n\nEach subclass calls the superclass __init__\nSets up the superclass instance\n\nWe independently version the sub and super classes\n\n\n\nTry to answer the following questions about data design\n\nIs the data design process now complete?\n\nNo\nTo account for this we’ve introduced versioning to a our data objects\n\nthe version attributes and check_version should allow us to add new attributes or modify the objects\n\n\nWhat happens if the fashion shop owner decides to sell a new kind of stock item? Suppose that she wanted to start selling Jeans, which are a type of pants that also has a style, which can be flared, bootleg or straight. What’s the best way to do this?\n\nWe can add a new subclass\n\nWe could subclass StockItem as before\n\nBut then would have to duplicate the Pants code\n\nWe can subclass Pants\n\n\n class Jeans(Pants):\n     \"\"\"\n     Represents the inventory details for a pair of Jeans\n\n     Inherits from `Pants`\n\n     Attributes\n     ----------\n     stock_ref : str\n         pants reference id\n     price : int | float\n         pants price\n     colour : str\n         description of pants's colour\n     pattern : str\n         description of the pants pattern\n     length : int\n         length of the pants\n     waist : int\n         waist size of the pants\n     style : str\n         style of the pants\n\n     See Also\n     --------\n     Pants : Parent Class\n     \"\"\"\n\n     def __init__(self, stock_level, price, colour, pattern, length, waist, style):\n         \"\"\"\n         Creates a `Jeans` instance\n\n         Parameters\n         ----------\n         stock_ref : str\n             stock reference code\n         price : int | float\n             pants price\n         colour : str\n             description of the pants colour\n         pattern : str\n             description of the pants pattern\n         length: int\n             length of the pants\n         waist : int\n             pants waist size\n         style : str\n             jeans style\n         \"\"\"\n         # pants constructor\n         super().__init__(stock_level, price, colour, pattern, length, waist)\n         self.style = style # new attribute\n         self.__Jeans_version = 1 # versioning\n\n     def __str__(self):\n         pants_details = super().__str__()\n         template = \"\"\"{0}\n Style: {1}\"\"\"\n         return template.format(pants_details, self.style)\n\n     @property\n     def item_name(self):\n         return \"Jeans\"\n\n     def check_version(self):\n         \"\"\"\n         Checks the version of a `Pants` instance and upgrades it if required\n\n         Returns\n         -------\n         None\n         \"\"\"\n         super().check_version()\nWhat happens if the fashion shop owner decides to store something new about the stock? For example suppose the client now adds a location attribute to stock items. Location is a string description of where in the store the stock item is stocked. She tells your her plan is to later provide a program that will allow customers to find where items are located in the store. How can we add this attribute and to which class would we add it?\n\nAll items need this property so most appropriate to add to StockItem\nShould be added to the __init__\n\n\n class StockItem(abc.ABC):\n\n     def __init__(self, stock_ref, price, colour, location):\n         self.stock_ref = stock_ref\n         self.__price = price\n         self.__stock_level = 0\n         self.colour = colour\n         self.location = location\n         self.__StockItem_version = 2 # we have to bump the version number\n\n\nThis has a problem that it breaks our program!\nIf we try create a new Dress we find\n\n   d = Dress(\"D001\", 100, \"red\", \"swirly\", 12)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[23], line 1\n----&gt; 1 d = Dress(\"D001\", 100, \"red\", \"swirly\", 12)\n\nCell In[22], line 3, in Dress.__init__(self, stock_ref, price, colour, pattern, size)\n      2 def __init__(self, stock_ref, price, colour, pattern, size):\n----&gt; 3     super().__init__(stock_ref, price, colour)\n      4     self.pattern = pattern\n      5     self.size = size\n\nTypeError: StockItem.__init__() missing 1 required positional argument: 'location'\n\n\n\nDress does not know about the new location argument to the StockItem constructor\n\nThus generates an error when trying to call the constructor\n\nTo fix this we have to update the Dress __init__ method\n\nSame for every other subclass\n\n\n  class Dress(StockItem):\n      def __init__(self, stock_ref, price, colour, location, pattern, size):\n          super().__init__(stock_ref, price, colour, location)\n          self.pattern = pattern\n          self.size = size\n          self.__Dress_version = 1 # no attribute changes to `Dress`\n\nNow the instantiation should work\n\n  d = Dress(\"D001\", 100, \"red\", \"front shelf\", \"swirly\", 12)\n  print(d)\n\n&lt;__main__.Dress object at 0x7f71f0e45c10&gt;\n\n\nThe takeaway is that class hierarchies are very brittle to changes\n\nEspecially changes high up in the abstraction hierarchy\n\nHence you should aim to be very sure of the design of your high level classes\nAn alternative approach is to use properties, e.g.\n\n class StockItem(abc.ABC):\n\n     @property\n     def location(self):\n         \"\"\"\n         location : str\n             location in the store where the stock item is stored\n         \"\"\"\n         result = getattr(self, \"_location\", None)\n         return result\n\n     @location.setter\n     def location(self, location):\n         self._location = location\n\nWe define a getter and setter pair as usual. The setter looks pretty much as we would expect\nThe location get method is interesting though\n  result = getattr(self, \"_location\", None)\ngetattr is a python built-in function\nTakes three arguments\n\nAn object to get the attribute from\nThe attribute to get (as a string)\nA default value to return if the attribute is not found\n\nThe default value is returned if the attribute has not been set yet\n\nAttempting to read the location from a StockItem without one will thus return None\n\nNone is discussed in Chapter 7\nThis approach is good because we can dynamically update objects\n\nHowever it has the downside of we now need to find a new in our program to make sure that the location is set\n\nA third option would be to just dynamically add the attribute directly, e.g.\n\n d = Dress(\"D001\", price=100, colour=\"red\", pattern=\"swirly\", size=12)\n d.location = \"Front of Shop\"\n\nIf we use this approach we would probably want to pair it with hasattr\nhasattr is a similar function to getattr\nTakes two arguments\n\nAn object to check for the attribute\nname of the attribute (as a string)\n\nhasattr returns True if the attribute exists, else False\n\n\n d = Dress(\"D001\", 100, \"red\", \"swirly\", 12)\n d.location = \"Front of Shop\"\n\n e = Dress(\"D002\", 100, \"green\", \"swirly\", 12)\n\n def demo_hasattr(obj):\n     if hasattr(obj, \"location\"):\n         print(\"The dress is location: \", d.location)\n     else:\n         print(\"The dress does not have location information\")\n\n demo_hasattr(d)\n demo_hasattr(e)\n\nThe dress is location:  Front of Shop\nThe dress does not have location information\n\n\n\nOf the three methods, what are the pros and cons of each?\n\nAdding location to the __init__ is the most robust, but requires the most changes to the class hierarchy\n\nEnforces location defined\n\nIs robust, and still maintains a cohesive well-defined class via properties, but requires external management of when to define a location\n\nProvides sensible behaviour if an attribute has not been set\nThis behaviour is also hidden from the user\n\nIs simple and easy to write, but fragile since it relies on python’s dynamic attributes\n\nRequires a mental model of how we add those attributes\nLikely breaks a lot of tooling\n\n\nThe third approach is easy and probably fine for small personal projects\n\nNot suitable for large professional applications\nLiable to break and hard to maintain\n\nGenerally when in doubt, the best approach is to use the __init__\n\nMakes it easy to follow since all the attribute code is in the same place\n\n\n\n\n\n\nA technique for following the flow of a program is to add instrumentation to code. The most basic form of instrumentation is to add print statements that show the flow of the program. Work through the following exercise to see how this works.\nFor example the below code demonstrates adding instrumentation to the StockItem class. We add a class level variable show_instrumentation that lets us toggle on or off the instrumentation. The most basic implementation just adds print statements that let us know which classes are called.\n\nimport abc\n\nclass StockItem(abc.ABC):\n\n    show_instrumentation = True # make it optional\n\n    def __init__(self, stock_ref, price, colour, location):\n        if StockItem.show_instrumentation:\n            print(\"**StockItem __init__ called\")\n        self.stock_ref = stock_ref\n        self.__price = price\n        self.__stock_level = 0\n        self.__StockItem_version = 1\n        self.colour = colour\n        self.location = location\n\nEach instrumentation call string is given by the ** prefix to distinguish it from the normal code.\nThe code for the instrumentation is replicated below, and can be found in Instrumented Stock Items. Work through the following code and consider the examples below\n\n# Example 11.5 Fashion Items using Instrumentation\n#\n# Adds optional instrumentation to the StockItem hierarchy to demonstrate the\n# control flow\n\nimport abc\n\n\nclass StockItem(abc.ABC):\n    \"\"\"\n    Abstract base class representing a single inventory item.\n\n    Subclasses are expected to overwrite the `item_name` abstract\n    property with a user friendly string description\n\n    Attributes\n    ----------\n    stock_ref : str\n        reference id of the stock item\n    colour : str\n        description of the item's colour\n\n    Class Attributes\n    ----------------\n    show_instrumentation : bool\n        Indicates if instrumentation should be printed\n    \"\"\"\n\n    show_instrumentation = True\n\n    def __init__(self, stock_ref, price, colour):\n        \"\"\"\n        Creates a `StockItem` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            stock reference id\n        price : int | float\n            stock price\n        colour : str\n            description of stock item's colour\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem __init__ called\")\n        self.stock_ref = stock_ref\n        self.__price = price\n        self.colour = colour\n        self.__stock_level = 0\n        self.__StockItem_version = 1\n\n    def __str__(self):\n        if StockItem.show_instrumentation:\n            print(\"**StockItem __str__ called\")\n        template = \"\"\"Stock Reference: {0}\nType: {1}\nPrice: {2}\nStock level: {3}\nColour: {4}\"\"\"\n        return template.format(\n            self.stock_ref, self.item_name, self.price, self.stock_level, self.colour\n        )\n\n    @property\n    @abc.abstractmethod\n    def item_name(self):\n        \"\"\"\n        item_name : str\n            the stock item's name as a user friendly string\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem item_name called\")\n        pass\n\n    @property\n    def price(self):\n        \"\"\"\n        price : int | float\n            dress price\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem get price called\")\n        return self.__price\n\n    @property\n    def stock_level(self):\n        \"\"\"\n        stock_level : int\n            amount of stock in inventory\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem get stock_level called\")\n        return self.__stock_level\n\n    def check_version(self):\n        \"\"\"\n        Checks the version of a StockItem instance and upgrades it if required\n\n        Returns\n        -------\n        None\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem check_version called\")\n        pass  # for version 1, no need to check\n\n\nclass Dress(StockItem):\n    \"\"\"\n    Represents the inventory details for a Dress\n\n    Inherits from `StockItem`\n\n    Attributes\n    ----------\n    stock_ref : str\n        dress reference id\n    price : int | float\n        dress price\n    colour : str\n        description of dress's colour\n    pattern : str\n        description of the dress pattern\n    size : int\n        dress size\n\n    See Also\n    --------\n    StockItem : Parent Class\n    \"\"\"\n\n    def __init__(self, stock_ref, price, colour, pattern, size):\n        \"\"\"\n        Creates a `Dress` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            stock reference code\n        price : int | float\n            dress price\n        colour : str\n            description of the dress colour\n        pattern : str\n            description of the dress pattern\n        size : int\n            dress size\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**Dress __init__ called\")\n        super().__init__(stock_ref, price, colour)\n        self.pattern = pattern\n        self.size = size\n        self.__Dress_version = 1\n\n    def __str__(self):\n        if StockItem.show_instrumentation:\n            print(\"**Dress __str__ called\")\n        stock_details = super().__str__()\n        template = \"\"\"{0}\nPattern: {1}\nSize: {2}\"\"\"\n        return template.format(stock_details, self.pattern, self.size)\n\n    @property\n    def item_name(self):  # type: ignore\n        if StockItem.show_instrumentation:\n            print(\"**Dress get item_name called\")\n        return \"Dress\"\n\n    def check_version(self):\n        \"\"\"\n        Checks the version of a `Dress` instance and upgrades it if required\n\n        Returns\n        -------\n        None\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**Dress check_version called\")\n        super().check_version()\n\n\nclass Pants(StockItem):\n    \"\"\"\n    Represents the inventory details for a pair of Pants\n\n    Inherits from `StockItem`\n\n    Attributes\n    ----------\n    stock_ref : str\n        pants reference id\n    price : int | float\n        pants price\n    colour : str\n        description of pants's colour\n    pattern : str\n        description of the pants pattern\n    length : int\n        length of the pants\n    waist : int\n        waist size of the pants\n\n    See Also\n    --------\n    StockItem : Parent Class\n    \"\"\"\n\n    def __init__(self, stock_ref, price, colour, pattern, length, waist):\n        \"\"\"\n        Creates a `Pants` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            stock reference code\n        price : int | float\n            pants price\n        colour : str\n            description of the pants colour\n        pattern : str\n            description of the pants pattern\n        length: int\n            length of the pants\n        waist : int\n            pants waist size\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**Pants __init__ called\")\n        super().__init__(stock_ref, price, colour)\n        self.pattern = pattern\n        self.length = length\n        self.waist = waist\n        self.__Pants_version = 1\n\n    def __str__(self):\n        if StockItem.show_instrumentation:\n            print(\"**Pants __str__ called\")\n        stock_details = super().__str__()\n        template = \"\"\"{0}\nPattern: {1}\nLength: {2}\nWaist: {3}\"\"\"\n        return template.format(stock_details, self.pattern, self.length, self.waist)\n\n    @property\n    def item_name(self):  # type: ignore\n        if StockItem.show_instrumentation:\n            print(\"**Pants get item_name called\")\n        return \"Pants\"\n\n    def check_version(self):\n        \"\"\"\n        Checks the version of a `Pants` instance and upgrades it if required\n\n        Returns\n        -------\n        None\n        \"\"\"\n        print(\"**Pants check_version called\")\n        super().check_version()\n\n\nclass Jeans(Pants):\n    \"\"\"\n    Represents the inventory details for a pair of Jeans\n\n    Inherits from `Pants`\n\n    Attributes\n    ----------\n    stock_ref : str\n        jeans reference id\n    price : int | float\n        jeans price\n    colour : str\n        description of jeans colour\n    pattern : str\n        description of the jeans pattern\n    length : int\n        length of the jeans\n    waist : int\n        waist size of the jeans\n    style : str\n        style of the jeans\n\n    See Also\n    --------\n    Pants : Parent Class\n    \"\"\"\n\n    def __init__(self, stock_ref, price, colour, pattern, length, waist, style):\n        \"\"\"\n        Creates a `Jeans` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            jeans reference id\n        price : int | float\n            jeans price\n        colour : str\n            description of jeans colour\n        pattern : str\n            description of the jeans pattern\n        length : int\n            length of the jeans\n        waist : int\n            waist size of the jeans\n        style : str\n            style of the jeans\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**Jeans __init__ called\")\n        super().__init__(stock_ref, price, colour, pattern, length, waist)\n        self.style = style\n        self.__Jeans_version = 1\n\n    def __str__(self):\n        if StockItem.show_instrumentation:\n            print(\"**Jeans __str__ called\")\n        pants_details = super().__str__()\n        template = \"\"\"{0}\nStyle: {1}\"\"\"\n        return template.format(pants_details, self.style)\n\n    @property\n    def item_name(self):  # type: ignore\n        if StockItem.show_instrumentation:\n            print(\"**Jeans get item_name called\")\n        return \"Jeans\"\n\n    def check_version(self):\n        if StockItem.show_instrumentation:\n            print(\"**Jeans check_version called\")\n        super().check_version()\n\nFirst define a new Dress item as described\n\ndress = Dress(stock_ref=\"D001\", price=100, colour=\"Red\", pattern=\"Swirly\", size=12)\n\n**Dress __init__ called\n**StockItem __init__ called\n\n\n\nWe can see that first the Dress __init__ is called\nThen the StockItem __init__ is called (from within the previous __init__)\n\nNow define a new Jeans item as below\n\njeans = Jeans(\n    stock_ref=\"TR12327\",\n    price=50,\n    colour=\"Black\",\n    pattern=\"Plain\",\n    length=30,\n    waist=25,\n    style=\"flared\",\n)\n\n**Jeans __init__ called\n**Pants __init__ called\n**StockItem __init__ called\n\n\n\nWe can see this time there are three __init__ calls, in order they are\n\nJeans\nPants\nStockItem\n\nNow lets see what happens when we try to print a Jeans item\n\n\nprint(jeans)\n\n**Jeans __str__ called\n**Pants __str__ called\n**StockItem __str__ called\n**Jeans get item_name called\n**StockItem get price called\n**StockItem get stock_level called\nStock Reference: TR12327\nType: Jeans\nPrice: 50\nStock level: 0\nColour: Black\nPattern: Plain\nLength: 30\nWaist: 25\nStyle: flared\n\n\n\nWe can see that when we the __str__ method is called from the Jeans subclass\nWe propagate up the class hierarchy calling __str__ for Pants then StockItem\nWithin the StockItem __str__ we see that the getter for item_name is called\n\nBut it resolves to the method on the Jeans object\nThis is because Jeans overrides the item_name property\n\nWithin the StockItem we also call the getters for\n\nprice and stock_level\nThese are not overwritten by Jeans and so resolve to the original StockItem\n\nIf we want to turn off the instrumentation we can change the value of StockItem.show_instrumentation e.g.\n\n\nStockItem.show_instrumentation = False\nprint(jeans)\n\nStock Reference: TR12327\nType: Jeans\nPrice: 50\nStock level: 0\nColour: Black\nPattern: Plain\nLength: 30\nWaist: 25\nStyle: flared\n\n\n\nWe can see now there is no instrumentation printed\nA more advanced form of instrumentation is called logging\n\nLogs are typically stored in a separate file\nCan provide more detailed information and triage of problems\n\n\n\n\n\n\n\nWe use our standard menu structure for the Fashion Shop\n\n    Mary's Fashion Shop\n\n    1: Create a new stock item\n    2: Add stock to an existing structure\n    3: Sell stock\n    4: Stock report\n    5: Exit\n\nEnter your command:\n\n\n\nIf a user selects to create a new stock item we then need to decide what stock item to create\nWe do this by using a sub menu\n  Create a new stock item\n\n  1. Dress\n  2. Pants\n  3. Hat\n  4. Blouse\n  5. Jeans\n\n  Enter item to add:\nThe full code is given in Creating Stock Items\n\n  class StockItem(abc.ABC):\n      \"\"\"\n      Abstract base class representing a single inventory item.\n\n      Subclasses are expected to overwrite the `item_name` abstract\n      property with a user friendly string description\n\n      Attributes\n      ----------\n      stock_ref : str\n          reference id of the stock item\n      colour : str\n          description of the item's colour\n      location : str\n          description of where the pants are located\n\n      Class Attributes\n      ----------------\n      show_instrumentation : bool\n          Indicates if instrumentation should be printed\n\n      min_price : int | float\n          minimum price of any stock item\n\n      max_price : int | float\n          maximum price of any stock item\n      \"\"\"\n\n      show_instrumentation = True\n\n      min_price = 0.5\n      max_price = 500\n\n      def __init__(self, stock_ref, price, colour, location):\n          \"\"\"\n          Creates a `StockItem` instance\n\n          Parameters\n          ----------\n          stock_ref : str\n              stock reference id\n          price : int | float\n              stock price\n          colour : str\n              description of stock item's colour\n          location : str\n              description of where the pants are located\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"**StockItem __init__ called\")\n          self.stock_ref = stock_ref\n          self.__price = price\n          self.colour = colour\n          self.location = location\n          self.__stock_level = 0\n          self.__StockItem_version = 2\n\n      def __str__(self):\n          if StockItem.show_instrumentation:\n              print(\"**StockItem __str__ called\")\n          template = \"\"\"Stock Reference: {0}\n  Type: {1}\n  Price: {2}\n  Stock level: {3}\n  Location: {4}\n  Colour: {5}\"\"\"\n          return template.format(\n              self.stock_ref,\n              self.item_name,\n              self.price,\n              self.stock_level,\n              self.location,\n              self.colour,\n          )\n\n      @property\n      @abc.abstractmethod\n      def item_name(self):\n          \"\"\"\n          item_name : str\n              the stock item's name as a user friendly string\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"**StockItem item_name called\")\n          pass\n\n      @property\n      def price(self):\n          \"\"\"\n          price : int | float\n              dress price\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"**StockItem get price called\")\n          return self.__price\n\n      @property\n      def stock_level(self):\n          \"\"\"\n          stock_level : int\n              amount of stock in inventory\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"**StockItem get stock_level called\")\n          return self.__stock_level\n\n      def check_version(self):\n          \"\"\"\n          Checks the version of a `StockItem` instance and upgrades it if required\n\n          Returns\n          -------\n          None\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"**StockItem check_version called\")\n          if self.__StockItem_version &lt; 2:\n              self.location = None\n              self.__StockItem_version = 2\n\n\n  class Dress(StockItem):\n      \"\"\"\n      Represents the inventory details for a Dress\n\n      Inherits from `StockItem`\n\n      Attributes\n      ----------\n      stock_ref : str\n          dress reference id\n      price : int | float\n          dress price\n      colour : str\n          description of dress's colour\n      pattern : str\n          description of the dress pattern\n      size : int\n          dress size\n      location : str\n          place where the dress is located\n\n      See Also\n      --------\n      StockItem : Parent Class\n      \"\"\"\n\n      def __init__(self, stock_ref, price, colour, pattern, size, location):\n          \"\"\"\n          Creates a `Dress` instance\n\n          Parameters\n          ----------\n          stock_ref : str\n              stock reference code\n          price : int | float\n              dress price\n          colour : str\n              description of the dress colour\n          pattern : str\n              description of the dress pattern\n          size : int\n              dress size\n          location : str\n              place where the dress is located\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"**Dress __init__ called\")\n          super().__init__(stock_ref, price, colour, location)\n          self.pattern = pattern\n          self.size = size\n          self.__Dress_version = 1\n\n      def __str__(self):\n          if StockItem.show_instrumentation:\n              print(\"**Dress __str__ called\")\n          stock_details = super().__str__()\n          template = \"\"\"{0}\n  Pattern: {1}\n  Size: {2}\"\"\"\n          return template.format(stock_details, self.pattern, self.size)\n\n      @property\n      def item_name(self):  # type: ignore\n          if StockItem.show_instrumentation:\n              print(\"**Dress get item_name called\")\n          return \"Dress\"\n\n      def check_version(self):\n          \"\"\"\n          Checks the version of a `Dress` instance and upgrades it if required\n\n          Returns\n          -------\n          None\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"**Dress check_version called\")\n          super().check_version()\n\n\n  class Pants(StockItem):\n      \"\"\"\n      Represents the inventory details for a pair of Pants\n\n      Inherits from `StockItem`\n\n      Attributes\n      ----------\n      stock_ref : str\n          pants reference id\n      price : int | float\n          pants price\n      colour : str\n          description of pants's colour\n      pattern : str\n          description of the pants pattern\n      length : int\n          length of the pants\n      waist : int\n          waist size of the pants\n      location : str\n          description of where the pants are located\n\n      See Also\n      --------\n      StockItem : Parent Class\n      \"\"\"\n\n      def __init__(self, stock_ref, price, colour, pattern, length, waist, location):\n          \"\"\"\n          Creates a `Pants` instance\n\n          Parameters\n          ----------\n          stock_ref : str\n              stock reference code\n          price : int | float\n              pants price\n          colour : str\n              description of the pants colour\n          pattern : str\n              description of the pants pattern\n          length: int\n              length of the pants\n          waist : int\n              pants waist size\n          location : str\n              description of where the pants are located\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"**Pants __init__ called\")\n          super().__init__(stock_ref, price, colour, location)\n          self.pattern = pattern\n          self.length = length\n          self.waist = waist\n          self.__Pants_version = 1\n\n      def __str__(self):\n          if StockItem.show_instrumentation:\n              print(\"**Pants __str__ called\")\n          stock_details = super().__str__()\n          template = \"\"\"{0}\n  Pattern: {1}\n  Length: {2}\n  Waist: {3}\"\"\"\n          return template.format(stock_details, self.pattern, self.length, self.waist)\n\n      @property\n      def item_name(self):  # type: ignore\n          if StockItem.show_instrumentation:\n              print(\"**Pants get item_name called\")\n          return \"Pants\"\n\n      def check_version(self):\n          \"\"\"\n          Checks the version of a `Pants` instance and upgrades it if required\n\n          Returns\n          -------\n          None\n          \"\"\"\n          print(\"**Pants check_version called\")\n          super().check_version()\n\n\n  class Jeans(Pants):\n      \"\"\"\n      Represents the inventory details for a pair of Jeans\n\n      Inherits from `Pants`\n\n      Attributes\n      ----------\n      stock_ref : str\n          jeans reference id\n      price : int | float\n          jeans price\n      colour : str\n          description of jeans colour\n      pattern : str\n          description of the jeans pattern\n      length : int\n          length of the jeans\n      waist : int\n          waist size of the jeans\n      style : str\n          style of the jeans\n      location : str\n          description of where the pants are located\n\n      See Also\n      --------\n      Pants : Parent Class\n      \"\"\"\n\n      def __init__(\n          self, stock_ref, price, colour, pattern, length, waist, style, location\n      ):\n          \"\"\"\n          Creates a `Jeans` instance\n\n          Parameters\n          ----------\n          stock_ref : str\n              jeans reference id\n          price : int | float\n              jeans price\n          colour : str\n              description of jeans colour\n          pattern : str\n              description of the jeans pattern\n          length : int\n              length of the jeans\n          waist : int\n              waist size of the jeans\n          style : str\n              style of the jeans\n          location : str\n              description of where the jeans are located\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"**Jeans __init__ called\")\n          super().__init__(stock_ref, price, colour, pattern, length, waist, location)\n          self.style = style\n          self.__Jeans_version = 1\n\n      def __str__(self):\n          if StockItem.show_instrumentation:\n              print(\"**Jeans __str__ called\")\n          pants_details = super().__str__()\n          template = \"\"\"{0}\n  Style: {1}\"\"\"\n          return template.format(pants_details, self.style)\n\n      @property\n      def item_name(self):  # type: ignore\n          if StockItem.show_instrumentation:\n              print(\"**Jeans get item_name called\")\n          return \"Jeans\"\n\n      def check_version(self):\n          if StockItem.show_instrumentation:\n              print(\"**Jeans check_version called\")\n          super().check_version()\n\n\n  class Hat(StockItem):\n      \"\"\"\n      Represents the inventory details for a Hat\n\n      Inherits from `StockItem`\n\n      Attributes\n      ----------\n      stock_ref : str\n          hat reference id\n      price : int | float\n          hat price\n      colour : str\n          description of hats colour\n      size : int\n          Hat size in diameter\n      location : str\n          description of where the hat is located\n\n      See Also\n      --------\n      StockItem : Parent Class\n      \"\"\"\n\n      def __init__(self, stock_ref, price, colour, size, location):\n          \"\"\"\n          Creates a `Hat` instance\n\n          Parameters\n          ----------\n          stock_ref : str\n              hat stock reference id\n          price : int | float\n              hat price\n          colour : str\n              hat colour\n          size : int\n              hat size in diameter\n          location : str\n              where the hat is located in the store\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"**Hat __init__ called\")\n          super().__init__(stock_ref, price, colour, location)\n          self.size = size\n          self.__Hat_version = 1\n\n      def __str__(self):\n          if StockItem.show_instrumentation:\n              print(\"** Hat __str__ called\")\n          stock_details = super().__str__()\n          template = \"\"\"{0}\n  Size: {1}\"\"\"\n          return template.format(stock_details, self.size)\n\n      @property\n      def item_name(self):  # type: ignore\n          if StockItem.show_instrumentation:\n              print(\"** Hat get item_name called\")\n          return \"Hat\"\n\n      def check_version(self):\n          \"\"\"\n          Checks the version and upgrades a `Hat` instance as requires\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"** Hat check_version called\")\n          super().check_version()\n\n\n  class Blouse(StockItem):\n      \"\"\"\n      Represents the inventory details for a Blouse\n\n      Inherits from `StockItem`\n\n      Attributes\n      ----------\n      stock_ref : str\n          stock reference code\n      price : int | float\n          blouse price\n      colour : str\n          description of the blouse colour\n      pattern : str\n          description of the blouse pattern\n      style : str\n          description of the blouse style\n      size : int\n          blouse size\n      location : str\n          place where the blouse is located\n\n      See Also\n      --------\n      StockItem : Parent Class\n      \"\"\"\n\n      def __init__(self, stock_ref, price, colour, pattern, style, size, location):\n          \"\"\"\n          Creates a `Blouse` instance\n\n          Parameters\n          ----------\n          stock_ref : str\n              stock reference code\n          price : int | float\n              blouse price\n          colour : str\n              description of the blouse colour\n          pattern : str\n              description of the blouse pattern\n          style : str\n              description of the blouse style\n          size : int\n              blouse size\n          location : str\n              place where the blouse is located\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"** Blouse __init__ called\")\n          super().__init__(stock_ref, price, colour, location)\n          self.pattern = pattern\n          self.style = style\n          self.size = size\n          self.__Blouse_version = 1\n\n      def __str__(self):\n          if StockItem.show_instrumentation:\n              print(\"** Blouse __str__ called\")\n          stock_details = super().__str__()\n          template = \"\"\"{0}\n  Size: {1}\n  Style: {2}\n  Pattern: {3}\"\"\"\n          return template.format(stock_details, self.size, self.style, self.pattern)\n\n      @property\n      def item_name(self):  # type: ignore\n          if StockItem.show_instrumentation:\n              print(\"** Blouse get item_name called\")\n          return \"Blouse\"\n\n      def check_version(self):\n          \"\"\"\n          Checks the version and upgrades a `Blouse` instance as required\n\n          Returns\n          -------\n          None\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"** Blouse check_version called\")\n          return super().check_version()\n\nWe’ve implemented in all our remaining subclasses Hat and Blouse\nWe’ve also added the location variable\nOur Menu looks pretty straight forward now\nIn StockItem we’ve also added extra class attributes\n\nmin_price and\nmax_price\nThese are designed to be used by external validators\n\nWe can add validation directly to the classes later\n\n\n\nmenu = \"\"\"\nCreate a new stock item\n\n1. Dress\n2. Pants\n3. Hat\n4. Blouse\n5. Jeans\n\nEnter item to add: \"\"\"\n\nfirst_menu_option = 1\nlast_menu_option = 5\n\nmin_stock_item_size = 0\nmax_stock_item_size = 99\n\nitem = BTCInput.read_int_ranged(menu, first_menu_option, last_menu_option)\n\nif item &lt; first_menu_option or item &gt; last_menu_option:\n    raise ValueError(\n        \"Unexpected value {0} found in menu. Please raise a bug report\".format(item)\n    )\n\nWe define our standard menu framework\nThe min_stock_item_size and max_stock_item_size are variables that store the min and max of any size related properties like size, length, waist etc.\nWe then get the user’s choice and check that it’s valid\n\nThis is our usual mechanism of making the code robust to changes\nWhen we add a command first_menu_option and/or second_menu_option should be updated\nNeeds to be replicated through to getting user input\nThe guard clause makes sure these align\n\nNow we have a valid item we can get the common attributes for a StockItem\n  # now we have a valid item so get the common attributes\n  stock_ref = BTCInput.read_text(\"Enter Stock reference: \")\n  price = BTCInput.read_float_ranged(\n      \"Enter price: \", min_value=StockItem.min_price, max_value=StockItem.max_price\n  )\n  colour = BTCInput.read_text(\"Enter colour: \")\n  location = BTCInput.read_text(\"Enter location: \")\nThen we implement the menu choices as below\nWe report to the user what object we’re creating\nWe then ask for the attributes unique to that stock item type\nThen create the appropriate object\n  if item == 1:\n  print(\"Creating a Dress\")\n  pattern = BTCInput.read_text(\"Enter pattern: \")\n  size = BTCInput.read_int_ranged(\n      \"Enter size: \", min_value=min_stock_item_size, max_value=max_stock_item_size\n  )\n  stock_item = Dress(stock_ref, price, colour, pattern, size, location)\n\n  elif item == 2:\n      print(\"Creating a pair of Pants\")\n      pattern = BTCInput.read_text(\"Enter pattern: \")\n      length = BTCInput.read_int_ranged(\n          \"Enter length: \", min_value=min_stock_item_size, max_value=max_stock_item_size\n      )\n      waist = BTCInput.read_int_ranged(\n          \"Enter waist size: \",\n          min_value=min_stock_item_size,\n          max_value=max_stock_item_size,\n      )\n      stock_item = Pants(stock_ref, price, colour, pattern, length, waist, location)\n\n  elif item == 3:\n      print(\"Creating a Hat\")\n      size = BTCInput.read_int_ranged(\n          \"Enter size: \", min_value=min_stock_item_size, max_value=max_stock_item_size\n      )\n      stock_item = Hat(stock_ref, price, colour, size, location)\n\n  elif item == 4:\n      print(\"Creating a Blouse\")\n      pattern = BTCInput.read_text(\"Enter pattern: \")\n      style = BTCInput.read_text(\"Enter style: \")\n      size = BTCInput.read_int_ranged(\n          \"Enter size: \", min_value=min_stock_item_size, max_value=max_stock_item_size\n      )\n      stock_item = Blouse(stock_ref, price, colour, pattern, style, size, location)\n\n  elif item == 5:\n      print(\"Creating a pair of Jeans\")\n      pattern = BTCInput.read_text(\"Enter pattern: \")\n      style = BTCInput.read_text(\"Enter style: \")\n      length = BTCInput.read_int_ranged(\n          \"Enter length: \", min_value=min_stock_item_size, max_value=max_stock_item_size\n      )\n      waist = BTCInput.read_int_ranged(\n          \"Enter waist size: \",\n          min_value=min_stock_item_size,\n          max_value=max_stock_item_size,\n      )\n      stock_item = Jeans(\n          stock_ref, price, colour, pattern, length, waist, style, location\n      )\n  else:\n      stock_item = None\nAn example output from this program might then look like\n\n\n\n\nCreate a new stock item\n\n\n\n1. Dress\n\n2. Pants\n\n3. Hat\n\n4. Blouse\n\n5. Jeans\n\n\n\nEnter item to add:  1\n\nEnter Stock reference: DO001\n\nEnter price: 100\n\nEnter colour: Red\n\nEnter location: Shop Window\n\nCreating a Dress\n\nEnter pattern: Swirly\n\nEnter size: 12\n\nEnter location: Front Window\n\n**Dress __init__ called\n\n**StockItem __init__ called\n\n**Dress __str__ called\n\n**StockItem __str__ called\n\n**Dress get item_name called\n\n**StockItem get price called\n\n**StockItem get stock_level called\n\nStock Reference: D001\n\nType: Dress\n\nPrice: 100\n\nStock level: 0\n\nLocation: Front Window\n\nColour: Red\n\nPattern: Swirly\n\nSize: 12\n\n\n\n\n\nIn the future we will look at how to wrap these user interactions in a class FashionShopShellApplication\n\n\n\n\n\nWhen items are created they start with a default stock level of \\(0\\)\nWe need some way to increase a stock item’s stock level when an order arrives\nWe can’t directly modify __stock_level as it’s private\nSo we need to add a method\n\n\n# Example 11.7 Updating Stock Levels on an Item\n#\n# Continues demonstrating behaviours of the fashion shop, here we highlight how\n# to implement adding to stock levels\n\nimport abc\n\n\nclass StockItem(abc.ABC):\n    \"\"\"\n    Abstract base class representing a single inventory item.\n\n    Subclasses are expected to overwrite the `item_name` abstract\n    property with a user friendly string description\n\n    Attributes\n    ----------\n    stock_ref : str\n        reference id of the stock item\n    colour : str\n        description of the item's colour\n    location : str\n        description of where the pants are located\n\n    Class Attributes\n    ----------------\n    show_instrumentation : bool\n        Indicates if instrumentation should be printed\n\n    max_stock_add : int\n        maximum amount of stock that can be added to an item's stock level at a time\n    \"\"\"\n\n    show_instrumentation = True\n\n    max_stock_add = 10\n\n    def __init__(self, stock_ref, price, colour, location):\n        \"\"\"\n        Creates a `StockItem` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            stock reference id\n        price : int | float\n            stock price\n        colour : str\n            description of stock item's colour\n        location : str\n            description of where the pants are located\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem __init__ called\")\n        self.stock_ref = stock_ref\n        self.__price = price\n        self.colour = colour\n        self.location = location\n        self.__stock_level = 0\n        self.__StockItem_version = 2\n\n    def __str__(self):\n        if StockItem.show_instrumentation:\n            print(\"**StockItem __str__ called\")\n        template = \"\"\"Stock Reference: {0}\nType: {1}\nPrice: {2}\nStock level: {3}\nLocation: {4}\nColour: {5}\"\"\"\n        return template.format(\n            self.stock_ref,\n            self.item_name,\n            self.price,\n            self.stock_level,\n            self.location,\n            self.colour,\n        )\n\n    @property\n    @abc.abstractmethod\n    def item_name(self):\n        \"\"\"\n        item_name : str\n            the stock item's name as a user friendly string\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem item_name called\")\n        pass\n\n    @property\n    def price(self):\n        \"\"\"\n        price : int | float\n            dress price\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem get price called\")\n        return self.__price\n\n    @property\n    def stock_level(self):\n        \"\"\"\n        stock_level : int\n            amount of stock in inventory\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem get stock_level called\")\n        return self.__stock_level\n\n    def check_version(self):\n        \"\"\"\n        Checks the version of a `StockItem` instance and upgrades it if required\n\n        Returns\n        -------\n        None\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem check_version called\")\n        if self.__StockItem_version &lt; 2:\n            self.location = None\n            self.__StockItem_version = 2\n\n    def add_stock(self, count):\n        \"\"\"\n        Add stock to an item\n\n        Parameters\n        ----------\n        count : int\n            amount of stock to add to an item\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        Exception\n            raised if `count` &lt; 0 or `count` &gt; `StockItem.max_stock_add`\n\n        See Also\n        --------\n        StockItem.max_stock_add : maximum amount of stock that can be added to a `StockItem`\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem add_stock called\")\n        if count &lt; 0 or count &gt; StockItem.max_stock_add:\n            raise Exception(\"Invalid add amount\")\n        self.__stock_level = self.__stock_level + count\n\n\nclass Dress(StockItem):\n    \"\"\"\n    Represents the inventory details for a Dress\n\n    Inherits from `StockItem`\n\n    Attributes\n    ----------\n    stock_ref : str\n        dress reference id\n    price : int | float\n        dress price\n    colour : str\n        description of dress's colour\n    pattern : str\n        description of the dress pattern\n    size : int\n        dress size\n    location : str\n        place where the dress is located\n\n    See Also\n    --------\n    StockItem : Parent Class\n    \"\"\"\n\n    def __init__(self, stock_ref, price, colour, pattern, size, location):\n        \"\"\"\n        Creates a `Dress` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            stock reference code\n        price : int | float\n            dress price\n        colour : str\n            description of the dress colour\n        pattern : str\n            description of the dress pattern\n        size : int\n            dress size\n        location : str\n            place where the dress is located\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**Dress __init__ called\")\n        super().__init__(stock_ref, price, colour, location)\n        self.pattern = pattern\n        self.size = size\n        self.__Dress_version = 1\n\n    def __str__(self):\n        if StockItem.show_instrumentation:\n            print(\"**Dress __str__ called\")\n        stock_details = super().__str__()\n        template = \"\"\"{0}\nPattern: {1}\nSize: {2}\"\"\"\n        return template.format(stock_details, self.pattern, self.size)\n\n    @property\n    def item_name(self):  # type: ignore\n        if StockItem.show_instrumentation:\n            print(\"**Dress get item_name called\")\n        return \"Dress\"\n\n    def check_version(self):\n        \"\"\"\n        Checks the version of a `Dress` instance and upgrades it if required\n\n        Returns\n        -------\n        None\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**Dress check_version called\")\n        super().check_version()\n\n\nWe add a new class attribute max_stock_add which defines the maximum amount of stock that can be added to an item in one go\nWe then define an add_stock method\n  def add_stock(self, count):\n      \"\"\"\n      Add stock to an item\n\n      Parameters\n      ----------\n      count : int\n          amount of stock to add to an item\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      Exception\n          raised if `count` &lt; 0 or `count` &gt; `StockItem.max_stock_add`\n\n      See Also\n      --------\n      StockItem.max_stock_add : maximum amount of stock that can be added to a `StockItem`\n      \"\"\"\n      if StockItem.show_instrumentation:\n          print(\"**StockItem add_stock called\")\n      if count &lt; 0 or count &gt; StockItem.max_stock_add:\n          raise Exception(\"Invalid add amount\")\n      self.__stock_level = self.__stock_level + count\nWe first validate the count variable\n\nRaising an Exception if invalid so it can be handled\n\nOnce validated we can directly update the private variable\nLet us see how this works with a Dress now\n\n  d = Dress(\n      \"D0001\", price=100, colour=\"Red\", pattern=\"Swirly\", size=12, location=\"Shop Window\"\n  )\n  d.add_stock(5)\n  print(d)\n\n**Dress __init__ called\n**StockItem __init__ called\n**StockItem add_stock called\n**Dress __str__ called\n**StockItem __str__ called\n**Dress get item_name called\n**StockItem get price called\n**StockItem get stock_level called\nStock Reference: D0001\nType: Dress\nPrice: 100\nStock level: 5\nLocation: Shop Window\nColour: Red\nPattern: Swirly\nSize: 12\n\n\nWe can see the Stock Level is now \\(5\\)\nWhat happens if we try to add more than StockItem.max_stock_add?\n\n\nd.add_stock(15)\n\n**StockItem add_stock called\n\n\n\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\nCell In[38], line 1\n----&gt; 1 d.add_stock(15)\n\nCell In[36], line 150, in StockItem.add_stock(self, count)\n    148     print(\"**StockItem add_stock called\")\n    149 if count &lt; 0 or count &gt; StockItem.max_stock_add:\n--&gt; 150     raise Exception(\"Invalid add amount\")\n    151 self.__stock_level = self.__stock_level + count\n\nException: Invalid add amount\n\n\n\n\nWell as expected we get an Exception, showing our error-handling is working correctly\nAs the above shows, by adding the method directly to StockItem it is automatically available to all of the subclasses without the need to write extra code\n\n\n\n\n\nNow we need to account for the opposite case where stock is sold\nThe stock level will correspondingly decrease\nWe do this with another method on StockItem\n  class StockItem(abc.ABC):\n      \"\"\"\n      Stock Item for the Fashion Shop\n      \"\"\"\n      ...\n\n      def sell_stock(self, count):\n          if count &lt; 1:\n              raise Exception(\"Invalid number of items to sell\")\n          if count &gt; self.__stock_level:\n              raise Exception(\"Not enough stock to sell\")\n          self.__stock_level = self.__stock_level - count\nThe amount to sell is given by the count parameter\nWe raise an exception in two cases\n\nThe user tries to sell \\(&lt; 1\\) items, since this physically doesn’t make sense\nThe user tries to sell more items than are available i.e. count \\(&gt;\\) self.__stock_level\n\nLet’s see how this plays out with the Dress class\n\n  d = Dress(\n      \"D0001\", price=100, colour=\"Red\", pattern=\"Swirly\", size=12, location=\"Shop Window\"\n  )\n  d.add_stock(5)\n  d.sell_stock(1)\n  print(d)\n\n**Dress __init__ called\n**StockItem __init__ called\n**StockItem add_stock called\n**StockItem sell_stock called\n**Dress __str__ called\n**StockItem __str__ called\n**Dress get item_name called\n**StockItem get price called\n**StockItem get stock_level called\nStock Reference: D0001\nType: Dress\nPrice: 100\nStock level: 4\nLocation: Shop Window\nColour: Red\nPattern: Swirly\nSize: 12\n\n\nAnd again what happens if we try to do something invalid like selling more stock than we have\n\n  d.sell_stock(10)\n\n**StockItem sell_stock called\n\n\n\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\nCell In[41], line 1\n----&gt; 1 d.sell_stock(10)\n\nCell In[39], line 178, in StockItem.sell_stock(self, count)\n    176     raise Exception(\"Invalid number of items to sell\")\n    177 if count &gt; self.__stock_level:\n--&gt; 178     raise Exception(\"Not enough stock to sell\")\n    179 self.__stock_level = self.__stock_level - count\n\nException: Not enough stock to sell\n\n\n\nAs expected, an exception is raised\n\n\n\n\n\n\nWe have completed the StockItem and it’s associated class hierarchy\nAll behaviours given by the fashion shop item data spec is now implemented by the class and its subclasses\nStockItem is a purely self-contained and cohesive\nWe’ve done some basic testing of the external behaviours\n\nLater we’ll look at how to implement automatic testing of our objects\n\nSometimes we call a cohesive, self-contained part a component\nE.g. in a car production line different parts of the line produce different parts, like the motor, panels, transmission etc.\n\nAll are made separately and the final product is composed of all the parts\n\nWe would like to do something similar with StockItem\n\nMove it around as it’s own component\nCan then potentially reuse it as it’s own feature in other projects\n\n\n\n\n\n\n\n\nTip\n\n\n\nSelf-contained components are a great way to build software\nBreaking software projects down into individual components is a great design philosophy. When you’re working solo it lets you focus on a small completable part of the program and progressively build up the complexity. When working with a larger team, different parts of the team can be assigned to work on the different independent components without interfering with each others work.\nFor example in our fashion shop project someone could be building the StockItem while another person works on the UI\n\n\n\n\n\n\n\nWe have implemented a complete StockItem component\n\nRepresents everything about a single item of stock\n\nNow we want to create a component that handles the management of collections of stock\nWe will call this component FashionShop\nWe identify the following requirements\n\nCreate a new fashion shop\nSave the fashion shop stock data to a file\nLoad the data from a file\nStore a new stock item\nFind a particular stock item\nProvide a listing of all stock items\n\nWe can start by stubbing out our class, (the template code is given by Fashion Shop Prototype)\n  # Example 11.9 Fashion Stock Prototype\n  #\n  # Provides a stubbed out template for the FashionShop Class\n\n\n  class FashionShop:\n      \"\"\"\n      Represents the inventory management system of a Fashion Shop\n      \"\"\"\n\n      def __init__(self):\n          \"\"\"\n          Create a new `FashionShop` instance\n          \"\"\"\n          pass\n\n      def save(self, filename):\n          \"\"\"\n          Save the `FashionShop` to a given file\n\n          `FashionShop` is saved as a pickled binary file in the file given\n          by `filename`. The file is created if it doesn't exist. If the file\n          already exists it is overwritten\n\n          Parameters\n          ----------\n          filename : str\n              path to the file to save\n\n          Returns\n          -------\n          None\n\n          Raises\n          ------\n          Exceptions\n              raised if the file fails to save\n\n          See Also\n          --------\n          FashionShop.load : load a `FashionShop` object from a file\n          \"\"\"\n          pass\n\n      @staticmethod\n      def load(filename):\n          \"\"\"\n          Create a `FashionShop` instance from a pickled binary file\n\n          Parameters\n          ----------\n          filename : str\n              path to a file containing pickled `FashionShop` data\n\n          Returns\n          -------\n          FashionShop\n              the loaded `FashionShop` instance\n\n          Raises\n          ------\n          Exceptions\n              raised if the file fails to load\n\n          See Also\n          --------\n          FashionShop.save : saves a `FashionShop` instance\n          \"\"\"\n          pass\n\n      def store_new_stock_item(self, item):\n          \"\"\"\n          Store a new item in the reference system\n\n          The provided `item` can be indexed by it's `stock_ref` parameter\n\n          Parameters\n          ----------\n          item : StockItem\n              item to add to the inventory system\n\n          Returns\n          -------\n          None\n\n          Raises\n          ------\n          KeyError\n              Raised if the item's `stock_ref` is already registered as a key\n          \"\"\"\n          pass\n\n      def find_stock_item(self, stock_ref):\n          \"\"\"\n          Find the stock item with the corresponding reference id\n\n          Parameters\n          ----------\n          stock_ref : str\n              stock reference id of the item to find\n\n          Returns\n          -------\n          StockItem | None\n              Returns a `StockItem` with a matching `stock_ref` else `None`\n          \"\"\"\n          return None\n\n      def __str__(self):\n          return \"\"\nWe’ll now start by filling in these methods one by one\nWe provide a complete docstring which documents what the function should do\n\nMeans someone else could come and implement it if we were working in a team\n\nSome methods return placeholder values\n\nThese implement partial functionality\ne.g. find_stock_item always returns None at the moment\n\nA program utilising FashionShop needs only call the methods based on the description\n\nDoes not need to know about the internals\n\n\n\n\n\nOur first step is to define our data attributes and define the __init__\nWe’ll start by using a dictionary to store our items\n\n  class FashionShop:\n\n      def __init__(self):\n          self.__stock_dictionary = {}\n\nThe __init__ takes no arguments\nPurely creates an empty dictionary (self.__stock_dictionary) to store future stock items\nWe make the dictionary private to avoid accidental modification\nWe can now create a new FashionShop\n\n  shop = FashionShop()\n  print(shop)\n\n&lt;__main__.FashionShop object at 0x7f71f0bc6690&gt;\n\n\n\n\n\n\n\nWe’ll use the same approach we’ve used before of pickling our files\nWorks exactly as we’ve seen before\n  class FashionShop:\n\n      def save(self, filename):\n          with open(filename, \"wb\") as out_file:\n              pickle.dump(self, out_file)\nWe use with to handle making sure the file is properly cleaned up once we’re done\nWe pass self to pickle.dump to save the object instance on which save is called\nThe below example demonstrates creating an (empty) FashionShop shop and then saving it\n  shop = FashionShop()\n  shop.save(\"FashionShop.pickle\")\n\n\n\n\n\nThe load in our template is marked as a @staticmethod\nWe can’t make it a object method, because there is no object yet\nMake it static so it’s still associated with the class\nThis means we want the load method to create and return a new FashionShop item\n  class FashionShop:\n      ...\n      def load(filename):\n          with open(filename, \"rb\") as input_file:\n              shop = pickle.load(input_file)\n          return shop\nIf we wanted to load the FashionShop object we had saved above we would write\n```python loaded_shop = FashionShop.load(“FashionShop.pickle”)\n\n\n\n\n\nFashionShop is effectively a container for StockItem objects\nAt the moment the underlying model is a dictionary\nWe can’t add new items directly to the dictionary for two reasons\n\nWe’ve made it private so we can’t directly add them\nWe want to prevent adding multiple items with the same reference\n\nAs mentioned above we want to prevent duplicates\nHow should we handle duplicates?\n\nWe could use a status code, but as said, we should favour exceptions\nWe’ll return a KeyError if the key already exists\nWe then need to document this in the docstring\n\n  class FashionShop:\n      ...\n  def store_new_stock_item(self, item):\n      \"\"\"\n      Store a new item in the reference system\n\n      The provided `item` can be indexed by it's `stock_ref` parameter\n\n      Parameters\n      ----------\n      item : StockItem\n          item to add to the inventory system\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      KeyError\n          Raised if the item's `stock_ref` is already registered as a key\n      \"\"\"\n      if item.stock_ref in self.__stock_dictionary:\n          raise KeyError(\"This stock reference is already used\")\n      self.__stock_dictionary[item.stock_ref] = item\nstore_new_stock_item adds a new stock item to the container\nIt does not create one, we have to do that separately\nThe method checks for duplicates, throwing a KeyError if the stock reference is already used\nIf no exception is raised, the item is inserted into the stock dictionary\nLet us see this in practice,\n\n  dress = Dress(stock_ref=\"D001\", price=100, colour=\"red\", pattern=\"swirly\", size=12, location=\"front\")\n  shop = FashionShop()\n  shop.store_new_stock_item(dress)\n\n**Dress __init__ called\n**StockItem __init__ called\n\n\nAnd if we try to add it again…\n\n  shop.store_new_stock_item(dress)\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[46], line 1\n----&gt; 1 shop.store_new_stock_item(dress)\n\nCell In[44], line 93, in FashionShop.store_new_stock_item(self, item)\n     73 \"\"\"\n     74 Store a new item in the reference system\n     75 \n   (...)     90     Raised if the item's `stock_ref` is already registered as a key\n     91 \"\"\"\n     92 if item.stock_ref in self.__stock_dictionary:\n---&gt; 93     raise KeyError(\"This stock reference is already used\")\n     94 self.__stock_dictionary[item.stock_ref] = item\n\nKeyError: 'This stock reference is already used'\n\n\n\n\n\n\n\n\nFinding stock is implemented as a dictionary lookup\nDictionaries provide the get method\n\nActs as a normal dictionary lookup\nHowever if the key is missing a default value is returned\nThe default value for this default parameter is None\n\n  class FashionShop:\n      ...\n      def find_stock_item(self, stock_ref):\n          \"\"\"\n          Find the stock item with the corresponding reference id\n\n          Parameters\n          ----------\n          stock_ref : str\n              stock reference id of the item to find\n\n          Returns\n          -------\n          StockItem | None\n              Returns a `StockItem` with a matching `stock_ref` else `None`\n          \"\"\"\n          return self.__stock_dictionary.get(stock_ref)\nThe calling code is responsible for checking that the returned value is a valid StockItem\nLet’s demonstrate this by trying to find the dress we just added, and one that didn’t exist\n\n\nprint(shop.find_stock_item(\"D001\"))\nprint(shop.find_stock_item(\"AAAA\"))\n\n**Dress __str__ called\n**StockItem __str__ called\n**Dress get item_name called\n**StockItem get price called\n**StockItem get stock_level called\nStock Reference: D001\nType: Dress\nPrice: 100\nStock level: 0\nLocation: front\nColour: red\nPattern: swirly\nSize: 12\nNone\n\n\n\n\n\n\nFinal step is to list the stock data\nWe want this in the form a human-readable string\nWe can use a similar approach seen with our Session class in [Chapter 10](../10_UseClassesToCreateActiveObjects/Chapter_10.qmd#code-analysis-creating-a-session-class)     -StockItemprovides astr` method\n\nWe can iterate over the container items to get all of these\nThen just have to nicely format the container\n\n  class FashionShop:\n      ...\n      def __str__(self):\n          stock = map(str, self.__stock_dictionary.values())\n          stock_list = \"\\n\".join(stock)\n          template = \"\"\"Items in Stock\n  {0}\n  \"\"\"\n      return template.format(stock_list)\nLet’s put everything we’ve put together in practice\nWe’ll create two items and add them to the shop then print the contents\nYou can find the complete implementation of the fashion shop class in Fashion Shop\n\nLike our instrumented version of StockItem, FashionShop provides instrumentation so you can view the program flow\n\n\n\ndress = Dress(\n    stock_ref=\"D001\",\n    price=100,\n    colour=\"red\",\n    pattern=\"swirly\",\n    size=12,\n    location=\"front\",\n)\npants = Pants(\n    stock_ref=\"A002\",\n    price=200,\n    colour=\"cream\",\n    pattern=\"plain\",\n    length=12,\n    waist=34,\n    location=\"back right corner\",\n)\n\nshop = FashionShop()\nshop.store_new_stock_item(dress)\nshop.store_new_stock_item(pants)\nprint(shop)\n\n**Dress __init__ called\n**StockItem __init__ called\n**Pants __init__ called\n**StockItem __init__ called\n**FashionShop __init__ called\n**FashionShop store new stock item called\n**FashionShop store new stock item called\n**Dress __str__ called\n**StockItem __str__ called\n**Dress get item_name called\n**StockItem get price called\n**StockItem get stock_level called\n**Pants __str__ called\n**StockItem __str__ called\n**Pants get item_name called\n**StockItem get price called\n**StockItem get stock_level called\n\nStock Reference: D001\nType: Dress\nPrice: 100\nStock level: 0\nLocation: front\nColour: red\nPattern: swirly\nSize: 12\nStock Reference: A002\nType: Pants\nPrice: 200\nStock level: 0\nLocation: back right corner\nColour: cream\nPattern: plain\nLength: 12\nWaist: 34\n\n\n\n\n\n\nYou can use a similar structure to the FashionShop inventory management class for any program that needs to manage a key-based lookup of items, examples may include a bank account management system, a doll collection or competition entries\nImplement a basic bank account management system. The system should have three different account types\n\nSavings accounts\n\nHave an account number, a monthly interest rate, a balance, and a person associated with the account\nA savings account can have money deposited or withdrawn\nA savings account balance cannot be negative\nEvery month a savings account balance is increased by the interest rate\n\nLong-term savings account\n\nLike a savings account\nHowever also has a start date, and a term maturation period\nMoney cannot be withdrawn from a long-term savings account before the maturation date\nOnce a long-term savings deposit has matured the interest rate is quartered\nAn account holder can either reinvest a matured long-term savings deposit (starting a new term and maturation)\n\nOr close out a matured long-term deposit transferring it to another account\n\n\nCredit Account\n\nHave a maximum withdrawal limit\nA credit account balance cannot be positive\nEvery month a credit account balance is increased by the interest rate (i.e. any unpaid credit is increased)\nA credit account can not have a negative balance whose magnitude is greater than the maximum withdrawal limit\n\n\nThe bank system should have a similar interface to the FashionShop, with the following,\n\nCreate a new bank system\nSave the bank system data to a file\nLoad the data from a file\nStore a new bank account\nFind a particular bank account\nProvide a listing of all accounts\nFind all accounts associated with a particular person\n\nLets start by mapping out a class hierarchy for accounts. We can see that all accounts have a number, interest rate, balance and an associated account holder, each also supports being able to withdraw or deposit money and have interest applied, however they each implement these methods differently. So we’ll define an abstract base class Account that provides these data attributes and declares these methods. Subclasses then overwrite the method.\nOur first subclass will be a savings account which requires no additional data attributes. Our second is a long-term savings account. This acts like a saving account but also has a maturation period and a start date. There are additional restrictions on how the account operates depending on if it has matured or not, so we’ll inherit from a Savings Account. A credit account has different behaviours for its deposit and withdraw methods and has a maximum withdrawal limit, so will be a subclass derived from the base account class\n\n\n\n\n\n---\ntitle: Account Class Diagram\n---\n\nclassDiagram\n    class object\n\n    class Account {\n        str account_number\n        str account_holder\n        number interest_rate\n        number balance\n        deposit()\n        withdraw()\n        apply_interest()\n    }\n\n    class SavingsAccount\n\n    class LongTermSavingsAccount {\n        date start_date\n        int term_period\n    }\n\n    class CreditAccount {\n        number max_withdrawal_limit\n    }\n\n    object &lt;|-- Account\n    Account &lt;|-- SavingsAccount\n    SavingsAccount &lt;|--  LongTermSavingsAccount\n    Account &lt;|-- CreditAccount\n\n\n\n\n\n\nOur abstract base class is fairly simple, it defines the properties and the abstract methods. You’ll observe that we make the majority of data attributes read-only. This is because when dealing with people’s money we want to be really careful about inappropriate changes!\n\nimport datetime\n\n\nclass Account(abc.ABC):\n    \"\"\"\n    Abstract class representing a single account\n\n    Subclasses are expected to overwrite the `deposit`,\n    `withdraw` and `apply_interest` abstract methods\n\n    Attributes:\n    -----------\n    account_holder : str\n        name of the account owner\n    interest_rate : int | float\n        interest rate applied to the account\n\n    \"\"\"\n\n    def __init__(self, account_number, account_holder, interest_rate):\n        \"\"\"\n        Creates a new `Account` instance\n\n        `Account` is abstract and should never be called directly\n\n        Parameters\n        ----------\n        account_number : str\n            Unique account number\n        account_holder : str\n            Name of the account holder\n        interest_rate : int | float\n            interest rate applied to the account\n        \"\"\"\n        self.__account_number = account_number\n        self.account_holder = account_holder.strip().lower()\n        self.interest_rate = interest_rate\n        self.__balance = 0\n\n    def __str__(self):\n        template = \"\"\"Account Number: {0}\nAccount Holder: {1}\nInterest Rate: {2}\nBalance: ${3}\"\"\"\n        return template.format(\n            self.account_number, self.account_holder, self.interest_rate, self.balance\n        )\n\n    @property\n    def account_number(self):\n        \"\"\"\n        account_number : str\n            Unique account number\n        \"\"\"\n        return self.__account_number\n\n    @property\n    def balance(self):\n        \"\"\"\n        balance: int | float\n            account balance in dollars\n        \"\"\"\n        return self.__balance\n\n    @abc.abstractmethod\n    def deposit(self, amount):\n        \"\"\"\n        Deposit money in an account\n\n        Parameters\n        ----------\n        amount : int | float\n            amount in dollars to deposit in the account\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        ValueError\n            Raised if `amount` cannot be deposited\n        \"\"\"\n        self.__balance += amount\n\n    @abc.abstractmethod\n    def withdraw(self, amount):\n        \"\"\"\n        Withdraw money from an account\n\n        Parameters\n        ----------\n        amount : int | float\n            amount to withdraw from the account in dollars\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        ValueError\n            Raised if `amount` cannot be withdrawn\n        \"\"\"\n        self.__balance -= amount\n\n    @abc.abstractmethod\n    def apply_interest(self):\n        \"\"\"\n        Apply the interest rate to the account and update the balance\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.__balance += self.__balance * self.interest_rate\n\n\nAccount defines __init__, __str__, withdraw, deposit, apply_interest functions\n\n__init__ is a basic constructor\n__str__ is the string representation\nwithdraw is an abstract method for decreasing a balance\n\nSince balance itself is a private attribute this method does the actual adjustment\nSubclasses are expected to override the to modify the behaviour and provide validation, then forward the final result onto the super function\n\ndeposit is an abstract method for increasing a balance\n\nWorks like withdraw in that it should be overridden\n\napply_interest an abstract method that should be used to apply interest\n\nProvides a simple default implementation\n\n\nWe can then define our savings account\n\n\nclass SavingsAccount(Account):\n    \"\"\"\n    Represents a standard savings account\n\n    Savings accounts must have non-negative balances, and\n    have interest paid on their balances\n\n    See Also\n    --------\n    Account : Parent Class\n    \"\"\"\n\n    def __init__(self, account_number, account_holder, interest_rate):\n        \"\"\"\n        Creates a new `SavingsAccount` instance\n\n        Parameters\n        ----------\n        account_number : str\n            Unique account number\n        account_holder : str\n            Name of the account holder\n        interest_rate : int | float\n            interest rate applied to the account\n        \"\"\"\n        super().__init__(account_number, account_holder, interest_rate)\n\n    def __str__(self):\n        template = \"\"\"==Savings Account==\n{0}\"\"\"\n        return template.format(super().__str__())\n\n    def deposit(self, amount):\n        if amount &lt;= 0:\n            raise ValueError(\"A deposit must be a non-negative number\")\n        super().deposit(amount)\n\n    def withdraw(self, amount):\n        \"\"\"\n        Withdraw money from an account\n\n        Parameters\n        ----------\n        amount : int | float\n            amount to withdraw from the account in dollars\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        ValueError\n            Raised if `amount` is non-negative or the greater than\n            the account balance\n        \"\"\"\n        if amount &lt;= 0:\n            raise ValueError(\"A withdrawal must be a non-negative number\")\n        if amount &gt; self.balance:\n            raise ValueError(\"Cannot withdraw more than the account balance\")\n        super().withdraw(amount)\n\n    def apply_interest(self):\n        super().apply_interest()\n\n\nThe savings account overwrites the __str__ method to prepend the account type\n__init__ just forwards to the base class\ndeposit checks that the argument is valid (&gt; 0) then forwards it to the base class method\n\ndepositing a negative number is effectively a withdrawal\n\nwithdraw does the same but checks that the amount also does not exceed the balance\nApply interest just uses the default implementation\nWe then derive from SavingsAccount for LongTermSavingsAccount\n\n\nclass LongTermSavingsAccount(SavingsAccount):\n    \"\"\"\n    Represents a long term savings account\n\n    An account in which money cannot be withdrawn before the term limit expires.\n    After the term limit has expired a reduced interest rate is applied.\n\n    See Also\n    --------\n    SavingsAccount : Parent class\n    \"\"\"\n\n    def __init__(\n        self, account_number, account_holder, interest_rate, term_period_in_weeks\n    ):\n        \"\"\"\n        Creates a new `Account` instance\n\n        `Account` is abstract and should never be called directly\n\n        Parameters\n        ----------\n        account_number : str\n            Unique account number\n        account_holder : str\n            Name of the account holder\n        interest_rate : int | float\n            interest rate applied to the account\n        term_period_in_weeks : int\n            length of the high yield savings term in weeks\n        \"\"\"\n        self.__start_date = datetime.date.today()\n        self.__term_period = term_period_in_weeks\n        super().__init__(account_number, account_holder, interest_rate)\n\n    def __str__(self):\n        template = \"\"\"{0}\nTerm Period: {1} weeks\nStart Date: {2}\nMaturation Date: {3}\nHas matured? {4}\"\"\"\n        formatted = template.format(\n            super().__str__(),\n            self.term_period,\n            self.start_date,\n            self.maturation_date,\n            self.has_matured(),\n        )\n        return formatted.replace(\"Savings Account\", \"Long Term Savings Account\")\n\n    @property\n    def start_date(self):\n        \"\"\"\n        start_date : datetime.date\n            date the current term period started\n        \"\"\"\n        return self.__start_date\n\n    @property\n    def term_period(self):\n        \"\"\"\n        term_period : int\n            length of the term in weeks\n        \"\"\"\n        return self.__term_period\n\n    @property\n    def maturation_date(self):\n        \"\"\"\n        maturation_date : datetime.date\n            date the account matures\n        \"\"\"\n        return self.__start_date + datetime.timedelta(weeks=self.__term_period)\n\n    def has_matured(self):\n        \"\"\"\n        Indicates if an account has matured\n\n        Returns\n        -------\n        `True` if the account has matured else, `False`\n        \"\"\"\n        return datetime.date.today() &gt;= self.maturation_date\n\n    def withdraw(self, amount):\n        \"\"\"\n        Withdraw money from a Long Term Savings Account\n\n        Money cannot be withdrawn unless the account has matured\n\n        Parameters\n        ----------\n        amount : int | float\n            amount to withdraw from the account in dollars\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        ValueError\n            Raised if `amount` is non-negative or the greater than\n            the account balance.\n        ValueError\n            Raised if the account has not\n            yet matured\n        \"\"\"\n        if not self.has_matured():\n            raise ValueError(\"Cannot withdraw from an immature account\")\n        super().withdraw(amount)\n\n    def apply_interest(self):\n        \"\"\"\n        Apply interest to a Long Term Savings Account\n\n        The applied interest for a Long Term Savings account is quartered\n        if the account has matured\n\n        Returns\n        -------\n        None\n        \"\"\"\n        effective_rate = self.interest_rate\n        if self.has_matured():\n            effective_rate /= 4\n        self.deposit(self.balance * effective_rate)\n\n    def manage_account(self, transfer_account=None):\n        \"\"\"\n        Manage a matured long term savings account\n\n        A mature long term savings account can be closed\n        by providing an alternate account to transfer the\n        balance into. Alternately if no account is provided\n        the account is reinvested and a new term starts.\n\n        The owner of the long term savings account and the\n        account to transfer into must be the same\n\n        Parameters\n        ----------\n        transfer_account : Account, optional\n            account to transfer into, pass None to reinvest instead, by default None\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        ValueError\n            Raised in attempting to manage an immature account\n        ValueError:\n            Could not transfer to the new account\n        \"\"\"\n        if not self.has_matured():\n            raise ValueError(\"Cannot manage an immature account\")\n        if transfer_account is None:\n            self.__start_date = datetime.date.today()\n        else:\n            balance = self.balance\n            try:\n                self.withdraw(balance)\n                transfer_account.deposit(balance)\n            except ValueError as e:\n                # need to ensure balances preserved\n                if not self.balance == balance:\n                    self.deposit(balance - self.balance)\n                    raise ValueError(str(e))\n\n\nThis class has two new attributes, start_date and term_period\nThe term period is passed to the constructor as an integer number of weeks\nThe start date is calculated at __init__ time\nNote that we use the datetime library rather than time\n\ndatetime provides similar time objects that we can perform comparisons and arithmetic on\ndatetime.date.today() is the equivalent of time.localtime() and returns the current date\n\ndate means there is no hours, minutes, seconds etc.\nIf we want this we would use datetime.datetime.today() instead\n\n\nWe provide a property maturation_date\n\nThis is a bit different to other properties we’ve seen\nIt doesn’t mask a private attribute\nInstead it quickly calculates the maturation_date on the fly\nWe use a datetime.timedelta object which handles performing the arithmetic correctly\n\n  @property\n  def maturation_date(self):\n      \"\"\"\n      maturation_date : datetime.date\n          date the account matures\n      \"\"\"\n      return self.__start_date + datetime.timedelta(weeks=self.__term_period)\nWe then define a simple helper function has_matured which checks if the account has matured\nSince we’re using datetime we can just get the current date and compare the two\n  def has_matured(self):\n      \"\"\"\n      Indicates if an account has matured\n\n      Returns\n      -------\n      `True` if the account has matured else, `False`\n      \"\"\"\n      return datetime.date.today() &gt;= self.maturation_date\nThe Long Term Savings Account can just use the SavingsAccount deposit method\nWe update the withdraw method to throw an error if the account hasn’t matured\n  def withdraw(self, amount):\n      \"\"\"\n      Withdraw money from a Long Term Savings Account\n\n      Money cannot be withdrawn unless the account has matured\n\n      Parameters\n      ----------\n      amount : int | float\n          amount to withdraw from the account in dollars\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      ValueError\n          Raised if `amount` is non-negative or the greater than\n          the account balance.\n      ValueError\n          Raised if the account has not\n          yet matured\n      \"\"\"\n      if not self.has_matured():\n          raise ValueError(\"Cannot withdraw from an immature account\")\n      super().withdraw(amount)\nWe also have to redefine our apply_interest\n\nWe apply a different effective rate for a matured account\nThis does not fit the signature, so we can’t just use the super method\nInstead we calculate the effective rate and then use deposit\n\n  def apply_interest(self):\n      \"\"\"\n      Apply interest to a Long Term Savings Account\n\n      The applied interest for a Long Term Savings account is quartered\n      if the account has matured\n\n      Returns\n      -------\n      None\n      \"\"\"\n      effective_rate = self.interest_rate\n      if self.has_matured():\n          effective_rate /= 4\n      self.deposit(self.balance * effective_rate)\nWe also add a new function for handling a matured account\n  def manage_account(self, transfer_account=None):\n      \"\"\"\n      Manage a matured long term savings account\n\n      A mature long term savings account can be closed\n      by providing an alternate account to transfer the\n      balance into. Alternately if no account is provided\n      the account is reinvested and a new term starts.\n\n      The owner of the long term savings account and the\n      account to transfer into must be the same\n\n      Parameters\n      ----------\n      transfer_account : Account, optional\n          account to transfer into, pass None to reinvest instead, by default None\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      ValueError\n          Raised in attempting to manage an immature account\n      ValueError:\n          Could not transfer to the new account\n      \"\"\"\n      if not self.has_matured():\n          raise ValueError(\"Cannot manage an immature account\")\n      if transfer_account is None:\n          self.__start_date = datetime.date.today()\n      else:\n          balance = self.balance\n          try:\n              self.withdraw(balance)\n              transfer_account.deposit(balance)\n          except ValueError as e:\n              # need to ensure balances preserved\n              if not self.balance == balance:\n                  self.deposit(balance - self.balance)\n                  raise ValueError(str(e))\nThis works in two ways\n\nIf no transfer_account is provided, a new term period is started\nIf a transfer_account is provided, the method attempts to transfer the balance to this account\n\nThis can potentially fail\nWe don’t want the user to lose money\nSo we wrap this in a try...except block\nIf transfer fails we ensure that both accounts maintain their original balances\nThen report to the user\n\n\nLastly we define a CreditAccount class\nWorks very similar to a SavingsAccount but can only have negative balances\n\n\nclass CreditAccount(Account):\n    \"\"\"\n    Represents a basic credit account\n\n    Savings accounts must have non-positive balances, and\n    charge interest on their debts\n\n    See Also\n    --------\n    Account : Parent Class\n    \"\"\"\n\n    def __init__(\n        self, account_number, account_holder, interest_rate, max_withdrawal_limit\n    ):\n        \"\"\"\n        Creates a new `SavingsAccount` instance\n\n        Parameters\n        ----------\n        account_number : str\n            Unique account number\n        account_holder : str\n            Name of the account holder\n        interest_rate : int | float\n            interest rate applied to the account\n        max_withdrawal_limit : int | float\n            maximum account that can be loaned out at once\n        \"\"\"\n        self.__max_withdrawal_limit = max_withdrawal_limit\n        super().__init__(account_number, account_holder, interest_rate)\n\n    def __str__(self):\n        template = \"\"\"==Credit Account==\n{0}\nMaximum Withdrawal Limit: {1}\"\"\"\n        formatted_string = template.format(\n            super().__str__(), self.__max_withdrawal_limit\n        )\n        return formatted_string.replace(\"Balance\", \"Balance owed\").replace(\"$-\", \"-$\")\n\n    def deposit(self, amount):\n        \"\"\"\n        Pay off a Credit loan\n\n        Parameters\n        ----------\n        amount : int | float\n            amount to pay off in dollars\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        ValueError\n            Raised if 1amount` is not a positive integer\n        ValueError\n            Raised if deposit is greater than the current debt\n        \"\"\"\n        if amount &lt;= 0:\n            raise ValueError(\"A deposit must be a non-negative number\")\n        if amount + self.balance &gt; 0:\n            raise ValueError(\n                \"Exceeded max deposit limit: {0}\".format(-1 * self.balance)\n            )\n        super().deposit(amount)\n\n    def withdraw(self, amount):\n        \"\"\"\n        Take out a loan of credit\n\n        Parameters\n        ----------\n        amount : int | float\n            amount to loan from the account in dollars\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        ValueError\n            Raised if `amount` is non-negative or the greater than\n            the account balance\n        \"\"\"\n        if amount &lt;= 0:\n            raise ValueError(\"A withdrawal must be a non-negative number\")\n        if self.balance - amount &lt; -1 * self.__max_withdrawal_limit:\n            raise ValueError(\"Cannot exceed withdrawal limit\")\n        super().withdraw(amount)\n\n    def apply_interest(self):\n        \"\"\"\n        Applies interest to any loans\n\n        Returns\n        -------\n        None\n        \"\"\"\n        super().apply_interest()\n\n\nWe also add a new max_withdrawal_limit attribute passed in via the __init__\nThis limits how much credit can be withdrawn\ndeposit can now only be used to pay off a line of credit\n\nPrevents the balance going positive\n\nwithdraw checks that the withdrawal keeps the balance under the withdrawal limit\n\nWe can then define our AccountSystem, this is basically the FashionShop renamed. However we also add a second dictionary account_name_dictionary which stores all the accounts where the list of accounts associated with a specific account holder is keyed by that account holder. This means we can do fast lookup both by account number (to get a specific account) or by client to get all their associated accounts. We provide two methods get_account which performs the id based lookup and find_users_accounts which finds the accounts associated with a user\n\n# Exercise 11.1b Account System\n#\n# Provides a class for managing and storing collections of accounts\n\nimport pickle\n\n\nclass AccountSystem:\n    \"\"\"\n    Represents the account management system of a bank\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Create a new `AccountSystem` instance\n        \"\"\"\n        self.__account_dictionary = {}\n        self.__account_name_dictionary = {}\n\n    def __str__(self):\n        print_string = \"\"\n        for holder, accounts in self.__account_name_dictionary.items():\n            print_string += \"Client: \" + str(holder) + \"\\n\"\n            account_list = \"\\n\".join(map(str, accounts))\n            print_string += account_list + \"\\n\"\n        return print_string\n\n    def save(self, filename):\n        \"\"\"\n        Save the `AccountSystem` to a given file\n\n        `AccountSystem` is saved as a pickled binary file in the file given\n        by `filename`. The file is created if it doesn't exist. If the file\n        already exists it is overwritten\n\n        Parameters\n        ----------\n        filename : str\n            path to the file to save\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        Exceptions\n            raised if the file fails to save\n\n        See Also\n        --------\n        AccountSystem.load : load a `AccountSystem` object from a file\n        \"\"\"\n        with open(filename, \"wb\") as output_file:\n            pickle.dump(self, output_file)\n\n    @staticmethod\n    def load(filename):\n        \"\"\"\n        Create an `AccountSystem` instance from a pickled binary file\n\n        Parameters\n        ----------\n        filename : str\n            path to a file containing pickled `FashionShop` data\n\n        Returns\n        -------\n        AccountSystem\n            the loaded `AccountSystem` instance\n\n        Raises\n        ------\n        Exceptions\n            raised if the file fails to load\n\n        See Also\n        --------\n        AccountSystem.save : saves an `AccountSystem` instance\n        \"\"\"\n        with open(filename, \"rb\") as input_file:\n            accounts = pickle.load(input_file)\n        return accounts\n\n    def add_new_account(self, account):\n        \"\"\"\n        Store a new account in the reference system\n\n        The provided `account` can be indexed by it's `account_number` parameter\n\n        Parameters\n        ----------\n        account : Account\n            account to add to the inventory system\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        KeyError\n            Raised if the accounts's `account_number` is already registered as a key\n        \"\"\"\n        if account.account_number in self.__account_dictionary:\n            raise KeyError(\"This account number is already in use\")\n        self.__account_dictionary[account.account_number] = account\n        if account.account_holder in self.__account_name_dictionary:\n            self.__account_name_dictionary[account.account_holder].append(account)\n        else:\n            self.__account_name_dictionary[account.account_holder] = [account]\n\n    def get_account(self, account_number):\n        \"\"\"\n        Get the account with the corresponding account number\n\n        Parameters\n        ----------\n        account_number : str\n            account_number of the account to find\n\n        Returns\n        -------\n        Account | None\n            Returns an `Account` with a matching `account_number` if it exists, else `None`\n        \"\"\"\n        return self.__account_dictionary.get(account_number)\n\n    def find_users_accounts(self, name):\n        \"\"\"\n        Find the accounts associated with a given user\n\n        Parameters\n        ----------\n        name : str\n            account holder to search for\n\n        Returns\n        -------\n        List[Account]\n            list of accounts held by the given name, if there are no matches the list is empty\n        \"\"\"\n        name = name.strip().lower()\n        try:\n            return self.__account_name_dictionary[name]\n        except KeyError:\n            return []\n\nBelow demonstrates how the code works\n\n# Test Savings Account\nnew_saving = SavingsAccount(1, \"Alice\", 0.003)\nnew_saving.deposit(100)\nnew_saving.withdraw(50)\nnew_saving.apply_interest()\n\n# Test long-term savings\nnew_long_term = LongTermSavingsAccount(2, \"Alice\", 0.012, 26)\nnew_long_term.deposit(100)\nnew_long_term.apply_interest()\n\n# Test Credit\nnew_credit = CreditAccount(3, \"Bob\", 0.08, 1000)\nnew_credit.withdraw(500)\nnew_credit.apply_interest()\n\naccount_system = AccountSystem()\naccount_system.add_new_account(new_saving)\naccount_system.add_new_account(new_long_term)\naccount_system.add_new_account(new_credit)\n\nprint(\"Getting the account with a specific id\")\nprint(account_system.get_account(1))\nprint(\"Getting all accounts associated with a specific client\")\nprint(account_system.find_users_accounts(\"felix\"))\nprint(\"Printing the entire system\")\nprint(account_system)\n\nGetting the account with a specific id\n==Savings Account==\nAccount Number: 1\nAccount Holder: alice\nInterest Rate: 0.003\nBalance: $50.15\nGetting all accounts associated with a specific client\n[]\nPrinting the entire system\nClient: alice\n==Savings Account==\nAccount Number: 1\nAccount Holder: alice\nInterest Rate: 0.003\nBalance: $50.15\n==Long Term Savings Account==\nAccount Number: 2\nAccount Holder: alice\nInterest Rate: 0.012\nBalance: $101.2\nTerm Period: 26 weeks\nStart Date: 2026-02-10\nMaturation Date: 2026-08-11\nHas matured? False\nClient: bob\n==Credit Account==\nAccount Number: 3\nAccount Holder: bob\nInterest Rate: 0.08\nBalance owed: -$540.0\nMaximum Withdrawal Limit: 1000\n\n\n\n\n\n\n\n\nWe now have our data items (StockItem) and how container for managing them FashionShop\nThe last step is to provide a component that handles the user interface\nWe’ll create a class FashionShopShellApplication to handle the UI\nThe class should\n\nInitialise the application, by loading from a file (or creating a new instance if this fails)\nDisplay the menu to the user\n\nThis class provides a text-based interface\nIn future we may swap this for a graphical interface\n\n\n\n\nWe’ll define our __init__ method to try and load from a file\nIf the load fails we then pass an empty instance\nWe use an internal __shop attribute to store the inventory management component\n  import FashionShop\n\n\n  class FashionShopApplication:\n      def __init__(self, filename):\n          \"\"\"\n          Creates a new `FashionShopApplication`\n\n          Attempts to load a `FashionShop` from the provided file. Otherwise\n          an empty instance is created\n\n          Parameters\n          ----------\n          filename : str\n              path to a file containing pickled `FashionShop` data\n\n          See Also\n          --------\n          FashionShop : Main class for handling inventory management\n          \"\"\"\n          FashionShopApplication.__filename = filename\n          try:\n              self.__shop = FashionShop.FashionShop.load(filename)\n          except:  # noqa: E722\n              print(\"Failed to load Fashion Shop\")\n              print(\"Creating an empty Fashion Shop\")\n              self.__shop = FashionShop.FashionShop()\nWe might then declare our FashionShopApplication as follows\n  ui = FashionShopApplication(\"fashionshop.pickle\")\n\n\n\n\n\nThe next step is to implement our standard looping menu\nWe’ll implement this as a method\nEach option will then correspond to another method defined on the FashionShopApplication\n    def main_menu(self):\n      \"\"\"\n      Provides a looping main menu. Users are able to\n\n      1. Create a new item\n      2. add stock to an existing item\n      3. sell stock\n      4. show a stock report\n      5. exit\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      ValueError\n          Raised if an invalid command is received. Should not arise in\n          production. Report if encountered\n      \"\"\"\n\n      prompt = \"\"\"Fashion Shop Inventory Management\n\n1. Create a New Stock Item\n2. Add Stock to an Existing Item\n3. Sell Stock\n4. Stock Report\n5. Exit\n\nEnter your command: \"\"\"\n\n      while True:\n          command = BTCInput.read_int_ranged(prompt, 1, 5)\n          if command == 1:\n              self.create_new_stock_item()\n          elif command == 2:\n              self.add_stock()\n          elif command == 3:\n              self.sell_stock()\n          elif command == 4:\n              self.do_report()\n          elif command == 5:\n              self.__shop.save(self.__filename)\n              print(\"Shop data saved\")\n              break\n          else:\n              raise ValueError(\n                  \"Invalid command id {0} encountered in main menu!\".format(command)\n              )\nThis follows the same structure of all our previous menu setups\nThe only difference is this time it’s been wrapped in a class\nStarting the program looks like,\n  ui = FashionShopApplication(\"fashionshop.pickle\")\n  ui.main_menu()\n\n\n\n\n\nNow we need to implement the menu options\nWe already partially implemented these before (see Implement Application Behaviours) we just need to reimplement them as part of the class, or provide a connection\nFor example, we write a sell_stock wrapper as below,\n    def sell_stock(self):\n      print(\"Sell Stock\")\n\n      item = self.__shop.find_stock_item(\n          BTCInput.read_text(\"Enter the stock reference: \")\n      )\n      if item is None:\n          print(\"Item not found\")\n          return\n\n      print(\"Selling\")\n      print(item)\n\n      number_sold = BTCInput.read_int_ranged(\n          \"How many to sell? (0 to abandon) - {0} in current stock: \".format(\n              item.stock_level\n          ),\n          min_value=0,\n          max_value=item.stock_level,\n      )\n      if not number_sold:\n          print(\"Sell item cancelled\")\n          return\n\n      item.sell_stock(number_sold)\n      print(\"Items sold\")\nThis walks through the sales process\nFirst the user is prompted for a reference to get an item\nThen the user is prompted for an amount to sell\nWe use the read_input_ranged to ensure the provided number is valid\nOnce validated we then forward to the item’s sell_stock method\n\n\n\n\n\n\n\nNote\n\n\n\nYou will spend a lot of time writing code to deal with failure\nThe sell_stock method does the following,\n\nIt handles invalid stock references\nIt ensures that we do not sell more inventory than we hold\nIt provides the user a way to back out of a sale\n\nThe actual “happy path” code, i.e. the code that is followed when everything works fine is a very small part of the entire function. Multiply this across all the functions and the majority of the code is probably taken up with input validation and handling failure cases.\n\n\n\nA complete working version of the code is found in 11_FashionShopApplication\nWe’ve split the classes into their own files for readability purposes\nThe program can be run by running FashionShopApplication.py\n\n\n\n\nImplement a banking application wrapper class to complete the Bank Account system created earlier. This class should work like FashionShopApplication attempting to load from a file, then providing a looping menu. The user should be able to,\n\nCreate a new account\nDeposit into an account\nWithdraw from an account\nView an account\nView all their accounts\nManage a matured long term savings account\nApply interest to all accounts\n\nWe first start by templating out our BankApplication class using a similar framework to the FashionShop application\nclass BankAccountApplication:\n    \"\"\"\n    Provides a text-based interface for Bank Account Management\n    \"\"\"\n\n    def __init__(self, filename):\n        \"\"\"\n        Creates a new `BankAccountApplication`\n\n        Attempts to load an existing application from the provided file.\n        Otherwise an empty instance is created\n\n        Parameters\n        ----------\n        filename : str\n            path to a file containing pickled `AccountSystem` data\n\n        See Also\n        --------\n        AccountSystem : Main class for handling bank accounts\n        \"\"\"\n        self.__filename = filename\n        try:\n            self.__accounts = AccountSystem.AccountSystem.load(filename)\n        except:  # noqa: E722\n            print(\"Failed to load accounts\")\n            print(\"Creating an empty instance\")\n            self.__accounts = AccountSystem.AccountSystem()\n\n    def main_menu(self):\n        \"\"\"\n        Provides a looping main menu\n\n        Users are able to\n        1. Create a new account\n        2. Deposit into an account\n        3. Withdraw from an account\n        4. View an account\n        5. View all accounts associated with a name\n        6. Manage a matured long term savings account\n        7. Apply interest to all accounts\n        8. Exit\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        ValueError\n            Raised if an invalid command is received. Should not arise in\n            production. Report if encountered\n        \"\"\"\n\n        prompt = \"\"\"Account Management System\n\n1. Create a new account\n2. Deposit into an account\n3. Withdraw from an account\n4. View an account\n5. View all accounts associated with a name\n6. Manage a matured long term savings account\n7. Apply interest to all accounts\n8. Exit\n\nEnter your command: \"\"\"\n\n        while True:\n            command = BTCInput.read_int_ranged(prompt, 1, 8)\n            if command == 1:\n                self.create_new_account()\n            elif command == 2:\n                self.deposit_into_account()\n            elif command == 3:\n                self.withdraw_from_account()\n            elif command == 4:\n                self.view_account()\n            elif command == 5:\n                self.view_accounts_for_name()\n            elif command == 6:\n                self.manage_matured_long_term_savings()\n            elif command == 7:\n                self.__accounts.apply_interest()\n            elif command == 8:\n                self.__accounts.save(self.__filename)\n                print(\"Accounts saved\")\n                break\n            else:\n                raise ValueError(\n                    \"Invalid command id {0} encountered in main menu! Please report!\".format(\n                        command\n                    )\n                )\nThe __init__ is simple as it first tries to load the accounts from a given file (storing this filename for later saving), else creating an empty AccountSystem if one is not found.\nThe menu also uses our standard numeric interface. Now we need to start implementing our methods. The most complicated for us being creating a new account. To start with we know that all accounts have an interest rate. Depending on if we are viewing this program as something that a bank owner would use to manage their internal system, or something that the a client uses we might want to implement this differently.\nOne question is around the interest rate we apply to accounts. If this was client facing. We probably don’t want them specifying their own interest rate. So instead the application provides some logic to determine the interest rate to apply to a new account. This is done by using class variables to define interest rates for SavingsAccounts and CreditAccounts. We then also provide a static method that calculates the interest rate for a long-term savings account based on the principle that the longer the term is the higher the interest.\nclass BankAccountApplication:\n    \"\"\"\n    Provides a text-based interface for Bank Account Management\n\n    Class Attributes\n    ----------------\n    savings_account_interest : float\n        current interest rate on newly opened savings accounts\n    credit_account_interest : float\n        current interest rate on newly opened credit accounts\n    \"\"\"\n\n    savings_account_interest = 0.01\n    credit_account_interest = 0.10\n\n    @staticmethod\n    def calculate_long_term_interest(term_limit):\n        \"\"\"\n        Calculates the bonus interest assigned to a long term savings account\n\n        Parameters\n        ----------\n        term_limit : int\n            proposed term limit in weeks\n\n        Returns\n        -------\n        float\n            interest rate for a long-term savings account\n        \"\"\"\n        term_contribution = (\n            term_limit / Account.LongTermSavingsAccount.max_term_limit * (0.1)\n        )\n        return BankAccountApplication.savings_account_interest + term_contribution\nSimilarly here, we don’t want a client to be able to put an arbitrary term limit in. So we’ll add class variables to the LongTermSavingsAccount for the min and max term limits, and provide a static validation method.\nclass LongTermSavingsAccount(SavingsAccount):\n    \"\"\"\n    Represents a long term savings account\n\n    An account in which money cannot be withdrawn before the term limit expires.\n    After the term limit has expired a reduced interest rate is applied.\n\n    Class Attributes\n    ----------------\n    min_term_limit: int\n        minimum term limit in weeks\n    max_term_limit: int\n        maximum term limit in weeks\n\n    See Also\n    --------\n    SavingsAccount : Parent class\n    \"\"\"\n\n    min_term_limit = 12\n    max_term_limit = 156\n\n    @staticmethod\n    def validate_term_limit(term_limit):\n        \"\"\"\n        Validates a proposed term limit\n\n        Parameters\n        ----------\n        term_limit : int\n            proposed term limit in weeks\n\n        Returns\n        -------\n        bool\n            `True` if the proposed term limit is valid, else `False`\n        \"\"\"\n        return (\n            LongTermSavingsAccount.min_term_limit\n            &lt;= term_limit\n            &lt;= LongTermSavingsAccount.max_term_limit\n        )\nNow we can move on to implementing our account creation function. Here the user has to specify the account type to create. Then they are prompted to provide an account holder. The next bit of fun we introduce is to have the user’s account number then be randomly generated. We’ll make the account number a 4 character alphanumeric string. (We keep it small to make it easy to demo)\n    def create_new_account(self):\n        \"\"\"\n        Create a new account and add it to the system\n\n        Prompts the user for the type of account to create and\n        the necessary descriptors of the item. The account is\n        then added to the system\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        ValueError\n            Raised if an invalid account type id is encountered.\n            Should not arise in production, please report if found.\n        \"\"\"\n        menu = \"\"\"Create New Account\n\n1. Savings Account\n2. Long Term Savings Account\n3. Credit Account\n\nEnter account type: \"\"\"\n\n        def generate_account_number():\n            \"\"\"\n            Generates an account number\n\n            The generated account number is a 16 character random\n            alphanumeric string\n\n            Returns\n            -------\n            str\n                string representing a valid account number\n            \"\"\"\n            account_number_string_length = 4\n            account_number_string_tuple = (\n                \"A\",\n                \"B\",\n                \"C\",\n                \"D\",\n                \"E\",\n                \"F\",\n                \"G\",\n                \"H\",\n                \"I\",\n                \"J\",\n                \"K\",\n                \"L\",\n                \"M\",\n                \"N\",\n                \"O\",\n                \"P\",\n                \"Q\",\n                \"R\",\n                \"S\",\n                \"T\",\n                \"U\",\n                \"V\",\n                \"W\",\n                \"X\",\n                \"Y\",\n                \"Z\",\n                \"0\",\n                \"1\",\n                \"2\",\n                \"3\",\n                \"4\",\n                \"5\",\n                \"6\",\n                \"7\",\n                \"8\",\n                \"9\",\n            )\n\n            account_number = \"\".join(\n                random.choices(\n                    account_number_string_tuple, k=account_number_string_length\n                )\n            )\n            return account_number\n\n        account_type = BTCInput.read_int_ranged(menu, 1, 3)\n        if account_type &lt; 1 or account_type &gt; 3:\n            raise ValueError(\n                \"Invalid account type id {0} encountered while creating account\".format(\n                    account_type\n                )\n            )\n\n        account_number = generate_account_number()\n        account_holder = BTCInput.read_text(\"Enter account holder: \")\nYou can see we define a tuple that contains the possible characters. We then use random.choices to select the appropriate number of characters (with replacement) where the number of characters is defined by account_number_string_length (so we can easily modify it). To convert from a collection to a string we use \"\".join to join the characters together, the empty string means that no extra characters are embedded.\nNow that we’ve got the account number, the account holder and the type of account we can proceed. For a SavingsAccount we have all the details required to create the account. For a LongTermSavingsAccount we have to get the term limit, (making sure it’s valid) and for a CreditAccount we have to get the credit limit. Once that’s done we then add it to the AccountSystem\n        if account_type == 1:\n            print(\"Creating a savings account\")\n            account = Account.SavingsAccount(\n                account_number,\n                account_holder,\n                BankAccountApplication.savings_account_interest,\n            )\n            print(\"Created a new savings account {0}\".format(account_number))\n        elif account_type == 2:\n            print(\"Creating a long-term savings account\")\n            while True:\n                term_limit = BTCInput.read_int_ranged(\n                    \"Enter term limit ({0} - {1}): \".format(\n                        Account.LongTermSavingsAccount.min_term_limit,\n                        Account.LongTermSavingsAccount.max_term_limit,\n                    ),\n                    Account.LongTermSavingsAccount.min_term_limit,\n                    Account.LongTermSavingsAccount.max_term_limit,\n                )\n                if Account.LongTermSavingsAccount.validate_term_limit(term_limit):\n                    break\n            account = Account.LongTermSavingsAccount(\n                account_number,\n                account_holder,\n                BankAccountApplication.calculate_long_term_interest(term_limit),\n                term_limit,\n            )\n            print(\"Created a new long-term savings account {0}\".format(account_number))\n        elif account_type == 3:\n            print(\"Creating a  credit account\")\n            withdrawal_limit = BTCInput.read_float(\"Enter max withdrawal limit: \")\n            account = Account.CreditAccount(\n                account_number,\n                account_holder,\n                BankAccountApplication.credit_account_interest,\n                withdrawal_limit,\n            )\n            print(\"Created a new credit account {0}\".format(account_number))\n        self.__accounts.add_new_account(account)  # type: ignore\nDeposit, withdraw and view account are all implemented using similar logic. First the user is prompted for an account number, then we perform a function. We’ll extract this get_account behaviour into a function\n    def get_account(self):\n        \"\"\"\n        Prompts the user for an account number and returns any match\n\n        Returns\n        -------\n        Account | None\n            Account is the account number matches, else `None`\n        \"\"\"\n        account_number = BTCInput.read_text(\"Enter account number: \").upper().strip()\n        return self.__accounts.get_account(account_number)\nThe implementations for deposit, withdraw, and view then largely just need to forward onto the appropriate message on the account, deposit, withdraw and __str__ respectively\n    def deposit_into_account(self):\n        \"\"\"\n        Deposit into a user-prompted account\n\n        User is prompted for an account, if the account exists,\n        the user is then prompted for how much to deposit\n\n        Returns\n        -------\n        None\n        \"\"\"\n        print(\"Deposit into account\")\n\n        account = self.get_account()\n\n        if account is None:\n            print(\"Account not found\")\n            return\n        print(\"Depositing\")\n        print(account)\n\n        try:\n            amount = BTCInput.read_float(\n                \"Enter amount to deposit (Current balance: {0}): \".format(\n                    account.balance\n                )\n            )\n            account.deposit(amount)\n        except ValueError as e:\n            print(e)\n\n    def withdraw_from_account(self):\n        \"\"\"\n        Withdraw from a user-prompted account\n\n        User is prompted for an account, if the account exists,\n        the user is then prompted for how much to withdraw\n\n        Returns\n        -------\n        None\n        \"\"\"\n        print(\"Withdraw from account\")\n\n        account = self.get_account()\n        if account is None:\n            print(\"Account not found\")\n            return\n        print(\"Withdrawing\")\n        print(account)\n\n        try:\n            amount = BTCInput.read_float(\n                \"Enter amount to withdraw (Current balance: {0}): \".format(\n                    account.balance\n                )\n            )\n            account.withdraw(amount)\n        except ValueError as e:\n            print(e)\n\n    def view_account(self):\n        \"\"\"\n        Display a user-specified account\n\n        Returns\n        -------\n        None\n        \"\"\"\n        print(\"View account\")\n\n        account = self.get_account()\n        if account is None:\n            print(\"Account not found\")\n            return\n        print(account)\nNext we want to implement the complement to view_account which is view_account_by_name. This simply takes a user’s name and then forwards onto the appropriate message on the AccountSystem. The resulting list is then converted to a string representation using map and displayed to the user\n    def view_accounts_for_name(self):\n        \"\"\"\n        Find and display accounts for a user prompted name\n\n        Names are converted to lower case and stripped of\n        leading and trailing whitespace\n\n        Returns\n        -------\n        None\n        \"\"\"\n        print(\"View account holders accounts\")\n\n        accounts = self.__accounts.find_users_accounts(\n            BTCInput.read_text(\"Enter account holder: \")\n        )\n        print(\"\\n\".join(map(str, accounts)))\nOur last major implementation detail is then to implement managing a matured savings account. Recall from the original exercise that a long-term savings account that has matured can either be reinvested or transferred to another account. To implement this structure as follows,\n\nThe user is prompted for an account number\nWe verify that account number is valid and a long-term account\nWe then validate that the account has matured\nThe user is then prompted if they want to reinvest\n\nIf yes, the account is reinvested and the process stops\nElse we continue\n\nThe user is then prompted for the account to transfer to\nWe validate that the account exists, and the account holder matches the long term account\nWe then attempt to close out the account\n\nThe implementation is given below,\n    def manage_matured_long_term_savings(self):\n        \"\"\"\n        Close out or reinvest a user specified matured long-term account\n\n        Returns\n        -------\n        None\n        \"\"\"\n\n        account_number = BTCInput.read_text(\"Enter account number: \").upper().strip()\n\n        account = self.__accounts.get_account(account_number)\n        if account is None:\n            print(\"Account not found\")\n            return\n        if not isinstance(account, Account.LongTermSavingsAccount):\n            print(\"Account is not a long term savings account\")\n            return\n        if not account.has_matured():\n            print(\"Account cannot be managed: has not matured\")\n            return\n\n        reinvest = BTCInput.read_int_ranged(\n            \"Reinvest this account? (1 - yes, 0 - no): \", 0, 1\n        )\n        if reinvest:\n            account.manage_account()\n            return\n\n        holder = account.account_holder\n        other_accounts = set(self.__accounts.find_users_accounts(holder)).difference(\n            {account}\n        )\n        if len(other_accounts) == 0:\n            print(\"Account cannot be closed: No accounts to transfer to\")\n            return\n        print(\"\\n\".join(map(str, other_accounts)))\n\n        account_number = (\n            BTCInput.read_text(\"Enter transfer account number: \").upper().strip()\n        )\n\n        transfer_account = self.__accounts.get_account(account_number)\n        if transfer_account is None:\n            print(\"Account not found\")\n            return\n        if transfer_account.account_holder != holder:\n            print(\"Could not transfer, account holder does not match\")\n            return\n        try:\n            account.manage_account(transfer_account)\n            print(\n                \"Funds in account {0} transferred to account {1}\".format(\n                    account.account_number, transfer_account.account_number\n                )\n            )\n        except ValueError as e:\n            print(\"Failed to close account:\", e)\nOur last step is to implement the application of interest rates. This is done to all accounts, typically at some specified point, e.g. the first of each month. However, the natural place for this to be implemented is on the AccountSystem class,\nclass AccountSystem:\n    \"\"\"\n    Represents the account management system of a bank\n    \"\"\"\n    ...\n    def apply_interest(self):\n        \"\"\"\n        Applies interest to all accounts in the system\n\n        Returns\n        -------\n        None\n        \"\"\"\n        for account in self.__account_dictionary.values():\n            account.apply_interest()\nWe then just need to forward to this method from BankApplication, as can be seen already in the main_menu function\ndef main_menu(self):\n    ...\n    elif command == 7:\n        self.__accounts.apply_interest()\nRunning the program is the same as for our Fashion Shop Application\nui = BankAccountApplication(\"accounts.pkl\")\nui.main_menu()\n\n\nNow that we’ve completed the program it’s worth reviewing the program. Overall the design is one that we’re pretty happy with but there could be some improvements. The most glaring is that account numbers must be unique, yet our program doesn’t enforce this. There are a number of solutions. The ideal way to handle this would be that when we try to add an account if self.__account.add_new_account(account) returns a KeyError would be to regenerate a new number. However this number is private and can’t be changed once an object is created. We don’t want to change this, so we would have to create an entire new object which is fine, but the way the code is organised means that it’s not clear when we get to adding the account, what type it is. Solutions include,\n\nMoving the call to add_new_account to each individual account type path\n\nThis means we can catch the KeyError regenerate a new number, and then rebuild the appropriate account type\nHas the downside that we replicate the code for adding the account for every account type\n\nImplement a method on AccountSystem that tells us if a generated account number is valid.\n\nThis means we can check at the time of number generation\nRepeat until we get a valid one\nThis has the downside that if we had a concurrent system, we could potentially be told that the account number is free, then have another process beat us to using that number\nPlus we already have the KeyError to tell us if the number is free\n\nIn Python you generally prefer to ask for forgiveness rather than permission\n\ni.e. use exceptions over checking then setting\n\n\n\nHandle the Error, report it to the user and leave it up to them how they want to resolve\n\nSimplest implementation\nProbably not the best user experience (since user might have to enter the same details all over again)\n\n\nNone of the solutions above are strictly the best they are all just options to consider. For this small program we’ve left the bug in as a demonstration.\nThere are a couple other design considerations. One is about cohesion, we have logic for defining the interest applied to accounts separate from the Account class stored on arguably the UI class BankAccountApplication. This is fine for this small system but perhaps suggests a lack of cohesion. If we were to change out our UI class to a GUI that GUI would then have to implement the same business logic. One solution is to move those details to the Account class hierarchy. Here each subclass might have to define a property base_interest_rate which defines the default interest rate for an account. On the other hand if we decide that an Account should have an interest rate, but has no business knowing how that interest rate is set, we may have to implement this behaviour either in the AccountSystem or in another class that purely handles the business logic around interest rates and propagates that through to the accounts. For the scale of this system, we probably don’t need that extra layer (remember the simpler the solution the easier, we can always refactor later)\nThe last question is more on of a philosophical design choice. This program implements features that are very client focused such as creating accounts, depositing and withdrawing (and arguably managing a long-term account), and some that a more targeted towards an internal user (applying interest, the ability to modify any account and see anybody’s account). This is fine for a simple toy program like the one we’re building. But if we were to scale this up we would probably want to split out the client-facing functions from the internal user facing components. Both would still talk to the same underlying data model though.\n\n\n\n\n\n\nWe can show the final class diagram and interactions of our program below\n(We’ve hidden some of the subclasses and object for simplicity)\n\n\n\n\n\n\n---\ntitle: Complete Fashion Shop Class Diagram\n---\n\nclassDiagram\n\n    class StockItem {\n        str stock_ref\n        str item_name\n        str colour\n        number price\n        int stock_level\n    }\n\n    class Dress {\n        str pattern\n        int size\n    }\n\n    class Pants {\n        int length\n        str pattern\n        int waist\n    }\n\n    class FashionShop {\n        dictionary __stock_dictionary\n    }\n\n    class FashionShopApplication {\n        FashionShop __shop\n    }\n\n    StockItem &lt;|-- Dress\n    StockItem &lt;|--  Pants\n\n    FashionShop \"1\" o-- \"0..n\" StockItem\n    FashionShopApplication \"1\" *-- \"1\" FashionShop\n\n\n\n\n\n\n\n\n\nClass diagrams more broadly discuss associations\nOne form of association is inheritance which we’ve seen before is represented by a open arrow\nAnother is aggregation represented by an open diamond-headed arrow\n\nWe say that FashionShop aggregates StockItem because it is a container\nWe can additionally specify multiplicities\ni.e. how many items are represented in a relationship\nWe do this by adding number on either end of the arrow\nAbove we have \\(1\\) next to the FashionShop and \\(0 \\ldots n\\) next to StockItem\nThis says that one FashionShop aggregates \\(0\\) to an arbitrary finite number of StockItems\n\nA similar relationship is composition\n\nWhere as inheritance is a is-a relationship\nComposition can be thought of as a has-a relationship\nAgain we can specify multiplicities\nHere we indicate that there is one FashionShopApplication which contains one FashionShop\n\nThese class diagrams help express the structure and relationship of a system\nGood way to describe how the elements of your program fit together\n\n\n\n\n\nSets are collections of values like tuples and lists\nThey are mutable like lists\nUnlike lists each value in a set must be unique\n\n\n\nWork through the following steps in the python interpreter to understand sets\nA set can be created by explicitly using the set initializer\n\nset1 = set()\nset1\n\nset()\n\n\nThis creates an empty set.\nWe can add to set like with a list, but we use add rather than append\n\nset1.add(1)\nset1\n\n{1}\n\n\nSets can only hold one instance of a given value, what happens if we try to add the same element twice?\n\nset1.add(1)\nset1\n\n{1}\n\n\nAs we can see the set contents have not changed, there is only one 1 in the set. However the other thing to observe is that no error was thrown, the second add fails silently\nWe can add multiple values as long as they are distinct\n\nset1.add(2)\nset1\n\n{1, 2}\n\n\nLike with lists and dictionaries there is a quick set declaration syntax. We simply provide a comma-separated list enclosed in curly braces\n\nset2 = {2,3,4,5}\nset2\n\n{2, 3, 4, 5}\n\n\nThis is similar but distinct to the dictionary case where the curly brace list is comma separated key:value pairs\nFor those familiar with set theory, sets provide the standard suite of set operations.\ndifference is called on one set, and takes another set as an argument. It returns a new set containing the elements in the original set that are not in the argument set, e.g.\n\nset1.difference(set2)\n\n{1}\n\n\nand\n\nset2.difference(set1)\n\n{3, 4, 5}\n\n\nUnion returns a set containing the elements that are in either of the sets\n\nset1.union(set2)\n\n{1, 2, 3, 4, 5}\n\n\nintersection returns a set containing the elements that are in both of the sets\n\nset1.intersection(set2)\n\n{2}\n\n\nThere are also a number of methods for comparing the contents of a set. isdisjoint returns True if the two sets have no common elements\n\nset1.isdisjoint(set2)\n\nFalse\n\n\nissubset takes the form seta.issubset(setb) and returns True if seta is a subset of setb. \\(A\\) being a subset of \\(B\\) means all the elements of \\(A\\) are in \\(B\\)\n\nset3 = {2, 3}\nset3.issubset(set2)\n\nTrue\n\n\nThe opposite method is issuperset which returns true if the set the method is called on is a superset of the argument. \\(A\\) is a superset of \\(B\\) if \\(A\\) contains every element of \\(B\\)\n\nset3.issuperset(set2)\n\nFalse\n\n\n\nHow are sets useful?\n\nLet us remove duplicates in a collection\n\n\n\nset(\"Hello World\")\n\n{' ', 'H', 'W', 'd', 'e', 'l', 'o', 'r'}\n\n\n\nPython’s sets are unordered\nThey can be sorted using the function sorted\n\n\nprint(sorted(\"Hello World\"))\nprint(sorted(set(\"Hello World\")))\n\n[' ', 'H', 'W', 'd', 'e', 'l', 'l', 'l', 'o', 'o', 'r']\n[' ', 'H', 'W', 'd', 'e', 'l', 'o', 'r']\n\n\n\nWe might also use them to manage a collection of items\n\ne.g. a players inventory\n\n\n\npocket = {\"axe\", \"apple\", \"herbs\", \"flashlight\"}\n\n\nSets allow for easy membership checks\nespecially when we want to look at multiple members\n\n  apple_potion = {\"apple\", \"herbs\"}\n  if apple_potion.issubset(pocket):\n      print(\"Making an apple potion\")\n\nMaking an apple potion\n\n\nIn the above example we check that the player’s inventory has the ingredients for an apple potion\n\nThis is done by checking the ingredients are a subset of the inventory\n\nWe can then make the apple potion using set operations\n\nUse set difference to remove the ingredients\nThen add an apple potion\n\n\n  pocket = pocket - apple_potion\n  pocket.add(\"apple potion\")\n  pocket\n\n{'apple potion', 'axe', 'flashlight'}\n\n\nThe subtraction operator on sets works like the set difference operation we’ve seen before\n\n\n\n\n\nSets are less common than dictionaries and lists\nHowever they can be very useful\nOur Fashion Shop client has provided an updated spec\n\n\nCustomers often pursue a similar “look” or “style” e.g. flowery, summer, formal, etc. She would like to be able to tag stock items so they can be easily searched\n\n\nTagging items with descriptors is very common\nBlogs or Youtube videos are often tagged with metadata that describes their content\nSets are a good technique here since each tag should be unique\n\n\n\n\nEach StockItem should have a tags attribute\ntags comprises a set of tag values\nCreating a StockItem now requires us to input the tag values at object creation\nA sample UI might look like,\n\n\nprint(\"Enter tags (separated by commas): \\033[31moutdoor, spring, informal, short\\033[0m\")\n\n\nEnter tags (separated by commas): outdoor, spring, informal, short\n\n\n\n\n\nThen need to convert the comma separated list into individual tag items\nFirst we want to normalise tags, i.e. lowercase and leading / trailing whitespace stripped\nHowever, we want to split the individual tags before we strip the whitespace\n\nSince there might be white space between the words\n\nSo we can first lower, then separate the words using split\n\nsplit takes a string to split and a separator character (here ,) to split on\nThe separator is not included in the split strings\nReturns a list containing the new strings\n\nWe can then use map to apply the string method str.strip to each individual tag\n\n  tag_list = str.split(str.lower(tag_string), sep=',')\n  tag_list = map(str.strip, tag_list)\n  print(list(tag_list))\n\n['outdoor', 'spring', 'informal', 'short']\n\n\nThe last step is to ensure all the tags are unique by converting to a set\n\n  tags = set(tag_list)\n\nNow that we’ve defined this pipeline for creating our sets, we should really encapsulate it as a method\n\nclass FashionShopApplication:\n    ...\n    @staticmethod\n    def tag_set_from_text(tag_text):\n        \"\"\"\n        Create a set of tags from a comma-separated list\n\n        Tags are normalised as lowercase with leading and\n        trailing whitespace stripped\n\n        Parameters\n        ----------\n        tag_text: str\n            comma-separated list of tags\n\n        Returns\n        -------\n        set\n            set containing unique tags. Tags are lowercase with\n            no leading or trailing whitespace\n        \"\"\"\n        tags = set(map(str.strip, str.split(str.lower(tag_text), sep=\",\")))\n        return tags\n\nImplemented as a static method\n\nThe behaviour is associated with the class\nBut not associated with any specific instance\n\n\n\n\n\n\nNow that we’ve added tags we need a way to use them to search for items\nThe client wants to provide a list of tags and receive a list of items matching those tags\nBelow is a proposed interface\n\n  print(\"Enter the tags to look for (comma separated): \\033[31moutdoor, spring\\033[0m\")\n  print(\"Stock Reference: BL343\")\n  print(\"Type: Blouse\\033[0m\")\n  print(\"Price: 100\")\n  print(\"Stock Level: 0\")\n  print(\"Colour: Pink\")\n  print(\"\"\"Tags: {\"spring\", \"friendly\", \"city\", \"outdoor\"}\"\"\")\n  print(\"Size: 14\")\n  print(\"Style: plain\")\n  print(\"Pattern: check\")\n\n\nEnter the tags to look for (comma separated): outdoor, spring\n\nStock Reference: BL343\n\nType: Blouse\n\nPrice: 100\n\nStock Level: 0\n\nColour: Pink\n\nTags: {\"spring\", \"friendly\", \"city\", \"outdoor\"}\n\nSize: 14\n\nStyle: plain\n\nPattern: check\n\n\n\n\nWe can reuse get_tag_set_from_text to create a search set\nWe take match to mean the search tags are a subset of the item’s tags\n\nThis means that an item must match all the tags\n\nAn alternative approach might be to match any items that match at least one of the tags\n\nThis could be done by checking the intersection is non-empty\n\nIn the above example we can see the blouse matched because the search tags ({\"outdoor\", \"spring\"}) are a subset of the blouse’s tags ({\"spring\", \"friendly\", \"city\", \"outdoor\"})\nThis implementation is thus a simple application of issubset\n\n  def match_tags(item):\n      \"\"\"\n      Checks if the given item matches the specified search tags\n\n      Parameters\n      ----------\n      item : StockItem\n          StockItem to check for matching tags\n\n      Returns\n      -------\n      `True` if the search tags are a subset of `item.tags`, else `False`\n      \"\"\"\n      return search_tags.issubset(item.tags)\n\nWe can see that the search tags are passed in via a global parameter rather than explicitly through the function signature\nThis is so we can use the filter python function\nfilter works like map\n\nmap returns the result of a applying a function to each member of a collection\nfilter applies a boolean function (one that returns True or False) to each member of a collection, and returns the subcollection of all elements that evaluate True\n\n  filtered_list = filter(match_tags, stock_list)\nThe above uses filter to find all items in the stock_list that match the specified tags. Putting this all together\n\nclass FashionShop:\n    def find_matching_with_tags(self, search_tags):\n        \"\"\"\n        Get stock items that match all the specified search tags\n\n        Parameters\n        ----------\n        search_tags : str\n            set of tags to search against.\n            Item's must match all tags\n\n        Returns\n        -------\n        list[StockItem]\n            list containing all StockItem's matching the\n            specified set of tags. If no matches are found\n            the list is empty\n        \"\"\"\n\n        def match_tags(item):\n            \"\"\"\n            Checks if the given item matches the specified search tags\n\n            Parameters\n            ----------\n            item : StockItem\n                StockItem to check for matching tags\n\n            Returns\n            -------\n            `True` if the search tags are a subset of `item.tags`, else `False`\n            \"\"\"\n            return search_tags.issubset(item.tags)\n\n        return filter(match_tags, self.__stock_dictionary.values())\n\nfind_matching_with_tags is added to the FashionShop class as it is a method for handling a collection of stock items\nIt returns the list of matching stock items\nYou may notice something odd, we have declared the match_tags function inside the find_matching_with_tags function\nThis is allowed in python\nMeans that match_tags can access variables in the scope of the find_matching_with_tags function\nThe full tags based implementation is given in the FashionShopWithTags folder\nOne of the minor implementation details is that as tags adds a data attribute to StockItem we have to bump the version number (for the versions in our implementations this is \\(2 \\rightarrow 3\\)), and update check_version\nThe new implementation below, simply adds a empty tags field to older items\n\nNote we don’t need to update the version of the subclasses\nHowever, we do need to update all their __init__ signatures too\n\n  class StockItem:\n      def check_version(self):\n      \"\"\"\n      Checks the version of a `StockItem` instance and upgrades it if required\n\n      Returns\n      -------\n      None\n      \"\"\"\n      if StockItem.show_instrumentation:\n          print(\"**StockItem check_version called\")\n      if self.__StockItem_version &lt; 2:\n          self.location = None\n          self.__StockItem_version = 2\n      if self.__StockItem_version &lt; 3:\n          self.tags = set()\n          self.__StockItem_version = 3\n\n\n\n\n\n\nIt’s quite common for customers to provide feedback on the usability of their product\nFor example our client might prefer the tag-based interface more generally over a rigid class structure\n\n\nYour client would like to make changes to how the program functions. She enjoys using tags to identify stock elements. She finds having to specify a specific item type (e.g. pants, jeans, hat etc.) a painful process. She would prefer to index all stock using tags. Dresses would have the dress tag, etc. Together you propose the following mock-up\n\n\n\n\nEnter stock reference: D001\n\nEnter price: 120\n\nEnter tags (separated by commas): dress, colour:red, location:shop window, pattern:swirly, size:12, evening, long\n\n\n\n\n\nThe client finds searching by tags easy to work with\nTags are more flexible and remind her more of how she would organise stock by hand\nTags give the flexibility to add new items or change how items are described without needing to recompose the class hierarchy\nThe only additional request the client has is to allow the ability to edit the tags on a stock item\n\nCan add or remove tags\nCan correct edits\n\nThe downside is that any tags that are not entered correctly will result in failed searches\n\nThe class hierarchy enforces that the specified attributes for each StockItem subclass exist\n\nA tags only implementation is given by in the TagOnlyFashionShop folder\nThe StockItem implementation becomes much simpler\nFirst since there are no longer subclasses, we no longer define it as an abstract class\nWe update the docstrings and __init__ method\n\nThis involves removing all the attributes that do not describe the stock id, price or stock level\nWe also increment the version number\n\n  class StockItem:\n  \"\"\"\n  Represents a single inventory item\n\n  Attributes\n  ----------\n  stock_ref : str\n      reference id of the stock item\n  tags : set[str]\n      set of tags describing the stock item\n\n  Class Attributes\n  ----------------\n  show_instrumentation : bool\n      Indicates if instrumentation should be printed\n  max_stock_add : int\n      maximum amount of stock that can be added to an item's stock level at a time\n  min_price : int | float\n      minimum price of any stock item\n  max_price : int | float\n      maximum price of any stock item\n  \"\"\"\n\n  show_instrumentation = True\n\n  max_stock_add = 10\n\n  min_price = 0.5\n  max_price = 500\n\n  def __init__(self, stock_ref, price, tags):\n      \"\"\"\n      Creates a `StockItem` instance\n\n      Parameters\n      ----------\n      stock_ref : str\n          stock reference id\n      price : int | float\n          stock price\n      tags : set[str]\n          set of tags describing the stock item\n      \"\"\"\n      if StockItem.show_instrumentation:\n          print(\"**StockItem __init__ called\")\n      self.stock_ref = stock_ref\n      self.__price = price\n      self.tags = tags\n      self.__stock_level = 0\n      self.__StockItem_version = 4\nSince we no longer have multiple subclasses we can remove the item_name property\nThen we have to update the __str__ method\n  def __str__(self):\n      if StockItem.show_instrumentation:\n          print(\"**StockItem __str__ called\")\n      template = \"\"\"Stock Reference: {0}\nPrice: {1}\nStock level: {2}\nTags: {3}\"\"\"\n      return template.format(self.stock_ref, self.price, self.stock_level, self.tags)\nAll our actual core functions can stay the same, but we just need to adjust the check_version\nWe could make check_version convert all the previous attributes to tags, but this has a problem\n\nAll the subclasses that are actually instantiated no longer exist!\nSo really the customer will likely have to remake these objects\nIn our implementation, even though a StockItem should not be created directly, we can provide a warning message that the user should manually update the current object\n\n  def check_version(self):\n      \"\"\"\n      Checks the version of a `StockItem` instance and upgrades it if required\n\n      Returns\n      -------\n      None\n      \"\"\"\n      if StockItem.show_instrumentation:\n          print(\"**StockItem check_version called\")\n      if self.__StockItem_version != 4:\n          print(\"Stock item uses old data model, please recreate this item\")\n\n\n\n\n\n\n\nImportant\n\n\n\nData Migration is Painful\nIn moving from the class hierarchy to a tags based implementation, we’ve encountered one common problem. Data Migration. Before we’ve used simple versioning on classes to update them when we change their implementation. But here we have a bigger scale problem. What do we do when we change the application architecture? We can’t just update the subclasses because they no longer exist. For our small toy problem manually recreating objects probably works fine.\nHowever if we were working on a larger project we would have to create a migration plan. This might be a simple script that converts the old data to the new data schema, or for larger projects this might be a longer term project where we slowly phase in the new system and phase the old system out.\n\n\n\nThe FashionShop class needs no updates\nIt only ever sees objects as StockItems and manages the collection\nWe do need to make minor updates to FashionShopApplication\n\nThis is just adjusting how we create new items to reflect that we don’t have a class hierarchy\n\n  def create_new_stock_item(self):\n      \"\"\"\n      Create a new stock item and add it to the system\n\n      Prompts the user for the necessary descriptors and\n      any optional tags then creates a corresponding stock\n      item and adds it to the store\n\n      Returns\n      -------\n      None\n      \"\"\"\n\n      # now we have a valid item so get the common attributes\n      stock_ref = BTCInput.read_text(\"Enter Stock reference: \")\n      price = BTCInput.read_float_ranged(\n          \"Enter price: \",\n          min_value=StockItem.StockItem.min_price,\n          max_value=StockItem.StockItem.max_price,\n      )\n      tags = FashionShopApplication.tag_set_from_text(\n          BTCInput.read_text(\"Enter tags (separated by commas): \")\n      )\n\n      self.__shop.store_new_stock_item(StockItem.StockItem(stock_ref, price, tags))\nWe’ve also updated the docstring\n\n\n\n\n\n\n\nWarning\n\n\n\nComments can easily go stale\nOne of the reasons that people argue against using comments is that like code itself, they need to be maintained. As we’ve seen above, whenever we modify the code we have to ensure that the comments still correctly describe the behaviour. Since the comments we’re talking about are the docstrings it’s important to have these, and even more important they are up to date. Especially if we want to release documentation for our API.\nHowever, you should be considered in how you document your code. A comment is a maintenance overhead, and an incorrect comment can result in a lot of frustration if it confuses someone looking at the code base\n\n\n\n\n\nClient is now in control of how stock is organised\nTags can be added and searched for on the fly\n\nThis may get unwieldy if the number of tags gets very large\n\nThe program implementation is much simpler\n\nNo need for complicated, synchronised class hierarchy\nEverything is now a stock item\n\n\n\n\n\n\nClass hierarchies allow you to implement strict business or application logic\nAll objects created must obey the specified interfaces\n\nFor example we enforce that a dress has a size, pattern and colour\n\nUsing open-ended tags means that a required tag (say size) might be missing\n\nNo obligation to specify in the size embedded in the code\n\nClasses also allow for polymorphism\n\nCan make a dress behave differently from a hat for example\nWe saw this with the __str__ method\nEach subclass defined it’s own logic for conversion to a string\ntags don’t provide an easy way to have an item-type dependent presentation\n\n\n\n\n\n\n\n\nImportant\n\n\n\nWhat’s important to the programmer may not be important to the customer\nOften when writing programs for other clients it is easy to get fixated on developing a piece of logic that the customer may not actually like. Equally as a programmer, you may not fully understand or appreciate the nature of the businesses logic.\nIn the case of the Fashion Shop application we created a complex hierarchy based on the assumption that the it was important to store all the details for different categories of stock. The class hierarchy enforces that all objects are fully described.\nHowever, from the client’s perspective as long as the item is properly referenced, priced and it’s stock levels tracked, the other information is just a useful bonus. She finds it much more useful to be able to add and modify tags or organise stock as needed.\nProperly understanding the business needs of a client and what their important use cases are is a crucial part of project management. One of the techniques for solving this is called domain-driven design which strives to make sure that software accurately models the domain it is applied to\n\n\n\n\n\nLook at the following scenarios and decide if a class-based or tags based implementation makes sense\n\nYou’re creating banking software for a local bank to manage their accounts. The bank offers credit and checking accounts. Should we use a class hierarchy?\n\nYes\nAccounts are likely to have a rigid set of attributes that all need to be specified and validated\nSome elements are likely common\n\ne.g. the account holder details\n\nDifferent account types might specify different attributes\n\ne.g. credit account requires a credit limit\n\nWe can thus use an abstract Account class, and then subclass this to provide specific implementations\nMeans we can also use method overloading and polymorphism\n\ne.g. Different accounts will process funds withdrawals in different ways\n\nYou can see an example in our model bank system class structure\n\nYou’ve been approached to help a local gallery track their artwork. The gallery holds pictures, sculptures, and manuscripts. Should we use a class hierarchy?\n\nLikely not\nThere is likely not a lot of common functionality between the objects\nThe items are also likely to be flexibly described rather than have a rigid data model\nThe gallery may evolve and change how they categorise\n\ne.g. They may switch from categorising by type to categorising by artist etc.\n\nSets and tags makes sense here\nIn theory you could just reuse the tags-only fashion shop application (maybe renaming some items so they contextually make sense)",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 11: Object-based Solution Design"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/11_ObjectBasedSolutionDesign/Chapter_11.html#notes",
    "href": "02_AdvancedProgramming/11_ObjectBasedSolutionDesign/Chapter_11.html#notes",
    "title": "Chapter 11: Object-based Solution Design",
    "section": "",
    "text": "The previous chapter looked at creating useful objects\nIn this chapter we’ll explore how to create systems comprising large numbers of different but related objects\nWe’ll also look at connecting objects via their methods\n\n\n\n\nConsider the following scenario\n\n\nA friend who runs a fashion shop would like you to build an application to help manage her stock. She sells a large range of clothing items and wants to be able to track inventory. Her workflow is as follows, stock arrives from suppliers, the details are entered in the system. When an item is sold it should be removed from the stock. She would also like to be produce reports indicating how many of each item are in stock.\n\n\nWorking with the client you define the following information about how her stock operates\nEach item has a unique reference\nEach reference contains:\n\nA description\nA price\nA number in stock\nA list of delivery amounts and dates, and sales\n\nFor now the client is happy to just print out the entire stock list\nHas indicated in future they may wish to have more analytics, e.g.\n\ndetermine which item has the lowest stock\n\nOur prototype interface is then,\n  Mary's Fashion Shop\n\n  1. Create a new stock item\n  2. Add stock to an existing item\n  3. Sell stock\n  4. Stock report\n  5. Exit\n\n  Enter your command:\nThe above options are all pretty straightforward for now\n\n\n\n\nBefore designing the program we need to understand the data we have to represent\nOur client tells us that each stock item requires,\n\nStock reference id\nPrice\nColour\nNumber in stock\n\nThe client also has specifics for different types of stock items\n\nFor Dresses we require\n\nSize\nStyle\nPattern\n\nFor pants we require\n\nLength\nWaist size\nStyle\nPattern\n\nFor hats we require\n\nSize\n\nFor blouses we require\n\nSize\nStyle\nPattern\n\n\nWe can map out some descriptions\n  Dress: stock reference: 'D0001' price: 100.0 colour: red pattern: swirly size: 12\n  Pants: stock reference: 'TR12327'price: 50 colour: black pattern: plain length: 30 waist: 30\nNow that we have our data requirements and some mock items, we want to carry out data design\nData design is the process of specifying how we represent a programs data\n\n\n\n\n\nA design paradigm we could use is to represent each data object as a class\n\nThis object-centric approach is called object-oriented programming\n\nSolution elements are mapped to software objects\nA way to formulate classes is to break a problem statement down into nouns\nnouns describe things which naturally translate to objects\n\ne.g. a food service point-of-sale system might be described as\n\n\n\nThe customer will select a dish from the menu and add it to his order.\n\n\n\n\nThe four nouns above (written in red) could map to classes in the application\n\nThis is only a starting point\nWe would have to dive deeper into the design requirements with the client\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nDon’t write any code before you have completed your data design\nDesign mistakes are easiest to correct early in a project’s lifecycle. For this reason data design is almost always carried out and completed before we actually starting to right code.\nIf we were to continue developing the restaurant point of sale system above, we would have to work through the data requirements with the client. For example if we were developing a Customer class, we might map out paper variants of the class, and work through usage scenarios with the client to ensure all the details are captured.\nFor example if a customer needed to provide a telephone number we would want to capture this design requirement early.\n\n\n\nFor our first design we could implement all these different stock items as different classes, (you can find the code in SeparateClasses.py)\n\n\n# Example 11.1 Fashion Items as Separate Classes\n#\n# Mocks out the class-based implementation of the fashion items, treating\n# each different item type as it's own standalone class\n\n\nclass Dress:\n    \"\"\"\n    Represents the inventory details for a Dress\n    \"\"\"\n\n    def __init__(self, stock_ref, price, colour, pattern, size):\n        \"\"\"\n        Creates a `Dress` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            stock reference code\n        price : int | float\n            dress price\n        colour : str\n            description of the dress colour\n        pattern : str\n            description of the dress pattern\n        size : int\n            dress size\n        \"\"\"\n        self.stock_ref = stock_ref\n        self.__price = price\n        self.__stock_level = 0\n        self.colour = colour\n        self.pattern = pattern\n        self.size = size\n\n    @property\n    def price(self):\n        \"\"\"\n        price : int | float\n            dress price\n        \"\"\"\n        return self.__price\n\n    @property\n    def stock_level(self):\n        \"\"\"\n        stock_level : int\n            amount of stock in inventory\n        \"\"\"\n        return self.__stock_level\n\n\nclass Pants:\n    \"\"\"\n    Represents the inventory details for a pair of Pants\n    \"\"\"\n\n    def __init__(self, stock_ref, price, colour, pattern, length, waist):\n        \"\"\"\n        Creates a `Pants` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            stock reference code\n        price : int | float\n            pants price\n        colour : str\n            description of the pants colour\n        pattern : str\n            description of the pants pattern\n        length: int\n            length of the pants\n        waist : int\n            pants waist size\n        \"\"\"\n        self.stock_ref = stock_ref\n        self.__price = price\n        self.__stock_level = 0\n        self.colour = colour\n        self.pattern = pattern\n        self.length = length\n        self.waist = waist\n\n    @property\n    def price(self):\n        \"\"\"\n        price : int | float\n            dress price\n        \"\"\"\n        return self.__price\n\n    @property\n    def stock_level(self):\n        \"\"\"\n        stock_level : int\n            amount of stock in inventory\n        \"\"\"\n        return self.__stock_level\n\n\nx = Dress(stock_ref=\"D001\", price=100, colour=\"Red\", pattern=\"Swirly\", size=12)\ny = Pants(\n    stock_ref=\"TR12327\", price=50, colour=\"Black\", pattern=\"Plain\", length=30, waist=25\n)\n\nprint(x.price)\nprint(y.stock_level)\n\n100\n0\n\n\n\nWe define a Dress and a Pants class\nEach class has to have an __init__ to set them up\nBoth classes have private price and stock levels\n\nThese are important parts of the inventory system that should have controlled modification\nWe don’t want the price being modified and overcharging customers\nWe don’t want the stock level being off causing us to mis-order\n\nBoth classes have properties to access price and stock levels\n\nLater we’ll make methods to control these\n\n\n\n\n\n\n\n\nCaution\n\n\n\nAvoid overusing block-copy\nUsing a text editor it might seem convenient to copy a large block of code when we have to reuse it elsewhere. Whenever you feel yourself copying lets of code to different sections this is usually a good indicator that something is not right. You should aim to write a piece of code once. Code written once is more maintainable, as we only need to modify it in one place. If the code is used multiple times, it is a good candidate to be converted into a function or a method\nAs mentioned block copying is liable to introduce bugs. If we need to slightly modify the code in the new section we have to make sure we do it correctly (which might be hard if you’ve copied a big chunk). Additionally if you latter find a bug, you may have to fix all the copies (which requires you to remember where they are).\nUse this as advice, if you find yourself copying lots of code, its a good time to take a step back at look at your overall design\n\n\n\n\n\n\nMany languages (including python) let us use inheritance\nInheritance allows one class to base itself on another\n\ni.e. it inherits the behaviour of another class\n\nThe original class is called the superclass\nCreating this new class is called extending the superclass\nBy default all python classes extend the object class\nWe could write this explicitly\n  class Contact(object)\nWe can replace the object in the above with the class we want to use as a superclass\nLooking at our data design we can see there is a bunch of behaviour common to all stock items\nWe can start by defining a StockItem to act as a superclass\n\nStockItem stores all common attributes\n\nStock reference\nPrice\nColour\nStock level\n\n\nDress and Pants now extend StockItem\n\nThe other stock items will do so as well\n\nThe diagram below shows what’s called a class diagram or inheritance hierarchy\n\n\n\n\n\n\n---\ntitle: Fashion Shop Class Diagram\n---\n\nclassDiagram\n    class object\n\n    class StockItem {\n        str stock_ref\n        str item_name\n        str colour\n        number price\n        int stock_level\n    }\n\n    class Dress {\n        str pattern\n        int size\n    }\n\n    class Pants {\n        int length\n        str pattern\n        int waist\n    }\n\n    object &lt;|-- StockItem\n    StockItem &lt;|-- Dress\n    StockItem &lt;|--  Pants\n\n\n\n\n\n\n\nWe can see that both Pants and Dress are subclasses of StockItem\nThe inverse relationship is StockItem is the superclass of Pants and Dress\nWe call this inheritance because the subclasses inherit the attributes of the superclass\nWhen building an inheritance hierarchy you need to focus on your data\n\nHere we have a collection of related data items\nThe basic behaviour of a data item is the same\nThe related items also have some common data attributes\n\nWe capture the common behaviour and data in a superclass\n\nThen extend with subclasses the specific behaviour of different data items\n\nAlso means that if we add new common behaviour we only have to add it in one place\n\ni.e. the superclass\nOtherwise we would have to put it in all the classes\n\n\n\n\n\nAbstraction is a term used to describe attempting to capture behaviours and data of a system at a higher level\nHere by introducing a StockItem class we are attempting to talk about the behaviour of stock items in generality as opposed to any specific type of stock item\n\ni.e. We know that a stock item should be,\n\nAble to be added\nAble to be sold\nFind out what stock items we have\n\nWe do not capture the specifics of how these processes occur\n\nJust know that we need to capture them in our program\n\n\nAbstract lets us look at processes without getting caught up in the details\nLater we can go and fill those details in\nTypically as we move down a class hierarchy, we should move from the more abstract to the more concrete\n\nAt the highest level a class or interface might just say what methods an object should have\nThe next level down might implement some common attributes and methods (StockItem)\nThe next level down might provide specialised attributes and specific methods (Dress and Pants)\n\n\n\n\n\nWork through the following questions on object-oriented design and inheritance. It’s a good idea to consider your own thoughts on the topic\n\nWhy don’t we put all the attributes in one class and not bother with subclasses?\n\nWe could add every possible attribute to one class\nHowever then we would have to handle the fact that some attributes are not defined for certain types\n\ne.g. Dress has no waist attribute and Pants has no size\n\nAs we add more classes we would have to consider all the valid possible combinations of attributes and manage them\n\nExactly the kind of thing that the subclass approach does naturally\n\nAdditionally if we want to customise behaviour by type, we would have to add an attribute to track this\n\nInheritance provides polymorphism as a way to do this naturally\n\n\nWhy is the superclass called super?\n\nIt is derived from mathematical terminology around sets\nIn maths \\(A\\) is a subset of \\(B\\) if \\(A\\) is entirely contained in \\(B\\)\n\\(A\\) is a superset of \\(B\\) if \\(A\\) contains \\(B\\)\nThe idea carries onto the language of classes, where the superclass is called super because every subclass is also an instance of the superclass.\n\nWhich is most abstract, a superclass or a subclass?\n\nRecall, the concept of the class hierarchy\nMoving down into subclasses is getting more concrete (less abstract)\nMoving up into superclasses is getting more abstract\n\nCan you extend a subclass?\n\nYes\nWe can see this in the class hierarchy\nStockItem is a subclass of Object\nDress extends StockItem to create a new subclass\n\nWhy is the pattern attribute not in the StockItem class?\n\nLooking at our current class diagram this does make sense\n\nBoth Dress and Pants have a pattern attribute\n\nHowever our client had other types of items e.g. Hat that didn’t have a pattern attribute\nIf we wanted to remove the duplication we might introduce a PatternedItem between StockItem and the Dress and Pants classes\n\nHowever for one specific attribute this is probably not necessary right now\nEspecially as the PatternedItem seems partially arbitrary rather than reflecting an actual category of item\n\n\nWill our system ever create a StockItem object?\n\nNothing prevents us from doing so\nHowever, in practice we there’s no real use case\n\nStockItem is not representing an actual physical item\nIt represents the concept of a stock item\n\nIf we wanted to do we could define StockItem as an abstract class\n\nAbstract classes can’t be instantiated\nThey are good for defining the structure and behaviour of a class\nImplementation left to the subclasses\n\n\nThe client decides in future she may like to track which customers have bought which stock items. Here are three potential implementations. Which implementation makes the most sense?\n\nExtend the StockItem class to make a Customer subclass that contains the customer details because customers buy StockItems\nAdd Customer details to each StockItem\nCreate a new Customer class that contains a list of the StockItems that the Customer has bought\n\n\nClass hierarchies should reflect an is-a relationship\nA Customer is not a Stock item\nSo option 1 is out\nMultiple customers might buy the same stock item\nThe stock item also represents a category of stock as opposed to one specific item\nSo we don’t want to have a Customer field\n\nWe could have a list of customers if we wanted to do it this way\n\nHowever, in the future we might want to add more behaviour for interacting with a customer itself\n\nThus makes sense to define a Customer class\n\n\n\n\n\n\n\nNow lets refactor our code to use a class hierarchy\nThe naive implementation looks like,\n\n\nfrom abc import ABC\n\n\nclass StockItem(ABC):\n    \"\"\"\n    Abstract base class representing a single inventory item.\n\n    Attributes\n    ----------\n    stock_ref : str\n        reference id of the stock item\n    colour : str\n        description of the item's colour\n    \"\"\"\n\n    def __init__(self, stock_ref, price, colour):\n        \"\"\"\n        Creates a `StockItem` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            stock reference id\n        price : int | float\n            stock price\n        colour : str\n            description of stock item's colour\n        \"\"\"\n        self.stock_ref = stock_ref\n        self.__price = price\n        self.colour = colour\n        self.__stock_level = 0\n        self.__stock_level = 0\n\n    @property\n    def price(self):\n        \"\"\"\n        price : int | float\n            dress price\n        \"\"\"\n        return self.__price\n\n    @property\n    def stock_level(self):\n        \"\"\"\n        stock_level : int\n            amount of stock in inventory\n        \"\"\"\n        return self.__stock_level\n\n\nThe StockItem looks pretty standard for a class\nYou may observe that we import ABC from the abc module\n\nabc is a python module to provide abstract classes\nABC is the superclass for abstract classes\n\nWe inherit from ABC to make StockItem abstract\n\nFor now this only indicates that the user should not directly instantiate it\nWe’ll see later the concept of abstract methods which can be used to prevent instantiation of an abstract class\n\nWe move the common attributes and properties to the class\nDefine an __init__ as usual\nNow lets define our Dress class, naively you might write,\n\n  class Dress(StockItem):\n      \"\"\"\n      Represents the inventory details for a Dress\n\n      Inherits from `StockItem`\n\n      Attributes\n      ----------\n      stock_ref : str\n          dress reference id\n      price : int | float\n          dress price\n      colour : str\n          description of dress's colour\n      pattern : str\n          description of the dress pattern\n      size : int\n          dress size\n\n      See Also\n      --------\n      `StockItem` : Parent Class\n      \"\"\"\n\n      def __init__(self, stock_ref, price, colour, pattern, size):\n          \"\"\"\n          Creates a `Dress` instance\n\n          Parameters\n          ----------\n          stock_ref : str\n              stock reference code\n          price : int | float\n              dress price\n          colour : str\n              description of the dress colour\n          pattern : str\n              description of the dress pattern\n          size : int\n              dress size\n          \"\"\"\n          self.pattern = pattern\n          self.size = size\n\nDress subclasses StockItem\nWe add the unique attributes\nCurrently no need to define any new behaviour\nHowever, when we try to create a Dress instance and use it we see\n\n  x = Dress(stock_ref=\"D0001\", price=100, colour=\"red\", pattern=\"swirly\", size=12)\n  print(x.pattern)\n  print(x.price)\n\nswirly\n\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[5], line 3\n      1 x = Dress(stock_ref=\"D0001\", price=100, colour=\"red\", pattern=\"swirly\", size=12)\n      2 print(x.pattern)\n----&gt; 3 print(x.price)\n\nCell In[3], line 41, in StockItem.price(self)\n     35 @property\n     36 def price(self):\n     37     \"\"\"\n     38     price : int | float\n     39         dress price\n     40     \"\"\"\n---&gt; 41     return self.__price\n\nAttributeError: 'Dress' object has no attribute '_StockItem__price'\n\n\n\nWe see that we have no issue creating the object\nCan also access the attributes defined in the subclass (pattern)\nBut we get an error, when we try to access a property on the superclass (price)\nIn fact the error tells us that we can’t find the attribute _StockItem__price\nWhy? Well if we look at the initializer we never seem to have set up the stock level, price, stock reference or colour\n\nWe can’t just write self.colour = colour etc\nBecause this adds an attribute on the subclass\nAlso basically means we’ve rewritten the superclass __init__ again\n\nNeed a way to pass arguments to the __init__ method of the superclass\nWe can do this using super()\n\nsuper() is like self\nUsed to return a reference to the superclass instance\n\n\n\nclass Dress(StockItem):\n    \"\"\"\n    Represents the inventory details for a Dress\n\n    Inherits from `StockItem`\n\n    Attributes\n    ----------\n    stock_ref : str\n        dress reference id\n    price : int | float\n        dress price\n    colour : str\n        description of dress's colour\n    pattern : str\n        description of the dress pattern\n    size : int\n        dress size\n\n    See Also\n    --------\n    `StockItem` : Parent Class\n    \"\"\"\n\n    def __init__(self, stock_ref, price, colour, pattern, size):\n        \"\"\"\n        Creates a `Dress` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            stock reference code\n        price : int | float\n            dress price\n        colour : str\n            description of the dress colour\n        pattern : str\n            description of the dress pattern\n        size : int\n            dress size\n        \"\"\"\n        super().__init__(stock_ref, price, colour)\n        self.pattern = pattern\n        self.size = size\n\n\nx = Dress(stock_ref=\"D0001\", price=100, colour=\"red\", pattern=\"swirly\", size=12)\nprint(x.pattern)\nprint(x.price)\n\nswirly\n100\n\n\n\nWe use super() to get a reference to the super object\nThen call the __init__ object on the instance and pass the required parameters\nKey Takeaway: When initialising a subclass you must explicitly initialise the superclass too\nThe complete code for our class hierarchy incorporating Pants can be found in ClassHierarchy.py\n\n\n\n\n\nSo far each class name matches the stock type being stored\nWe might not want to maintain this relationship\ne.g. if we introduced an “Evening Dress” we can’t create a Evening Dress class\n\nSince class names must be contiguous\n\nThe client thus wants us to provide a way of giving a user friendly string description off the item name\nIn the class diagram we defined a property called an Item Name in the Stock Item\n\nIntended to hold the item name\n\nProvides a user friendly string name\nImplement as a class property\n\n  class StockItem(object):\n\n      @property\n      def item_name(self):\n          \"\"\"\n          stock_level : int\n              amount of stock in inventory\n          \"\"\"\n          return \"Stock Item\"\n\nWe can then override this attribute in the subclasses\n\nOverridden attributes are used inplace of the superclass implementation\n\ne.g. For the Dress class we might write\n\n  class Dress(StockItem):\n      ...\n      @property\n      def item_name(self):\n          return \"Dress\"\n\n\nThen calling item_name on a Dress instance should return \"Dress\" instead of \"Stock Item\" as demonstrated below\n\n    item = StockItem()\n    print(\"item name is\", item.item_name)\n    dress = Dress()\n    print(\"dress name is\", dress.item_name)\n\nitem name is Stock Item\ndress name is Dress\n\n\n\n\n\n\n\nWe’ve just seen how StockItem defines a property item_name which returns a string\nHowever, the intention is that this is overwritten by a subclass\nIt would be good if we could force a subclass to define this method\nWe saw that the abc module allowed us to inherit a class ABC that meant the class should not be directly instantiated\n\nIs there something similar for methods\n\nTurns out there is!\n\nabc contains a abstractmethod decorator\nIf a class has methods decorated with @abstractmethod subclasses can’t be instantiated unless they override all the abstract methods\n\nWe can see this in practice below\n\n\n    import abc\n    class StockItem(abc.ABC):\n\n        @property\n        @abc.abstractmethod\n        def item_name(self):\n            \"\"\"\n            stock_level : int\n                amount of stock in inventory\n            \"\"\"\n            pass\n\n    class Dress(StockItem):\n\n        @property\n        def item_name(self):\n            return \"Dress\"\n\n    class Pants(StockItem):\n        pass\n\n\nHere we define StockItem with item_name as an abstract property\n\nWe do this by using both the @property and @abstractmethod decorators on the method\n\nSince item_name is always overridden, rather than return a value, we simply use pass to indicate a placeholder\nWe next define Dress and Pants as two subclasses\n\nDress overrides the item_name method\nPants does not\n\nLet’s see what happens when we try to instantiate these\n\n  d = Dress()\n  print(d.item_name)\n\n  p = Pants()\n  print(p.item_name)\n\nDress\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[11], line 4\n      1 d = Dress()\n      2 print(d.item_name)\n----&gt; 4 p = Pants()\n      5 print(p.item_name)\n\nTypeError: Can't instantiate abstract class Pants without an implementation for abstract method 'item_name'\n\n\n\nWe can see that the Dress instantiation works as expected\nWe can call Dress and access the overridden item_name property\nHowever, when we try to instantiate p as Pants we get a TypeError!\n\nThe message tells us we need to implement the abstract method item_name\n\n\n\n\n\n\n\nAs seen earlier objects can use the __str__ method to define a string representation\nWe should add these to StockItem and it’s derived classes\nDefining a __str__ method is technically overriding the __str__ method on the parent\n\nIncluding the object class\n\n\n\n\nOpen the python interpreter and work through the following steps to understand method overriding\nEnter the following statement\n\no = object()\n\nThis creates an object instance referenced by o. If we print the value of o we are calling the __str__ method on the object class\nRun the print statement as below\n\nprint(o)\n\n&lt;object object at 0x7f71f0872be0&gt;\n\n\nprint requires a str argument, so o is converted to a string by calling its __str__ method. In this case the __str__ method of the object class. We can see the result is a message that indicates the type of the object and the memory address where the instance is stored.\nThis should be familiar to what we see in the earlier Contact class before we defined a __str__ method. What happened there was that when __str__ was called to convert a Contact to an string, it deferred to the superclass __str__ method which was object\nTo define different behaviour we have to provide our own __str__ method which is said to override the superclass __str__ method.\nDefine a new class StrTest by entering the statements below\n\nclass StrTest(object):\n    def __str__(self):\n        return \"string from StrTest\"\n\nRemember that we don’t have to explicitly inherit from object we’ve just done it to be clear\nIf we now print this new StrTest object, we can see that the new __str__ method on the StrTest is used.\nTest this by running the line below\n\nprint(StrTest())\n\nstring from StrTest\n\n\nBut what if we want to use the __str__ method from the superclass as part of the __str__ method of the subclass? Well we can do so by using super() to access the superclass instance associated with the subclass instance. We can then directly reference the __str__ method\nDemonstrate this by defining a new class, as below\n\nclass StrTestSub(StrTest):\n    def __str__(self):\n        return super().__str__() + \"..with sub\"\n\nThe __str__ method still overrides the superclass, but super() lets us incorporate the __str__ result from the StrTest superclass. We can see this behaviour if we try to print the object.\nCall print on an instance of StrTestSub as below\n\nprint(StrTestSub())\n\nstring from StrTest..with sub\n\n\n\nNow let’s define __str__ methods for our StockItem and Subclasses\n  class StockItem(abc.ABC):\n      ...\n      def __str__(self):\n          template = \"\"\"Stock Reference: {0}\nType: {1}\nPrice: {2}\nStock level: {3}\nColour: {4}\"\"\"\n          return template.format(\n              self.stock_ref, self.item_name, self.price, self.stock_level, self.colour\n          )\nThis __str__ item uses a template string which is formatted\nStockItem attributes are printed one per line\nWhy are we making a __str__ method for the StockItem when we’re going to override this?\nWell the subclasses all have to refer to the common attributes in the StockItem\nMakes sense to use the __str__ method for the superclass to handle how we represent these common attributes\nLet’s see how we put this into practice with the Dress subclass\n\nclass Dress(StockItem):\n    ...\n    def __str__(self):\n        stock_details = super().__str__()\n        template = \"\"\"{0}\nPattern: {1}\nSize: {2}\"\"\"\n        return template.format(stock_details, self.pattern, self.size)\n\nWe use the super() to get the initial part of the string\nThen again use a template string\n\nFirst inject the superclasses string\nThen add on the new attributes in the same style\n\nLet us look at this in practice\n\n\nx = Dress(stock_ref=\"D001\", price=100, colour=\"red\", pattern=\"swirly\", size=12)\nprint(x)\n\nStock Reference: D001\nType: Dress\nPrice: 100\nStock level: 0\nColour: red\nPattern: swirly\nSize: 12\n\n\n\nWe can the final result merges the superclasses string with the added attributes of the Dress class. You can see the complete code in Stock Items with Str\n\n\n\n\n\nConsider the following questions about method overriding\n\nHow does method overriding work?\n\nWhen a method is called, python looks at the object to see if the method exists\nIf it doesn’t python looks up the class hierarchy to see if it can find a matching method\nFirst matching method found is called\nIf all the superclasses are exhausted then an AttributeError is raised\n\nIs an overriding method forced to call the method it is overriding?\n\nNo\nYou only need to do it, if you need to access the superclasses implementation\n__str__ method in the Dress class calls the __str__ in the super because the functionality is useful\n\nMeans if StockItem is updated, we can update the __str__ method and it automatically propagates through to the Dress class\n\n\n\n\n\n\n\nRecall in the Time Tracker we versioned our Session and Contact classes\nThere the goal was to keep old data files usable\n\nWe want to do the same for our Fashion Shop\n\nWhere should the version numbers go?\n\nFor example Dress is a subclass of StockItem, so we could\n\nVersion in the StockItem superclass\nVersion in the Dress superclass\nVersion in both the StockItem and the Dress superclass\n\nWe want both, why?\n\nStockItem might change, but the subclasses don’t\n\nWe don’t want to bump every subclass version\n\nDress might change\n\nStockItem doesn’t, so don’t want to bump it because then that would propagate through to all the other subclasses\n\n\n\nSo we need to implement a version and check_version for both\n\nclass StockItem(abc.ABC):\n\n    def __init__(self, stock_ref, price, colour):\n        self.stock_ref = stock_ref\n        self.__price = price\n        self.colour = colour\n        self.__stock_level = 0\n        self.__StockItem_version = 1\n\n    ...\n\n    def check_version(self):\n        \"\"\"\n        Checks the version of a StockItem instance and upgrades it if required\n\n        Returns\n        -------\n        None\n        \"\"\"\n        pass  # for version 1, no need to check\n\nFor StockItem we add a version attribute labelled __StockItem_version to distinguish from the version numbers of the subclasses\n\nVersion number is hard-coded by the constructor\nWhen we create a new version of the StockItem this is where we bump the version\n\nCurrently there is only one version of the StockItem class, so the corresponding check_version method doesn’t need to do anything\n\nWe still need to include it for the future API\nWe just use pass to make it a placeholder method for now\n\nWe can now define versions and version checking for our subclasses, e.g. for Dress\n\nclass Dress(StockItem):\n\n    def __init__(self, stock_ref, price, colour, pattern, size):\n        super().__init__(stock_ref, price, colour)\n        self.pattern = pattern\n        self.size = size\n        self.__Dress_version = 1\n\n    ...\n\n    def check_version(self):\n        \"\"\"\n        Checks the version of a `Dress` instance and upgrades it if required\n\n        Returns\n        -------\n        None\n        \"\"\"\n        super().check_version()\n\nAs before we add a version attribute (here __Dress_version)\nWe define a new check_version\n\nAgain, right now there is only one version of the Dress so we don’t need to do any self upgrades\nHowever, Dress doesn’t know about the version of StockItem so we have to call super to run check_version for the superclass instance\n\nTogether this means we can update Dress and StockItem independently and saved objects will still be synchronised across both class definitions\nThe implementation for Pants is similar and can be found along with the complete implementation in Versioned Stock Items\n\n\n\n\n\nOverriding methods is an example of a more broader concept of polymorphism\nPolymorphism refers to the same behaviour being able to be applied differently depending on the specific context or object\n\ne.g. all python objects have a __str__ method\ndefines how they are converted to a string representation\nWe can override the __str__ method to make different objects have different behaviours\n\ne.g. default object prints the memory address, an int gives a string representation of its number, and our StockItem class prints its attributes as a newline separated list\n\nThis behaviour is said to be polymorphic, because different objects have different responses to the same behaviour (string conversion)\n\nSoftware is frequently polymorphic\n\ne.g. a Play button might be used to start playback of music, video or a slide show\n\nSame concept (play button)\nDifferent outcome\n\n\nPolymorphism and Abstraction are typically a partnership\n\nAt an abstract level one might define a general set of behaviours a group of similar objects or classes need to do (e.g. “be played”)\nThen use polymorphic behaviour to capture that common concept in one function, say play that is implemented differently for each class e.g. music, video, slide show\n\n\n\n\nTry and work through the following questions about polymorphism before reading the answers\n\nIs polymorphism all about providing methods in a class hierarchy?\n\nNo\nIn this example we’ve used a class hierarchy\n\n__str__ behaves differently, but all objects have a __str__\nHowever we have defined a check_version\nStockItem and Dress both behave differently when check_version is called\n\nBut another object say Book might also have a check_version function\nAgain behaves completely differently\nBut no direct method overwrite chain\nWould still say this behaviour is polymorphic\n\n\nPolymorphism is a broader concept that a class hierarchy\n\nThough we’ve seen, a class hierarchy is one way of structuring polymorphic behaviour\n\n\nHow do I know which methods in my application should be polymorphic?\n\nThis is part of the design process\nIdentify the similar behaviours performed by different objects that work differently for each\ne.g. in a video game all enemies might attack but different enemy types might do so differently\n\nCould then define a class hierarchy with some base enemy type\nThis could then define attack, etc.\n\nSubclasses then override the behaviour polymorphically\nBut we can still talk about “enemies” as a whole\n\n\n\n\n\n\n\n\n\nWhen constructing our classes we made some attributes private\nHow does this carry through the class hierarchy? e.g.\n  class StockItem(abc.ABC):\n      \"\"\"\n      Abstract base class representing a single inventory item.\n\n      Subclasses are expected to overwrite the `item_name` abstract\n      property with a user friendly string description\n\n      Attributes\n      ----------\n      stock_ref : str\n          reference id of the stock item\n      colour : str\n          description of the item's colour\n      \"\"\"\n      def __init__(self, stock_ref, price, colour):\n          \"\"\"\n          Creates a `StockItem` instance\n\n          Parameters\n          ----------\n          stock_ref : str\n              stock reference id\n          price : int | float\n              stock price\n          colour : str\n              description of stock item's colour\n          \"\"\"\n          self.stock_ref = stock_ref\n          self.__price = price\n          self.colour = colour\n          self.__stock_level = 0\n          self.__StockItem_version = 1\nThe above shows the __init__ method for StockItem\nWe can see some public attributes\n\nstock_ref\ncolour\n\nThese can be accessed by anyone\n\nIncluding subclasses\n\nAlso some private ones\n\n__price\n__stock_level\n__StockItem_version\n\nPrivate means restricted to the class in which it was declared\n\nSubclasses are still regarded as other classes\nPrivate variables are thus not accessible in subclasses\n\nSometimes people refer to variables marked with _ i.e. one underscore as Protected\n\nA protected variable is one that can be accessed by the class it is defined in, or any subclasses of that class\n\nWhen designing a class hierarchy you should think about how the data may be used by subclasses\nIf you think you might need to customise behaviour on an attribute\n\nConsider a read-only property, or making it protected/public\n\n\n\n\n\n\n\nLet’s recap our design\nThe client owns a fashion shop\nShe sells several different clothing types\nShe needs a stock management system\nAll clothing items have\n\nA stock reference\nPrice\nStock level\nColour\n\nSpecific clothing items define additional attributes\nTo avoid duplicate code we define a StockItem class\n\nWe define subclasses for specific items\n\nDress\nPants\nHat\nBlouse\n\nsubclasses extend the attributes on a StockItem\n\nEach class has an __init__ to initialise it\n\nEach subclass calls the superclass __init__\nSets up the superclass instance\n\nWe independently version the sub and super classes\n\n\n\nTry to answer the following questions about data design\n\nIs the data design process now complete?\n\nNo\nTo account for this we’ve introduced versioning to a our data objects\n\nthe version attributes and check_version should allow us to add new attributes or modify the objects\n\n\nWhat happens if the fashion shop owner decides to sell a new kind of stock item? Suppose that she wanted to start selling Jeans, which are a type of pants that also has a style, which can be flared, bootleg or straight. What’s the best way to do this?\n\nWe can add a new subclass\n\nWe could subclass StockItem as before\n\nBut then would have to duplicate the Pants code\n\nWe can subclass Pants\n\n\n class Jeans(Pants):\n     \"\"\"\n     Represents the inventory details for a pair of Jeans\n\n     Inherits from `Pants`\n\n     Attributes\n     ----------\n     stock_ref : str\n         pants reference id\n     price : int | float\n         pants price\n     colour : str\n         description of pants's colour\n     pattern : str\n         description of the pants pattern\n     length : int\n         length of the pants\n     waist : int\n         waist size of the pants\n     style : str\n         style of the pants\n\n     See Also\n     --------\n     Pants : Parent Class\n     \"\"\"\n\n     def __init__(self, stock_level, price, colour, pattern, length, waist, style):\n         \"\"\"\n         Creates a `Jeans` instance\n\n         Parameters\n         ----------\n         stock_ref : str\n             stock reference code\n         price : int | float\n             pants price\n         colour : str\n             description of the pants colour\n         pattern : str\n             description of the pants pattern\n         length: int\n             length of the pants\n         waist : int\n             pants waist size\n         style : str\n             jeans style\n         \"\"\"\n         # pants constructor\n         super().__init__(stock_level, price, colour, pattern, length, waist)\n         self.style = style # new attribute\n         self.__Jeans_version = 1 # versioning\n\n     def __str__(self):\n         pants_details = super().__str__()\n         template = \"\"\"{0}\n Style: {1}\"\"\"\n         return template.format(pants_details, self.style)\n\n     @property\n     def item_name(self):\n         return \"Jeans\"\n\n     def check_version(self):\n         \"\"\"\n         Checks the version of a `Pants` instance and upgrades it if required\n\n         Returns\n         -------\n         None\n         \"\"\"\n         super().check_version()\nWhat happens if the fashion shop owner decides to store something new about the stock? For example suppose the client now adds a location attribute to stock items. Location is a string description of where in the store the stock item is stocked. She tells your her plan is to later provide a program that will allow customers to find where items are located in the store. How can we add this attribute and to which class would we add it?\n\nAll items need this property so most appropriate to add to StockItem\nShould be added to the __init__\n\n\n class StockItem(abc.ABC):\n\n     def __init__(self, stock_ref, price, colour, location):\n         self.stock_ref = stock_ref\n         self.__price = price\n         self.__stock_level = 0\n         self.colour = colour\n         self.location = location\n         self.__StockItem_version = 2 # we have to bump the version number\n\n\nThis has a problem that it breaks our program!\nIf we try create a new Dress we find\n\n   d = Dress(\"D001\", 100, \"red\", \"swirly\", 12)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[23], line 1\n----&gt; 1 d = Dress(\"D001\", 100, \"red\", \"swirly\", 12)\n\nCell In[22], line 3, in Dress.__init__(self, stock_ref, price, colour, pattern, size)\n      2 def __init__(self, stock_ref, price, colour, pattern, size):\n----&gt; 3     super().__init__(stock_ref, price, colour)\n      4     self.pattern = pattern\n      5     self.size = size\n\nTypeError: StockItem.__init__() missing 1 required positional argument: 'location'\n\n\n\nDress does not know about the new location argument to the StockItem constructor\n\nThus generates an error when trying to call the constructor\n\nTo fix this we have to update the Dress __init__ method\n\nSame for every other subclass\n\n\n  class Dress(StockItem):\n      def __init__(self, stock_ref, price, colour, location, pattern, size):\n          super().__init__(stock_ref, price, colour, location)\n          self.pattern = pattern\n          self.size = size\n          self.__Dress_version = 1 # no attribute changes to `Dress`\n\nNow the instantiation should work\n\n  d = Dress(\"D001\", 100, \"red\", \"front shelf\", \"swirly\", 12)\n  print(d)\n\n&lt;__main__.Dress object at 0x7f71f0e45c10&gt;\n\n\nThe takeaway is that class hierarchies are very brittle to changes\n\nEspecially changes high up in the abstraction hierarchy\n\nHence you should aim to be very sure of the design of your high level classes\nAn alternative approach is to use properties, e.g.\n\n class StockItem(abc.ABC):\n\n     @property\n     def location(self):\n         \"\"\"\n         location : str\n             location in the store where the stock item is stored\n         \"\"\"\n         result = getattr(self, \"_location\", None)\n         return result\n\n     @location.setter\n     def location(self, location):\n         self._location = location\n\nWe define a getter and setter pair as usual. The setter looks pretty much as we would expect\nThe location get method is interesting though\n  result = getattr(self, \"_location\", None)\ngetattr is a python built-in function\nTakes three arguments\n\nAn object to get the attribute from\nThe attribute to get (as a string)\nA default value to return if the attribute is not found\n\nThe default value is returned if the attribute has not been set yet\n\nAttempting to read the location from a StockItem without one will thus return None\n\nNone is discussed in Chapter 7\nThis approach is good because we can dynamically update objects\n\nHowever it has the downside of we now need to find a new in our program to make sure that the location is set\n\nA third option would be to just dynamically add the attribute directly, e.g.\n\n d = Dress(\"D001\", price=100, colour=\"red\", pattern=\"swirly\", size=12)\n d.location = \"Front of Shop\"\n\nIf we use this approach we would probably want to pair it with hasattr\nhasattr is a similar function to getattr\nTakes two arguments\n\nAn object to check for the attribute\nname of the attribute (as a string)\n\nhasattr returns True if the attribute exists, else False\n\n\n d = Dress(\"D001\", 100, \"red\", \"swirly\", 12)\n d.location = \"Front of Shop\"\n\n e = Dress(\"D002\", 100, \"green\", \"swirly\", 12)\n\n def demo_hasattr(obj):\n     if hasattr(obj, \"location\"):\n         print(\"The dress is location: \", d.location)\n     else:\n         print(\"The dress does not have location information\")\n\n demo_hasattr(d)\n demo_hasattr(e)\n\nThe dress is location:  Front of Shop\nThe dress does not have location information\n\n\n\nOf the three methods, what are the pros and cons of each?\n\nAdding location to the __init__ is the most robust, but requires the most changes to the class hierarchy\n\nEnforces location defined\n\nIs robust, and still maintains a cohesive well-defined class via properties, but requires external management of when to define a location\n\nProvides sensible behaviour if an attribute has not been set\nThis behaviour is also hidden from the user\n\nIs simple and easy to write, but fragile since it relies on python’s dynamic attributes\n\nRequires a mental model of how we add those attributes\nLikely breaks a lot of tooling\n\n\nThe third approach is easy and probably fine for small personal projects\n\nNot suitable for large professional applications\nLiable to break and hard to maintain\n\nGenerally when in doubt, the best approach is to use the __init__\n\nMakes it easy to follow since all the attribute code is in the same place\n\n\n\n\n\n\nA technique for following the flow of a program is to add instrumentation to code. The most basic form of instrumentation is to add print statements that show the flow of the program. Work through the following exercise to see how this works.\nFor example the below code demonstrates adding instrumentation to the StockItem class. We add a class level variable show_instrumentation that lets us toggle on or off the instrumentation. The most basic implementation just adds print statements that let us know which classes are called.\n\nimport abc\n\nclass StockItem(abc.ABC):\n\n    show_instrumentation = True # make it optional\n\n    def __init__(self, stock_ref, price, colour, location):\n        if StockItem.show_instrumentation:\n            print(\"**StockItem __init__ called\")\n        self.stock_ref = stock_ref\n        self.__price = price\n        self.__stock_level = 0\n        self.__StockItem_version = 1\n        self.colour = colour\n        self.location = location\n\nEach instrumentation call string is given by the ** prefix to distinguish it from the normal code.\nThe code for the instrumentation is replicated below, and can be found in Instrumented Stock Items. Work through the following code and consider the examples below\n\n# Example 11.5 Fashion Items using Instrumentation\n#\n# Adds optional instrumentation to the StockItem hierarchy to demonstrate the\n# control flow\n\nimport abc\n\n\nclass StockItem(abc.ABC):\n    \"\"\"\n    Abstract base class representing a single inventory item.\n\n    Subclasses are expected to overwrite the `item_name` abstract\n    property with a user friendly string description\n\n    Attributes\n    ----------\n    stock_ref : str\n        reference id of the stock item\n    colour : str\n        description of the item's colour\n\n    Class Attributes\n    ----------------\n    show_instrumentation : bool\n        Indicates if instrumentation should be printed\n    \"\"\"\n\n    show_instrumentation = True\n\n    def __init__(self, stock_ref, price, colour):\n        \"\"\"\n        Creates a `StockItem` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            stock reference id\n        price : int | float\n            stock price\n        colour : str\n            description of stock item's colour\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem __init__ called\")\n        self.stock_ref = stock_ref\n        self.__price = price\n        self.colour = colour\n        self.__stock_level = 0\n        self.__StockItem_version = 1\n\n    def __str__(self):\n        if StockItem.show_instrumentation:\n            print(\"**StockItem __str__ called\")\n        template = \"\"\"Stock Reference: {0}\nType: {1}\nPrice: {2}\nStock level: {3}\nColour: {4}\"\"\"\n        return template.format(\n            self.stock_ref, self.item_name, self.price, self.stock_level, self.colour\n        )\n\n    @property\n    @abc.abstractmethod\n    def item_name(self):\n        \"\"\"\n        item_name : str\n            the stock item's name as a user friendly string\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem item_name called\")\n        pass\n\n    @property\n    def price(self):\n        \"\"\"\n        price : int | float\n            dress price\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem get price called\")\n        return self.__price\n\n    @property\n    def stock_level(self):\n        \"\"\"\n        stock_level : int\n            amount of stock in inventory\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem get stock_level called\")\n        return self.__stock_level\n\n    def check_version(self):\n        \"\"\"\n        Checks the version of a StockItem instance and upgrades it if required\n\n        Returns\n        -------\n        None\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem check_version called\")\n        pass  # for version 1, no need to check\n\n\nclass Dress(StockItem):\n    \"\"\"\n    Represents the inventory details for a Dress\n\n    Inherits from `StockItem`\n\n    Attributes\n    ----------\n    stock_ref : str\n        dress reference id\n    price : int | float\n        dress price\n    colour : str\n        description of dress's colour\n    pattern : str\n        description of the dress pattern\n    size : int\n        dress size\n\n    See Also\n    --------\n    StockItem : Parent Class\n    \"\"\"\n\n    def __init__(self, stock_ref, price, colour, pattern, size):\n        \"\"\"\n        Creates a `Dress` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            stock reference code\n        price : int | float\n            dress price\n        colour : str\n            description of the dress colour\n        pattern : str\n            description of the dress pattern\n        size : int\n            dress size\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**Dress __init__ called\")\n        super().__init__(stock_ref, price, colour)\n        self.pattern = pattern\n        self.size = size\n        self.__Dress_version = 1\n\n    def __str__(self):\n        if StockItem.show_instrumentation:\n            print(\"**Dress __str__ called\")\n        stock_details = super().__str__()\n        template = \"\"\"{0}\nPattern: {1}\nSize: {2}\"\"\"\n        return template.format(stock_details, self.pattern, self.size)\n\n    @property\n    def item_name(self):  # type: ignore\n        if StockItem.show_instrumentation:\n            print(\"**Dress get item_name called\")\n        return \"Dress\"\n\n    def check_version(self):\n        \"\"\"\n        Checks the version of a `Dress` instance and upgrades it if required\n\n        Returns\n        -------\n        None\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**Dress check_version called\")\n        super().check_version()\n\n\nclass Pants(StockItem):\n    \"\"\"\n    Represents the inventory details for a pair of Pants\n\n    Inherits from `StockItem`\n\n    Attributes\n    ----------\n    stock_ref : str\n        pants reference id\n    price : int | float\n        pants price\n    colour : str\n        description of pants's colour\n    pattern : str\n        description of the pants pattern\n    length : int\n        length of the pants\n    waist : int\n        waist size of the pants\n\n    See Also\n    --------\n    StockItem : Parent Class\n    \"\"\"\n\n    def __init__(self, stock_ref, price, colour, pattern, length, waist):\n        \"\"\"\n        Creates a `Pants` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            stock reference code\n        price : int | float\n            pants price\n        colour : str\n            description of the pants colour\n        pattern : str\n            description of the pants pattern\n        length: int\n            length of the pants\n        waist : int\n            pants waist size\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**Pants __init__ called\")\n        super().__init__(stock_ref, price, colour)\n        self.pattern = pattern\n        self.length = length\n        self.waist = waist\n        self.__Pants_version = 1\n\n    def __str__(self):\n        if StockItem.show_instrumentation:\n            print(\"**Pants __str__ called\")\n        stock_details = super().__str__()\n        template = \"\"\"{0}\nPattern: {1}\nLength: {2}\nWaist: {3}\"\"\"\n        return template.format(stock_details, self.pattern, self.length, self.waist)\n\n    @property\n    def item_name(self):  # type: ignore\n        if StockItem.show_instrumentation:\n            print(\"**Pants get item_name called\")\n        return \"Pants\"\n\n    def check_version(self):\n        \"\"\"\n        Checks the version of a `Pants` instance and upgrades it if required\n\n        Returns\n        -------\n        None\n        \"\"\"\n        print(\"**Pants check_version called\")\n        super().check_version()\n\n\nclass Jeans(Pants):\n    \"\"\"\n    Represents the inventory details for a pair of Jeans\n\n    Inherits from `Pants`\n\n    Attributes\n    ----------\n    stock_ref : str\n        jeans reference id\n    price : int | float\n        jeans price\n    colour : str\n        description of jeans colour\n    pattern : str\n        description of the jeans pattern\n    length : int\n        length of the jeans\n    waist : int\n        waist size of the jeans\n    style : str\n        style of the jeans\n\n    See Also\n    --------\n    Pants : Parent Class\n    \"\"\"\n\n    def __init__(self, stock_ref, price, colour, pattern, length, waist, style):\n        \"\"\"\n        Creates a `Jeans` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            jeans reference id\n        price : int | float\n            jeans price\n        colour : str\n            description of jeans colour\n        pattern : str\n            description of the jeans pattern\n        length : int\n            length of the jeans\n        waist : int\n            waist size of the jeans\n        style : str\n            style of the jeans\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**Jeans __init__ called\")\n        super().__init__(stock_ref, price, colour, pattern, length, waist)\n        self.style = style\n        self.__Jeans_version = 1\n\n    def __str__(self):\n        if StockItem.show_instrumentation:\n            print(\"**Jeans __str__ called\")\n        pants_details = super().__str__()\n        template = \"\"\"{0}\nStyle: {1}\"\"\"\n        return template.format(pants_details, self.style)\n\n    @property\n    def item_name(self):  # type: ignore\n        if StockItem.show_instrumentation:\n            print(\"**Jeans get item_name called\")\n        return \"Jeans\"\n\n    def check_version(self):\n        if StockItem.show_instrumentation:\n            print(\"**Jeans check_version called\")\n        super().check_version()\n\nFirst define a new Dress item as described\n\ndress = Dress(stock_ref=\"D001\", price=100, colour=\"Red\", pattern=\"Swirly\", size=12)\n\n**Dress __init__ called\n**StockItem __init__ called\n\n\n\nWe can see that first the Dress __init__ is called\nThen the StockItem __init__ is called (from within the previous __init__)\n\nNow define a new Jeans item as below\n\njeans = Jeans(\n    stock_ref=\"TR12327\",\n    price=50,\n    colour=\"Black\",\n    pattern=\"Plain\",\n    length=30,\n    waist=25,\n    style=\"flared\",\n)\n\n**Jeans __init__ called\n**Pants __init__ called\n**StockItem __init__ called\n\n\n\nWe can see this time there are three __init__ calls, in order they are\n\nJeans\nPants\nStockItem\n\nNow lets see what happens when we try to print a Jeans item\n\n\nprint(jeans)\n\n**Jeans __str__ called\n**Pants __str__ called\n**StockItem __str__ called\n**Jeans get item_name called\n**StockItem get price called\n**StockItem get stock_level called\nStock Reference: TR12327\nType: Jeans\nPrice: 50\nStock level: 0\nColour: Black\nPattern: Plain\nLength: 30\nWaist: 25\nStyle: flared\n\n\n\nWe can see that when we the __str__ method is called from the Jeans subclass\nWe propagate up the class hierarchy calling __str__ for Pants then StockItem\nWithin the StockItem __str__ we see that the getter for item_name is called\n\nBut it resolves to the method on the Jeans object\nThis is because Jeans overrides the item_name property\n\nWithin the StockItem we also call the getters for\n\nprice and stock_level\nThese are not overwritten by Jeans and so resolve to the original StockItem\n\nIf we want to turn off the instrumentation we can change the value of StockItem.show_instrumentation e.g.\n\n\nStockItem.show_instrumentation = False\nprint(jeans)\n\nStock Reference: TR12327\nType: Jeans\nPrice: 50\nStock level: 0\nColour: Black\nPattern: Plain\nLength: 30\nWaist: 25\nStyle: flared\n\n\n\nWe can see now there is no instrumentation printed\nA more advanced form of instrumentation is called logging\n\nLogs are typically stored in a separate file\nCan provide more detailed information and triage of problems\n\n\n\n\n\n\n\nWe use our standard menu structure for the Fashion Shop\n\n    Mary's Fashion Shop\n\n    1: Create a new stock item\n    2: Add stock to an existing structure\n    3: Sell stock\n    4: Stock report\n    5: Exit\n\nEnter your command:\n\n\n\nIf a user selects to create a new stock item we then need to decide what stock item to create\nWe do this by using a sub menu\n  Create a new stock item\n\n  1. Dress\n  2. Pants\n  3. Hat\n  4. Blouse\n  5. Jeans\n\n  Enter item to add:\nThe full code is given in Creating Stock Items\n\n  class StockItem(abc.ABC):\n      \"\"\"\n      Abstract base class representing a single inventory item.\n\n      Subclasses are expected to overwrite the `item_name` abstract\n      property with a user friendly string description\n\n      Attributes\n      ----------\n      stock_ref : str\n          reference id of the stock item\n      colour : str\n          description of the item's colour\n      location : str\n          description of where the pants are located\n\n      Class Attributes\n      ----------------\n      show_instrumentation : bool\n          Indicates if instrumentation should be printed\n\n      min_price : int | float\n          minimum price of any stock item\n\n      max_price : int | float\n          maximum price of any stock item\n      \"\"\"\n\n      show_instrumentation = True\n\n      min_price = 0.5\n      max_price = 500\n\n      def __init__(self, stock_ref, price, colour, location):\n          \"\"\"\n          Creates a `StockItem` instance\n\n          Parameters\n          ----------\n          stock_ref : str\n              stock reference id\n          price : int | float\n              stock price\n          colour : str\n              description of stock item's colour\n          location : str\n              description of where the pants are located\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"**StockItem __init__ called\")\n          self.stock_ref = stock_ref\n          self.__price = price\n          self.colour = colour\n          self.location = location\n          self.__stock_level = 0\n          self.__StockItem_version = 2\n\n      def __str__(self):\n          if StockItem.show_instrumentation:\n              print(\"**StockItem __str__ called\")\n          template = \"\"\"Stock Reference: {0}\n  Type: {1}\n  Price: {2}\n  Stock level: {3}\n  Location: {4}\n  Colour: {5}\"\"\"\n          return template.format(\n              self.stock_ref,\n              self.item_name,\n              self.price,\n              self.stock_level,\n              self.location,\n              self.colour,\n          )\n\n      @property\n      @abc.abstractmethod\n      def item_name(self):\n          \"\"\"\n          item_name : str\n              the stock item's name as a user friendly string\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"**StockItem item_name called\")\n          pass\n\n      @property\n      def price(self):\n          \"\"\"\n          price : int | float\n              dress price\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"**StockItem get price called\")\n          return self.__price\n\n      @property\n      def stock_level(self):\n          \"\"\"\n          stock_level : int\n              amount of stock in inventory\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"**StockItem get stock_level called\")\n          return self.__stock_level\n\n      def check_version(self):\n          \"\"\"\n          Checks the version of a `StockItem` instance and upgrades it if required\n\n          Returns\n          -------\n          None\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"**StockItem check_version called\")\n          if self.__StockItem_version &lt; 2:\n              self.location = None\n              self.__StockItem_version = 2\n\n\n  class Dress(StockItem):\n      \"\"\"\n      Represents the inventory details for a Dress\n\n      Inherits from `StockItem`\n\n      Attributes\n      ----------\n      stock_ref : str\n          dress reference id\n      price : int | float\n          dress price\n      colour : str\n          description of dress's colour\n      pattern : str\n          description of the dress pattern\n      size : int\n          dress size\n      location : str\n          place where the dress is located\n\n      See Also\n      --------\n      StockItem : Parent Class\n      \"\"\"\n\n      def __init__(self, stock_ref, price, colour, pattern, size, location):\n          \"\"\"\n          Creates a `Dress` instance\n\n          Parameters\n          ----------\n          stock_ref : str\n              stock reference code\n          price : int | float\n              dress price\n          colour : str\n              description of the dress colour\n          pattern : str\n              description of the dress pattern\n          size : int\n              dress size\n          location : str\n              place where the dress is located\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"**Dress __init__ called\")\n          super().__init__(stock_ref, price, colour, location)\n          self.pattern = pattern\n          self.size = size\n          self.__Dress_version = 1\n\n      def __str__(self):\n          if StockItem.show_instrumentation:\n              print(\"**Dress __str__ called\")\n          stock_details = super().__str__()\n          template = \"\"\"{0}\n  Pattern: {1}\n  Size: {2}\"\"\"\n          return template.format(stock_details, self.pattern, self.size)\n\n      @property\n      def item_name(self):  # type: ignore\n          if StockItem.show_instrumentation:\n              print(\"**Dress get item_name called\")\n          return \"Dress\"\n\n      def check_version(self):\n          \"\"\"\n          Checks the version of a `Dress` instance and upgrades it if required\n\n          Returns\n          -------\n          None\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"**Dress check_version called\")\n          super().check_version()\n\n\n  class Pants(StockItem):\n      \"\"\"\n      Represents the inventory details for a pair of Pants\n\n      Inherits from `StockItem`\n\n      Attributes\n      ----------\n      stock_ref : str\n          pants reference id\n      price : int | float\n          pants price\n      colour : str\n          description of pants's colour\n      pattern : str\n          description of the pants pattern\n      length : int\n          length of the pants\n      waist : int\n          waist size of the pants\n      location : str\n          description of where the pants are located\n\n      See Also\n      --------\n      StockItem : Parent Class\n      \"\"\"\n\n      def __init__(self, stock_ref, price, colour, pattern, length, waist, location):\n          \"\"\"\n          Creates a `Pants` instance\n\n          Parameters\n          ----------\n          stock_ref : str\n              stock reference code\n          price : int | float\n              pants price\n          colour : str\n              description of the pants colour\n          pattern : str\n              description of the pants pattern\n          length: int\n              length of the pants\n          waist : int\n              pants waist size\n          location : str\n              description of where the pants are located\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"**Pants __init__ called\")\n          super().__init__(stock_ref, price, colour, location)\n          self.pattern = pattern\n          self.length = length\n          self.waist = waist\n          self.__Pants_version = 1\n\n      def __str__(self):\n          if StockItem.show_instrumentation:\n              print(\"**Pants __str__ called\")\n          stock_details = super().__str__()\n          template = \"\"\"{0}\n  Pattern: {1}\n  Length: {2}\n  Waist: {3}\"\"\"\n          return template.format(stock_details, self.pattern, self.length, self.waist)\n\n      @property\n      def item_name(self):  # type: ignore\n          if StockItem.show_instrumentation:\n              print(\"**Pants get item_name called\")\n          return \"Pants\"\n\n      def check_version(self):\n          \"\"\"\n          Checks the version of a `Pants` instance and upgrades it if required\n\n          Returns\n          -------\n          None\n          \"\"\"\n          print(\"**Pants check_version called\")\n          super().check_version()\n\n\n  class Jeans(Pants):\n      \"\"\"\n      Represents the inventory details for a pair of Jeans\n\n      Inherits from `Pants`\n\n      Attributes\n      ----------\n      stock_ref : str\n          jeans reference id\n      price : int | float\n          jeans price\n      colour : str\n          description of jeans colour\n      pattern : str\n          description of the jeans pattern\n      length : int\n          length of the jeans\n      waist : int\n          waist size of the jeans\n      style : str\n          style of the jeans\n      location : str\n          description of where the pants are located\n\n      See Also\n      --------\n      Pants : Parent Class\n      \"\"\"\n\n      def __init__(\n          self, stock_ref, price, colour, pattern, length, waist, style, location\n      ):\n          \"\"\"\n          Creates a `Jeans` instance\n\n          Parameters\n          ----------\n          stock_ref : str\n              jeans reference id\n          price : int | float\n              jeans price\n          colour : str\n              description of jeans colour\n          pattern : str\n              description of the jeans pattern\n          length : int\n              length of the jeans\n          waist : int\n              waist size of the jeans\n          style : str\n              style of the jeans\n          location : str\n              description of where the jeans are located\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"**Jeans __init__ called\")\n          super().__init__(stock_ref, price, colour, pattern, length, waist, location)\n          self.style = style\n          self.__Jeans_version = 1\n\n      def __str__(self):\n          if StockItem.show_instrumentation:\n              print(\"**Jeans __str__ called\")\n          pants_details = super().__str__()\n          template = \"\"\"{0}\n  Style: {1}\"\"\"\n          return template.format(pants_details, self.style)\n\n      @property\n      def item_name(self):  # type: ignore\n          if StockItem.show_instrumentation:\n              print(\"**Jeans get item_name called\")\n          return \"Jeans\"\n\n      def check_version(self):\n          if StockItem.show_instrumentation:\n              print(\"**Jeans check_version called\")\n          super().check_version()\n\n\n  class Hat(StockItem):\n      \"\"\"\n      Represents the inventory details for a Hat\n\n      Inherits from `StockItem`\n\n      Attributes\n      ----------\n      stock_ref : str\n          hat reference id\n      price : int | float\n          hat price\n      colour : str\n          description of hats colour\n      size : int\n          Hat size in diameter\n      location : str\n          description of where the hat is located\n\n      See Also\n      --------\n      StockItem : Parent Class\n      \"\"\"\n\n      def __init__(self, stock_ref, price, colour, size, location):\n          \"\"\"\n          Creates a `Hat` instance\n\n          Parameters\n          ----------\n          stock_ref : str\n              hat stock reference id\n          price : int | float\n              hat price\n          colour : str\n              hat colour\n          size : int\n              hat size in diameter\n          location : str\n              where the hat is located in the store\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"**Hat __init__ called\")\n          super().__init__(stock_ref, price, colour, location)\n          self.size = size\n          self.__Hat_version = 1\n\n      def __str__(self):\n          if StockItem.show_instrumentation:\n              print(\"** Hat __str__ called\")\n          stock_details = super().__str__()\n          template = \"\"\"{0}\n  Size: {1}\"\"\"\n          return template.format(stock_details, self.size)\n\n      @property\n      def item_name(self):  # type: ignore\n          if StockItem.show_instrumentation:\n              print(\"** Hat get item_name called\")\n          return \"Hat\"\n\n      def check_version(self):\n          \"\"\"\n          Checks the version and upgrades a `Hat` instance as requires\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"** Hat check_version called\")\n          super().check_version()\n\n\n  class Blouse(StockItem):\n      \"\"\"\n      Represents the inventory details for a Blouse\n\n      Inherits from `StockItem`\n\n      Attributes\n      ----------\n      stock_ref : str\n          stock reference code\n      price : int | float\n          blouse price\n      colour : str\n          description of the blouse colour\n      pattern : str\n          description of the blouse pattern\n      style : str\n          description of the blouse style\n      size : int\n          blouse size\n      location : str\n          place where the blouse is located\n\n      See Also\n      --------\n      StockItem : Parent Class\n      \"\"\"\n\n      def __init__(self, stock_ref, price, colour, pattern, style, size, location):\n          \"\"\"\n          Creates a `Blouse` instance\n\n          Parameters\n          ----------\n          stock_ref : str\n              stock reference code\n          price : int | float\n              blouse price\n          colour : str\n              description of the blouse colour\n          pattern : str\n              description of the blouse pattern\n          style : str\n              description of the blouse style\n          size : int\n              blouse size\n          location : str\n              place where the blouse is located\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"** Blouse __init__ called\")\n          super().__init__(stock_ref, price, colour, location)\n          self.pattern = pattern\n          self.style = style\n          self.size = size\n          self.__Blouse_version = 1\n\n      def __str__(self):\n          if StockItem.show_instrumentation:\n              print(\"** Blouse __str__ called\")\n          stock_details = super().__str__()\n          template = \"\"\"{0}\n  Size: {1}\n  Style: {2}\n  Pattern: {3}\"\"\"\n          return template.format(stock_details, self.size, self.style, self.pattern)\n\n      @property\n      def item_name(self):  # type: ignore\n          if StockItem.show_instrumentation:\n              print(\"** Blouse get item_name called\")\n          return \"Blouse\"\n\n      def check_version(self):\n          \"\"\"\n          Checks the version and upgrades a `Blouse` instance as required\n\n          Returns\n          -------\n          None\n          \"\"\"\n          if StockItem.show_instrumentation:\n              print(\"** Blouse check_version called\")\n          return super().check_version()\n\nWe’ve implemented in all our remaining subclasses Hat and Blouse\nWe’ve also added the location variable\nOur Menu looks pretty straight forward now\nIn StockItem we’ve also added extra class attributes\n\nmin_price and\nmax_price\nThese are designed to be used by external validators\n\nWe can add validation directly to the classes later\n\n\n\nmenu = \"\"\"\nCreate a new stock item\n\n1. Dress\n2. Pants\n3. Hat\n4. Blouse\n5. Jeans\n\nEnter item to add: \"\"\"\n\nfirst_menu_option = 1\nlast_menu_option = 5\n\nmin_stock_item_size = 0\nmax_stock_item_size = 99\n\nitem = BTCInput.read_int_ranged(menu, first_menu_option, last_menu_option)\n\nif item &lt; first_menu_option or item &gt; last_menu_option:\n    raise ValueError(\n        \"Unexpected value {0} found in menu. Please raise a bug report\".format(item)\n    )\n\nWe define our standard menu framework\nThe min_stock_item_size and max_stock_item_size are variables that store the min and max of any size related properties like size, length, waist etc.\nWe then get the user’s choice and check that it’s valid\n\nThis is our usual mechanism of making the code robust to changes\nWhen we add a command first_menu_option and/or second_menu_option should be updated\nNeeds to be replicated through to getting user input\nThe guard clause makes sure these align\n\nNow we have a valid item we can get the common attributes for a StockItem\n  # now we have a valid item so get the common attributes\n  stock_ref = BTCInput.read_text(\"Enter Stock reference: \")\n  price = BTCInput.read_float_ranged(\n      \"Enter price: \", min_value=StockItem.min_price, max_value=StockItem.max_price\n  )\n  colour = BTCInput.read_text(\"Enter colour: \")\n  location = BTCInput.read_text(\"Enter location: \")\nThen we implement the menu choices as below\nWe report to the user what object we’re creating\nWe then ask for the attributes unique to that stock item type\nThen create the appropriate object\n  if item == 1:\n  print(\"Creating a Dress\")\n  pattern = BTCInput.read_text(\"Enter pattern: \")\n  size = BTCInput.read_int_ranged(\n      \"Enter size: \", min_value=min_stock_item_size, max_value=max_stock_item_size\n  )\n  stock_item = Dress(stock_ref, price, colour, pattern, size, location)\n\n  elif item == 2:\n      print(\"Creating a pair of Pants\")\n      pattern = BTCInput.read_text(\"Enter pattern: \")\n      length = BTCInput.read_int_ranged(\n          \"Enter length: \", min_value=min_stock_item_size, max_value=max_stock_item_size\n      )\n      waist = BTCInput.read_int_ranged(\n          \"Enter waist size: \",\n          min_value=min_stock_item_size,\n          max_value=max_stock_item_size,\n      )\n      stock_item = Pants(stock_ref, price, colour, pattern, length, waist, location)\n\n  elif item == 3:\n      print(\"Creating a Hat\")\n      size = BTCInput.read_int_ranged(\n          \"Enter size: \", min_value=min_stock_item_size, max_value=max_stock_item_size\n      )\n      stock_item = Hat(stock_ref, price, colour, size, location)\n\n  elif item == 4:\n      print(\"Creating a Blouse\")\n      pattern = BTCInput.read_text(\"Enter pattern: \")\n      style = BTCInput.read_text(\"Enter style: \")\n      size = BTCInput.read_int_ranged(\n          \"Enter size: \", min_value=min_stock_item_size, max_value=max_stock_item_size\n      )\n      stock_item = Blouse(stock_ref, price, colour, pattern, style, size, location)\n\n  elif item == 5:\n      print(\"Creating a pair of Jeans\")\n      pattern = BTCInput.read_text(\"Enter pattern: \")\n      style = BTCInput.read_text(\"Enter style: \")\n      length = BTCInput.read_int_ranged(\n          \"Enter length: \", min_value=min_stock_item_size, max_value=max_stock_item_size\n      )\n      waist = BTCInput.read_int_ranged(\n          \"Enter waist size: \",\n          min_value=min_stock_item_size,\n          max_value=max_stock_item_size,\n      )\n      stock_item = Jeans(\n          stock_ref, price, colour, pattern, length, waist, style, location\n      )\n  else:\n      stock_item = None\nAn example output from this program might then look like\n\n\n\n\nCreate a new stock item\n\n\n\n1. Dress\n\n2. Pants\n\n3. Hat\n\n4. Blouse\n\n5. Jeans\n\n\n\nEnter item to add:  1\n\nEnter Stock reference: DO001\n\nEnter price: 100\n\nEnter colour: Red\n\nEnter location: Shop Window\n\nCreating a Dress\n\nEnter pattern: Swirly\n\nEnter size: 12\n\nEnter location: Front Window\n\n**Dress __init__ called\n\n**StockItem __init__ called\n\n**Dress __str__ called\n\n**StockItem __str__ called\n\n**Dress get item_name called\n\n**StockItem get price called\n\n**StockItem get stock_level called\n\nStock Reference: D001\n\nType: Dress\n\nPrice: 100\n\nStock level: 0\n\nLocation: Front Window\n\nColour: Red\n\nPattern: Swirly\n\nSize: 12\n\n\n\n\n\nIn the future we will look at how to wrap these user interactions in a class FashionShopShellApplication\n\n\n\n\n\nWhen items are created they start with a default stock level of \\(0\\)\nWe need some way to increase a stock item’s stock level when an order arrives\nWe can’t directly modify __stock_level as it’s private\nSo we need to add a method\n\n\n# Example 11.7 Updating Stock Levels on an Item\n#\n# Continues demonstrating behaviours of the fashion shop, here we highlight how\n# to implement adding to stock levels\n\nimport abc\n\n\nclass StockItem(abc.ABC):\n    \"\"\"\n    Abstract base class representing a single inventory item.\n\n    Subclasses are expected to overwrite the `item_name` abstract\n    property with a user friendly string description\n\n    Attributes\n    ----------\n    stock_ref : str\n        reference id of the stock item\n    colour : str\n        description of the item's colour\n    location : str\n        description of where the pants are located\n\n    Class Attributes\n    ----------------\n    show_instrumentation : bool\n        Indicates if instrumentation should be printed\n\n    max_stock_add : int\n        maximum amount of stock that can be added to an item's stock level at a time\n    \"\"\"\n\n    show_instrumentation = True\n\n    max_stock_add = 10\n\n    def __init__(self, stock_ref, price, colour, location):\n        \"\"\"\n        Creates a `StockItem` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            stock reference id\n        price : int | float\n            stock price\n        colour : str\n            description of stock item's colour\n        location : str\n            description of where the pants are located\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem __init__ called\")\n        self.stock_ref = stock_ref\n        self.__price = price\n        self.colour = colour\n        self.location = location\n        self.__stock_level = 0\n        self.__StockItem_version = 2\n\n    def __str__(self):\n        if StockItem.show_instrumentation:\n            print(\"**StockItem __str__ called\")\n        template = \"\"\"Stock Reference: {0}\nType: {1}\nPrice: {2}\nStock level: {3}\nLocation: {4}\nColour: {5}\"\"\"\n        return template.format(\n            self.stock_ref,\n            self.item_name,\n            self.price,\n            self.stock_level,\n            self.location,\n            self.colour,\n        )\n\n    @property\n    @abc.abstractmethod\n    def item_name(self):\n        \"\"\"\n        item_name : str\n            the stock item's name as a user friendly string\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem item_name called\")\n        pass\n\n    @property\n    def price(self):\n        \"\"\"\n        price : int | float\n            dress price\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem get price called\")\n        return self.__price\n\n    @property\n    def stock_level(self):\n        \"\"\"\n        stock_level : int\n            amount of stock in inventory\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem get stock_level called\")\n        return self.__stock_level\n\n    def check_version(self):\n        \"\"\"\n        Checks the version of a `StockItem` instance and upgrades it if required\n\n        Returns\n        -------\n        None\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem check_version called\")\n        if self.__StockItem_version &lt; 2:\n            self.location = None\n            self.__StockItem_version = 2\n\n    def add_stock(self, count):\n        \"\"\"\n        Add stock to an item\n\n        Parameters\n        ----------\n        count : int\n            amount of stock to add to an item\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        Exception\n            raised if `count` &lt; 0 or `count` &gt; `StockItem.max_stock_add`\n\n        See Also\n        --------\n        StockItem.max_stock_add : maximum amount of stock that can be added to a `StockItem`\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**StockItem add_stock called\")\n        if count &lt; 0 or count &gt; StockItem.max_stock_add:\n            raise Exception(\"Invalid add amount\")\n        self.__stock_level = self.__stock_level + count\n\n\nclass Dress(StockItem):\n    \"\"\"\n    Represents the inventory details for a Dress\n\n    Inherits from `StockItem`\n\n    Attributes\n    ----------\n    stock_ref : str\n        dress reference id\n    price : int | float\n        dress price\n    colour : str\n        description of dress's colour\n    pattern : str\n        description of the dress pattern\n    size : int\n        dress size\n    location : str\n        place where the dress is located\n\n    See Also\n    --------\n    StockItem : Parent Class\n    \"\"\"\n\n    def __init__(self, stock_ref, price, colour, pattern, size, location):\n        \"\"\"\n        Creates a `Dress` instance\n\n        Parameters\n        ----------\n        stock_ref : str\n            stock reference code\n        price : int | float\n            dress price\n        colour : str\n            description of the dress colour\n        pattern : str\n            description of the dress pattern\n        size : int\n            dress size\n        location : str\n            place where the dress is located\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**Dress __init__ called\")\n        super().__init__(stock_ref, price, colour, location)\n        self.pattern = pattern\n        self.size = size\n        self.__Dress_version = 1\n\n    def __str__(self):\n        if StockItem.show_instrumentation:\n            print(\"**Dress __str__ called\")\n        stock_details = super().__str__()\n        template = \"\"\"{0}\nPattern: {1}\nSize: {2}\"\"\"\n        return template.format(stock_details, self.pattern, self.size)\n\n    @property\n    def item_name(self):  # type: ignore\n        if StockItem.show_instrumentation:\n            print(\"**Dress get item_name called\")\n        return \"Dress\"\n\n    def check_version(self):\n        \"\"\"\n        Checks the version of a `Dress` instance and upgrades it if required\n\n        Returns\n        -------\n        None\n        \"\"\"\n        if StockItem.show_instrumentation:\n            print(\"**Dress check_version called\")\n        super().check_version()\n\n\nWe add a new class attribute max_stock_add which defines the maximum amount of stock that can be added to an item in one go\nWe then define an add_stock method\n  def add_stock(self, count):\n      \"\"\"\n      Add stock to an item\n\n      Parameters\n      ----------\n      count : int\n          amount of stock to add to an item\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      Exception\n          raised if `count` &lt; 0 or `count` &gt; `StockItem.max_stock_add`\n\n      See Also\n      --------\n      StockItem.max_stock_add : maximum amount of stock that can be added to a `StockItem`\n      \"\"\"\n      if StockItem.show_instrumentation:\n          print(\"**StockItem add_stock called\")\n      if count &lt; 0 or count &gt; StockItem.max_stock_add:\n          raise Exception(\"Invalid add amount\")\n      self.__stock_level = self.__stock_level + count\nWe first validate the count variable\n\nRaising an Exception if invalid so it can be handled\n\nOnce validated we can directly update the private variable\nLet us see how this works with a Dress now\n\n  d = Dress(\n      \"D0001\", price=100, colour=\"Red\", pattern=\"Swirly\", size=12, location=\"Shop Window\"\n  )\n  d.add_stock(5)\n  print(d)\n\n**Dress __init__ called\n**StockItem __init__ called\n**StockItem add_stock called\n**Dress __str__ called\n**StockItem __str__ called\n**Dress get item_name called\n**StockItem get price called\n**StockItem get stock_level called\nStock Reference: D0001\nType: Dress\nPrice: 100\nStock level: 5\nLocation: Shop Window\nColour: Red\nPattern: Swirly\nSize: 12\n\n\nWe can see the Stock Level is now \\(5\\)\nWhat happens if we try to add more than StockItem.max_stock_add?\n\n\nd.add_stock(15)\n\n**StockItem add_stock called\n\n\n\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\nCell In[38], line 1\n----&gt; 1 d.add_stock(15)\n\nCell In[36], line 150, in StockItem.add_stock(self, count)\n    148     print(\"**StockItem add_stock called\")\n    149 if count &lt; 0 or count &gt; StockItem.max_stock_add:\n--&gt; 150     raise Exception(\"Invalid add amount\")\n    151 self.__stock_level = self.__stock_level + count\n\nException: Invalid add amount\n\n\n\n\nWell as expected we get an Exception, showing our error-handling is working correctly\nAs the above shows, by adding the method directly to StockItem it is automatically available to all of the subclasses without the need to write extra code\n\n\n\n\n\nNow we need to account for the opposite case where stock is sold\nThe stock level will correspondingly decrease\nWe do this with another method on StockItem\n  class StockItem(abc.ABC):\n      \"\"\"\n      Stock Item for the Fashion Shop\n      \"\"\"\n      ...\n\n      def sell_stock(self, count):\n          if count &lt; 1:\n              raise Exception(\"Invalid number of items to sell\")\n          if count &gt; self.__stock_level:\n              raise Exception(\"Not enough stock to sell\")\n          self.__stock_level = self.__stock_level - count\nThe amount to sell is given by the count parameter\nWe raise an exception in two cases\n\nThe user tries to sell \\(&lt; 1\\) items, since this physically doesn’t make sense\nThe user tries to sell more items than are available i.e. count \\(&gt;\\) self.__stock_level\n\nLet’s see how this plays out with the Dress class\n\n  d = Dress(\n      \"D0001\", price=100, colour=\"Red\", pattern=\"Swirly\", size=12, location=\"Shop Window\"\n  )\n  d.add_stock(5)\n  d.sell_stock(1)\n  print(d)\n\n**Dress __init__ called\n**StockItem __init__ called\n**StockItem add_stock called\n**StockItem sell_stock called\n**Dress __str__ called\n**StockItem __str__ called\n**Dress get item_name called\n**StockItem get price called\n**StockItem get stock_level called\nStock Reference: D0001\nType: Dress\nPrice: 100\nStock level: 4\nLocation: Shop Window\nColour: Red\nPattern: Swirly\nSize: 12\n\n\nAnd again what happens if we try to do something invalid like selling more stock than we have\n\n  d.sell_stock(10)\n\n**StockItem sell_stock called\n\n\n\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\nCell In[41], line 1\n----&gt; 1 d.sell_stock(10)\n\nCell In[39], line 178, in StockItem.sell_stock(self, count)\n    176     raise Exception(\"Invalid number of items to sell\")\n    177 if count &gt; self.__stock_level:\n--&gt; 178     raise Exception(\"Not enough stock to sell\")\n    179 self.__stock_level = self.__stock_level - count\n\nException: Not enough stock to sell\n\n\n\nAs expected, an exception is raised\n\n\n\n\n\n\nWe have completed the StockItem and it’s associated class hierarchy\nAll behaviours given by the fashion shop item data spec is now implemented by the class and its subclasses\nStockItem is a purely self-contained and cohesive\nWe’ve done some basic testing of the external behaviours\n\nLater we’ll look at how to implement automatic testing of our objects\n\nSometimes we call a cohesive, self-contained part a component\nE.g. in a car production line different parts of the line produce different parts, like the motor, panels, transmission etc.\n\nAll are made separately and the final product is composed of all the parts\n\nWe would like to do something similar with StockItem\n\nMove it around as it’s own component\nCan then potentially reuse it as it’s own feature in other projects\n\n\n\n\n\n\n\n\nTip\n\n\n\nSelf-contained components are a great way to build software\nBreaking software projects down into individual components is a great design philosophy. When you’re working solo it lets you focus on a small completable part of the program and progressively build up the complexity. When working with a larger team, different parts of the team can be assigned to work on the different independent components without interfering with each others work.\nFor example in our fashion shop project someone could be building the StockItem while another person works on the UI\n\n\n\n\n\n\n\nWe have implemented a complete StockItem component\n\nRepresents everything about a single item of stock\n\nNow we want to create a component that handles the management of collections of stock\nWe will call this component FashionShop\nWe identify the following requirements\n\nCreate a new fashion shop\nSave the fashion shop stock data to a file\nLoad the data from a file\nStore a new stock item\nFind a particular stock item\nProvide a listing of all stock items\n\nWe can start by stubbing out our class, (the template code is given by Fashion Shop Prototype)\n  # Example 11.9 Fashion Stock Prototype\n  #\n  # Provides a stubbed out template for the FashionShop Class\n\n\n  class FashionShop:\n      \"\"\"\n      Represents the inventory management system of a Fashion Shop\n      \"\"\"\n\n      def __init__(self):\n          \"\"\"\n          Create a new `FashionShop` instance\n          \"\"\"\n          pass\n\n      def save(self, filename):\n          \"\"\"\n          Save the `FashionShop` to a given file\n\n          `FashionShop` is saved as a pickled binary file in the file given\n          by `filename`. The file is created if it doesn't exist. If the file\n          already exists it is overwritten\n\n          Parameters\n          ----------\n          filename : str\n              path to the file to save\n\n          Returns\n          -------\n          None\n\n          Raises\n          ------\n          Exceptions\n              raised if the file fails to save\n\n          See Also\n          --------\n          FashionShop.load : load a `FashionShop` object from a file\n          \"\"\"\n          pass\n\n      @staticmethod\n      def load(filename):\n          \"\"\"\n          Create a `FashionShop` instance from a pickled binary file\n\n          Parameters\n          ----------\n          filename : str\n              path to a file containing pickled `FashionShop` data\n\n          Returns\n          -------\n          FashionShop\n              the loaded `FashionShop` instance\n\n          Raises\n          ------\n          Exceptions\n              raised if the file fails to load\n\n          See Also\n          --------\n          FashionShop.save : saves a `FashionShop` instance\n          \"\"\"\n          pass\n\n      def store_new_stock_item(self, item):\n          \"\"\"\n          Store a new item in the reference system\n\n          The provided `item` can be indexed by it's `stock_ref` parameter\n\n          Parameters\n          ----------\n          item : StockItem\n              item to add to the inventory system\n\n          Returns\n          -------\n          None\n\n          Raises\n          ------\n          KeyError\n              Raised if the item's `stock_ref` is already registered as a key\n          \"\"\"\n          pass\n\n      def find_stock_item(self, stock_ref):\n          \"\"\"\n          Find the stock item with the corresponding reference id\n\n          Parameters\n          ----------\n          stock_ref : str\n              stock reference id of the item to find\n\n          Returns\n          -------\n          StockItem | None\n              Returns a `StockItem` with a matching `stock_ref` else `None`\n          \"\"\"\n          return None\n\n      def __str__(self):\n          return \"\"\nWe’ll now start by filling in these methods one by one\nWe provide a complete docstring which documents what the function should do\n\nMeans someone else could come and implement it if we were working in a team\n\nSome methods return placeholder values\n\nThese implement partial functionality\ne.g. find_stock_item always returns None at the moment\n\nA program utilising FashionShop needs only call the methods based on the description\n\nDoes not need to know about the internals\n\n\n\n\n\nOur first step is to define our data attributes and define the __init__\nWe’ll start by using a dictionary to store our items\n\n  class FashionShop:\n\n      def __init__(self):\n          self.__stock_dictionary = {}\n\nThe __init__ takes no arguments\nPurely creates an empty dictionary (self.__stock_dictionary) to store future stock items\nWe make the dictionary private to avoid accidental modification\nWe can now create a new FashionShop\n\n  shop = FashionShop()\n  print(shop)\n\n&lt;__main__.FashionShop object at 0x7f71f0bc6690&gt;\n\n\n\n\n\n\n\nWe’ll use the same approach we’ve used before of pickling our files\nWorks exactly as we’ve seen before\n  class FashionShop:\n\n      def save(self, filename):\n          with open(filename, \"wb\") as out_file:\n              pickle.dump(self, out_file)\nWe use with to handle making sure the file is properly cleaned up once we’re done\nWe pass self to pickle.dump to save the object instance on which save is called\nThe below example demonstrates creating an (empty) FashionShop shop and then saving it\n  shop = FashionShop()\n  shop.save(\"FashionShop.pickle\")\n\n\n\n\n\nThe load in our template is marked as a @staticmethod\nWe can’t make it a object method, because there is no object yet\nMake it static so it’s still associated with the class\nThis means we want the load method to create and return a new FashionShop item\n  class FashionShop:\n      ...\n      def load(filename):\n          with open(filename, \"rb\") as input_file:\n              shop = pickle.load(input_file)\n          return shop\nIf we wanted to load the FashionShop object we had saved above we would write\n```python loaded_shop = FashionShop.load(“FashionShop.pickle”)\n\n\n\n\n\nFashionShop is effectively a container for StockItem objects\nAt the moment the underlying model is a dictionary\nWe can’t add new items directly to the dictionary for two reasons\n\nWe’ve made it private so we can’t directly add them\nWe want to prevent adding multiple items with the same reference\n\nAs mentioned above we want to prevent duplicates\nHow should we handle duplicates?\n\nWe could use a status code, but as said, we should favour exceptions\nWe’ll return a KeyError if the key already exists\nWe then need to document this in the docstring\n\n  class FashionShop:\n      ...\n  def store_new_stock_item(self, item):\n      \"\"\"\n      Store a new item in the reference system\n\n      The provided `item` can be indexed by it's `stock_ref` parameter\n\n      Parameters\n      ----------\n      item : StockItem\n          item to add to the inventory system\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      KeyError\n          Raised if the item's `stock_ref` is already registered as a key\n      \"\"\"\n      if item.stock_ref in self.__stock_dictionary:\n          raise KeyError(\"This stock reference is already used\")\n      self.__stock_dictionary[item.stock_ref] = item\nstore_new_stock_item adds a new stock item to the container\nIt does not create one, we have to do that separately\nThe method checks for duplicates, throwing a KeyError if the stock reference is already used\nIf no exception is raised, the item is inserted into the stock dictionary\nLet us see this in practice,\n\n  dress = Dress(stock_ref=\"D001\", price=100, colour=\"red\", pattern=\"swirly\", size=12, location=\"front\")\n  shop = FashionShop()\n  shop.store_new_stock_item(dress)\n\n**Dress __init__ called\n**StockItem __init__ called\n\n\nAnd if we try to add it again…\n\n  shop.store_new_stock_item(dress)\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[46], line 1\n----&gt; 1 shop.store_new_stock_item(dress)\n\nCell In[44], line 93, in FashionShop.store_new_stock_item(self, item)\n     73 \"\"\"\n     74 Store a new item in the reference system\n     75 \n   (...)     90     Raised if the item's `stock_ref` is already registered as a key\n     91 \"\"\"\n     92 if item.stock_ref in self.__stock_dictionary:\n---&gt; 93     raise KeyError(\"This stock reference is already used\")\n     94 self.__stock_dictionary[item.stock_ref] = item\n\nKeyError: 'This stock reference is already used'\n\n\n\n\n\n\n\n\nFinding stock is implemented as a dictionary lookup\nDictionaries provide the get method\n\nActs as a normal dictionary lookup\nHowever if the key is missing a default value is returned\nThe default value for this default parameter is None\n\n  class FashionShop:\n      ...\n      def find_stock_item(self, stock_ref):\n          \"\"\"\n          Find the stock item with the corresponding reference id\n\n          Parameters\n          ----------\n          stock_ref : str\n              stock reference id of the item to find\n\n          Returns\n          -------\n          StockItem | None\n              Returns a `StockItem` with a matching `stock_ref` else `None`\n          \"\"\"\n          return self.__stock_dictionary.get(stock_ref)\nThe calling code is responsible for checking that the returned value is a valid StockItem\nLet’s demonstrate this by trying to find the dress we just added, and one that didn’t exist\n\n\nprint(shop.find_stock_item(\"D001\"))\nprint(shop.find_stock_item(\"AAAA\"))\n\n**Dress __str__ called\n**StockItem __str__ called\n**Dress get item_name called\n**StockItem get price called\n**StockItem get stock_level called\nStock Reference: D001\nType: Dress\nPrice: 100\nStock level: 0\nLocation: front\nColour: red\nPattern: swirly\nSize: 12\nNone\n\n\n\n\n\n\nFinal step is to list the stock data\nWe want this in the form a human-readable string\nWe can use a similar approach seen with our Session class in [Chapter 10](../10_UseClassesToCreateActiveObjects/Chapter_10.qmd#code-analysis-creating-a-session-class)     -StockItemprovides astr` method\n\nWe can iterate over the container items to get all of these\nThen just have to nicely format the container\n\n  class FashionShop:\n      ...\n      def __str__(self):\n          stock = map(str, self.__stock_dictionary.values())\n          stock_list = \"\\n\".join(stock)\n          template = \"\"\"Items in Stock\n  {0}\n  \"\"\"\n      return template.format(stock_list)\nLet’s put everything we’ve put together in practice\nWe’ll create two items and add them to the shop then print the contents\nYou can find the complete implementation of the fashion shop class in Fashion Shop\n\nLike our instrumented version of StockItem, FashionShop provides instrumentation so you can view the program flow\n\n\n\ndress = Dress(\n    stock_ref=\"D001\",\n    price=100,\n    colour=\"red\",\n    pattern=\"swirly\",\n    size=12,\n    location=\"front\",\n)\npants = Pants(\n    stock_ref=\"A002\",\n    price=200,\n    colour=\"cream\",\n    pattern=\"plain\",\n    length=12,\n    waist=34,\n    location=\"back right corner\",\n)\n\nshop = FashionShop()\nshop.store_new_stock_item(dress)\nshop.store_new_stock_item(pants)\nprint(shop)\n\n**Dress __init__ called\n**StockItem __init__ called\n**Pants __init__ called\n**StockItem __init__ called\n**FashionShop __init__ called\n**FashionShop store new stock item called\n**FashionShop store new stock item called\n**Dress __str__ called\n**StockItem __str__ called\n**Dress get item_name called\n**StockItem get price called\n**StockItem get stock_level called\n**Pants __str__ called\n**StockItem __str__ called\n**Pants get item_name called\n**StockItem get price called\n**StockItem get stock_level called\n\nStock Reference: D001\nType: Dress\nPrice: 100\nStock level: 0\nLocation: front\nColour: red\nPattern: swirly\nSize: 12\nStock Reference: A002\nType: Pants\nPrice: 200\nStock level: 0\nLocation: back right corner\nColour: cream\nPattern: plain\nLength: 12\nWaist: 34\n\n\n\n\n\n\nYou can use a similar structure to the FashionShop inventory management class for any program that needs to manage a key-based lookup of items, examples may include a bank account management system, a doll collection or competition entries\nImplement a basic bank account management system. The system should have three different account types\n\nSavings accounts\n\nHave an account number, a monthly interest rate, a balance, and a person associated with the account\nA savings account can have money deposited or withdrawn\nA savings account balance cannot be negative\nEvery month a savings account balance is increased by the interest rate\n\nLong-term savings account\n\nLike a savings account\nHowever also has a start date, and a term maturation period\nMoney cannot be withdrawn from a long-term savings account before the maturation date\nOnce a long-term savings deposit has matured the interest rate is quartered\nAn account holder can either reinvest a matured long-term savings deposit (starting a new term and maturation)\n\nOr close out a matured long-term deposit transferring it to another account\n\n\nCredit Account\n\nHave a maximum withdrawal limit\nA credit account balance cannot be positive\nEvery month a credit account balance is increased by the interest rate (i.e. any unpaid credit is increased)\nA credit account can not have a negative balance whose magnitude is greater than the maximum withdrawal limit\n\n\nThe bank system should have a similar interface to the FashionShop, with the following,\n\nCreate a new bank system\nSave the bank system data to a file\nLoad the data from a file\nStore a new bank account\nFind a particular bank account\nProvide a listing of all accounts\nFind all accounts associated with a particular person\n\nLets start by mapping out a class hierarchy for accounts. We can see that all accounts have a number, interest rate, balance and an associated account holder, each also supports being able to withdraw or deposit money and have interest applied, however they each implement these methods differently. So we’ll define an abstract base class Account that provides these data attributes and declares these methods. Subclasses then overwrite the method.\nOur first subclass will be a savings account which requires no additional data attributes. Our second is a long-term savings account. This acts like a saving account but also has a maturation period and a start date. There are additional restrictions on how the account operates depending on if it has matured or not, so we’ll inherit from a Savings Account. A credit account has different behaviours for its deposit and withdraw methods and has a maximum withdrawal limit, so will be a subclass derived from the base account class\n\n\n\n\n\n---\ntitle: Account Class Diagram\n---\n\nclassDiagram\n    class object\n\n    class Account {\n        str account_number\n        str account_holder\n        number interest_rate\n        number balance\n        deposit()\n        withdraw()\n        apply_interest()\n    }\n\n    class SavingsAccount\n\n    class LongTermSavingsAccount {\n        date start_date\n        int term_period\n    }\n\n    class CreditAccount {\n        number max_withdrawal_limit\n    }\n\n    object &lt;|-- Account\n    Account &lt;|-- SavingsAccount\n    SavingsAccount &lt;|--  LongTermSavingsAccount\n    Account &lt;|-- CreditAccount\n\n\n\n\n\n\nOur abstract base class is fairly simple, it defines the properties and the abstract methods. You’ll observe that we make the majority of data attributes read-only. This is because when dealing with people’s money we want to be really careful about inappropriate changes!\n\nimport datetime\n\n\nclass Account(abc.ABC):\n    \"\"\"\n    Abstract class representing a single account\n\n    Subclasses are expected to overwrite the `deposit`,\n    `withdraw` and `apply_interest` abstract methods\n\n    Attributes:\n    -----------\n    account_holder : str\n        name of the account owner\n    interest_rate : int | float\n        interest rate applied to the account\n\n    \"\"\"\n\n    def __init__(self, account_number, account_holder, interest_rate):\n        \"\"\"\n        Creates a new `Account` instance\n\n        `Account` is abstract and should never be called directly\n\n        Parameters\n        ----------\n        account_number : str\n            Unique account number\n        account_holder : str\n            Name of the account holder\n        interest_rate : int | float\n            interest rate applied to the account\n        \"\"\"\n        self.__account_number = account_number\n        self.account_holder = account_holder.strip().lower()\n        self.interest_rate = interest_rate\n        self.__balance = 0\n\n    def __str__(self):\n        template = \"\"\"Account Number: {0}\nAccount Holder: {1}\nInterest Rate: {2}\nBalance: ${3}\"\"\"\n        return template.format(\n            self.account_number, self.account_holder, self.interest_rate, self.balance\n        )\n\n    @property\n    def account_number(self):\n        \"\"\"\n        account_number : str\n            Unique account number\n        \"\"\"\n        return self.__account_number\n\n    @property\n    def balance(self):\n        \"\"\"\n        balance: int | float\n            account balance in dollars\n        \"\"\"\n        return self.__balance\n\n    @abc.abstractmethod\n    def deposit(self, amount):\n        \"\"\"\n        Deposit money in an account\n\n        Parameters\n        ----------\n        amount : int | float\n            amount in dollars to deposit in the account\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        ValueError\n            Raised if `amount` cannot be deposited\n        \"\"\"\n        self.__balance += amount\n\n    @abc.abstractmethod\n    def withdraw(self, amount):\n        \"\"\"\n        Withdraw money from an account\n\n        Parameters\n        ----------\n        amount : int | float\n            amount to withdraw from the account in dollars\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        ValueError\n            Raised if `amount` cannot be withdrawn\n        \"\"\"\n        self.__balance -= amount\n\n    @abc.abstractmethod\n    def apply_interest(self):\n        \"\"\"\n        Apply the interest rate to the account and update the balance\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.__balance += self.__balance * self.interest_rate\n\n\nAccount defines __init__, __str__, withdraw, deposit, apply_interest functions\n\n__init__ is a basic constructor\n__str__ is the string representation\nwithdraw is an abstract method for decreasing a balance\n\nSince balance itself is a private attribute this method does the actual adjustment\nSubclasses are expected to override the to modify the behaviour and provide validation, then forward the final result onto the super function\n\ndeposit is an abstract method for increasing a balance\n\nWorks like withdraw in that it should be overridden\n\napply_interest an abstract method that should be used to apply interest\n\nProvides a simple default implementation\n\n\nWe can then define our savings account\n\n\nclass SavingsAccount(Account):\n    \"\"\"\n    Represents a standard savings account\n\n    Savings accounts must have non-negative balances, and\n    have interest paid on their balances\n\n    See Also\n    --------\n    Account : Parent Class\n    \"\"\"\n\n    def __init__(self, account_number, account_holder, interest_rate):\n        \"\"\"\n        Creates a new `SavingsAccount` instance\n\n        Parameters\n        ----------\n        account_number : str\n            Unique account number\n        account_holder : str\n            Name of the account holder\n        interest_rate : int | float\n            interest rate applied to the account\n        \"\"\"\n        super().__init__(account_number, account_holder, interest_rate)\n\n    def __str__(self):\n        template = \"\"\"==Savings Account==\n{0}\"\"\"\n        return template.format(super().__str__())\n\n    def deposit(self, amount):\n        if amount &lt;= 0:\n            raise ValueError(\"A deposit must be a non-negative number\")\n        super().deposit(amount)\n\n    def withdraw(self, amount):\n        \"\"\"\n        Withdraw money from an account\n\n        Parameters\n        ----------\n        amount : int | float\n            amount to withdraw from the account in dollars\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        ValueError\n            Raised if `amount` is non-negative or the greater than\n            the account balance\n        \"\"\"\n        if amount &lt;= 0:\n            raise ValueError(\"A withdrawal must be a non-negative number\")\n        if amount &gt; self.balance:\n            raise ValueError(\"Cannot withdraw more than the account balance\")\n        super().withdraw(amount)\n\n    def apply_interest(self):\n        super().apply_interest()\n\n\nThe savings account overwrites the __str__ method to prepend the account type\n__init__ just forwards to the base class\ndeposit checks that the argument is valid (&gt; 0) then forwards it to the base class method\n\ndepositing a negative number is effectively a withdrawal\n\nwithdraw does the same but checks that the amount also does not exceed the balance\nApply interest just uses the default implementation\nWe then derive from SavingsAccount for LongTermSavingsAccount\n\n\nclass LongTermSavingsAccount(SavingsAccount):\n    \"\"\"\n    Represents a long term savings account\n\n    An account in which money cannot be withdrawn before the term limit expires.\n    After the term limit has expired a reduced interest rate is applied.\n\n    See Also\n    --------\n    SavingsAccount : Parent class\n    \"\"\"\n\n    def __init__(\n        self, account_number, account_holder, interest_rate, term_period_in_weeks\n    ):\n        \"\"\"\n        Creates a new `Account` instance\n\n        `Account` is abstract and should never be called directly\n\n        Parameters\n        ----------\n        account_number : str\n            Unique account number\n        account_holder : str\n            Name of the account holder\n        interest_rate : int | float\n            interest rate applied to the account\n        term_period_in_weeks : int\n            length of the high yield savings term in weeks\n        \"\"\"\n        self.__start_date = datetime.date.today()\n        self.__term_period = term_period_in_weeks\n        super().__init__(account_number, account_holder, interest_rate)\n\n    def __str__(self):\n        template = \"\"\"{0}\nTerm Period: {1} weeks\nStart Date: {2}\nMaturation Date: {3}\nHas matured? {4}\"\"\"\n        formatted = template.format(\n            super().__str__(),\n            self.term_period,\n            self.start_date,\n            self.maturation_date,\n            self.has_matured(),\n        )\n        return formatted.replace(\"Savings Account\", \"Long Term Savings Account\")\n\n    @property\n    def start_date(self):\n        \"\"\"\n        start_date : datetime.date\n            date the current term period started\n        \"\"\"\n        return self.__start_date\n\n    @property\n    def term_period(self):\n        \"\"\"\n        term_period : int\n            length of the term in weeks\n        \"\"\"\n        return self.__term_period\n\n    @property\n    def maturation_date(self):\n        \"\"\"\n        maturation_date : datetime.date\n            date the account matures\n        \"\"\"\n        return self.__start_date + datetime.timedelta(weeks=self.__term_period)\n\n    def has_matured(self):\n        \"\"\"\n        Indicates if an account has matured\n\n        Returns\n        -------\n        `True` if the account has matured else, `False`\n        \"\"\"\n        return datetime.date.today() &gt;= self.maturation_date\n\n    def withdraw(self, amount):\n        \"\"\"\n        Withdraw money from a Long Term Savings Account\n\n        Money cannot be withdrawn unless the account has matured\n\n        Parameters\n        ----------\n        amount : int | float\n            amount to withdraw from the account in dollars\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        ValueError\n            Raised if `amount` is non-negative or the greater than\n            the account balance.\n        ValueError\n            Raised if the account has not\n            yet matured\n        \"\"\"\n        if not self.has_matured():\n            raise ValueError(\"Cannot withdraw from an immature account\")\n        super().withdraw(amount)\n\n    def apply_interest(self):\n        \"\"\"\n        Apply interest to a Long Term Savings Account\n\n        The applied interest for a Long Term Savings account is quartered\n        if the account has matured\n\n        Returns\n        -------\n        None\n        \"\"\"\n        effective_rate = self.interest_rate\n        if self.has_matured():\n            effective_rate /= 4\n        self.deposit(self.balance * effective_rate)\n\n    def manage_account(self, transfer_account=None):\n        \"\"\"\n        Manage a matured long term savings account\n\n        A mature long term savings account can be closed\n        by providing an alternate account to transfer the\n        balance into. Alternately if no account is provided\n        the account is reinvested and a new term starts.\n\n        The owner of the long term savings account and the\n        account to transfer into must be the same\n\n        Parameters\n        ----------\n        transfer_account : Account, optional\n            account to transfer into, pass None to reinvest instead, by default None\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        ValueError\n            Raised in attempting to manage an immature account\n        ValueError:\n            Could not transfer to the new account\n        \"\"\"\n        if not self.has_matured():\n            raise ValueError(\"Cannot manage an immature account\")\n        if transfer_account is None:\n            self.__start_date = datetime.date.today()\n        else:\n            balance = self.balance\n            try:\n                self.withdraw(balance)\n                transfer_account.deposit(balance)\n            except ValueError as e:\n                # need to ensure balances preserved\n                if not self.balance == balance:\n                    self.deposit(balance - self.balance)\n                    raise ValueError(str(e))\n\n\nThis class has two new attributes, start_date and term_period\nThe term period is passed to the constructor as an integer number of weeks\nThe start date is calculated at __init__ time\nNote that we use the datetime library rather than time\n\ndatetime provides similar time objects that we can perform comparisons and arithmetic on\ndatetime.date.today() is the equivalent of time.localtime() and returns the current date\n\ndate means there is no hours, minutes, seconds etc.\nIf we want this we would use datetime.datetime.today() instead\n\n\nWe provide a property maturation_date\n\nThis is a bit different to other properties we’ve seen\nIt doesn’t mask a private attribute\nInstead it quickly calculates the maturation_date on the fly\nWe use a datetime.timedelta object which handles performing the arithmetic correctly\n\n  @property\n  def maturation_date(self):\n      \"\"\"\n      maturation_date : datetime.date\n          date the account matures\n      \"\"\"\n      return self.__start_date + datetime.timedelta(weeks=self.__term_period)\nWe then define a simple helper function has_matured which checks if the account has matured\nSince we’re using datetime we can just get the current date and compare the two\n  def has_matured(self):\n      \"\"\"\n      Indicates if an account has matured\n\n      Returns\n      -------\n      `True` if the account has matured else, `False`\n      \"\"\"\n      return datetime.date.today() &gt;= self.maturation_date\nThe Long Term Savings Account can just use the SavingsAccount deposit method\nWe update the withdraw method to throw an error if the account hasn’t matured\n  def withdraw(self, amount):\n      \"\"\"\n      Withdraw money from a Long Term Savings Account\n\n      Money cannot be withdrawn unless the account has matured\n\n      Parameters\n      ----------\n      amount : int | float\n          amount to withdraw from the account in dollars\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      ValueError\n          Raised if `amount` is non-negative or the greater than\n          the account balance.\n      ValueError\n          Raised if the account has not\n          yet matured\n      \"\"\"\n      if not self.has_matured():\n          raise ValueError(\"Cannot withdraw from an immature account\")\n      super().withdraw(amount)\nWe also have to redefine our apply_interest\n\nWe apply a different effective rate for a matured account\nThis does not fit the signature, so we can’t just use the super method\nInstead we calculate the effective rate and then use deposit\n\n  def apply_interest(self):\n      \"\"\"\n      Apply interest to a Long Term Savings Account\n\n      The applied interest for a Long Term Savings account is quartered\n      if the account has matured\n\n      Returns\n      -------\n      None\n      \"\"\"\n      effective_rate = self.interest_rate\n      if self.has_matured():\n          effective_rate /= 4\n      self.deposit(self.balance * effective_rate)\nWe also add a new function for handling a matured account\n  def manage_account(self, transfer_account=None):\n      \"\"\"\n      Manage a matured long term savings account\n\n      A mature long term savings account can be closed\n      by providing an alternate account to transfer the\n      balance into. Alternately if no account is provided\n      the account is reinvested and a new term starts.\n\n      The owner of the long term savings account and the\n      account to transfer into must be the same\n\n      Parameters\n      ----------\n      transfer_account : Account, optional\n          account to transfer into, pass None to reinvest instead, by default None\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      ValueError\n          Raised in attempting to manage an immature account\n      ValueError:\n          Could not transfer to the new account\n      \"\"\"\n      if not self.has_matured():\n          raise ValueError(\"Cannot manage an immature account\")\n      if transfer_account is None:\n          self.__start_date = datetime.date.today()\n      else:\n          balance = self.balance\n          try:\n              self.withdraw(balance)\n              transfer_account.deposit(balance)\n          except ValueError as e:\n              # need to ensure balances preserved\n              if not self.balance == balance:\n                  self.deposit(balance - self.balance)\n                  raise ValueError(str(e))\nThis works in two ways\n\nIf no transfer_account is provided, a new term period is started\nIf a transfer_account is provided, the method attempts to transfer the balance to this account\n\nThis can potentially fail\nWe don’t want the user to lose money\nSo we wrap this in a try...except block\nIf transfer fails we ensure that both accounts maintain their original balances\nThen report to the user\n\n\nLastly we define a CreditAccount class\nWorks very similar to a SavingsAccount but can only have negative balances\n\n\nclass CreditAccount(Account):\n    \"\"\"\n    Represents a basic credit account\n\n    Savings accounts must have non-positive balances, and\n    charge interest on their debts\n\n    See Also\n    --------\n    Account : Parent Class\n    \"\"\"\n\n    def __init__(\n        self, account_number, account_holder, interest_rate, max_withdrawal_limit\n    ):\n        \"\"\"\n        Creates a new `SavingsAccount` instance\n\n        Parameters\n        ----------\n        account_number : str\n            Unique account number\n        account_holder : str\n            Name of the account holder\n        interest_rate : int | float\n            interest rate applied to the account\n        max_withdrawal_limit : int | float\n            maximum account that can be loaned out at once\n        \"\"\"\n        self.__max_withdrawal_limit = max_withdrawal_limit\n        super().__init__(account_number, account_holder, interest_rate)\n\n    def __str__(self):\n        template = \"\"\"==Credit Account==\n{0}\nMaximum Withdrawal Limit: {1}\"\"\"\n        formatted_string = template.format(\n            super().__str__(), self.__max_withdrawal_limit\n        )\n        return formatted_string.replace(\"Balance\", \"Balance owed\").replace(\"$-\", \"-$\")\n\n    def deposit(self, amount):\n        \"\"\"\n        Pay off a Credit loan\n\n        Parameters\n        ----------\n        amount : int | float\n            amount to pay off in dollars\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        ValueError\n            Raised if 1amount` is not a positive integer\n        ValueError\n            Raised if deposit is greater than the current debt\n        \"\"\"\n        if amount &lt;= 0:\n            raise ValueError(\"A deposit must be a non-negative number\")\n        if amount + self.balance &gt; 0:\n            raise ValueError(\n                \"Exceeded max deposit limit: {0}\".format(-1 * self.balance)\n            )\n        super().deposit(amount)\n\n    def withdraw(self, amount):\n        \"\"\"\n        Take out a loan of credit\n\n        Parameters\n        ----------\n        amount : int | float\n            amount to loan from the account in dollars\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        ValueError\n            Raised if `amount` is non-negative or the greater than\n            the account balance\n        \"\"\"\n        if amount &lt;= 0:\n            raise ValueError(\"A withdrawal must be a non-negative number\")\n        if self.balance - amount &lt; -1 * self.__max_withdrawal_limit:\n            raise ValueError(\"Cannot exceed withdrawal limit\")\n        super().withdraw(amount)\n\n    def apply_interest(self):\n        \"\"\"\n        Applies interest to any loans\n\n        Returns\n        -------\n        None\n        \"\"\"\n        super().apply_interest()\n\n\nWe also add a new max_withdrawal_limit attribute passed in via the __init__\nThis limits how much credit can be withdrawn\ndeposit can now only be used to pay off a line of credit\n\nPrevents the balance going positive\n\nwithdraw checks that the withdrawal keeps the balance under the withdrawal limit\n\nWe can then define our AccountSystem, this is basically the FashionShop renamed. However we also add a second dictionary account_name_dictionary which stores all the accounts where the list of accounts associated with a specific account holder is keyed by that account holder. This means we can do fast lookup both by account number (to get a specific account) or by client to get all their associated accounts. We provide two methods get_account which performs the id based lookup and find_users_accounts which finds the accounts associated with a user\n\n# Exercise 11.1b Account System\n#\n# Provides a class for managing and storing collections of accounts\n\nimport pickle\n\n\nclass AccountSystem:\n    \"\"\"\n    Represents the account management system of a bank\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Create a new `AccountSystem` instance\n        \"\"\"\n        self.__account_dictionary = {}\n        self.__account_name_dictionary = {}\n\n    def __str__(self):\n        print_string = \"\"\n        for holder, accounts in self.__account_name_dictionary.items():\n            print_string += \"Client: \" + str(holder) + \"\\n\"\n            account_list = \"\\n\".join(map(str, accounts))\n            print_string += account_list + \"\\n\"\n        return print_string\n\n    def save(self, filename):\n        \"\"\"\n        Save the `AccountSystem` to a given file\n\n        `AccountSystem` is saved as a pickled binary file in the file given\n        by `filename`. The file is created if it doesn't exist. If the file\n        already exists it is overwritten\n\n        Parameters\n        ----------\n        filename : str\n            path to the file to save\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        Exceptions\n            raised if the file fails to save\n\n        See Also\n        --------\n        AccountSystem.load : load a `AccountSystem` object from a file\n        \"\"\"\n        with open(filename, \"wb\") as output_file:\n            pickle.dump(self, output_file)\n\n    @staticmethod\n    def load(filename):\n        \"\"\"\n        Create an `AccountSystem` instance from a pickled binary file\n\n        Parameters\n        ----------\n        filename : str\n            path to a file containing pickled `FashionShop` data\n\n        Returns\n        -------\n        AccountSystem\n            the loaded `AccountSystem` instance\n\n        Raises\n        ------\n        Exceptions\n            raised if the file fails to load\n\n        See Also\n        --------\n        AccountSystem.save : saves an `AccountSystem` instance\n        \"\"\"\n        with open(filename, \"rb\") as input_file:\n            accounts = pickle.load(input_file)\n        return accounts\n\n    def add_new_account(self, account):\n        \"\"\"\n        Store a new account in the reference system\n\n        The provided `account` can be indexed by it's `account_number` parameter\n\n        Parameters\n        ----------\n        account : Account\n            account to add to the inventory system\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        KeyError\n            Raised if the accounts's `account_number` is already registered as a key\n        \"\"\"\n        if account.account_number in self.__account_dictionary:\n            raise KeyError(\"This account number is already in use\")\n        self.__account_dictionary[account.account_number] = account\n        if account.account_holder in self.__account_name_dictionary:\n            self.__account_name_dictionary[account.account_holder].append(account)\n        else:\n            self.__account_name_dictionary[account.account_holder] = [account]\n\n    def get_account(self, account_number):\n        \"\"\"\n        Get the account with the corresponding account number\n\n        Parameters\n        ----------\n        account_number : str\n            account_number of the account to find\n\n        Returns\n        -------\n        Account | None\n            Returns an `Account` with a matching `account_number` if it exists, else `None`\n        \"\"\"\n        return self.__account_dictionary.get(account_number)\n\n    def find_users_accounts(self, name):\n        \"\"\"\n        Find the accounts associated with a given user\n\n        Parameters\n        ----------\n        name : str\n            account holder to search for\n\n        Returns\n        -------\n        List[Account]\n            list of accounts held by the given name, if there are no matches the list is empty\n        \"\"\"\n        name = name.strip().lower()\n        try:\n            return self.__account_name_dictionary[name]\n        except KeyError:\n            return []\n\nBelow demonstrates how the code works\n\n# Test Savings Account\nnew_saving = SavingsAccount(1, \"Alice\", 0.003)\nnew_saving.deposit(100)\nnew_saving.withdraw(50)\nnew_saving.apply_interest()\n\n# Test long-term savings\nnew_long_term = LongTermSavingsAccount(2, \"Alice\", 0.012, 26)\nnew_long_term.deposit(100)\nnew_long_term.apply_interest()\n\n# Test Credit\nnew_credit = CreditAccount(3, \"Bob\", 0.08, 1000)\nnew_credit.withdraw(500)\nnew_credit.apply_interest()\n\naccount_system = AccountSystem()\naccount_system.add_new_account(new_saving)\naccount_system.add_new_account(new_long_term)\naccount_system.add_new_account(new_credit)\n\nprint(\"Getting the account with a specific id\")\nprint(account_system.get_account(1))\nprint(\"Getting all accounts associated with a specific client\")\nprint(account_system.find_users_accounts(\"felix\"))\nprint(\"Printing the entire system\")\nprint(account_system)\n\nGetting the account with a specific id\n==Savings Account==\nAccount Number: 1\nAccount Holder: alice\nInterest Rate: 0.003\nBalance: $50.15\nGetting all accounts associated with a specific client\n[]\nPrinting the entire system\nClient: alice\n==Savings Account==\nAccount Number: 1\nAccount Holder: alice\nInterest Rate: 0.003\nBalance: $50.15\n==Long Term Savings Account==\nAccount Number: 2\nAccount Holder: alice\nInterest Rate: 0.012\nBalance: $101.2\nTerm Period: 26 weeks\nStart Date: 2026-02-10\nMaturation Date: 2026-08-11\nHas matured? False\nClient: bob\n==Credit Account==\nAccount Number: 3\nAccount Holder: bob\nInterest Rate: 0.08\nBalance owed: -$540.0\nMaximum Withdrawal Limit: 1000\n\n\n\n\n\n\n\n\nWe now have our data items (StockItem) and how container for managing them FashionShop\nThe last step is to provide a component that handles the user interface\nWe’ll create a class FashionShopShellApplication to handle the UI\nThe class should\n\nInitialise the application, by loading from a file (or creating a new instance if this fails)\nDisplay the menu to the user\n\nThis class provides a text-based interface\nIn future we may swap this for a graphical interface\n\n\n\n\nWe’ll define our __init__ method to try and load from a file\nIf the load fails we then pass an empty instance\nWe use an internal __shop attribute to store the inventory management component\n  import FashionShop\n\n\n  class FashionShopApplication:\n      def __init__(self, filename):\n          \"\"\"\n          Creates a new `FashionShopApplication`\n\n          Attempts to load a `FashionShop` from the provided file. Otherwise\n          an empty instance is created\n\n          Parameters\n          ----------\n          filename : str\n              path to a file containing pickled `FashionShop` data\n\n          See Also\n          --------\n          FashionShop : Main class for handling inventory management\n          \"\"\"\n          FashionShopApplication.__filename = filename\n          try:\n              self.__shop = FashionShop.FashionShop.load(filename)\n          except:  # noqa: E722\n              print(\"Failed to load Fashion Shop\")\n              print(\"Creating an empty Fashion Shop\")\n              self.__shop = FashionShop.FashionShop()\nWe might then declare our FashionShopApplication as follows\n  ui = FashionShopApplication(\"fashionshop.pickle\")\n\n\n\n\n\nThe next step is to implement our standard looping menu\nWe’ll implement this as a method\nEach option will then correspond to another method defined on the FashionShopApplication\n    def main_menu(self):\n      \"\"\"\n      Provides a looping main menu. Users are able to\n\n      1. Create a new item\n      2. add stock to an existing item\n      3. sell stock\n      4. show a stock report\n      5. exit\n\n      Returns\n      -------\n      None\n\n      Raises\n      ------\n      ValueError\n          Raised if an invalid command is received. Should not arise in\n          production. Report if encountered\n      \"\"\"\n\n      prompt = \"\"\"Fashion Shop Inventory Management\n\n1. Create a New Stock Item\n2. Add Stock to an Existing Item\n3. Sell Stock\n4. Stock Report\n5. Exit\n\nEnter your command: \"\"\"\n\n      while True:\n          command = BTCInput.read_int_ranged(prompt, 1, 5)\n          if command == 1:\n              self.create_new_stock_item()\n          elif command == 2:\n              self.add_stock()\n          elif command == 3:\n              self.sell_stock()\n          elif command == 4:\n              self.do_report()\n          elif command == 5:\n              self.__shop.save(self.__filename)\n              print(\"Shop data saved\")\n              break\n          else:\n              raise ValueError(\n                  \"Invalid command id {0} encountered in main menu!\".format(command)\n              )\nThis follows the same structure of all our previous menu setups\nThe only difference is this time it’s been wrapped in a class\nStarting the program looks like,\n  ui = FashionShopApplication(\"fashionshop.pickle\")\n  ui.main_menu()\n\n\n\n\n\nNow we need to implement the menu options\nWe already partially implemented these before (see Implement Application Behaviours) we just need to reimplement them as part of the class, or provide a connection\nFor example, we write a sell_stock wrapper as below,\n    def sell_stock(self):\n      print(\"Sell Stock\")\n\n      item = self.__shop.find_stock_item(\n          BTCInput.read_text(\"Enter the stock reference: \")\n      )\n      if item is None:\n          print(\"Item not found\")\n          return\n\n      print(\"Selling\")\n      print(item)\n\n      number_sold = BTCInput.read_int_ranged(\n          \"How many to sell? (0 to abandon) - {0} in current stock: \".format(\n              item.stock_level\n          ),\n          min_value=0,\n          max_value=item.stock_level,\n      )\n      if not number_sold:\n          print(\"Sell item cancelled\")\n          return\n\n      item.sell_stock(number_sold)\n      print(\"Items sold\")\nThis walks through the sales process\nFirst the user is prompted for a reference to get an item\nThen the user is prompted for an amount to sell\nWe use the read_input_ranged to ensure the provided number is valid\nOnce validated we then forward to the item’s sell_stock method\n\n\n\n\n\n\n\nNote\n\n\n\nYou will spend a lot of time writing code to deal with failure\nThe sell_stock method does the following,\n\nIt handles invalid stock references\nIt ensures that we do not sell more inventory than we hold\nIt provides the user a way to back out of a sale\n\nThe actual “happy path” code, i.e. the code that is followed when everything works fine is a very small part of the entire function. Multiply this across all the functions and the majority of the code is probably taken up with input validation and handling failure cases.\n\n\n\nA complete working version of the code is found in 11_FashionShopApplication\nWe’ve split the classes into their own files for readability purposes\nThe program can be run by running FashionShopApplication.py\n\n\n\n\nImplement a banking application wrapper class to complete the Bank Account system created earlier. This class should work like FashionShopApplication attempting to load from a file, then providing a looping menu. The user should be able to,\n\nCreate a new account\nDeposit into an account\nWithdraw from an account\nView an account\nView all their accounts\nManage a matured long term savings account\nApply interest to all accounts\n\nWe first start by templating out our BankApplication class using a similar framework to the FashionShop application\nclass BankAccountApplication:\n    \"\"\"\n    Provides a text-based interface for Bank Account Management\n    \"\"\"\n\n    def __init__(self, filename):\n        \"\"\"\n        Creates a new `BankAccountApplication`\n\n        Attempts to load an existing application from the provided file.\n        Otherwise an empty instance is created\n\n        Parameters\n        ----------\n        filename : str\n            path to a file containing pickled `AccountSystem` data\n\n        See Also\n        --------\n        AccountSystem : Main class for handling bank accounts\n        \"\"\"\n        self.__filename = filename\n        try:\n            self.__accounts = AccountSystem.AccountSystem.load(filename)\n        except:  # noqa: E722\n            print(\"Failed to load accounts\")\n            print(\"Creating an empty instance\")\n            self.__accounts = AccountSystem.AccountSystem()\n\n    def main_menu(self):\n        \"\"\"\n        Provides a looping main menu\n\n        Users are able to\n        1. Create a new account\n        2. Deposit into an account\n        3. Withdraw from an account\n        4. View an account\n        5. View all accounts associated with a name\n        6. Manage a matured long term savings account\n        7. Apply interest to all accounts\n        8. Exit\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        ValueError\n            Raised if an invalid command is received. Should not arise in\n            production. Report if encountered\n        \"\"\"\n\n        prompt = \"\"\"Account Management System\n\n1. Create a new account\n2. Deposit into an account\n3. Withdraw from an account\n4. View an account\n5. View all accounts associated with a name\n6. Manage a matured long term savings account\n7. Apply interest to all accounts\n8. Exit\n\nEnter your command: \"\"\"\n\n        while True:\n            command = BTCInput.read_int_ranged(prompt, 1, 8)\n            if command == 1:\n                self.create_new_account()\n            elif command == 2:\n                self.deposit_into_account()\n            elif command == 3:\n                self.withdraw_from_account()\n            elif command == 4:\n                self.view_account()\n            elif command == 5:\n                self.view_accounts_for_name()\n            elif command == 6:\n                self.manage_matured_long_term_savings()\n            elif command == 7:\n                self.__accounts.apply_interest()\n            elif command == 8:\n                self.__accounts.save(self.__filename)\n                print(\"Accounts saved\")\n                break\n            else:\n                raise ValueError(\n                    \"Invalid command id {0} encountered in main menu! Please report!\".format(\n                        command\n                    )\n                )\nThe __init__ is simple as it first tries to load the accounts from a given file (storing this filename for later saving), else creating an empty AccountSystem if one is not found.\nThe menu also uses our standard numeric interface. Now we need to start implementing our methods. The most complicated for us being creating a new account. To start with we know that all accounts have an interest rate. Depending on if we are viewing this program as something that a bank owner would use to manage their internal system, or something that the a client uses we might want to implement this differently.\nOne question is around the interest rate we apply to accounts. If this was client facing. We probably don’t want them specifying their own interest rate. So instead the application provides some logic to determine the interest rate to apply to a new account. This is done by using class variables to define interest rates for SavingsAccounts and CreditAccounts. We then also provide a static method that calculates the interest rate for a long-term savings account based on the principle that the longer the term is the higher the interest.\nclass BankAccountApplication:\n    \"\"\"\n    Provides a text-based interface for Bank Account Management\n\n    Class Attributes\n    ----------------\n    savings_account_interest : float\n        current interest rate on newly opened savings accounts\n    credit_account_interest : float\n        current interest rate on newly opened credit accounts\n    \"\"\"\n\n    savings_account_interest = 0.01\n    credit_account_interest = 0.10\n\n    @staticmethod\n    def calculate_long_term_interest(term_limit):\n        \"\"\"\n        Calculates the bonus interest assigned to a long term savings account\n\n        Parameters\n        ----------\n        term_limit : int\n            proposed term limit in weeks\n\n        Returns\n        -------\n        float\n            interest rate for a long-term savings account\n        \"\"\"\n        term_contribution = (\n            term_limit / Account.LongTermSavingsAccount.max_term_limit * (0.1)\n        )\n        return BankAccountApplication.savings_account_interest + term_contribution\nSimilarly here, we don’t want a client to be able to put an arbitrary term limit in. So we’ll add class variables to the LongTermSavingsAccount for the min and max term limits, and provide a static validation method.\nclass LongTermSavingsAccount(SavingsAccount):\n    \"\"\"\n    Represents a long term savings account\n\n    An account in which money cannot be withdrawn before the term limit expires.\n    After the term limit has expired a reduced interest rate is applied.\n\n    Class Attributes\n    ----------------\n    min_term_limit: int\n        minimum term limit in weeks\n    max_term_limit: int\n        maximum term limit in weeks\n\n    See Also\n    --------\n    SavingsAccount : Parent class\n    \"\"\"\n\n    min_term_limit = 12\n    max_term_limit = 156\n\n    @staticmethod\n    def validate_term_limit(term_limit):\n        \"\"\"\n        Validates a proposed term limit\n\n        Parameters\n        ----------\n        term_limit : int\n            proposed term limit in weeks\n\n        Returns\n        -------\n        bool\n            `True` if the proposed term limit is valid, else `False`\n        \"\"\"\n        return (\n            LongTermSavingsAccount.min_term_limit\n            &lt;= term_limit\n            &lt;= LongTermSavingsAccount.max_term_limit\n        )\nNow we can move on to implementing our account creation function. Here the user has to specify the account type to create. Then they are prompted to provide an account holder. The next bit of fun we introduce is to have the user’s account number then be randomly generated. We’ll make the account number a 4 character alphanumeric string. (We keep it small to make it easy to demo)\n    def create_new_account(self):\n        \"\"\"\n        Create a new account and add it to the system\n\n        Prompts the user for the type of account to create and\n        the necessary descriptors of the item. The account is\n        then added to the system\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        ValueError\n            Raised if an invalid account type id is encountered.\n            Should not arise in production, please report if found.\n        \"\"\"\n        menu = \"\"\"Create New Account\n\n1. Savings Account\n2. Long Term Savings Account\n3. Credit Account\n\nEnter account type: \"\"\"\n\n        def generate_account_number():\n            \"\"\"\n            Generates an account number\n\n            The generated account number is a 16 character random\n            alphanumeric string\n\n            Returns\n            -------\n            str\n                string representing a valid account number\n            \"\"\"\n            account_number_string_length = 4\n            account_number_string_tuple = (\n                \"A\",\n                \"B\",\n                \"C\",\n                \"D\",\n                \"E\",\n                \"F\",\n                \"G\",\n                \"H\",\n                \"I\",\n                \"J\",\n                \"K\",\n                \"L\",\n                \"M\",\n                \"N\",\n                \"O\",\n                \"P\",\n                \"Q\",\n                \"R\",\n                \"S\",\n                \"T\",\n                \"U\",\n                \"V\",\n                \"W\",\n                \"X\",\n                \"Y\",\n                \"Z\",\n                \"0\",\n                \"1\",\n                \"2\",\n                \"3\",\n                \"4\",\n                \"5\",\n                \"6\",\n                \"7\",\n                \"8\",\n                \"9\",\n            )\n\n            account_number = \"\".join(\n                random.choices(\n                    account_number_string_tuple, k=account_number_string_length\n                )\n            )\n            return account_number\n\n        account_type = BTCInput.read_int_ranged(menu, 1, 3)\n        if account_type &lt; 1 or account_type &gt; 3:\n            raise ValueError(\n                \"Invalid account type id {0} encountered while creating account\".format(\n                    account_type\n                )\n            )\n\n        account_number = generate_account_number()\n        account_holder = BTCInput.read_text(\"Enter account holder: \")\nYou can see we define a tuple that contains the possible characters. We then use random.choices to select the appropriate number of characters (with replacement) where the number of characters is defined by account_number_string_length (so we can easily modify it). To convert from a collection to a string we use \"\".join to join the characters together, the empty string means that no extra characters are embedded.\nNow that we’ve got the account number, the account holder and the type of account we can proceed. For a SavingsAccount we have all the details required to create the account. For a LongTermSavingsAccount we have to get the term limit, (making sure it’s valid) and for a CreditAccount we have to get the credit limit. Once that’s done we then add it to the AccountSystem\n        if account_type == 1:\n            print(\"Creating a savings account\")\n            account = Account.SavingsAccount(\n                account_number,\n                account_holder,\n                BankAccountApplication.savings_account_interest,\n            )\n            print(\"Created a new savings account {0}\".format(account_number))\n        elif account_type == 2:\n            print(\"Creating a long-term savings account\")\n            while True:\n                term_limit = BTCInput.read_int_ranged(\n                    \"Enter term limit ({0} - {1}): \".format(\n                        Account.LongTermSavingsAccount.min_term_limit,\n                        Account.LongTermSavingsAccount.max_term_limit,\n                    ),\n                    Account.LongTermSavingsAccount.min_term_limit,\n                    Account.LongTermSavingsAccount.max_term_limit,\n                )\n                if Account.LongTermSavingsAccount.validate_term_limit(term_limit):\n                    break\n            account = Account.LongTermSavingsAccount(\n                account_number,\n                account_holder,\n                BankAccountApplication.calculate_long_term_interest(term_limit),\n                term_limit,\n            )\n            print(\"Created a new long-term savings account {0}\".format(account_number))\n        elif account_type == 3:\n            print(\"Creating a  credit account\")\n            withdrawal_limit = BTCInput.read_float(\"Enter max withdrawal limit: \")\n            account = Account.CreditAccount(\n                account_number,\n                account_holder,\n                BankAccountApplication.credit_account_interest,\n                withdrawal_limit,\n            )\n            print(\"Created a new credit account {0}\".format(account_number))\n        self.__accounts.add_new_account(account)  # type: ignore\nDeposit, withdraw and view account are all implemented using similar logic. First the user is prompted for an account number, then we perform a function. We’ll extract this get_account behaviour into a function\n    def get_account(self):\n        \"\"\"\n        Prompts the user for an account number and returns any match\n\n        Returns\n        -------\n        Account | None\n            Account is the account number matches, else `None`\n        \"\"\"\n        account_number = BTCInput.read_text(\"Enter account number: \").upper().strip()\n        return self.__accounts.get_account(account_number)\nThe implementations for deposit, withdraw, and view then largely just need to forward onto the appropriate message on the account, deposit, withdraw and __str__ respectively\n    def deposit_into_account(self):\n        \"\"\"\n        Deposit into a user-prompted account\n\n        User is prompted for an account, if the account exists,\n        the user is then prompted for how much to deposit\n\n        Returns\n        -------\n        None\n        \"\"\"\n        print(\"Deposit into account\")\n\n        account = self.get_account()\n\n        if account is None:\n            print(\"Account not found\")\n            return\n        print(\"Depositing\")\n        print(account)\n\n        try:\n            amount = BTCInput.read_float(\n                \"Enter amount to deposit (Current balance: {0}): \".format(\n                    account.balance\n                )\n            )\n            account.deposit(amount)\n        except ValueError as e:\n            print(e)\n\n    def withdraw_from_account(self):\n        \"\"\"\n        Withdraw from a user-prompted account\n\n        User is prompted for an account, if the account exists,\n        the user is then prompted for how much to withdraw\n\n        Returns\n        -------\n        None\n        \"\"\"\n        print(\"Withdraw from account\")\n\n        account = self.get_account()\n        if account is None:\n            print(\"Account not found\")\n            return\n        print(\"Withdrawing\")\n        print(account)\n\n        try:\n            amount = BTCInput.read_float(\n                \"Enter amount to withdraw (Current balance: {0}): \".format(\n                    account.balance\n                )\n            )\n            account.withdraw(amount)\n        except ValueError as e:\n            print(e)\n\n    def view_account(self):\n        \"\"\"\n        Display a user-specified account\n\n        Returns\n        -------\n        None\n        \"\"\"\n        print(\"View account\")\n\n        account = self.get_account()\n        if account is None:\n            print(\"Account not found\")\n            return\n        print(account)\nNext we want to implement the complement to view_account which is view_account_by_name. This simply takes a user’s name and then forwards onto the appropriate message on the AccountSystem. The resulting list is then converted to a string representation using map and displayed to the user\n    def view_accounts_for_name(self):\n        \"\"\"\n        Find and display accounts for a user prompted name\n\n        Names are converted to lower case and stripped of\n        leading and trailing whitespace\n\n        Returns\n        -------\n        None\n        \"\"\"\n        print(\"View account holders accounts\")\n\n        accounts = self.__accounts.find_users_accounts(\n            BTCInput.read_text(\"Enter account holder: \")\n        )\n        print(\"\\n\".join(map(str, accounts)))\nOur last major implementation detail is then to implement managing a matured savings account. Recall from the original exercise that a long-term savings account that has matured can either be reinvested or transferred to another account. To implement this structure as follows,\n\nThe user is prompted for an account number\nWe verify that account number is valid and a long-term account\nWe then validate that the account has matured\nThe user is then prompted if they want to reinvest\n\nIf yes, the account is reinvested and the process stops\nElse we continue\n\nThe user is then prompted for the account to transfer to\nWe validate that the account exists, and the account holder matches the long term account\nWe then attempt to close out the account\n\nThe implementation is given below,\n    def manage_matured_long_term_savings(self):\n        \"\"\"\n        Close out or reinvest a user specified matured long-term account\n\n        Returns\n        -------\n        None\n        \"\"\"\n\n        account_number = BTCInput.read_text(\"Enter account number: \").upper().strip()\n\n        account = self.__accounts.get_account(account_number)\n        if account is None:\n            print(\"Account not found\")\n            return\n        if not isinstance(account, Account.LongTermSavingsAccount):\n            print(\"Account is not a long term savings account\")\n            return\n        if not account.has_matured():\n            print(\"Account cannot be managed: has not matured\")\n            return\n\n        reinvest = BTCInput.read_int_ranged(\n            \"Reinvest this account? (1 - yes, 0 - no): \", 0, 1\n        )\n        if reinvest:\n            account.manage_account()\n            return\n\n        holder = account.account_holder\n        other_accounts = set(self.__accounts.find_users_accounts(holder)).difference(\n            {account}\n        )\n        if len(other_accounts) == 0:\n            print(\"Account cannot be closed: No accounts to transfer to\")\n            return\n        print(\"\\n\".join(map(str, other_accounts)))\n\n        account_number = (\n            BTCInput.read_text(\"Enter transfer account number: \").upper().strip()\n        )\n\n        transfer_account = self.__accounts.get_account(account_number)\n        if transfer_account is None:\n            print(\"Account not found\")\n            return\n        if transfer_account.account_holder != holder:\n            print(\"Could not transfer, account holder does not match\")\n            return\n        try:\n            account.manage_account(transfer_account)\n            print(\n                \"Funds in account {0} transferred to account {1}\".format(\n                    account.account_number, transfer_account.account_number\n                )\n            )\n        except ValueError as e:\n            print(\"Failed to close account:\", e)\nOur last step is to implement the application of interest rates. This is done to all accounts, typically at some specified point, e.g. the first of each month. However, the natural place for this to be implemented is on the AccountSystem class,\nclass AccountSystem:\n    \"\"\"\n    Represents the account management system of a bank\n    \"\"\"\n    ...\n    def apply_interest(self):\n        \"\"\"\n        Applies interest to all accounts in the system\n\n        Returns\n        -------\n        None\n        \"\"\"\n        for account in self.__account_dictionary.values():\n            account.apply_interest()\nWe then just need to forward to this method from BankApplication, as can be seen already in the main_menu function\ndef main_menu(self):\n    ...\n    elif command == 7:\n        self.__accounts.apply_interest()\nRunning the program is the same as for our Fashion Shop Application\nui = BankAccountApplication(\"accounts.pkl\")\nui.main_menu()\n\n\nNow that we’ve completed the program it’s worth reviewing the program. Overall the design is one that we’re pretty happy with but there could be some improvements. The most glaring is that account numbers must be unique, yet our program doesn’t enforce this. There are a number of solutions. The ideal way to handle this would be that when we try to add an account if self.__account.add_new_account(account) returns a KeyError would be to regenerate a new number. However this number is private and can’t be changed once an object is created. We don’t want to change this, so we would have to create an entire new object which is fine, but the way the code is organised means that it’s not clear when we get to adding the account, what type it is. Solutions include,\n\nMoving the call to add_new_account to each individual account type path\n\nThis means we can catch the KeyError regenerate a new number, and then rebuild the appropriate account type\nHas the downside that we replicate the code for adding the account for every account type\n\nImplement a method on AccountSystem that tells us if a generated account number is valid.\n\nThis means we can check at the time of number generation\nRepeat until we get a valid one\nThis has the downside that if we had a concurrent system, we could potentially be told that the account number is free, then have another process beat us to using that number\nPlus we already have the KeyError to tell us if the number is free\n\nIn Python you generally prefer to ask for forgiveness rather than permission\n\ni.e. use exceptions over checking then setting\n\n\n\nHandle the Error, report it to the user and leave it up to them how they want to resolve\n\nSimplest implementation\nProbably not the best user experience (since user might have to enter the same details all over again)\n\n\nNone of the solutions above are strictly the best they are all just options to consider. For this small program we’ve left the bug in as a demonstration.\nThere are a couple other design considerations. One is about cohesion, we have logic for defining the interest applied to accounts separate from the Account class stored on arguably the UI class BankAccountApplication. This is fine for this small system but perhaps suggests a lack of cohesion. If we were to change out our UI class to a GUI that GUI would then have to implement the same business logic. One solution is to move those details to the Account class hierarchy. Here each subclass might have to define a property base_interest_rate which defines the default interest rate for an account. On the other hand if we decide that an Account should have an interest rate, but has no business knowing how that interest rate is set, we may have to implement this behaviour either in the AccountSystem or in another class that purely handles the business logic around interest rates and propagates that through to the accounts. For the scale of this system, we probably don’t need that extra layer (remember the simpler the solution the easier, we can always refactor later)\nThe last question is more on of a philosophical design choice. This program implements features that are very client focused such as creating accounts, depositing and withdrawing (and arguably managing a long-term account), and some that a more targeted towards an internal user (applying interest, the ability to modify any account and see anybody’s account). This is fine for a simple toy program like the one we’re building. But if we were to scale this up we would probably want to split out the client-facing functions from the internal user facing components. Both would still talk to the same underlying data model though.\n\n\n\n\n\n\nWe can show the final class diagram and interactions of our program below\n(We’ve hidden some of the subclasses and object for simplicity)\n\n\n\n\n\n\n---\ntitle: Complete Fashion Shop Class Diagram\n---\n\nclassDiagram\n\n    class StockItem {\n        str stock_ref\n        str item_name\n        str colour\n        number price\n        int stock_level\n    }\n\n    class Dress {\n        str pattern\n        int size\n    }\n\n    class Pants {\n        int length\n        str pattern\n        int waist\n    }\n\n    class FashionShop {\n        dictionary __stock_dictionary\n    }\n\n    class FashionShopApplication {\n        FashionShop __shop\n    }\n\n    StockItem &lt;|-- Dress\n    StockItem &lt;|--  Pants\n\n    FashionShop \"1\" o-- \"0..n\" StockItem\n    FashionShopApplication \"1\" *-- \"1\" FashionShop\n\n\n\n\n\n\n\n\n\nClass diagrams more broadly discuss associations\nOne form of association is inheritance which we’ve seen before is represented by a open arrow\nAnother is aggregation represented by an open diamond-headed arrow\n\nWe say that FashionShop aggregates StockItem because it is a container\nWe can additionally specify multiplicities\ni.e. how many items are represented in a relationship\nWe do this by adding number on either end of the arrow\nAbove we have \\(1\\) next to the FashionShop and \\(0 \\ldots n\\) next to StockItem\nThis says that one FashionShop aggregates \\(0\\) to an arbitrary finite number of StockItems\n\nA similar relationship is composition\n\nWhere as inheritance is a is-a relationship\nComposition can be thought of as a has-a relationship\nAgain we can specify multiplicities\nHere we indicate that there is one FashionShopApplication which contains one FashionShop\n\nThese class diagrams help express the structure and relationship of a system\nGood way to describe how the elements of your program fit together\n\n\n\n\n\nSets are collections of values like tuples and lists\nThey are mutable like lists\nUnlike lists each value in a set must be unique\n\n\n\nWork through the following steps in the python interpreter to understand sets\nA set can be created by explicitly using the set initializer\n\nset1 = set()\nset1\n\nset()\n\n\nThis creates an empty set.\nWe can add to set like with a list, but we use add rather than append\n\nset1.add(1)\nset1\n\n{1}\n\n\nSets can only hold one instance of a given value, what happens if we try to add the same element twice?\n\nset1.add(1)\nset1\n\n{1}\n\n\nAs we can see the set contents have not changed, there is only one 1 in the set. However the other thing to observe is that no error was thrown, the second add fails silently\nWe can add multiple values as long as they are distinct\n\nset1.add(2)\nset1\n\n{1, 2}\n\n\nLike with lists and dictionaries there is a quick set declaration syntax. We simply provide a comma-separated list enclosed in curly braces\n\nset2 = {2,3,4,5}\nset2\n\n{2, 3, 4, 5}\n\n\nThis is similar but distinct to the dictionary case where the curly brace list is comma separated key:value pairs\nFor those familiar with set theory, sets provide the standard suite of set operations.\ndifference is called on one set, and takes another set as an argument. It returns a new set containing the elements in the original set that are not in the argument set, e.g.\n\nset1.difference(set2)\n\n{1}\n\n\nand\n\nset2.difference(set1)\n\n{3, 4, 5}\n\n\nUnion returns a set containing the elements that are in either of the sets\n\nset1.union(set2)\n\n{1, 2, 3, 4, 5}\n\n\nintersection returns a set containing the elements that are in both of the sets\n\nset1.intersection(set2)\n\n{2}\n\n\nThere are also a number of methods for comparing the contents of a set. isdisjoint returns True if the two sets have no common elements\n\nset1.isdisjoint(set2)\n\nFalse\n\n\nissubset takes the form seta.issubset(setb) and returns True if seta is a subset of setb. \\(A\\) being a subset of \\(B\\) means all the elements of \\(A\\) are in \\(B\\)\n\nset3 = {2, 3}\nset3.issubset(set2)\n\nTrue\n\n\nThe opposite method is issuperset which returns true if the set the method is called on is a superset of the argument. \\(A\\) is a superset of \\(B\\) if \\(A\\) contains every element of \\(B\\)\n\nset3.issuperset(set2)\n\nFalse\n\n\n\nHow are sets useful?\n\nLet us remove duplicates in a collection\n\n\n\nset(\"Hello World\")\n\n{' ', 'H', 'W', 'd', 'e', 'l', 'o', 'r'}\n\n\n\nPython’s sets are unordered\nThey can be sorted using the function sorted\n\n\nprint(sorted(\"Hello World\"))\nprint(sorted(set(\"Hello World\")))\n\n[' ', 'H', 'W', 'd', 'e', 'l', 'l', 'l', 'o', 'o', 'r']\n[' ', 'H', 'W', 'd', 'e', 'l', 'o', 'r']\n\n\n\nWe might also use them to manage a collection of items\n\ne.g. a players inventory\n\n\n\npocket = {\"axe\", \"apple\", \"herbs\", \"flashlight\"}\n\n\nSets allow for easy membership checks\nespecially when we want to look at multiple members\n\n  apple_potion = {\"apple\", \"herbs\"}\n  if apple_potion.issubset(pocket):\n      print(\"Making an apple potion\")\n\nMaking an apple potion\n\n\nIn the above example we check that the player’s inventory has the ingredients for an apple potion\n\nThis is done by checking the ingredients are a subset of the inventory\n\nWe can then make the apple potion using set operations\n\nUse set difference to remove the ingredients\nThen add an apple potion\n\n\n  pocket = pocket - apple_potion\n  pocket.add(\"apple potion\")\n  pocket\n\n{'apple potion', 'axe', 'flashlight'}\n\n\nThe subtraction operator on sets works like the set difference operation we’ve seen before\n\n\n\n\n\nSets are less common than dictionaries and lists\nHowever they can be very useful\nOur Fashion Shop client has provided an updated spec\n\n\nCustomers often pursue a similar “look” or “style” e.g. flowery, summer, formal, etc. She would like to be able to tag stock items so they can be easily searched\n\n\nTagging items with descriptors is very common\nBlogs or Youtube videos are often tagged with metadata that describes their content\nSets are a good technique here since each tag should be unique\n\n\n\n\nEach StockItem should have a tags attribute\ntags comprises a set of tag values\nCreating a StockItem now requires us to input the tag values at object creation\nA sample UI might look like,\n\n\nprint(\"Enter tags (separated by commas): \\033[31moutdoor, spring, informal, short\\033[0m\")\n\n\nEnter tags (separated by commas): outdoor, spring, informal, short\n\n\n\n\n\nThen need to convert the comma separated list into individual tag items\nFirst we want to normalise tags, i.e. lowercase and leading / trailing whitespace stripped\nHowever, we want to split the individual tags before we strip the whitespace\n\nSince there might be white space between the words\n\nSo we can first lower, then separate the words using split\n\nsplit takes a string to split and a separator character (here ,) to split on\nThe separator is not included in the split strings\nReturns a list containing the new strings\n\nWe can then use map to apply the string method str.strip to each individual tag\n\n  tag_list = str.split(str.lower(tag_string), sep=',')\n  tag_list = map(str.strip, tag_list)\n  print(list(tag_list))\n\n['outdoor', 'spring', 'informal', 'short']\n\n\nThe last step is to ensure all the tags are unique by converting to a set\n\n  tags = set(tag_list)\n\nNow that we’ve defined this pipeline for creating our sets, we should really encapsulate it as a method\n\nclass FashionShopApplication:\n    ...\n    @staticmethod\n    def tag_set_from_text(tag_text):\n        \"\"\"\n        Create a set of tags from a comma-separated list\n\n        Tags are normalised as lowercase with leading and\n        trailing whitespace stripped\n\n        Parameters\n        ----------\n        tag_text: str\n            comma-separated list of tags\n\n        Returns\n        -------\n        set\n            set containing unique tags. Tags are lowercase with\n            no leading or trailing whitespace\n        \"\"\"\n        tags = set(map(str.strip, str.split(str.lower(tag_text), sep=\",\")))\n        return tags\n\nImplemented as a static method\n\nThe behaviour is associated with the class\nBut not associated with any specific instance\n\n\n\n\n\n\nNow that we’ve added tags we need a way to use them to search for items\nThe client wants to provide a list of tags and receive a list of items matching those tags\nBelow is a proposed interface\n\n  print(\"Enter the tags to look for (comma separated): \\033[31moutdoor, spring\\033[0m\")\n  print(\"Stock Reference: BL343\")\n  print(\"Type: Blouse\\033[0m\")\n  print(\"Price: 100\")\n  print(\"Stock Level: 0\")\n  print(\"Colour: Pink\")\n  print(\"\"\"Tags: {\"spring\", \"friendly\", \"city\", \"outdoor\"}\"\"\")\n  print(\"Size: 14\")\n  print(\"Style: plain\")\n  print(\"Pattern: check\")\n\n\nEnter the tags to look for (comma separated): outdoor, spring\n\nStock Reference: BL343\n\nType: Blouse\n\nPrice: 100\n\nStock Level: 0\n\nColour: Pink\n\nTags: {\"spring\", \"friendly\", \"city\", \"outdoor\"}\n\nSize: 14\n\nStyle: plain\n\nPattern: check\n\n\n\n\nWe can reuse get_tag_set_from_text to create a search set\nWe take match to mean the search tags are a subset of the item’s tags\n\nThis means that an item must match all the tags\n\nAn alternative approach might be to match any items that match at least one of the tags\n\nThis could be done by checking the intersection is non-empty\n\nIn the above example we can see the blouse matched because the search tags ({\"outdoor\", \"spring\"}) are a subset of the blouse’s tags ({\"spring\", \"friendly\", \"city\", \"outdoor\"})\nThis implementation is thus a simple application of issubset\n\n  def match_tags(item):\n      \"\"\"\n      Checks if the given item matches the specified search tags\n\n      Parameters\n      ----------\n      item : StockItem\n          StockItem to check for matching tags\n\n      Returns\n      -------\n      `True` if the search tags are a subset of `item.tags`, else `False`\n      \"\"\"\n      return search_tags.issubset(item.tags)\n\nWe can see that the search tags are passed in via a global parameter rather than explicitly through the function signature\nThis is so we can use the filter python function\nfilter works like map\n\nmap returns the result of a applying a function to each member of a collection\nfilter applies a boolean function (one that returns True or False) to each member of a collection, and returns the subcollection of all elements that evaluate True\n\n  filtered_list = filter(match_tags, stock_list)\nThe above uses filter to find all items in the stock_list that match the specified tags. Putting this all together\n\nclass FashionShop:\n    def find_matching_with_tags(self, search_tags):\n        \"\"\"\n        Get stock items that match all the specified search tags\n\n        Parameters\n        ----------\n        search_tags : str\n            set of tags to search against.\n            Item's must match all tags\n\n        Returns\n        -------\n        list[StockItem]\n            list containing all StockItem's matching the\n            specified set of tags. If no matches are found\n            the list is empty\n        \"\"\"\n\n        def match_tags(item):\n            \"\"\"\n            Checks if the given item matches the specified search tags\n\n            Parameters\n            ----------\n            item : StockItem\n                StockItem to check for matching tags\n\n            Returns\n            -------\n            `True` if the search tags are a subset of `item.tags`, else `False`\n            \"\"\"\n            return search_tags.issubset(item.tags)\n\n        return filter(match_tags, self.__stock_dictionary.values())\n\nfind_matching_with_tags is added to the FashionShop class as it is a method for handling a collection of stock items\nIt returns the list of matching stock items\nYou may notice something odd, we have declared the match_tags function inside the find_matching_with_tags function\nThis is allowed in python\nMeans that match_tags can access variables in the scope of the find_matching_with_tags function\nThe full tags based implementation is given in the FashionShopWithTags folder\nOne of the minor implementation details is that as tags adds a data attribute to StockItem we have to bump the version number (for the versions in our implementations this is \\(2 \\rightarrow 3\\)), and update check_version\nThe new implementation below, simply adds a empty tags field to older items\n\nNote we don’t need to update the version of the subclasses\nHowever, we do need to update all their __init__ signatures too\n\n  class StockItem:\n      def check_version(self):\n      \"\"\"\n      Checks the version of a `StockItem` instance and upgrades it if required\n\n      Returns\n      -------\n      None\n      \"\"\"\n      if StockItem.show_instrumentation:\n          print(\"**StockItem check_version called\")\n      if self.__StockItem_version &lt; 2:\n          self.location = None\n          self.__StockItem_version = 2\n      if self.__StockItem_version &lt; 3:\n          self.tags = set()\n          self.__StockItem_version = 3\n\n\n\n\n\n\nIt’s quite common for customers to provide feedback on the usability of their product\nFor example our client might prefer the tag-based interface more generally over a rigid class structure\n\n\nYour client would like to make changes to how the program functions. She enjoys using tags to identify stock elements. She finds having to specify a specific item type (e.g. pants, jeans, hat etc.) a painful process. She would prefer to index all stock using tags. Dresses would have the dress tag, etc. Together you propose the following mock-up\n\n\n\n\nEnter stock reference: D001\n\nEnter price: 120\n\nEnter tags (separated by commas): dress, colour:red, location:shop window, pattern:swirly, size:12, evening, long\n\n\n\n\n\nThe client finds searching by tags easy to work with\nTags are more flexible and remind her more of how she would organise stock by hand\nTags give the flexibility to add new items or change how items are described without needing to recompose the class hierarchy\nThe only additional request the client has is to allow the ability to edit the tags on a stock item\n\nCan add or remove tags\nCan correct edits\n\nThe downside is that any tags that are not entered correctly will result in failed searches\n\nThe class hierarchy enforces that the specified attributes for each StockItem subclass exist\n\nA tags only implementation is given by in the TagOnlyFashionShop folder\nThe StockItem implementation becomes much simpler\nFirst since there are no longer subclasses, we no longer define it as an abstract class\nWe update the docstrings and __init__ method\n\nThis involves removing all the attributes that do not describe the stock id, price or stock level\nWe also increment the version number\n\n  class StockItem:\n  \"\"\"\n  Represents a single inventory item\n\n  Attributes\n  ----------\n  stock_ref : str\n      reference id of the stock item\n  tags : set[str]\n      set of tags describing the stock item\n\n  Class Attributes\n  ----------------\n  show_instrumentation : bool\n      Indicates if instrumentation should be printed\n  max_stock_add : int\n      maximum amount of stock that can be added to an item's stock level at a time\n  min_price : int | float\n      minimum price of any stock item\n  max_price : int | float\n      maximum price of any stock item\n  \"\"\"\n\n  show_instrumentation = True\n\n  max_stock_add = 10\n\n  min_price = 0.5\n  max_price = 500\n\n  def __init__(self, stock_ref, price, tags):\n      \"\"\"\n      Creates a `StockItem` instance\n\n      Parameters\n      ----------\n      stock_ref : str\n          stock reference id\n      price : int | float\n          stock price\n      tags : set[str]\n          set of tags describing the stock item\n      \"\"\"\n      if StockItem.show_instrumentation:\n          print(\"**StockItem __init__ called\")\n      self.stock_ref = stock_ref\n      self.__price = price\n      self.tags = tags\n      self.__stock_level = 0\n      self.__StockItem_version = 4\nSince we no longer have multiple subclasses we can remove the item_name property\nThen we have to update the __str__ method\n  def __str__(self):\n      if StockItem.show_instrumentation:\n          print(\"**StockItem __str__ called\")\n      template = \"\"\"Stock Reference: {0}\nPrice: {1}\nStock level: {2}\nTags: {3}\"\"\"\n      return template.format(self.stock_ref, self.price, self.stock_level, self.tags)\nAll our actual core functions can stay the same, but we just need to adjust the check_version\nWe could make check_version convert all the previous attributes to tags, but this has a problem\n\nAll the subclasses that are actually instantiated no longer exist!\nSo really the customer will likely have to remake these objects\nIn our implementation, even though a StockItem should not be created directly, we can provide a warning message that the user should manually update the current object\n\n  def check_version(self):\n      \"\"\"\n      Checks the version of a `StockItem` instance and upgrades it if required\n\n      Returns\n      -------\n      None\n      \"\"\"\n      if StockItem.show_instrumentation:\n          print(\"**StockItem check_version called\")\n      if self.__StockItem_version != 4:\n          print(\"Stock item uses old data model, please recreate this item\")\n\n\n\n\n\n\n\nImportant\n\n\n\nData Migration is Painful\nIn moving from the class hierarchy to a tags based implementation, we’ve encountered one common problem. Data Migration. Before we’ve used simple versioning on classes to update them when we change their implementation. But here we have a bigger scale problem. What do we do when we change the application architecture? We can’t just update the subclasses because they no longer exist. For our small toy problem manually recreating objects probably works fine.\nHowever if we were working on a larger project we would have to create a migration plan. This might be a simple script that converts the old data to the new data schema, or for larger projects this might be a longer term project where we slowly phase in the new system and phase the old system out.\n\n\n\nThe FashionShop class needs no updates\nIt only ever sees objects as StockItems and manages the collection\nWe do need to make minor updates to FashionShopApplication\n\nThis is just adjusting how we create new items to reflect that we don’t have a class hierarchy\n\n  def create_new_stock_item(self):\n      \"\"\"\n      Create a new stock item and add it to the system\n\n      Prompts the user for the necessary descriptors and\n      any optional tags then creates a corresponding stock\n      item and adds it to the store\n\n      Returns\n      -------\n      None\n      \"\"\"\n\n      # now we have a valid item so get the common attributes\n      stock_ref = BTCInput.read_text(\"Enter Stock reference: \")\n      price = BTCInput.read_float_ranged(\n          \"Enter price: \",\n          min_value=StockItem.StockItem.min_price,\n          max_value=StockItem.StockItem.max_price,\n      )\n      tags = FashionShopApplication.tag_set_from_text(\n          BTCInput.read_text(\"Enter tags (separated by commas): \")\n      )\n\n      self.__shop.store_new_stock_item(StockItem.StockItem(stock_ref, price, tags))\nWe’ve also updated the docstring\n\n\n\n\n\n\n\nWarning\n\n\n\nComments can easily go stale\nOne of the reasons that people argue against using comments is that like code itself, they need to be maintained. As we’ve seen above, whenever we modify the code we have to ensure that the comments still correctly describe the behaviour. Since the comments we’re talking about are the docstrings it’s important to have these, and even more important they are up to date. Especially if we want to release documentation for our API.\nHowever, you should be considered in how you document your code. A comment is a maintenance overhead, and an incorrect comment can result in a lot of frustration if it confuses someone looking at the code base\n\n\n\n\n\nClient is now in control of how stock is organised\nTags can be added and searched for on the fly\n\nThis may get unwieldy if the number of tags gets very large\n\nThe program implementation is much simpler\n\nNo need for complicated, synchronised class hierarchy\nEverything is now a stock item\n\n\n\n\n\n\nClass hierarchies allow you to implement strict business or application logic\nAll objects created must obey the specified interfaces\n\nFor example we enforce that a dress has a size, pattern and colour\n\nUsing open-ended tags means that a required tag (say size) might be missing\n\nNo obligation to specify in the size embedded in the code\n\nClasses also allow for polymorphism\n\nCan make a dress behave differently from a hat for example\nWe saw this with the __str__ method\nEach subclass defined it’s own logic for conversion to a string\ntags don’t provide an easy way to have an item-type dependent presentation\n\n\n\n\n\n\n\n\nImportant\n\n\n\nWhat’s important to the programmer may not be important to the customer\nOften when writing programs for other clients it is easy to get fixated on developing a piece of logic that the customer may not actually like. Equally as a programmer, you may not fully understand or appreciate the nature of the businesses logic.\nIn the case of the Fashion Shop application we created a complex hierarchy based on the assumption that the it was important to store all the details for different categories of stock. The class hierarchy enforces that all objects are fully described.\nHowever, from the client’s perspective as long as the item is properly referenced, priced and it’s stock levels tracked, the other information is just a useful bonus. She finds it much more useful to be able to add and modify tags or organise stock as needed.\nProperly understanding the business needs of a client and what their important use cases are is a crucial part of project management. One of the techniques for solving this is called domain-driven design which strives to make sure that software accurately models the domain it is applied to\n\n\n\n\n\nLook at the following scenarios and decide if a class-based or tags based implementation makes sense\n\nYou’re creating banking software for a local bank to manage their accounts. The bank offers credit and checking accounts. Should we use a class hierarchy?\n\nYes\nAccounts are likely to have a rigid set of attributes that all need to be specified and validated\nSome elements are likely common\n\ne.g. the account holder details\n\nDifferent account types might specify different attributes\n\ne.g. credit account requires a credit limit\n\nWe can thus use an abstract Account class, and then subclass this to provide specific implementations\nMeans we can also use method overloading and polymorphism\n\ne.g. Different accounts will process funds withdrawals in different ways\n\nYou can see an example in our model bank system class structure\n\nYou’ve been approached to help a local gallery track their artwork. The gallery holds pictures, sculptures, and manuscripts. Should we use a class hierarchy?\n\nLikely not\nThere is likely not a lot of common functionality between the objects\nThe items are also likely to be flexibly described rather than have a rigid data model\nThe gallery may evolve and change how they categorise\n\ne.g. They may switch from categorising by type to categorising by artist etc.\n\nSets and tags makes sense here\nIn theory you could just reuse the tags-only fashion shop application (maybe renaming some items so they contextually make sense)",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 11: Object-based Solution Design"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/11_ObjectBasedSolutionDesign/Chapter_11.html#summary",
    "href": "02_AdvancedProgramming/11_ObjectBasedSolutionDesign/Chapter_11.html#summary",
    "title": "Chapter 11: Object-based Solution Design",
    "section": "Summary",
    "text": "Summary\n\nInheritance can be used to manage a large number of related items\n\nInheritance lets (sub)classes be based on other (super)classes\nSubclasses inherit the attributes and methods of their parent\nSubclasses can redefine attributes and methods to override the behaviour of the parent\n\nStructuring a program as individual cohesive components make it easy to develop, test and modify parts of a program\n\nComponents can be implemented as classes that provide specific methods\ne.g. StockItem which managed a stocked inventory item\n\nHad a add_stock to adjust its stock level\n\nDifferent components communicate purely through each others methods\ne.g. FashionShop stores StockItem objects via a dictionary\n\nCould instead use a database implementation\nNo need to rewrite the other classes as long as the method interface is the same\n\nComponents can be developed and tested independently and cooperatively once their interfaces are defined\n\nPython provides a set collection\n\nA set is a collection of unique values\nMutable like a list\nAn example use for sets is specifying unique, dynamic tags on an object\nThe set implementation supports all standard set operations\n\nIt’s important to understand client requirements when developing a program",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 11: Object-based Solution Design"
    ]
  },
  {
    "objectID": "02_AdvancedProgramming/11_ObjectBasedSolutionDesign/Chapter_11.html#questions-and-answers",
    "href": "02_AdvancedProgramming/11_ObjectBasedSolutionDesign/Chapter_11.html#questions-and-answers",
    "title": "Chapter 11: Object-based Solution Design",
    "section": "Questions and Answers",
    "text": "Questions and Answers\n\nDo I have to use a class hierarchy if I want to store many related items?\n\nNo\nThey are useful when you want to use polymorphism\n\ni.e. treat them all as one common object\nBut have each specific type behave differently\n\n\nWhat turns an object into a software component?\n\nA component is cohesive\nIt can perform all the functions of it’s domain without needing another object\ne.g. StockItem’s methods only rely on it’s internal state and some passed in basic parameters\n\nNo need to reach out to another external object instance\nFashionShop or FashionShopApplication may call methods on StockItem objects\n\nThese are internally encapsulated in the object\nSo all good, these are still cohesive\n\nWe don’t want to be calling out to external objects\nPoor cohesion would have methods like add_stock and sell_stock outside in a separate class\n\nConsidering how easy it would be to swap the class for one with a similar interface is a good test of how cohesive a class is\n\nIf the class is cohesive this should be easy\nFor example if we wanted to swap FashionShop from a dictionary implementation to a database implementation with the same interface\n\nWhen using component based design, it’s a good idea to ensure you define your components before you start implementing a design\n\nNeed to ensure that you understand correctly what data is needed where and how components will communicate\n\nComponents can then be implemented individually\n\nDo I have to use object-oriented design to make my programs?\n\nNo\nPython uses duck-typing, which means if we try to call a method on an object, it will be called so long as it’s defined\nThus we can implement polymorphism without a rigid class hierarchy\nThe downside is without a clear class hierarchy it can be hard to propagate method or design changes between related implementations\nRemember that typically the largest time cost of code is maintaining and understanding existing code\n\nWhy is the relationship between a subclass and a superclass so confusing?\n\nRecall that the sub and super names derive from set theory\nSo while a super class may have less functionality than a sub class that is because every subclass is an instance of a superclass\nA subclass can be thought of as a more specialised implementation of a superclass\n\nWhat exactly happens when a method in a class is overridden?\n\nWhen the method is called in python, python first looks for the method on the object class\nIf it exists, it’s used, else it looks in the next superclass\nThis continues until the base class for all python instances object is found\nIf the object is still not found an error will be found, for example with the int object below we try to call the fictitious method foo\n\n\n x = 10\n x.foo()\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[81], line 2\n      1 x = 10\n----&gt; 2 x.foo()\n\nAttributeError: 'int' object has no attribute 'foo'\n\n\n\n\nOverriding methods can slow a program down as this method resolution takes time\nThis is typically not a bottleneck in python programs\n\nWhat things in my class should be made static?\n\nStatic items are always present\nThey are associated with the class, not a specific instance\nstatic data attributes are good for storing class wide values\n\nFor example variables associated with validating data such as a max and min value\nWe don’t want to store a copy of these for every object instance\nSo we instead store it as a class attribute\n\nstatic methods are for methods that don’t need an instance of the class\n\nValidation or object creation methods are a common use case\nKeeps code associated with the class packaged with the class\nFor example load on FashionShop, there’s no FashionShop instance to load into yet\n\n\nWhen do I use abstraction?\n\nUsed when thinking about an object\nAbstraction helps reducing noise when considering a system\n\ne.g. rather than considering a range of different customers we just consider a Customer\n\nWe can then define the basic operations we need on a customer\nLater we might then specialise for different customers",
    "crumbs": [
      "Home",
      "Advanced Programming",
      "Chapter 11: Object-based Solution Design"
    ]
  },
  {
    "objectID": "03_UsefulPython/13_PythonAndGraphicalUserInterfaces/Chapter_13.html#summary",
    "href": "03_UsefulPython/13_PythonAndGraphicalUserInterfaces/Chapter_13.html#summary",
    "title": "Chapter 13: Python and Graphical User Interfaces",
    "section": "Summary",
    "text": "Summary",
    "crumbs": [
      "Home",
      "Useful Python",
      "Chapter 13: Python and Graphical User Interfaces"
    ]
  },
  {
    "objectID": "03_UsefulPython/13_PythonAndGraphicalUserInterfaces/Chapter_13.html#questions-and-answers",
    "href": "03_UsefulPython/13_PythonAndGraphicalUserInterfaces/Chapter_13.html#questions-and-answers",
    "title": "Chapter 13: Python and Graphical User Interfaces",
    "section": "Questions and Answers",
    "text": "Questions and Answers",
    "crumbs": [
      "Home",
      "Useful Python",
      "Chapter 13: Python and Graphical User Interfaces"
    ]
  }
]